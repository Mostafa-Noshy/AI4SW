clear: public void clear ( ) { attachments . clear ( 1024 ) ; bones . clear ( ) ; constraints . clear ( ) ;
onMeasure: protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; if ( mTarget == null ) { ensureTarget ( ) ; } if ( mTarget == null ) { return ; } mTarget . measure ( MeasureSpec . makeMeasureSpec ( getMeasuredWidth ( ) - getPaddingLeft ( ) - getPaddingRight ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( getMeasuredHeight ( ) - getPaddingTop ( ) - getPaddingBottom ( ) , MeasureSpec . EXACTLY ) ) ; if ( mRefreshHeader != null ) {
exitSideEffectBlockWithException: public void exitSideEffectBlockWithException ( Throwable runException , @ Nullable RetryPolicy retryPolicy , ExitSideEffectSyscallCallback callback ) { wrapAndPropagateExceptions (
received: public boolean received ( final EditorActiveRemoveMsg msg ) { if ( ! validateEditor ( ) ) return true ; BrainOutServer . PostRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; ActiveData activeData = map . getActiveData ( msg . id ) ; if ( activeData != null ) { map . removeActive ( activeData , true ) ; } } ) ; return true ;
forEach: public void forEach ( BiConsumer < ? super K , ? super V > action ) { while ( ! queue . isEmpty ( ) ) {
getImportSuggestions: public String [ ] getImportSuggestions ( ) { return importSuggestions ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem8ActionPerformed ( evt ) ;
release: public void release ( ) { mSoundPool . release ( ) ;
addFuel: public void addFuel ( ) { this . fuel += getGenerator ( ) . getRefillAmount ( ) ; updated ( ) ;
notificationMessage: public String notificationMessage ( ) { return String . format ( "Script execution result" ) ;
getGunGameWeapons: public Array < String > getGunGameWeapons ( ) { return weapons ;
write: public void write ( final Packet packet , final @ NonNull ConversationUID sourceConversation ) { final JRPCMessage message = JRPCMessageBuilder . builder ( ) . source ( server ) . target ( uniqueId ) . conversationUid ( sourceConversation ) . targetType ( Message . TargetType . DIRECT ) . data ( PacketDataSerializer . serialize ( packet ) ) . build ( ) ; write ( message ) ;
computeWorldVertices: public void computeWorldVertices ( Bone bone , float [ ] worldVertices , int offset , int stride ) { float [ ] vertexOffset = this . offset ; float x = bone . getWorldX ( ) , y = bone . getWorldY ( ) ; float a = bone . getA ( ) , b = bone . getB ( ) , c = bone . getC ( ) , d = bone . getD ( ) ; float offsetX , offsetY ; offsetX = vertexOffset [ BRX ] ; offsetY = vertexOffset [ BRY ] ; worldVertices [ offset ] = offsetX * a + offsetY * b + x ; worldVertices [ offset + 1 ] = offsetX * c + offsetY * d + y ; offset += stride ; offsetX = vertexOffset [ BLX ] ; offsetY = vertexOffset [ BLY ] ; worldVertices [ offset ] = offsetX * a + offsetY * b + x ; worldVertices [ offset + 1 ] = offsetX * c + offsetY * d + y ; offset += stride ; offsetX = vertexOffset [ ULX ] ; offsetY = vertexOffset [ ULY ] ; worldVertices [ offset ] = offsetX * a + offsetY * b + x ; worldVertices [ offset + 1 ] = offsetX * c + offsetY * d + y ; offset += stride ; offsetX = vertexOffset [ URX ] ; offsetY = vertexOffset [ URY ] ; worldVertices [ offset ] = offsetX * a + offsetY * b + x ; worldVertices [ offset + 1 ] = offsetX * c + offsetY * d + y ;
generateTransformedValuesCandle: public float [ ] generateTransformedValuesCandle ( ICandleDataSet data , float phaseX , float phaseY , int from , int to ) { final int count = ( int ) ( ( to - from ) * phaseX + 1 ) * 2 ; if ( valuePointsForGenerateTransformedValuesCandle . length != count ) { valuePointsForGenerateTransformedValuesCandle = new float [ count ] ; } float [ ] valuePoints = valuePointsForGenerateTransformedValuesCandle ; for ( int j = 0 ; j < count ; j += 2 ) { CandleEntry e = data . getEntryForIndex ( j / 2 + from ) ; if ( e != null ) { valuePoints [ j ] = e . getX ( ) ; valuePoints [ j + 1 ] = e . getHigh ( ) * phaseY ; } else { valuePoints [ j ] = 0 ; valuePoints [ j + 1 ] = 0 ; } } getValueToPixelMatrix ( ) . mapPoints ( valuePoints ) ; return valuePoints ;
upgraded: public void upgraded ( ObjectMap < String , Upgrade > upgrades ) { initUpgrades ( upgrades . values ( ) . toArray ( ) ) ;
resolvePromise: public void resolvePromise ( String key , ByteBuffer payload , SyscallCallback < Deferred < Void > > callback ) { syscallsExecutor . execute ( ( ) -> syscalls . resolvePromise ( key , payload , callback ) ) ;
iFillRegistrationFormWith: public void iFillRegistrationFormWith ( String login , String password ) { registerPage . fillRegisterForm ( login , password ) ;
getLastname: public String getLastname ( ) { return lastname ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ;
renderShape: public void renderShape ( Canvas c , IScatterDataSet dataSet , ViewPortHandler viewPortHandler , float posX , float posY , Paint renderPaint ) { final float shapeSize = dataSet . getScatterShapeSize ( ) ; final float shapeHalf = shapeSize / 2f ; final float shapeHoleSizeHalf = Utils . convertDpToPixel ( dataSet . getScatterShapeHoleRadius ( ) ) ; final float shapeHoleSize = shapeHoleSizeHalf * 2.f ; final float shapeStrokeSize = ( shapeSize - shapeHoleSize ) / 2.f ; final int shapeHoleColor = dataSet . getScatterShapeHoleColor ( ) ; renderPaint . setStyle ( Paint . Style . FILL ) ; Path tri = mTrianglePathBuffer ; tri . reset ( ) ; tri . moveTo ( posX , posY - shapeHalf ) ; tri . lineTo ( posX + shapeHalf , posY + shapeHalf ) ; tri . lineTo ( posX - shapeHalf , posY + shapeHalf ) ; if ( shapeSize > 0.0 ) { tri . lineTo ( posX , posY - shapeHalf ) ; tri . moveTo ( posX - shapeHalf + shapeStrokeSize , posY + shapeHalf - shapeStrokeSize ) ; tri . lineTo ( posX + shapeHalf - shapeStrokeSize , posY + shapeHalf - shapeStrokeSize ) ; tri . lineTo ( posX , posY - shapeHalf + shapeStrokeSize ) ; tri . lineTo ( posX - shapeHalf + shapeStrokeSize , posY + shapeHalf - shapeStrokeSize ) ; } tri . close ( ) ; c . drawPath ( tri , renderPaint ) ; tri . reset ( ) ; if ( shapeSize > 0.0 &&
deposit: void deposit ( ) { assertThrows ( IllegalArgumentException . class , ( ) -> bankAccount . deposit ( - 100 ) ) ; bankAccount . deposit ( 1000 ) ; assertEquals ( 1999 , bankAccount . getBalance ( ) ) ;
test_setIntegrationAsPrimary: public void test_setIntegrationAsPrimary ( ) throws NovuNetworkException , IOException , InterruptedException { SingleIntegrationResponse singleIntegrationResponse = new SingleIntegrationResponse ( ) ; Integration integration = new Integration ( ) ; integration . setActive ( true ) ; integration . setChannel ( "PUSH" ) ; integration . setPrimary ( true ) ; integration . setId ( "Test" ) ; singleIntegrationResponse . setData ( integration ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( singleIntegrationResponse ) ) ) ; SingleIntegrationResponse response = integrationsHandler . setIntegrationAsPrimary ( integration . getId ( ) ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/integrations/Test/set-primary" , request . getPath ( ) ) ; assertEquals ( "PUT" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( singleIntegrationResponse ) , gson . toJson ( response ) ) ;
onClick: public void onClick ( View v ) { shareLayout . setVisibility ( View . VISIBLE ) ;
updateBoundEffects: public void updateBoundEffects ( float dt ) { for ( ObjectMap . Entry < String , Pair < EffectData , Float > > entry : boundEffects ) { Pair < EffectData , Float > pair = entry . value ; pair . second -= dt ; if ( pair . second <= 0 ) { removeList . addLast ( entry . key ) ; } } if ( removeList . size > 0 )
showImageFitCenter: public static void showImageFitCenter ( Context context , Object imagePath , ImageView imageView , int placeHolder ) { DrawableRequestBuilder builder = getBuilder ( context , imagePath , placeHolder ) ; builder . fitCenter ( ) ; builder . into ( imageView ) ;
connectionFailed: public void connectionFailed ( ) { pushMenu ( new RichAlertPopup ( L . get ( "MENU_JOIN_BY_ROOM_ID" ) , L . get ( "MENU_PROMO_ERROR" ) ) ) ;
getProfileBadgeCompletionLevel: private int getProfileBadgeCompletionLevel ( ProfileBadge profileBadge ) { ContentLockTree . LockItem lockItem = profileBadge . getLockItem ( ) ; if ( lockItem == null ) return - Math . abs ( profileBadge . getID ( ) . hashCode ( ) ) ; if ( lockItem . isUnlocked ( BrainOutClient . ClientController . getUserProfile ( ) ) ) { return - Math . abs ( profileBadge . getID ( ) . hashCode ( ) ) ; } int need = lockItem . getParam ( ) ; int have = lockItem . getUnlockValue ( BrainOutClient . ClientController . getUserProfile ( ) , 0 ) ; if ( need == 0 ) return 0 ; return ( int ) ( 1.0f - ( ( float ) have / ( float ) need ) * 1000.0f ) ;
getPosition: public static void getPosition ( MPPointF center , float dist , float angle , MPPointF outputPoint ) { outputPoint . x = ( float ) ( center . x + dist * Math . cos ( Math . toRadians ( angle ) ) ) ; outputPoint . y = ( float ) ( center . y + dist * Math . sin ( Math . toRadians ( angle ) ) ) ;
dragStart: public DragAndDrop . Payload dragStart ( InputEvent event , float x , float y , int pointer ) { Group object = new Group ( ) ; object . setTouchable ( Touchable . disabled ) ; Group invalid = new Group ( ) ; invalid . setTouchable ( Touchable . disabled ) ; Group valid = new Group ( ) ; valid . setTouchable ( Touchable . disabled ) ; float scale = 1.0f / Map . GetWatcher ( ) . getScale ( ) ; float offsetX = - sprite . getWidth ( ) * scale * Constants . Graphics . BLOCK_SIZE * 0.5f + Constants . Graphics . BLOCK_SIZE * 0.5f , offsetY = - sprite . getHeight ( ) * scale * Constants . Graphics . BLOCK_SIZE * 0.5f + Constants . Graphics . BLOCK_SIZE * 0.5f ; RealEstateItemPayload payload = new RealEstateItemPayload ( offsetX , offsetY , entry . name , entry . payload ) ; { Group entry = renderSprite ( sprite , scale ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; object . addActor ( entry ) ; } { Image border = new Image ( BrainOutClient . Skin , "form-drag-good" ) ; border . setBounds ( offsetX - 2 , offsetY - 2 , sprite . getWidth ( ) * scale * Constants . Graphics . BLOCK_SIZE + 4 , sprite . getHeight ( ) * scale * Constants . Graphics . BLOCK_SIZE + 4 ) ; valid . addActor ( border ) ; Group entry = renderSprite ( sprite , scale ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; valid . addActor ( entry ) ; payload . addOffsetCallback ( ( x1 , y1 ) -> { border . setPosition ( offsetX - 2 + x1 , offsetY - 2 + y1 ) ; entry . setPosition ( offsetX + x1 , offsetY + y1 ) ; } ) ; } { Image border = new Image ( BrainOutClient . Skin , "form-border-red" ) ; border . setBounds ( offsetX - 2 , offsetY - 2 , sprite . getWidth ( ) * scale * Constants . Graphics . BLOCK_SIZE + 4 , sprite . getHeight ( ) * scale * Constants . Graphics . BLOCK_SIZE + 4 ) ; invalid . addActor ( border ) ; Group entry = renderSprite ( sprite , scale ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; invalid . addActor ( entry ) ; payload . addOffsetCallback ( ( x1 , y1 ) -> { border . setPosition ( offsetX - 2 + x1 , offsetY - 2 + y1 ) ; entry . setPosition ( offsetX + x1 , offsetY + y1 ) ; } ) ; } payload . setDragActor ( object ) ; payload . setObject ( sprite ) ; payload . setValidDragActor ( valid ) ; payload . setInvalidDragActor ( invalid ) ; return payload ;
setAnimationStart: public void setAnimationStart ( float animationStart ) { this . animationStart = animationStart ;
getAngle: public float getAngle ( ) { return 0 ;
isAnyAxisInverted: public boolean isAnyAxisInverted ( ) { if ( mAxisLeft . isInverted ( ) ) return true ; if ( mAxisRight . isInverted ( ) ) return true ; return false ;
getMarkerPosition: protected float [ ] getMarkerPosition ( Highlight high ) { return new float [ ] { high . getDrawY ( ) , high . getDrawX ( ) } ;
undo: void undo ( ) { counter . click ( ) ; counter . undo ( ) ; assertEquals ( 0 , counter . getValue ( ) ) ; counter . undo ( ) ; assertEquals ( 0 , counter . getValue ( ) ) ;
setRendererLeftYAxis: public void setRendererLeftYAxis ( YAxisRenderer rendererLeftYAxis ) { mAxisRendererLeft = rendererLeftYAxis ;
get: public int get ( int index ) { return v [ index ] ;
getFloorA: private ActiveData getFloorA ( ) { return findActiveData ( floorA ) ;
getContent: public Map < String , Object > getContent ( ) { return content ;
failingSideEffect: protected TestInvocationBuilder failingSideEffect ( String name , String reason ) { return testDefinitionForService (
setTrelloListName: public void setTrelloListName ( String trelloListName ) { this . trelloListName = trelloListName ;
consumeCustomData: public void consumeCustomData ( int target ) { Gdx . gl . glTexImage2D ( target , 0 , GL20 . GL_RGBA , width , height , 0 , GL20 . GL_RGBA , GL20 . GL_UNSIGNED_BYTE , buffer ) ;
success: public void success ( JSONObject response ) { button . setDisabled ( false ) ;
getEmbedIndex: public final int getEmbedIndex ( ) { return this . embedIndex ;
getCircleBitmap: private Bitmap getCircleBitmap ( Bitmap bitmap ) { Bitmap circleBitmap = Bitmap . createBitmap ( getMeasuredWidth ( ) , getMeasuredHeight ( ) , Bitmap . Config . ARGB_8888 ) ; Canvas canvas = new Canvas ( circleBitmap ) ; Paint paint = new Paint ( ) ; paint . setAntiAlias ( true ) ; paint . setFilterBitmap ( true ) ; paint . setDither ( true ) ; canvas . drawCircle ( getMeasuredWidth ( ) / 2 , getMeasuredHeight ( ) / 2 , getMeasuredWidth ( ) / 2 , paint ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . SRC_IN ) ) ; canvas . drawBitmap ( bitmap , 0 , 0 , paint ) ; return circleBitmap ;
getPathToYamlComponentFile: public String getPathToYamlComponentFile ( DynamicPrivilege entity ) { return getYamlDefaultFilePath ( EXPORT_PRIVILEGE_PATH_ , entity . getName ( ) , null ) ;
onMenuClose: public void onMenuClose ( int index ) { View titleView = getTitleViewByIndex ( index ) ; if ( titleView != null && titleView instanceof FilterTitleView ) {
toCSV: public File toCSV ( String filename , List < Object [ ] > data , String ... headers ) throws IOException , SQLException { return csvService . createCSV ( filename , data . stream ( ) . map ( Arrays :: asList )
getPlayer: public GetPlayerConversation . Response getPlayer ( final GetPlayerConversation . Request request ) { final Player player = Bukkit . getPlayer ( request . player ) ; if ( player == null ) { return new GetPlayerConversation . Response ( request , false , null ) ; } final PlayerDTO dto = PlayerDTO . fromPlayer ( player ) ; return new GetPlayerConversation . Response ( request , true , dto ) ;
printBanner: public void printBanner ( Class < ? > sourceClass , PrintStream printStream ) { new BannerService ( ) . printBanner ( ) ;
lockInput: public boolean lockInput ( ) { return true ;
run: public void run ( ) { onResponseFailData ( responseEntity ) ;
executeVirtualThreads: private long executeVirtualThreads ( Runnable runnable ) { Instant start = Instant . now ( ) ; try ( ExecutorService executor = Executors . newVirtualThreadPerTaskExecutor ( ) ) { for ( int i = 0 ; i < 10_000 ; i ++ ) { executor . submit ( runnable ) ; } } Instant finish = Instant . now ( ) ; return Duration . between ( start , finish ) . toMillis ( ) ;
onSuccess: No method body
init: public void init ( ) { this . effect = newEmitter ( particleEffect . getParticle ( ) ) ; this . emitter = this . effect . getEmitters ( ) . first ( ) ; angleMin = emitter . getAngle ( ) . getHighMin ( ) ; angleMax = emitter . getAngle ( ) . getHighMax ( ) ; rotationMin = emitter . getRotation ( ) . getHighMin ( ) ; rotationMax = emitter . getRotation ( ) . getHighMax ( ) ; effect . start ( ) ; prevPosition . set ( getX ( ) , getY ( ) ) ;
get: public final T get ( long time , @ NotNull TimeUnit unit ) throws Exception { return PromiseUtils . get ( this , unit . toMillis ( time ) ) ;
init: public void init ( ) { super . init ( ) ; BrainOutServer . PostRunnable ( ( ) ->
getXMin: No method body
union: void union ( ) { assertEquals ( Set . of ( 1 , 2 , 3 , 4 , 5 , 6 ) , Union . union ( Set . of ( 1 , 2 , 3 ) , Set . of ( 4 , 5 , 6 ) ) ) ; assertEquals ( Set . of ( 1 , 2 , 3 , 4 , 5 ) , Union . union ( Set . of ( 1 , 2 , 3 ) , Set . of ( 3 , 4 , 5 ) ) ) ; assertEquals ( Set . of ( ) , Union . union ( Set . of ( ) , Set . of ( ) ) ) ; assertEquals ( Set . of ( 1 , 2 , 3 ) , Union . union ( Set . of ( 1 , 2 , 3 ) , Set . of ( ) ) ) ; assertEquals ( Set . of ( 4 , 5 , 6 ) , Union . union ( Set . of ( ) , Set . of ( 4 , 5 , 6 ) ) ) ;
onItemClick: No method body
isValid: boolean isValid ( WayPointMap map ) { return getWayPoint ( map ) != null ;
setShearY: public void setShearY ( float shearY ) { this . shearY = shearY ;
convertAndSave: public Scheduler convertAndSave ( SchedulerConversionDto dto , String filePath ) { debug ( "[convertAndSave]" ) ; Scheduler scheduler = new Scheduler ( ) ; scheduler . setCronExpression ( dto . getCronExpression ( ) ) ; scheduler . setEventData ( dto . getEventData ( ) ) ; scheduler . setOnMasterOnly ( dto . isOnMasterOnly ( ) ) ; scheduler . setModuleName ( dto . getModule ( ) ) ; scheduler . setOrganizationId ( dto . getOrganizationId ( ) ) ; return repositories . secure . scheduler . saveOne ( scheduler ) ;
callback: No method body
saveNew: public Object saveNew ( @ PathVariable ( name = ORGANIZATIONID , required = false ) Long organizationId , @ RequestBody HashMap < String , String > params ) { debug ( "[saveNew]" ) ; CRUDControllerConfiguration conf = controllers . apiCrudControllerConfigurationMap . get ( key ) ; PrivilegeBase privilege = conf . getPostNewPrivilege ( ) ; if ( not ( hasGlobalOrOrgPrivilege ( privilege , organizationId ) ) ) { return ResponseEntity . status ( HttpStatus . UNAUTHORIZED ) . build ( ) ; } return Flow . init ( componentProvider )
test: public boolean test ( PlayerData playerData ) { GameMode gameMode = BrainOutClient . ClientController . getGameMode ( ) ; if ( gameMode instanceof GameModeLobby ) { GameModeRealization realization = gameMode . getRealization ( ) ; if ( realization instanceof ClientLobbyRealization ) { if ( ( ( ClientLobbyRealization ) realization ) . isInShootingRangeMode ( ) ) { return false ; } } } boolean hasWeapon = false ; for ( ClientEvent event : BrainOutClient . ClientController . getOnlineEvents ( ) ) { if ( ! event . getEvent ( ) . isValid ( ) ) continue ; if ( event . getEvent ( ) . taskAction . equals ( Constants . Other . SHOOTING_RANGE_ACTION ) ) { String data = event . getEvent ( ) . taskData ; if ( getShootingRange ( ) . hasWeapon ( data ) ) { hasWeapon = true ; break ; } } } if ( ! hasWeapon ) { return false ; } return super . test ( playerData ) ;
compress: public static byte [ ] compress ( String data ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( data . length ( ) ) ; GZIPOutputStream gzip = new GZIPOutputStream ( bos ) ; gzip . write ( data . getBytes ( ) ) ; gzip . close ( ) ; byte [ ] compressed = bos . toByteArray ( ) ; bos . close ( ) ; return compressed ;
getID: public ID getID ( ) { return ID . destroy ;
sha256HashByte: public static byte [ ] sha256HashByte ( byte [ ] data ) { try { MessageDigest digest = MessageDigest . getInstance ( "SHA-256" ) ; return digest . digest ( data ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return null ;
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { realization . write ( json , owner ) ; json . writeValue ( "phase" , phase ) ; json . writeValue ( "timer" , timer ) ; json . writeValue ( "et" , endTime ) ;
updateBean: No method body
getDefaultOrganizationId: public Long getDefaultOrganizationId ( ) { return defaultOrganizationId ;
compress: void compress ( int init_bits , OutputStream outs ) throws IOException { int fcode ; int i ; int c ; int ent ; int disp ; int hsize_reg ; int hshift ; g_init_bits = init_bits ; clear_flg = false ; n_bits = g_init_bits ; maxcode = MAXCODE ( n_bits ) ; ClearCode = 1 << ( init_bits - 1 ) ; EOFCode = ClearCode + 1 ; free_ent = ClearCode + 2 ; a_count = 0 ; ent = nextPixel ( ) ; hshift = 0 ; for ( fcode = hsize ; fcode < 65536 ; fcode *= 2 ) ++ hshift ; hshift = 8 - hshift ; hsize_reg = hsize ; cl_hash ( hsize_reg ) ; output ( ClearCode , outs ) ; outer_loop : while ( ( c = nextPixel ( ) ) != EOF ) { fcode = ( c << maxbits ) + ent ; i = ( c << hshift ) ^ ent ; if ( htab [ i ] == fcode ) { ent = codetab [ i ] ; continue ; } else if ( htab [ i ] >= 0 ) { disp = hsize_reg - i ; if ( i == 0 ) disp = 1 ; do { if ( ( i -= disp ) < 0 ) i += hsize_reg ; if ( htab [ i ] == fcode ) { ent = codetab [ i ] ; continue outer_loop ; } } while ( htab [ i ] >= 0 ) ; } output ( ent , outs ) ; ent = c ; if ( free_ent < maxmaxcode ) { codetab [ i ] = free_ent ++ ; htab [ i ] = fcode ; } else cl_block ( outs ) ; } output ( ent , outs ) ; output ( EOFCode , outs ) ;
disposeOnRelease: public boolean disposeOnRelease ( ) { return true ;
createNewEntity: public E createNewEntity ( Long organizationId ) { try {
translate: public Matrix translate ( final float [ ] transformedPts ) { Matrix save = new Matrix ( ) ; translate ( transformedPts , save ) ; return save ;
setEventData: public void setEventData ( String eventData ) { this . eventData = eventData ;
isInfoEnabled: public boolean isInfoEnabled ( ) { return logger . isInfoEnabled ( ) ;
texturesLoaded: public void texturesLoaded ( AssetManager assetManager ) { if ( getTextures ( ) != null )
GenerateKey: public static String GenerateKey ( String map , int layer , int x , int y ) { return "it" + map + "-" + layer + "x" + x + "y" + y ;
getColor: public Color getColor ( ) { return light ;
updateWorkflowOverrideById: public WorkflowOverrideResponse updateWorkflowOverrideById ( final String overrideId , final UpdateWorkflowOverrideRequest request ) throws IOException , NovuNetworkException { try {
clientInited: private void clientInited ( String teamId ) { Team team = ( ( Team ) BrainOut . ContentMgr . get ( teamId ) ) ; switchTo ( new CSGame ( team , playerData ) ) ;
setLevel: public void setLevel ( int level ) { this . level = level ;
getTitle: protected String getTitle ( ) { return item . getTitle ( ) . get ( ) ;
onSizeChanged: protected void onSizeChanged ( int w , int h , int oldWidth , int oldHeight ) { super . onSizeChanged ( w , h , oldWidth , oldHeight ) ; mHeight = h - getPaddingTop ( ) - getPaddingBottom ( ) ; mWidth = w ;
setProjectionMatrix: public void setProjectionMatrix ( Matrix4 projection ) { if ( drawing ) flush ( ) ; projectionMatrix . set ( projection ) ; if ( drawing ) setupMatrices ( ) ;
getScale: public float getScale ( ) { return 1.5f ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
getSkins: public Array < Skin > getSkins ( ) { return skins ;
setStyle: public void setStyle ( SearchFieldStyle style ) { if ( style == null ) throw new IllegalArgumentException ( "style cannot be null." ) ; this . style = style ; if ( searchFieldResultList != null ) { searchFieldResultList . setStyle ( style . scrollStyle ) ; searchFieldResultList . list . setStyle ( style . listStyle ) ; } invalidateHierarchy ( ) ;
setRequiredPrivilege: public void setRequiredPrivilege ( String requiredPrivilege ) { this . requiredPrivilege = requiredPrivilege ;
getGroup: public PrivilegeGroup getGroup ( ) { return group ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
findBestPreviewSizeValue: public static Point findBestPreviewSizeValue ( Camera . Parameters parameters , final Point screenResolution ) { List < Camera . Size > rawSupportedSizes = parameters . getSupportedPreviewSizes ( ) ; if ( rawSupportedSizes == null ) { Log . w ( TAG , "Device returned no supported preview sizes; using default" ) ; Camera . Size defaultSize = parameters . getPreviewSize ( ) ; if ( defaultSize == null ) { throw new IllegalStateException ( "Parameters contained no preview size!" ) ; } return new Point ( defaultSize . width , defaultSize . height ) ; } if ( Log . isLoggable ( TAG , Log . INFO ) ) { StringBuilder previewSizesString = new StringBuilder ( ) ; for ( Camera . Size size : rawSupportedSizes ) { previewSizesString . append ( size . width ) . append ( 'x' ) . append ( size . height ) . append ( ' ' ) ; } Log . i ( TAG , "Supported preview sizes: " + previewSizesString ) ; } double screenAspectRatio ; if ( screenResolution . x < screenResolution . y ) { screenAspectRatio = screenResolution . x / ( double ) screenResolution . y ; } else { screenAspectRatio = screenResolution . y / ( double ) screenResolution . x ; } Log . i ( TAG , "screenAspectRatio: " + screenAspectRatio ) ; int maxResolution = 0 ; Camera . Size maxResPreviewSize = null ; for ( Camera . Size size : rawSupportedSizes ) { int realWidth = size . width ; int realHeight = size . height ; int resolution = realWidth * realHeight ; if ( resolution < MIN_PREVIEW_PIXELS ) { continue ; } boolean isCandidatePortrait = realWidth < realHeight ; int maybeFlippedWidth = isCandidatePortrait ? realWidth : realHeight ; int maybeFlippedHeight = isCandidatePortrait ? realHeight : realWidth ; Log . i ( TAG , String . format ( "maybeFlipped:%d * %d" , maybeFlippedWidth , maybeFlippedHeight ) ) ; double aspectRatio = maybeFlippedWidth / ( double ) maybeFlippedHeight ; Log . i ( TAG , "aspectRatio: " + aspectRatio ) ; double distortion = Math . abs ( aspectRatio - screenAspectRatio ) ; Log . i ( TAG , "distortion: " + distortion ) ; if ( distortion > MAX_ASPECT_DISTORTION ) { continue ; } if ( maybeFlippedWidth == screenResolution . x && maybeFlippedHeight == screenResolution . y ) { Point exactPoint = new Point ( realWidth , realHeight ) ; Log . i ( TAG , "Found preview size exactly matching screen size: " + exactPoint ) ; return exactPoint ; } if ( resolution > maxResolution ) { maxResolution = resolution ; maxResPreviewSize = size ; } } if ( maxResPreviewSize != null ) { Point largestSize = new Point ( maxResPreviewSize . width , maxResPreviewSize . height ) ; Log . i ( TAG , "Using largest suitable preview size: " + largestSize ) ; return largestSize ; } Camera . Size defaultPreview = parameters . getPreviewSize ( ) ; if ( defaultPreview == null ) { throw new IllegalStateException ( "Parameters contained no preview size!" ) ; } Point defaultSize = new Point ( defaultPreview . width , defaultPreview . height ) ; Log . i ( TAG , "No suitable preview sizes, using default: " + defaultSize ) ; return defaultSize ;
changed: public void changed ( ChangeEvent event , Actor actor ) { validate ( isValid ( ) ) ;
initBackground: protected void initBackground ( ) { setBackground ( "form-default" ) ;
setColors: public void setColors ( int [ ] colors , Context c ) { if ( mColors == null ) { mColors = new ArrayList < > ( ) ; } mColors . clear ( ) ; for ( int color : colors ) {
getName: public String getName ( ) { return name ;
sendEmail: No method body
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; exitTime = jsonData . getFloat ( "exitTime" , 1.0f ) ; location = jsonData . getString ( "location" , "" ) ;
run: public void run ( ) { updateInvoiceList ( ) ; EventBus . getDefault ( ) . post ( new PayInvoiceSuccessEvent ( ) ) ; mLoadingDialog . dismiss ( ) ; rootView . findViewById ( R . id . lv_lucky_packet_step_one ) . setVisibility ( View . GONE ) ; rootView . findViewById ( R . id . lv_lucky_packet_success ) . setVisibility ( View . VISIBLE ) ; rootView . findViewById ( R . id . layout_cancel ) . setVisibility ( View . GONE ) ; rootView . findViewById ( R . id . layout_close ) . setVisibility ( View . VISIBLE ) ; showStepSuccess ( rootView ) ;
isDrawValuesEnabled: public boolean isDrawValuesEnabled ( ) { return mDrawValues ;
setScatterShape: public void setScatterShape ( ScatterChart . ScatterShape shape ) { mShapeRenderer = getRendererForShape ( shape ) ;
getOrganizationId: public Long getOrganizationId ( ) { return organizationId ;
addClass: private void addClass ( String className , Class clazz , boolean bothWays ) { if ( classesList . containsKey ( className ) ) { throw new RuntimeException ( "Double class registration: " + className ) ; } classesList . put ( className , clazz ) ; if ( bothWays )
testRun: void testRun ( ) { final OpenAiChatCompletionsParameters parameters = new OpenAiChatCompletionsParameters ( ) ; parameters . setModel ( "gpt-3.5-turbo" ) ; parameters . setTemperature ( 0D ) ; final OpenAiChatCompletionsChain chain = new OpenAiChatCompletionsChain ( "Hello, this is ${name}. What was my name again?" , parameters , System . getenv ( "OPENAI_API_KEY" ) , "You are a helpful assistant who answers questions to ${name}" ) ; final String name = "Manuel" ; final String result = chain . run ( Collections . singletonMap ( "name" , name ) ) ; LOGGER . info ( result ) ; assertNotNull ( result , "got no result from OpenAiChatCompletionsChain" ) ; assertTrue ( result . contains ( name ) , "The answer did not contain the name" ) ;
render: public void render ( Batch batch , RenderContext context ) { if ( size == 0 ) return ; for ( int j = 0 ; j < blockHeight ; j ++ )
setKills: public void setKills ( int kills ) { this . kills = kills ;
runQueries: private boolean runQueries ( boolean transactional , boolean logTime , String ... queries ) { long start = System . nanoTime ( ) ; runEntityManagerOperation ( transactional , em -> { executeQueries ( em , queries ) ; return null ; } ) ; long stop = System . nanoTime ( ) ; debug ( "[runQueries] Successfully in {} us" , ( stop - start ) / 1000 ) ; return true ;
updateActiveDatas: private void updateActiveDatas ( ) { Map map = Map . Get ( getMenu ( ) . getDimension ( ) ) ; closestActive = map . getClosestActive ( 8 , position . x , position . y , LightData . class , activeData -> true ) ;
setCancelable: public Builder setCancelable ( boolean cancelable ) { P . mCancelable = cancelable ; return this ;
update: public void update ( float dt ) { counter += dt ;
prepareHttpHeaders: public static HttpHeaders prepareHttpHeaders ( Map < String , String > headers ) { HttpHeaders httpHeaders = new HttpHeaders ( ) ; httpHeaders . setContentType ( MediaType . APPLICATION_JSON_UTF8 ) ; for ( Map . Entry < String , String > e : headers . entrySet ( ) ) { httpHeaders . set ( e . getKey ( ) , e . getValue ( ) ) ; } return httpHeaders ;
renderItem: protected void renderItem ( Table content , OwnableContent item ) { if ( item instanceof InstrumentSlotItem ) { InstrumentSlotItem slotItem = ( ( InstrumentSlotItem ) item ) ; if ( slotItem . getInstrument ( ) instanceof Weapon ) { Weapon weapon = ( ( Weapon ) slotItem . getInstrument ( ) ) ; if ( weapon . getPrimaryProperties ( ) . isVisible ( ) ) { InstrumentSlotItem . InstrumentSelection selection = ( ( InstrumentSlotItem . InstrumentSelection ) slotItem . getStaticSelection ( ) ) ; InstrumentCharacteristics chars = new InstrumentCharacteristics ( selection . getInfo ( ) , - 1 ) ; content . add ( chars ) . pad ( 16 ) . expandX ( ) . fillX ( ) . row ( ) ; } return ; } } Label description = new Label ( getDescription ( ) , BrainOutClient . Skin , "title-small" ) ; description . setAlignment ( Align . center ) ; description . setWrap ( true ) ; content . add ( description ) . width ( 500 ) . expandX ( ) . fillX ( ) . row ( ) ;
setSubject: public void setSubject ( String subject ) { this . subject = subject ;
onPageSelected: public void onPageSelected ( int position ) { super . onPageSelected ( position ) ; changeDotSelected ( position , count ) ;
getTakingPoints: public ObjectMap < Team , Integer > getTakingPoints ( ) { return takingPoints ;
consecutiveGetWithEmpty: protected TestInvocationBuilder consecutiveGetWithEmpty ( ) { return testDefinitionForVirtualObject (
resetTitle: public void resetTitle ( ) { for ( int i = 0 ; i < getTitleSize ( ) ; i ++ ) {
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { dragAndDropTargetActor = new Widget ( ) ; ( ( Widget ) dragAndDropTargetActor ) . setFillParent ( true ) ; data . addActor ( dragAndDropTargetActor ) ; } modePanel = new Table ( ) ; { Table toolbar = new Table ( BrainOutClient . Skin ) ; toolbar . align ( Align . left ) ; renderTopToolbar ( toolbar ) ; data . add ( toolbar ) . pad ( 8 ) . expandX ( ) . fillX ( ) . height ( 32 ) . row ( ) ; } data . add ( ) . expand ( ) . row ( ) ; { Table toolbar = new Table ( BrainOutClient . Skin ) ; toolbar . align ( Align . left ) ; renderBottomToolbar ( toolbar ) ; data . add ( toolbar ) . pad ( 8 ) . expandX ( ) . fillX ( ) . height ( 32 ) . row ( ) ; } return data ;
saveAll: public < S extends DynamicPrivilege > List < S > saveAll ( Iterable < S > entities ) { throw new NotImplementedException ( NO_IMPLEMENTATION_IN_CORE_OPENKODA ) ;
reset: public void reset ( ) { this . playerData = null ;
onError: public void onError ( Error error ) { view . findViewById ( R . id . refresh_btn ) . setVisibility ( View . VISIBLE ) ; if ( error . isServerError ( ) ) {
selectBlock: private void selectBlock ( ) { SelectContentMenu m = new SelectContentMenu ( currentBlock , Block . class , new SelectContentMenu . ContentSelected ( ) { @ Override public void selected ( Content content ) { currentBlock = ( ( Block ) content ) ; updateBlockButton ( ) ; } @ Override public void canceled ( ) { } @ Override public boolean filter ( Content content ) { return true ; } } ) ; getMenu ( ) . pushMenu ( m ) ;
getSelectValue: public String getSelectValue ( ) { return String . valueOf ( getValue ( ) ) ;
populateTo: protected User populateTo ( User entity ) { entity . setFirstName ( getSafeValue ( entity . getFirstName ( ) , FIRST_NAME_ , emptyIfBlank ) ) ; entity . setLastName ( getSafeValue ( entity . getLastName ( ) , LAST_NAME_ , emptyIfBlank ) ) ; entity . setEmail ( getSafeValue ( entity . getEmail ( ) , EMAIL_ ) ) ; entity . setEnabled ( getSafeValue ( entity . isEnabled ( ) , ENABLED_ ) ) ; entity . setLanguage ( getSafeValue ( entity . getLanguage ( ) , LANGUAGE ) ) ; return entity ;
onPrepareActionMode: public boolean onPrepareActionMode ( ActionMode mode , Menu menu ) { return false ; }
removeNonExisting: public void removeNonExisting ( ) { long schedulerId = 1L ; mockAndAuthenticateUser ( 1l , "test@openkoda.com" , "TEST" , "(canManageBackend)" ) ; boolean result = schedulerService . remove ( schedulerId ) ; assertFalse ( result ) ;
uid: public long uid ( ) { return uid ;
parseLong: public long parseLong ( String s ) { return Long . parseLong ( s ) ;
updatePlayersInfo: private void updatePlayersInfo ( ) { final Array < ClientsInfo . PingInfo > infos = new Array < > ( ) ; getClients ( ) . foreach ( pingMatching , client -> infos . add ( new ClientsInfo . PingInfo ( client . getId ( ) , client . getPing ( ) , client . getScore ( ) , client . getKills ( ) , client . getDeaths ( ) , client . getTeam ( ) . getID ( ) , client . getLevel ( Constants . User . LEVEL , 1 ) , client . getRights ( ) ) ) ) ; getClients ( ) . sendUDP ( new ClientsInfo ( infos ) , pingMatching ) ;
initBuffers: No method body
getBalance: public double getBalance ( ) { return balance ;
resize: void resize ( ) { circle . resize ( 2 ) ; assertEquals ( 20 , circle . getRadius ( ) ) ;
launchEffect: public void launchEffect ( String kind , EffectSet . EffectAttacher effectAttacher ) { if ( "shoot" . equals ( kind ) ) { extLaunchData = null ; extAttacher = effectAttacher ; shootExtTimer = ( ( ExtendedInstrumentEffectsComponent ) getContentComponent ( ) ) . getExtendedShootPeriod ( ) ; update ( 0 ) ; } effects . launchEffects ( kind , effectAttacher ) ;
update: void update ( ) throws Exception { assertNotNull ( updateRoleByRoleParam , "updateRoleParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . put ( "/role/update" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( updateRoleByRoleParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "更新角色接口测试成功！" ) ;
sideEffectGuard: No method body
isEnabled: public static boolean isEnabled ( ) { return Prefs . getBoolean ( PreferenceKeys . REMOVE_DISCORD_REBRAND_V2 , false ) ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; attached . read ( attachedValue ) ; attachedValue = null ;
setCollectPerClass: public void setCollectPerClass ( ) { this . collectPerClass = true ; sentPerClass . clear ( ) ;
handleHttpResponse: public void handleHttpResponse ( Net . HttpResponse httpResponse ) { byte [ ] result = httpResponse . getResult ( ) ; Gdx . app . postRunnable ( ( ) ->
main: public static void main ( String [ ] args ) { startApp ( TimelogApp . class , args ) ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( L . get ( "EDITOR_NEW_MAP" ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . row ( ) ; data . add ( header ) . size ( 462 , 32 ) . row ( ) ; } { Table contents = new Table ( BrainOutClient . Skin ) ; contents . setBackground ( "form-default" ) ; contents . align ( Align . center ) ; renderContents ( contents ) ; data . add ( contents ) . size ( 464 , 304 ) . row ( ) ; } { Table buttons = new Table ( ) ; { TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ; } } ) ; buttons . add ( cancel ) . expandX ( ) . fillX ( ) . uniformX ( ) . height ( 64 ) ; } { createButton = new TextButton ( L . get ( "MENU_CREATE" ) , BrainOutClient . Skin , "button-green" ) ; createButton . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; create ( ) ; } } ) ; buttons . add ( createButton ) . expandX ( ) . fillX ( ) . uniformX ( ) . height ( 64 ) ; } data . add ( buttons ) . expandX ( ) . fillX ( ) . row ( ) ; } return data ;
removeFirst: No method body
saveAll: public MapSaveResult saveAll ( final Set < String > dimensions , final ActiveData . ComponentWriter componentWriter , boolean addSignature , int owner , final MapSaver saver ) { return saveAll ( dimensions , componentWriter , addSignature , owner , "default" , saver ) ;
getLogitBias: public Map < Integer , Integer > getLogitBias ( ) { return logitBias ;
getScatterShapeHoleColor: No method body
updateOrgAdminAndUserRole: public void updateOrgAdminAndUserRole ( ) { if ( SpringProfilesHelper . isInitializationProfile ( ) ) {
subscribeTransactions: public Observable < lnrpc . LightningOuterClass . Transaction > subscribeTransactions ( lnrpc . LightningOuterClass . GetTransactionsRequest request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . subscribeTransactions ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
lockUpdate: public boolean lockUpdate ( ) { return true ;
testDetachWarehouse: public void testDetachWarehouse ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . merchants ( ) . detachWarehouse ( Identifier . fromId ( 1 ) , Identifier . fromId ( 1 ) , options ) ;
initializeDialUpdateThread: public void initializeDialUpdateThread ( ) { UI . uiThreads . add ( new Thread ( ( ) -> { try { while ( true ) { annunciator . update ( ) ; if ( this . isVisible ( ) ) { java . awt . EventQueue . invokeLater ( ( ) -> { float alignment1 = tg1 . getGenAligmnent ( ) ; float rpm1 = tg1 . getRpm ( ) ; float alignment2 = tg2 . getGenAligmnent ( ) ; float rpm2 = tg2 . getRpm ( ) ; if ( rpm1 > 2800 ) { radial1 . setValue ( alignment1 ) ; } radial2 . setValue ( tg1 . getRpm ( ) ) ; if ( rpm2 > 2800 ) { radial4 . setValue ( alignment2 ) ; } radial1 . setUserLedOn ( alignment1 > 48.5 && alignment1 < 51.5 && rpm1 >= 2997.5 && rpm1 <= 3002.5 ) ; radial4 . setUserLedOn ( alignment2 > 48.5 && alignment2 < 51.5 && rpm2 >= 2997.5 && rpm2 <= 3002.5 ) ; radial3 . setValue ( tg2 . getRpm ( ) ) ; radial2Top1 . setValue ( TG1InletValves . get ( 0 ) . getPosition ( ) * 100 ) ; radial2Top2 . setValue ( TG2InletValves . get ( 0 ) . getPosition ( ) * 100 ) ; linear1 . setValue ( tg1 . getGeneratorLoad ( ) ) ; linear2 . setValue ( tg1 . getSteamInflow ( ) * 20 ) ; linear3 . setValue ( tg2 . getGeneratorLoad ( ) ) ; linear4 . setValue ( tg2 . getSteamInflow ( ) * 20 ) ; pressure1 . setValue ( mcc . drum1 . getPressure ( ) ) ; pressure2 . setValue ( mcc . drum2 . getPressure ( ) ) ; valvePos1 . setValue ( sdv_c . get ( 0 ) . getPosition ( ) * 100 ) ; valvePos2 . setValue ( sdv_c . get ( 1 ) . getPosition ( ) * 100 ) ; valvePos3 . setValue ( sdv_c . get ( 2 ) . getPosition ( ) * 100 ) ; valvePos4 . setValue ( sdv_c . get ( 3 ) . getPosition ( ) * 100 ) ; valvePos5 . setValue ( sdv_c . get ( 4 ) . getPosition ( ) * 100 ) ; valvePos6 . setValue ( sdv_c . get ( 5 ) . getPosition ( ) * 100 ) ; valvePos7 . setValue ( sdv_c . get ( 6 ) . getPosition ( ) * 100 ) ; valvePos8 . setValue ( sdv_c . get ( 7 ) . getPosition ( ) * 100 ) ; } ) ; } if ( this . isFocused ( ) ) { Thread . sleep ( UI . getUpdateRate ( ) ) ; } else { Thread . sleep ( 200 ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } ) ) ; UI . uiThreads . get ( UI . uiThreads . size ( ) - 1 ) . start ( ) ;
enableBlending: public void enableBlending ( ) { flush ( ) ; blendingDisabled = false ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { filter2InItemStateChanged ( evt ) ;
getSoundVolume: public IntegerRangeProperty getSoundVolume ( ) { return soundVolume ;
get: public String get ( @ Nullable MultiMap carrier , String key ) { if ( carrier == null ) { return null ; } return carrier . get ( key ) ;
byte2Hex: public static String byte2Hex ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { String byteHexString = Integer . toHexString ( bytes [ i ] & 0xFF ) ; if ( byteHexString . length ( ) == 1 ) { sb . append ( "0" ) ; } sb . append ( byteHexString ) ; } return sb . toString ( ) ;
setLockInheritance: public void setLockInheritance ( boolean lock ) { this . lock = lock ;
write: public void write ( Json json ) { super . write ( json ) ;
onDestroy: protected void onDestroy ( ) { super . onDestroy ( ) ; if ( mWebView != null ) { mWebView . releaseWebView ( ) ; } if ( mInterfaceObject != null ) { mInterfaceObject . release ( ) ; } release ( ) ;
create: public WebhookSubscription create ( WebhookSubscription model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < WebhookSubscription > responseModel = ( Class < WebhookSubscription > ) ( Class < ? > ) WebhookSubscription . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/webhooks/subscriptions" ) , query , null , responseModel , model ) ;
getInterpolation: public float getInterpolation ( float input ) { input -- ; return ( float ) Math . sqrt ( 1f - input * input ) ;
saveCompanyToLocal: public static void saveCompanyToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_COMPANY_ID , value ) ;
getValueTextSize: public float getValueTextSize ( ) { return mValueTextSize ;
run: No method body
updateResourceCategory: No method body
saveOne: public < S extends T > S saveOne ( S entity ) { return wrapped . saveOne ( scope , entity ) ;
run: public void run ( ) { mViewPortHandler . restrainViewPort ( left , top , right , bottom ) ; prepareOffsetMatrix ( ) ; prepareValuePxMatrix ( ) ;
collision: private float collision ( Fixture fixture , Vector2 point , Vector2 normal , float fraction ) { Map map = getMap ( ) ; if ( map == null ) return 0 ; point . scl ( Constants . Physics . SCALE_OF ) ; normal . scl ( Constants . Physics . SCALE_OF ) ; tmpEnd . set ( normal ) . scl ( - 0.1f ) . add ( point ) ; Object userData = fixture . getUserData ( ) ; if ( userData == null ) { return 1 ; } detect ( ) ; return 1 ;
addTabIcon: public Tab addTabIcon ( String icon ) { return addTabIcon ( icon , null ) ;
getItemText: private String getItemText ( ConsumableRecord record ) { if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; return ici . getInstrumentData ( ) . getInstrument ( ) . getTitle ( ) . get ( ) ; } return record . getItem ( ) . getContent ( ) . getTitle ( ) . get ( ) ;
isStopEmitter: public boolean isStopEmitter ( ) { return stopEmitter ;
discard: No method body
validateFrequency: public static int validateFrequency ( int value ) { value = MathUtils . clamp ( value , MIN_FREQUENCY , MAX_FREQUENCY ) ; int frequencyLastNumeral = value % 10 ; if ( frequencyLastNumeral != 0 && frequencyLastNumeral != 5 ) { int frequencyRoundingAmount = frequencyLastNumeral % 5 ; value -= frequencyRoundingAmount ; } return value ;
getShortLocalizedName: public String getShortLocalizedName ( ) { return L . get ( "QUEST_TASK_SPEND_TIME" ,
getComponent: public ClientGeneratorLightsComponentData getComponent ( ComponentObject componentObject ) { return new ClientGeneratorLightsComponentData ( componentObject , this ) ;
getData: No method body
getBoundingBoxes: public Array < BoundingBoxAttachment > getBoundingBoxes ( ) { return boundingBoxes ;
hasBeenCompleted: public boolean hasBeenCompleted ( UserProfile userProfile , String account ) { return isQuestDoneForToday ( userProfile ) ;
awakeable: public < T > Awakeable < T > awakeable ( Serde < T > serde ) throws TerminalException { Map . Entry < String , Deferred < ByteBuffer > > awakeable = Util . blockOnSyscall ( syscalls :: awakeable ) ; return new Awakeable < > ( syscalls , awakeable . getValue ( ) , serde , awakeable . getKey ( ) ) ;
getTableColumns: public String getTableColumns ( ) { return tableColumns ;
parseEntities: public void parseEntities ( Table data , XmlReader . Element root , Skin skin , String defaultStyle ) { Table line = new Table ( ) ; for ( int i = 0 , t = root . getChildCount ( ) ; i < t ; i ++ ) { XmlReader . Element item = root . getChild ( i ) ; String kind = item . getName ( ) ; RichElement element ; try { element = RichElement . valueOf ( kind ) ; } catch ( IllegalArgumentException ignored ) { continue ; } switch ( element ) { case br : { data . add ( line ) . expandX ( ) . fillX ( ) . row ( ) ; line = new Table ( ) ; break ; } case text : { addLabel ( line , item . getText ( ) , item , skin , defaultStyle ) ; break ; } case loc : { addLabel ( line , L . get ( item . getText ( ) ) , item , skin , defaultStyle ) ; break ; } case img : { TextureAtlas . AtlasRegion region = BrainOutClient . getRegion ( item . getText ( ) ) ; if ( region == null ) continue ; Image image = new Image ( region ) ; Cell cell = addItem ( line , image , item ) ; String align = item . getAttribute ( "align" , null ) ; if ( align != null ) { if ( align . equals ( "center" ) ) cell . center ( ) ; else if ( align . equals ( "left" ) ) cell . left ( ) ; else if ( align . equals ( "right" ) ) cell . right ( ) ; } break ; } case div : { Table child = new Table ( skin ) ; parseEntities ( child , item , skin , defaultStyle ) ; addItem ( line , child , item ) ; break ; } case define : { String id = item . getAttribute ( "id" , null ) ; if ( id != null ) { String defineValue = BrainOut . PackageMgr . getDefine ( id , "default" ) ; XmlReader . Element cond = item . getChildByName ( defineValue ) ; if ( cond != null ) { Table child = new Table ( skin ) ; parseEntities ( child , cond , skin , defaultStyle ) ; addItem ( line , child , cond ) ; } } break ; } } } data . add ( line ) . expandX ( ) . fillX ( ) . row ( ) ;
getPosY: public int getPosY ( ) { return posY ;
getNeighbors: protected int getNeighbors ( Map map , int currentX , int currentY , int layer ) { int v = ( isMatchNeighbor ( map , currentX , currentY , layer , 0 , 1 ) ? 1 : 0 ) + ( isMatchNeighbor ( map , currentX , currentY , layer , 1 , 0 ) ? 2 : 0 ) + ( isMatchNeighbor ( map , currentX , currentY , layer , 0 , - 1 ) ? 4 : 0 ) + ( isMatchNeighbor ( map , currentX , currentY , layer , - 1 , 0 ) ? 8 : 0 ) ; if ( getContentComponent ( ) . isNine ( ) ) { v += ( isMatchNeighbor ( map , currentX , currentY , layer , 1 , 1 ) ? 16 : 0 ) + ( isMatchNeighbor ( map , currentX , currentY , layer , 1 , - 1 ) ? 32 : 0 ) + ( isMatchNeighbor ( map , currentX , currentY , layer , - 1 , - 1 ) ? 64 : 0 ) + ( isMatchNeighbor ( map , currentX , currentY , layer , - 1 , 1 ) ? 128 : 0 ) ; } return v ;
main: public static void main ( String [ ] args ) { try {
getPackagesFolder: protected String getPackagesFolder ( ) { return "packages" ;
applyForce: public void applyForce ( Vector2 force ) { this . force . add ( force ) ;
keyDown: public boolean keyDown ( InputEvent event , int keycode ) { if ( keycode == Input . Keys . ESCAPE ) hide ( ) ; return false ;
markSchemaAsDeleted: public String markSchemaAsDeleted ( long orgId , int assignedDatasource ) { debug ( "[markSchemeAsRemoved] OrgId: {}" , orgId ) ; return multitenancyService . markSchemaAsDeleted ( orgId , assignedDatasource ) ;
obtain: public static Event obtain ( boolean success ) { PartyStartResultEvent e = obtain ( PartyStartResultEvent . class ) ; if ( e == null ) return null ; return e . init ( success ) ;
lockInput: public boolean lockInput ( ) { return true ;
play: protected void play ( ) { if ( soundId == - 1 )
newMeshAttachment: public MeshAttachment newMeshAttachment ( Skin skin , String name , String path ) { TextureAtlas . AtlasRegion region = BrainOutClient . getRegion ( path ) ; if ( region == null ) throw new RuntimeException ( "Region not found in atlas: " + path + " (mesh attachment: " + name + ")" ) ; MeshAttachment attachment = new MeshAttachment ( name ) ; attachment . setRegion ( region ) ; return attachment ;
readAttachment: private Attachment readAttachment ( JsonValue map , Skin skin , int slotIndex , String name , SkeletonData skeletonData ) { float scale = this . scale ; name = map . getString ( "name" , name ) ; switch ( AttachmentType . valueOf ( map . getString ( "type" , AttachmentType . region . name ( ) ) ) ) { case region : { String path = map . getString ( "path" , name ) ; RegionAttachment region = attachmentLoader . newRegionAttachment ( skin , name , path ) ; if ( region == null ) return null ; region . setPath ( path ) ; region . setX ( map . getFloat ( "x" , 0 ) * scale ) ; region . setY ( map . getFloat ( "y" , 0 ) * scale ) ; region . setScaleX ( map . getFloat ( "scaleX" , 1 ) ) ; region . setScaleY ( map . getFloat ( "scaleY" , 1 ) ) ; region . setRotation ( map . getFloat ( "rotation" , 0 ) ) ; region . setWidth ( map . getFloat ( "width" ) * scale ) ; region . setHeight ( map . getFloat ( "height" ) * scale ) ; String color = map . getString ( "color" , null ) ; if ( color != null ) Color . valueOf ( color , region . getColor ( ) ) ; region . updateOffset ( ) ; return region ; } case boundingbox : { BoundingBoxAttachment box = attachmentLoader . newBoundingBoxAttachment ( skin , name ) ; if ( box == null ) return null ; readVertices ( map , box , map . getInt ( "vertexCount" ) << 1 ) ; String color = map . getString ( "color" , null ) ; if ( color != null ) Color . valueOf ( color , box . getColor ( ) ) ; return box ; } case mesh : case linkedmesh : { String path = map . getString ( "path" , name ) ; MeshAttachment mesh = attachmentLoader . newMeshAttachment ( skin , name , path ) ; if ( mesh == null ) return null ; mesh . setPath ( path ) ; String color = map . getString ( "color" , null ) ; if ( color != null ) Color . valueOf ( color , mesh . getColor ( ) ) ; mesh . setWidth ( map . getFloat ( "width" , 0 ) * scale ) ; mesh . setHeight ( map . getFloat ( "height" , 0 ) * scale ) ; String parent = map . getString ( "parent" , null ) ; if ( parent != null ) { linkedMeshes . add ( new LinkedMesh ( mesh , map . getString ( "skin" , null ) , slotIndex , parent , map . getBoolean ( "deform" , true ) ) ) ; return mesh ; } float [ ] uvs = map . require ( "uvs" ) . asFloatArray ( ) ; readVertices ( map , mesh , uvs . length ) ; mesh . setTriangles ( map . require ( "triangles" ) . asShortArray ( ) ) ; mesh . setRegionUVs ( uvs ) ; mesh . updateUVs ( ) ; if ( map . has ( "hull" ) ) mesh . setHullLength ( map . require ( "hull" ) . asInt ( ) << 1 ) ; if ( map . has ( "edges" ) ) mesh . setEdges ( map . require ( "edges" ) . asShortArray ( ) ) ; return mesh ; } case path : { PathAttachment path = attachmentLoader . newPathAttachment ( skin , name ) ; if ( path == null ) return null ; path . setClosed ( map . getBoolean ( "closed" , false ) ) ; path . setConstantSpeed ( map . getBoolean ( "constantSpeed" , true ) ) ; int vertexCount = map . getInt ( "vertexCount" ) ; readVertices ( map , path , vertexCount << 1 ) ; float [ ] lengths = new float [ vertexCount / 3 ] ; int i = 0 ; for ( JsonValue curves = map . require ( "lengths" ) . child ; curves != null ; curves = curves . next ) lengths [ i ++ ] = curves . asFloat ( ) * scale ; path . setLengths ( lengths ) ; String color = map . getString ( "color" , null ) ; if ( color != null ) Color . valueOf ( color , path . getColor ( ) ) ; return path ; } case point : { PointAttachment point = attachmentLoader . newPointAttachment ( skin , name ) ; if ( point == null ) return null ; point . setX ( map . getFloat ( "x" , 0 ) * scale ) ; point . setY ( map . getFloat ( "y" , 0 ) * scale ) ; point . setRotation ( map . getFloat ( "rotation" , 0 ) ) ; String color = map . getString ( "color" , null ) ; if ( color != null ) Color . valueOf ( color , point . getColor ( ) ) ; return point ; } case clipping : ClippingAttachment clip = attachmentLoader . newClippingAttachment ( skin , name ) ; if ( clip == null ) return null ; String end = map . getString ( "end" , null ) ; if ( end != null ) { SlotData slot = skeletonData . findSlot ( end ) ; if ( slot == null ) throw new SerializationException ( "Clipping end slot not found: " + end ) ; clip . setEndSlot ( slot ) ; } readVertices ( map , clip , map . getInt ( "vertexCount" ) << 1 ) ; String color = map . getString ( "color" , null ) ; if ( color != null ) Color . valueOf ( color , clip . getColor ( ) ) ; return clip ; } return null ;
encode: protected void encode ( final ChannelHandlerContext context , final JRPCClientHandshakeMessage message , ByteBuf out ) throws Exception { final byte [ ] data = PacketDataSerializer . serialize ( message ) ; out . writeInt ( data . length ) . writeBytes ( data ) ;
init: public void init ( ) { super . init ( ) ; BrainOutServer . EventMgr . subscribe ( Event . ID . playerWon , this ) ;
dictionary: public < T extends SearchableEntity > Map dictionary ( Class < T > entityClass , String keyField , String labelField , String sortField ) { CriteriaQuery < Tuple > q = getTupleCriteriaQuery ( entityClass , keyField , labelField , sortField ) . distinct ( true ) ; List < Tuple > result = em . createQuery ( q ) . getResultList ( ) ; return toLinkedMap ( result ) ;
create: public static RequestBody create ( @ NotNull byte [ ] toByteArray , @ Nullable MediaType mediaType ) { return new RequestBody ( ) ;
rewardClaimed: private void rewardClaimed ( int rewardIndex , EventReward reward ) { client . designEvent ( 1 , "gameplay" , "event-reward-claimed" , "reward-" + ( rewardIndex + 1 ) ) ; if ( reward . reward . getAction ( ) instanceof ServerReward . ServerAction ) { ServerReward . ServerAction action = ( ( ServerReward . ServerAction ) reward . reward . getAction ( ) ) ; action . apply ( client , true ) ; } reward . claimed = true ;
release: public void release ( ) { handlers . clear ( ) ; playerClient = null ;
isAllowedToLeave: private boolean isAllowedToLeave ( PlayerData playerData ) { return true ;
getHookedInstrument: public InstrumentData getHookedInstrument ( ) { return hookedInstrument ;
reset: public void reset ( ) { this . eventId = 0 ; this . rewardIndex = 0 ; this . success = false ;
checkReadPhoneStatePermission: public static boolean checkReadPhoneStatePermission ( Context context ) { return PermissionUtils . hasSelfPermissions ( context , Manifest . permission . READ_PHONE_STATE ) ;
init: private Event init ( boolean flag ) { this . flag = flag ; return this ;
newNetworkClient: public NetworkClient newNetworkClient ( Kryo kryo , NetworkConnectionListener listener ) { return new KryoNetworkClient ( kryo , listener ) ;
update: public Carrier update ( Identifier carrierIdentifier , Carrier model ) throws ApiErrorException , ConnectionException { Class < Carrier > responseModel = ( Class < Carrier > ) ( Class < ? > ) Carrier . class ; return this . request ( "put" , this . resolvePath ( "/carriers/%s" , carrierIdentifier ) , null , null , responseModel , model ) ;
setSwipeEnable: public void setSwipeEnable ( boolean swipeEnable ) { isSwipeEnable = swipeEnable ;
setBuilder: public void setBuilder ( Map < String , String > builder ) { this . builder = builder ;
calcMinMaxY: public void calcMinMaxY ( float fromX , float toX ) { mYMax = - Float . MAX_VALUE ; mYMin = Float . MAX_VALUE ; if ( mEntries == null || mEntries . isEmpty ( ) ) return ; int indexFrom = getEntryIndex ( fromX , Float . NaN , Rounding . DOWN ) ; int indexTo = getEntryIndex ( toX , Float . NaN , Rounding . UP ) ; if ( indexTo < indexFrom ) return ; for ( int i = indexFrom ; i <= indexTo ; i ++ ) {
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCreateRequest.json" ) ; Shop requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Shop . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Shop responseEntity = this . api . shops ( ) . create ( requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
setSearchText: public void setSearchText ( String searchText ) { this . mSearchText = searchText ;
updateDepart: public AjaxResult updateDepart ( @ RequestBody @ Valid UpdateDepartByUserParam param ) { userService . updateDepart ( param . getUserId ( ) , param . getDepartId ( ) ) ; return AjaxResult . success ( "更新用户部门成功！" ) ;
globalWon: private void globalWon ( GlobalConflict . Owner owner , GlobalConflict . ConflictData data , GlobalConflict conflict , ProfileService profileService , LoginService loginService , long lastConflict ) { JSONObject cc = new JSONObject ( ) ; for ( GlobalConflict . Zone zone : conflict . getZones ( ) ) { cc . put ( zone . getKey ( ) , JSONObject . NULL ) ; } { long now = System . currentTimeMillis ( ) ; JSONObject newLast = new JSONObject ( ) ; newLast . put ( "@func" , "<" ) ; newLast . put ( "@cond" , now ) ; newLast . put ( "@then" , now ) ; cc . put ( "last" , newLast ) ; } cc . put ( "prev" , lastConflict ) ; cc . put ( "winner" , owner . toString ( ) ) ; JSONObject update = new JSONObject ( ) ; update . put ( "conflict" , cc ) ; profileService . updateMyProfile ( loginService . getCurrentAccessToken ( ) , update , null , true ,
requestMaps: private void requestMaps ( ) { if ( ! BrainOutClient . Env . getGameUser ( ) . hasWorkshop ( ) ) { renderFailed ( "Workshop is not implemented" ) ; return ; } GameUser . WorkshopItemsQuery query = BrainOutClient . Env . getGameUser ( ) . queryMyPublishedWorkshopItems ( ) ; query . addRequiredTag ( "map" ) ; query . sendQuery ( new GameUser . WorkshopItemsQueryCallback ( )
loadClusterAware: public boolean loadClusterAware ( long formId ) { debug ( "[loadClusterAware] {}" , formId ) ; if ( ClusterHelper . isCluster ( ) ) { return clusterEventSenderService . loadForm ( formId ) ; } return addForm ( formId ) ;
timedOut: public boolean timedOut ( PlayStateEndGame . GameResult gameResult ) { Array < Client > clients = BrainOutServer . Controller . getClients ( ) . values ( ) . toArray ( ) ; clients . sort ( Comparator . comparingInt ( this :: getClientRank ) ) ; if ( clients . size > 0 ) { gameResult . setPlayerWon ( clients . get ( 0 ) . getId ( ) ) ; } if ( gameResult instanceof ServerPSEndGame . ServerGameResult ) { ServerPSEndGame . ServerGameResult serverGameResult = ( ( ServerPSEndGame . ServerGameResult ) gameResult ) ; serverGameResult . getRewardClients ( ) . clear ( ) ; for ( int i = 0 ; i < ( float ) clients . size / 2.0f ; i ++ ) { serverGameResult . getRewardClients ( ) . add ( clients . get ( i ) ) ; } } return true ;
copy: protected void copy ( BarLineScatterCandleBubbleDataSet barLineScatterCandleBubbleDataSet ) { super . copy ( barLineScatterCandleBubbleDataSet ) ; barLineScatterCandleBubbleDataSet . mHighLightColor = mHighLightColor ;
update: public void update ( float dt ) { super . update ( dt ) ; ItemData itemData = ( ( ItemData ) getComponentObject ( ) ) ; check -= dt ; if ( check < dt )
onRelease: public void onRelease ( ) { super . onRelease ( ) ; map = null ; if ( previewTexture != null )
getHoldPrevious: public boolean getHoldPrevious ( ) { return holdPrevious ;
getName: public String getName ( ) { return oauth2User . getAttribute ( "name" ) ;
setDescription: public void setDescription ( String description ) { this . description = description ;
goodAtTheBeginning: public static boolean goodAtTheBeginning ( String s ) { if ( s . length ( ) < 4 ) { return false ; } return ( s . charAt ( 0 ) == 'g' && s . charAt ( 1 ) == 'o' && s . charAt ( 2 ) == 'o' && s . charAt ( 3 ) == 'd' ) ;
run: public void run ( ) { try {
definitions: public Stream < TestSuite > definitions ( ) { return Stream . of (
testAddRemoveEntry: public void testAddRemoveEntry ( ) { List < Entry > entries = new ArrayList < Entry > ( ) ; entries . add ( new Entry ( 10 , 10 ) ) ; entries . add ( new Entry ( 15 , 2 ) ) ; entries . add ( new Entry ( 21 , 5 ) ) ; ScatterDataSet set = new ScatterDataSet ( entries , "" ) ; assertEquals ( 3 , set . getEntryCount ( ) ) ; set . addEntryOrdered ( new Entry ( 5 , 1 ) ) ; assertEquals ( 4 , set . getEntryCount ( ) ) ; assertEquals ( 5 , set . getXMin ( ) , 0.01f ) ; assertEquals ( 21 , set . getXMax ( ) , 0.01f ) ; assertEquals ( 1f , set . getYMin ( ) , 0.01f ) ; assertEquals ( 10f , set . getYMax ( ) , 0.01f ) ; assertEquals ( 5 , set . getEntryForIndex ( 0 ) . getX ( ) , 0.01f ) ; assertEquals ( 1 , set . getEntryForIndex ( 0 ) . getY ( ) , 0.01f ) ; set . addEntryOrdered ( new Entry ( 20 , 50 ) ) ; assertEquals ( 5 , set . getEntryCount ( ) ) ; assertEquals ( 20 , set . getEntryForIndex ( 3 ) . getX ( ) , 0.01f ) ; assertEquals ( 50 , set . getEntryForIndex ( 3 ) . getY ( ) , 0.01f ) ; assertTrue ( set . removeEntry ( 3 ) ) ; assertEquals ( 4 , set . getEntryCount ( ) ) ; assertEquals ( 21 , set . getEntryForIndex ( 3 ) . getX ( ) , 0.01f ) ; assertEquals ( 5 , set . getEntryForIndex ( 3 ) . getY ( ) , 0.01f ) ; assertEquals ( 5 , set . getEntryForIndex ( 0 ) . getX ( ) , 0.01f ) ; assertEquals ( 1 , set . getEntryForIndex ( 0 ) . getY ( ) , 0.01f ) ; assertTrue ( set . removeFirst ( ) ) ; assertEquals ( 3 , set . getEntryCount ( ) ) ; assertEquals ( 10 , set . getEntryForIndex ( 0 ) . getX ( ) , 0.01f ) ; assertEquals ( 10 , set . getEntryForIndex ( 0 ) . getY ( ) , 0.01f ) ; set . addEntryOrdered ( new Entry ( 15 , 3 ) ) ; assertEquals ( 4 , set . getEntryCount ( ) ) ; assertEquals ( 15 , set . getEntryForIndex ( 1 ) . getX ( ) , 0.01f ) ; assertEquals ( 3 , set . getEntryForIndex ( 1 ) . getY ( ) , 0.01f ) ; assertEquals ( 21 , set . getEntryForIndex ( 3 ) . getX ( ) , 0.01f ) ; assertEquals ( 5 , set . getEntryForIndex ( 3 ) . getY ( ) , 0.01f ) ; assertTrue ( set . removeLast ( ) ) ; assertEquals ( 3 , set . getEntryCount ( ) ) ; assertEquals ( 15 , set . getEntryForIndex ( 2 ) . getX ( ) , 0.01f ) ; assertEquals ( 2 , set . getEntryForIndex ( 2 ) . getY ( ) , 0.01f ) ; assertTrue ( set . removeLast ( ) ) ; assertEquals ( 2 , set . getEntryCount ( ) ) ; assertTrue ( set . removeLast ( ) ) ; assertEquals ( 1 , set . getEntryCount ( ) ) ; assertEquals ( 10 , set . getEntryForIndex ( 0 ) . getX ( ) , 0.01f ) ; assertEquals ( 10 , set . getEntryForIndex ( 0 ) . getY ( ) , 0.01f ) ; assertTrue ( set . removeLast ( ) ) ; assertEquals ( 0 , set . getEntryCount ( ) ) ; assertFalse ( set . removeLast ( ) ) ; assertFalse ( set . removeFirst ( ) ) ;
setMultiply: public void setMultiply ( int multiply ) { this . multiply = multiply ;
setParameterType: public void setParameterType ( String parameterType ) { this . parameterType = parameterType ;
getDepartListPage: public List < DepartDto > getDepartListPage ( Integer pageNum , Integer pageSize , String queryKey ) { PageHelper . startPage ( pageNum , pageSize ) ; List < DepartDto > departDtos = new ArrayList < > ( ) ; List < Depart > departList = this . baseMapper . selectAllByQueryKey ( queryKey ) ; if ( ! CollectionUtils . isEmpty ( departList ) ) { departDtos = DepartConverterMapper . INSTANCE . DepartToDepartDtoList ( departList ) ; departDtos = getDepartDtos ( departDtos ) ; } return departDtos ;
get: public Actor get ( ) { Table tooltip = new Tooltip . TooltipTable ( ) ; tooltip . align ( Align . top | Align . center ) ; Table content = new Table ( ) ; content . setBackground ( new NinePatchDrawable ( BrainOutClient . getNinePatch ( "form-default" ) ) ) ; Label title = new Label ( getTitle ( ) , BrainOutClient . Skin , "title-level" ) ; title . setAlignment ( Align . center ) ; title . setWrap ( true ) ; tooltip . add ( new BorderActor ( title , 500 , "form-gray" ) ) . expandX ( ) . fillX ( ) . row ( ) ; tooltip . add ( content ) . expand ( ) . fill ( ) . row ( ) ; boolean addBottomLine = true ; ContentLockTree . LockItem lockItem = item . getLockItem ( ) ; if ( userProfile != null && ! item . hasItem ( userProfile ) && item . isLocked ( userProfile ) ) { TextureRegion locked = BrainOutClient . getRegion ( getLockedIcon ( lockItem ) ) ; Image lockedImage = new Image ( locked ) ; lockedImage . setScaling ( Scaling . none ) ; content . add ( lockedImage ) . padBottom ( 8 ) . expandX ( ) . fillX ( ) . row ( ) ; } else { addBottomLine = false ; } if ( lockItem == null || ! lockItem . isValid ( ) ) { Label lockedText = new Label ( lockItem != null && lockItem . isUnlockTitleValid ( ) ? lockItem . getUnlockTitle ( ) : L . get ( "MENU_LOCKED" ) , BrainOutClient . Skin , "title-small" ) ; lockedText . setAlignment ( Align . center ) ; lockedText . setWrap ( true ) ; content . add ( lockedText ) . width ( 500 ) . expandX ( ) . fillX ( ) . row ( ) ; addBottomLine = false ; } else { String f = lockItem . getUnlockFor ( ) ; Label taskText = new Label ( L . get ( "MENU_TASK" ) , BrainOutClient . Skin , "title-gray" ) ; taskText . setAlignment ( Align . center ) ; taskText . setWrap ( true ) ; content . add ( taskText ) . expandX ( ) . fillX ( ) . row ( ) ; String text ; if ( f . equals ( Constants . User . LEVEL ) ) { Levels levels = BrainOutClient . ClientController . getLevels ( Constants . User . LEVEL ) ; if ( levels != null ) { Levels . Level level = levels . getLevel ( lockItem . getParam ( ) ) ; text = L . get ( "MENU_TASK_REACH_LEVEL" , level . toShortString ( ) ) ; } else { text = "???" ; } } else if ( f . equals ( Constants . User . TECH_LEVEL ) ) { Levels levels = BrainOutClient . ClientController . getLevels ( Constants . User . TECH_LEVEL ) ; Levels . Level level = levels . getLevel ( lockItem . getParam ( ) ) ; text = L . get ( "MENU_TASK_REACH_TECH_LEVEL" , level . toShortString ( ) ) ; } else { text = lockItem . isUnlockTitleValid ( ) ? lockItem . getUnlockTitle ( lockItem . getParam ( ) ) : L . get ( "MENU_LOCKED" ) ; } Label reachLevel = new Label ( text , BrainOutClient . Skin , "title-small" ) ; reachLevel . setAlignment ( Align . center ) ; reachLevel . setWrap ( true ) ; content . add ( reachLevel ) . expandX ( ) . fillX ( ) . row ( ) ; } if ( addBottomLine || forceBottomLine ( ) ) { Actor progress = renderBottomLine ( ) ; BorderActor ba = new BorderActor ( progress , 512 ) ; ba . getCell ( ) . height ( 20 ) ; tooltip . add ( ba ) . expandX ( ) . fillX ( ) . row ( ) ; } tooltip . setSize ( 544 , 210 ) ; return tooltip ;
initRoot: protected void initRoot ( ) { root . addUpdateItem ( blocks ) ; root . addRenderableItem ( blocks . getRenderLayer ( Constants . Layers . BLOCK_LAYER_BACKGROUND ) , RenderFilter . pre ) ; root . addRenderableItem ( blocks . getRenderLayer ( Constants . Layers . BLOCK_LAYER_FOREGROUND ) , RenderFilter . pre ) ; root . addItem ( bullets , RenderFilter . pre ) ; root . addItem ( actives , RenderFilter . pre ) ; root . addItem ( components , RenderFilter . pre ) ;
saveJiraconfig: public Object saveJiraconfig ( @ PathVariable ( ORGANIZATIONID ) Long orgId , @ Valid IntegrationJiraForm form , BindingResult br ) { debug ( "[saveJiraconfig] OrgId: {}" , orgId ) ; return Flow . init ( integrationJiraForm , form )
getComponent: public ServerUnlockContentItemComponentData getComponent ( ComponentObject componentObject ) { return new ServerUnlockContentItemComponentData ( ( ItemData ) componentObject , this ) ;
aabbIntersectsSkeleton: public boolean aabbIntersectsSkeleton ( SkeletonBounds bounds ) { if ( bounds == null ) throw new IllegalArgumentException ( "bounds cannot be null." ) ; return minX < bounds . maxX && maxX > bounds . minX && minY < bounds . maxY && maxY > bounds . minY ;
updateFee: private void updateFee ( ) { if ( ! isPriceValid ( ) ) { create . setText ( L . get ( "MENU_MARKET_INVALID_PRICE" ) ) ; create . setDisabled ( true ) ; return ; } create . setText ( L . get ( "MENU_CREATE_FOR_RU" , String . valueOf ( calculateCreationPrice ( ) ) ) ) ; create . setDisabled ( ! isEnoughRUForAFee ( ) ) ;
preparePaymentProbe: public RouterOuterClass . SendPaymentRequest preparePaymentProbe ( LightningOuterClass . PayReq paymentRequest ) { return preparePaymentProbe ( paymentRequest . getDestination ( ) , paymentRequest . getAmount ( ) , paymentRequest . getPaymentAddr ( ) , paymentRequest . getRouteHintsList ( ) , paymentRequest . getFeaturesMap ( ) ) ;
dismiss: public void dismiss ( ) { if ( mAlertDialog != null && mAlertDialog . isShowing ( ) ) {
component1: public final Type component1 ( ) { return this . type ;
delete: public void delete ( String shopKey , String countryCode , Integer voucherId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/vouchers/%s" , shopKey , countryCode , voucherId ) , null , null , null ) ;
isSameOwner: private boolean isSameOwner ( ) { if ( weaponData . getOwner ( ) == null || originalOwner == null ) return false ; return weaponData . getOwner ( ) . getOwnerId ( ) == originalOwner . getId ( ) ;
setValueTextColors: public void setValueTextColors ( List < Integer > colors ) { mValueColors = colors ;
getWindowBackground: protected Drawable getWindowBackground ( ) { return ContextCompat . getDrawable ( mContext , R . color . color_f9f9f9 ) ;
channelActive: public void channelActive ( final @ NotNull ChannelHandlerContext context ) { this . channel = context . channel ( ) ;
activate: public void activate ( ConsumableRecord record ) { ActiveData owner = instrumentData . getOwner ( ) ; if ( owner instanceof PlayerData ) { getContentComponent ( ) . getActivateEffect ( ) . launchEffects ( ( ( PlayerData ) owner ) . getLaunchData ( ) ) ; } PlayerOwnerComponent poc = owner . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null )
setPosition: public void setPosition ( XAxisPosition pos ) { mPosition = pos ;
setTotalHeapMemory: public void setTotalHeapMemory ( long totalHeapMemory ) { this . totalHeapMemory = totalHeapMemory ;
getPubKey: public String getPubKey ( ) { return mPubKey ;
getBtcPriceChange: public String getBtcPriceChange ( Context context ) { btcPriceChange = PreferencesUtils . getBtcPriceChangeFromLocal ( context ) ; return btcPriceChange ;
random: No method body
jwtAuthenticationConverter: public Converter < Jwt , ? extends Mono < ? extends AbstractAuthenticationToken > > jwtAuthenticationConverter ( ) { JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter ( ) ; jwtGrantedAuthoritiesConverter . setAuthorityPrefix ( AuthConstants . AUTHORITY_PREFIX ) ; jwtGrantedAuthoritiesConverter . setAuthoritiesClaimName ( AuthConstants . JWT_AUTHORITIES_KEY ) ; JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter ( ) ; jwtAuthenticationConverter . setJwtGrantedAuthoritiesConverter ( jwtGrantedAuthoritiesConverter ) ; return new ReactiveJwtAuthenticationConverterAdapter ( jwtAuthenticationConverter ) ;
newBlockMatrixData: protected BlockMatrixData newBlockMatrixData ( String dimension ) { return new BlockMatrixData ( dimension ) ;
onChanged: No method body
sendToUserChannel: public boolean sendToUserChannel ( User user , String channelName , Object payload , Map < String , Object > headers ) { checkChannelName ( channelName ) ; sendToUserChannel ( user . getEmail ( ) , channelName , payload , headers ) ; return true ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoSteamPressure3OffItemStateChanged ( evt ) ;
sendMessageToSlack: public boolean sendMessageToSlack ( String message , String webHook ) { return slackService . sendMessageToSlack ( message , webHook ) ;
onWebViewLoadError: No method body
copy: public Attachment copy ( ) { PathAttachment copy = new PathAttachment ( name ) ; copyTo ( copy ) ; copy . lengths = new float [ lengths . length ] ; arraycopy ( lengths , 0 , copy . lengths , 0 , lengths . length ) ; copy . closed = closed ; copy . constantSpeed = constantSpeed ; copy . color . set ( color ) ; return copy ;
getData: public EnterPremisesDoorData getData ( String dimension ) { return new EnterPremisesDoorData ( this , dimension ) ;
clickLoadError: No method body
isQQClientAvailable: public static boolean isQQClientAvailable ( Context context ) { final PackageManager packageManager = context . getPackageManager ( ) ; List < PackageInfo > pInfo = packageManager . getInstalledPackages ( 0 ) ; if ( pInfo != null ) { for ( int i = 0 ; i < pInfo . size ( ) ; i ++ ) { String pn = pInfo . get ( i ) . packageName ; if ( pn . equals ( "com.tencent.mobileqq" ) ) { return true ; } } } return false ;
onFragmentDestroyed: public void onFragmentDestroyed ( FragmentManager fm , Fragment fragment ) { LogUtils . e ( TAG , "Fragment======》" + fragment . getClass ( ) . getSimpleName ( ) + "     销毁" ) ; LoadingDialog . getInstance ( ) . onFragmentDestroy ( fragment ) ;
getFrontendMappingDefinitions: private Map < String , FrontendMappingDefinition > getFrontendMappingDefinitions ( Map < String , Object > configsFromZip , Map < String , String > componentResourcesFromZip ) { return configsFromZip . values ( ) . stream ( )
processClan: private void processClan ( SocialService . Group group , boolean inTournament ) { this . clan = new Clan ( group ) ; this . inTournament = inTournament ; Clan myClan = BrainOutClient . SocialController . getMyClan ( ) ; if ( BrainOutClient . ClientController . isLobby ( ) &&
dispose: private void dispose ( ) { if ( physicsBody != null )
getClient: public Client getClient ( ) { return BrainOutServer . Controller . getClients ( ) . get ( clientId ) ;
getCurrency: public String getCurrency ( ) { return currency ;
saveAndPrepareFileEntity: public File saveAndPrepareFileEntity ( Long orgId , String uuid , String fileName , long totalFileSize , String originalFilename , InputStream inputStream ) throws IOException , SQLException { debug ( "[saveAndPrepareFileEntity]" ) ; File f = null ; Path path = new java . io . File ( originalFilename ) . toPath ( ) ; String mimeType = Files . probeContentType ( path ) ; StorageType actualStorageType = getStorageType ( ) ; if ( actualStorageType == filesystem ) { f = handleFilesystemWrite ( orgId , uuid , fileName , totalFileSize , originalFilename , inputStream , f , mimeType , actualStorageType ) ; } else if ( actualStorageType == database ) { Blob b = BlobProxy . generateProxy ( inputStream , totalFileSize ) ; f = new File ( orgId , originalFilename , mimeType , totalFileSize , uuid , actualStorageType ) ; f . setContent ( b ) ; } return f ;
isDragXEnabled: public boolean isDragXEnabled ( ) { return mDragXEnabled ;
getY: No method body
setAttachmentURL: public void setAttachmentURL ( String attachmentURL ) { this . attachmentURL = attachmentURL ;
getY: public float getY ( ) { return bulletData . getY ( ) ;
isSysstatInstalled: public boolean isSysstatInstalled ( ) { return sysstatInstalled ;
getAll: void getAll ( ) throws Exception { MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . get ( "/resource/getAll" ) . contentType ( MediaType . APPLICATION_JSON ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "获取资源树接口测试成功:{}" , map . get ( "data" ) ) ;
getOffsetY: public float getOffsetY ( ) { return offsetY ;
getPhone: public String getPhone ( ) { return phone ;
file: public static void file ( String tag , String text ) { if ( Constants . isSaveLog ) {
getFilterFields: public static List < FrontendMappingFieldDefinition > getFilterFields ( FrontendMappingDefinition fd , String [ ] fieldNames ) { if ( fieldNames == null ) { return Collections . emptyList ( ) ; } List < FrontendMappingFieldDefinition > result = new ArrayList < > ( fieldNames . length ) ; for ( int k = 0 ; k < fieldNames . length ; k ++ ) { FrontendMappingFieldDefinition field = fd . findField ( fieldNames [ k ] ) ; if ( field . getType ( ) . equals ( FieldType . dropdown ) || field . getType ( ) . equals ( FieldType . many_to_one ) ) { FrontendMappingFieldDefinition dictionaryField = fd . findField ( field . datalistId ) ; if ( dictionaryField != null ) { result . add ( dictionaryField ) ; } } result . add ( field ) ; } return result ;
getDeclaredPickerAttributes: public static int [ ] getDeclaredPickerAttributes ( ) { return new int [ ] {
setDragOffsetY: public void setDragOffsetY ( float offset ) { mTransOffsetY = Utils . convertDpToPixel ( offset ) ;
getDone: public Boolean getDone ( ) { return done ;
setCustom: public void setCustom ( LegendEntry [ ] entries ) { mEntries = entries ; mIsLegendCustom = true ;
filterLayouts: public FilterLayoutResponse filterLayouts ( final FilterLayoutRequest request ) throws IOException , NovuNetworkException { Map < String , Object > params = new HashMap < > ( ) ; if ( request . getPage ( ) != null ) { params . put ( "page" , request . getPage ( ) ) ; } if ( request . getPageSize ( ) != null ) { params . put ( "pageSize" , request . getPageSize ( ) ) ; } if ( request . getSortBy ( ) != null ) { params . put ( "sortBy" , request . getSortBy ( ) ) ; } if ( request . getOrderBy ( ) != null ) { params . put ( "orderBy" , request . getOrderBy ( ) ) ; } Response < FilterLayoutResponse > response = layoutApi . filterLayouts ( params ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
invalidateMessage: public static void invalidateMessage ( long id ) { if ( WIDGET_CHAT_LIST == null ) { LogUtils . log ( TAG , "invalidateMessage() failed" ) ; return ; } WidgetChatListAdapter adapter = WidgetChatList . access$getAdapter$p ( WIDGET_CHAT_LIST ) ; List < ? > data = adapter . getInternalData ( ) ; if ( data == null ) return ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) {
listAccounts: public Single < walletrpc . Walletkit . ListAccountsResponse > listAccounts ( walletrpc . Walletkit . ListAccountsRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . listAccounts ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
shouldInterceptRequest: public WebResourceResponse shouldInterceptRequest ( WebView view , String url ) { if ( mCallBack != null ) { WebResourceResponse response = mCallBack . shouldInterceptRequest ( view , url ) ; if ( response != null ) { return response ; } } return super . shouldInterceptRequest ( view , url ) ;
cancel: public boolean cancel ( ) { if ( ! isRunning ( ) ) { return false ; } if ( ! cancellable ) { return false ; } task . cancel ( ) ; if ( cancelled != null ) { cancelled . run ( ) ; } cleanUp ( ) ; return true ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { off6ActionPerformed ( evt ) ;
setMyLevelOnly: public void setMyLevelOnly ( boolean myLevelOnly ) { this . myLevelOnly = myLevelOnly ;
getRecoverySeedString: public static String getRecoverySeedString ( Context context ) { return getString ( SETTINGS , context , RECOVERY_SEED_STRING ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
isEnabled: private boolean isEnabled ( boolean checkShootingDisabled ) { if ( data . getOwner ( ) == null ) return true ; ActiveData owner = data . getOwner ( ) ; if ( owner == null ) return false ; Map map = getMap ( ) ; if ( map == null ) return false ; ChunkData chunk = map . getChunkAt ( ( ( int ) owner . getX ( ) ) , ( ( int ) owner . getY ( ) ) ) ; if ( checkShootingDisabled && chunk != null ) { if ( chunk . hasFlag ( ChunkData . ChunkFlag . shootingDisabled ) ) return false ; } PlayerOwnerComponent poc = owner . getComponent ( PlayerOwnerComponent . class ) ; return poc == null || poc . isEnabled ( ) ;
updateSteamInflow: public void updateSteamInflow ( double flow , double tempC ) { Double [ ] inflowData = NPPMath . mixSteam ( steamMass , steamTemperature , flow , tempC ) ; steamMass = inflowData [ 0 ] ; steamTemperature = inflowData [ 1 ] ; steamInflow = flow ;
unlockWallet: No method body
hasRender: public boolean hasRender ( ) { return false ;
init: public void init ( InitCallback done ) { BrainOutClient . getInstance ( ) . switchState ( new LoadingState ( ) ) ; super . init ( done ) ; for ( PackageInfo packageInfo : packages ) { packagesToLoad . add ( packageInfo . name ) ; } if ( System . getenv ( "BRAINOUT_NO_SOUND" ) != null ) { packagesToLoad . removeValue ( "sounds" , false ) ; } BrainOutClient . ClientController . setState ( new CSPackagesLoad ( packagesToLoad ) ) ;
getGameAtlas: public TextureAtlas getGameAtlas ( ) { return game ;
update: public void update ( float dt ) { super . update ( dt ) ; if ( menu . getCurrentMode ( ) != null )
switchLightMode: private void switchLightMode ( ) { switchMode ( modeLight ) ;
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductVariantCreateRequest.json" ) ; ProductVariant requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , ProductVariant . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ProductVariant responseEntity = this . api . productVariants ( ) . create ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductVariantCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
selectHookedInstrument: private void selectHookedInstrument ( ) { InstrumentData hooked = getHookedInstrument ( ) ; if ( hooked != null )
fileToBitmapUcrop: private Bitmap fileToBitmapUcrop ( String path ) { Bitmap decoded = BitmapFactory . decodeFile ( path ) ; if ( Prefs . getBoolean ( PreferenceKeys . BACKGROUND_BLUR , false ) ) { float blurLevel = Prefs . getFloat ( PreferenceKeys . BACKGROUND_BLUR_LEVEL , 12.5f ) ; if ( blurLevel > 0 ) { return blurImage ( getContext ( ) , decoded , blurLevel ) ; } } return decoded ;
runQueriesInTransaction: public boolean runQueriesInTransaction ( String ... queries ) { return runQueries ( true , false , queries ) ;
test_getFeeds: public void test_getFeeds ( ) throws IOException , NovuNetworkException , InterruptedException { BulkFeedsResponse feedResponse = new BulkFeedsResponse ( ) ; feedResponse . setData ( Collections . singletonList ( new FeedResponseData ( ) ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( feedResponse ) ) ) ; BulkFeedsResponse response = feedsHandler . getFeeds ( ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/feeds" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( feedResponse ) , gson . toJson ( response ) ) ;
showInSummaryScreen: public boolean showInSummaryScreen ( ) { return true ;
getMaxAttempts: public int getMaxAttempts ( ) { return MAX_ATTEMPTS_DEFAULT ;
getFlipX: public boolean getFlipX ( ) { return false ;
updateSteamInflow: public void updateSteamInflow ( double flow , double tempC ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
renderEventUI: private void renderEventUI ( Table data ) { Label title = new Label ( event . getTitle ( ) , BrainOutClient . Skin , valuables ? "title-small" : "title-level" ) ; title . setAlignment ( Align . center ) ; data . add ( new BorderActor ( title , valuables ? "form-yellow" : "form-red" ) ) . size ( 420 , 32 ) . expandX ( ) . fillX ( ) . row ( ) ; Table info = new Table ( ) ; info . align ( Align . center ) ; String iconId = event . getIconId ( ) ; Weapon asWeapon = BrainOutClient . ContentMgr . get ( iconId , Weapon . class ) ; if ( asWeapon != null ) { InstrumentInfo instrumentInfo = new InstrumentInfo ( ) ; instrumentInfo . instrument = asWeapon ; instrumentInfo . skin = asWeapon . getDefaultSkin ( ) ; float scale ; InstrumentAnimationComponent iac = asWeapon . getComponentFrom ( InstrumentAnimationComponent . class ) ; if ( iac != null ) { scale = iac . getIconScale ( ) ; } else { scale = 1.0f ; } InstrumentIcon instrumentIcon = new InstrumentIcon ( instrumentInfo , scale , false ) ; instrumentIcon . setTouchable ( Touchable . disabled ) ; instrumentIcon . setBounds ( 0 , 0 , 192 , 64 ) ; instrumentIcon . init ( ) ; info . add ( instrumentIcon ) . size ( 192 , 64 ) . pad ( 16 , 16 , 0 , 16 ) . row ( ) ; } else { TextureRegion icon = event . getIcon ( ) ; if ( icon != null ) { Image image = new Image ( icon ) ; image . setScaling ( Scaling . none ) ; info . add ( image ) . pad ( 16 , 16 , 0 , 16 ) . row ( ) ; } } Label description = new Label ( event . getDescription ( ) , BrainOutClient . Skin , "title-small" ) ; description . setWrap ( true ) ; description . setAlignment ( Align . center ) ; info . add ( description ) . pad ( 16 ) . width ( 400 ) . expandX ( ) . fillX ( ) . row ( ) ; data . add ( new BorderActor ( info , valuables ? "form-border-yellow" : "form-border-red" ) ) . width ( 420 ) . expandX ( ) . fillX ( ) . row ( ) ; switch ( event . getEvent ( ) . behaviour ) { case increment : { float targetScore = event . getEvent ( ) . getTargetScore ( ) ; LabeledProgress progress = new LabeledProgress ( BrainOutClient . Skin , valuables ? "progress-spawn" : "progress-event" , 0 , ( int ) targetScore , ( int ) event . getEvent ( ) . score , ( int ) targetScore ) ; data . add ( new BorderActor ( progress , 400 , valuables ? "form-border-yellow" : "form-border-red" ) ) . width ( 420 ) . row ( ) ; break ; } case maximum : { Table bestResult = new Table ( BrainOutClient . Skin ) ; bestResult . setBackground ( "form-gray" ) ; { Label bestResultTitle = new Label ( L . get ( "MENU_BEST_RESULT" ) , BrainOutClient . Skin , "title-yellow" ) ; bestResult . add ( bestResultTitle ) . expandX ( ) . left ( ) ; } { Label value = new Label ( String . valueOf ( ( int ) event . getEvent ( ) . score ) , BrainOutClient . Skin , "title-small" ) ; bestResult . add ( value ) . row ( ) ; } data . add ( bestResult ) . width ( 420 ) . row ( ) ; break ; } } Table rewards = new Table ( ) ; int rewardId = 0 ; for ( Event . EventReward reward : event . getEvent ( ) . rewards ) { final int index = rewardId ++ ; Table rewardData = new Table ( ) ; if ( reward . isComplete ( ) ) { Label complete = new Label ( L . get ( "MENU_COMPLETE" ) , BrainOutClient . Skin , valuables ? "title-small" : "title-yellow" ) ; complete . setAlignment ( Align . center ) ; rewardData . add ( new BorderActor ( complete , valuables ? "form-yellow" : "form-red" ) ) . expandX ( ) . fillX ( ) . row ( ) ; } else { String task = String . valueOf ( ( int ) event . getEvent ( ) . score ) + " / " + ( int ) reward . targetScore ; Label taskTitle = new Label ( task , BrainOutClient . Skin , "title-small" ) ; taskTitle . setAlignment ( Align . center ) ; rewardData . add ( new BorderActor ( taskTitle , "form-gray" ) ) . expandX ( ) . fillX ( ) . row ( ) ; } Table rewardContent = new Table ( ) ; rewardContent . setBackground ( new TextureRegionDrawable ( BrainOutClient . getRegion ( "reward-bg" ) ) ) ; renderReward ( reward , rewardContent ) ; if ( reward . isComplete ( ) ) { rewardData . add ( new BorderActor ( rewardContent , valuables ? "form-border-yellow" : "form-border-red" ) ) . height ( 96 ) . expandX ( ) . fill ( ) . row ( ) ; if ( ! reward . isClaimed ( ) ) { TextButton claim = new TextButton ( L . get ( "MENU_CLAIM" ) , BrainOutClient . Skin , "button-default" ) ; claim . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; claimReward ( index , success -> { if ( success ) { claim . remove ( ) ; } } ) ; } } ) ; rewardData . add ( claim ) . expandX ( ) . expandY ( ) . fillX ( ) . padBottom ( - 64 ) . row ( ) ; } } else { rewardData . add ( new BorderActor ( rewardContent , "form-default" ) ) . expandX ( ) . fill ( ) . row ( ) ; } rewards . add ( rewardData ) . top ( ) . uniformY ( ) . fillY ( ) . expandX ( ) . width ( 220 ) ; } data . add ( rewards ) . pad ( 32 ) . expandX ( ) . fillX ( ) . row ( ) ; if ( isShootingRange ( event ) )
getCircleHoleRadius: public float getCircleHoleRadius ( ) { return mCircleHoleRadius ;
debug: public void debug ( String format , Object arg1 , Object arg2 ) { logger . debug ( format , arg1 , arg2 ) ;
getAdditionalSettings: public ServerSettings . BaseConditions getAdditionalSettings ( ) { return null ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , FieldType type , BiFunction < OrganizationUser , LongIdEntity , Boolean > canReadCheck , BiFunction < OrganizationUser , LongIdEntity , Boolean > canWriteCheck , String url ) { return new FrontendMappingFieldDefinition ( formName , name , type , canReadCheck , canWriteCheck , null , null , null , null , false , null , null , null , false , url , null , null , null , null , null , null , null , null , null , false , false ) ;
getRealEstateInfo: public RealEstateInfo getRealEstateInfo ( ) { return realEstateInfo ;
runOnIOThread: public static < T > Promise < T > runOnIOThread ( @ NotNull Promise < T > promise ) { Promise < T > ret = new Promise < > ( ) ; promise . add ( new PromiseListener < T > ( ) { @ Override public void succeeded ( T result ) { ThreadUtils . runOnIOThread ( ( ) -> ret . resolve ( result ) ) ; } @ Override public void failed ( Throwable th ) { ThreadUtils . runOnIOThread ( ( ) -> ret . fail ( th ) ) ; } } ) ; return ret ;
setInitWalletType: public void setInitWalletType ( Context context , String initWalletType ) { PreferencesUtils . saveInitWalletType ( context , initWalletType ) ; this . initWalletType = initWalletType ;
createOrUpdateCustomData: public Map < String , Object > createOrUpdateCustomData ( Identifier variantIdentifier , Map < String , Object > model ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "put" , this . resolvePath ( "/variants/%s/custom-data" , variantIdentifier ) , null , null , responseModel , model ) ;
isParallelLoadingRequired: protected boolean isParallelLoadingRequired ( Content c ) { return c instanceof SoundEffect ||
getTaggedDataFieldLength: private static int getTaggedDataFieldLength ( String lengthString ) { return Bech32 . CHARSET . indexOf ( lengthString . charAt ( 0 ) ) * 32 + Bech32 . CHARSET . indexOf ( lengthString . charAt ( 1 ) ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
getSprite: public String getSprite ( ) { return sprite ;
updateInfo: protected void updateInfo ( ) { super . updateInfo ( ) ; updateSpawnInfo ( ) ; updateSpawnPointsInfo ( ) ;
getJavaMailProperties: public Properties getJavaMailProperties ( ) { Properties mailProps = new Properties ( super . getJavaMailProperties ( ) ) ; if ( emailConfig != null ) { if ( emailConfig . getSmtpAuth ( ) != null ) { mailProps . setProperty ( "spring.mail.properties.mail.smtp.auth" , emailConfig . getSmtpAuth ( ) . toString ( ) ) ; } if ( emailConfig . getSsl ( ) != null ) { mailProps . setProperty ( "spring.mail.smtp.ssl.enable" , emailConfig . getSmtpAuth ( ) . toString ( ) ) ; } if ( emailConfig . getStarttls ( ) != null ) { mailProps . setProperty ( "spring.mail.properties.mail.smtp.starttls.enabl" , emailConfig . getStarttls ( ) . toString ( ) ) ; } } return mailProps ;
emailModelPreHandle: public boolean emailModelPreHandle ( Map < String , Object > model ) { for ( EmailModelPreHandler h : emailModelPreHandlers ) { h . preHandle ( model ) ; } return true ;
getMessages: public OrderedMap < String , ClientMessage > getMessages ( ) { return messages ;
getY: public float getY ( ) { return launchData . getY ( ) ;
awaitResult: protected Result < T > awaitResult ( ) { if ( ! this . deferred . isCompleted ( ) ) { Util . < Void > blockOnSyscall ( cb -> syscalls . resolveDeferred ( this . deferred , cb ) ) ; } if ( this . result == null ) { this . result = this . deferred . toResult ( ) ; } return this . result ;
onActivityResumed: public void onActivityResumed ( Activity activity ) { if ( activity == mActivity ) {
getUpdateAPKSizeFromLocal: public static long getUpdateAPKSizeFromLocal ( Context context ) { return getLong ( SETTINGS , context , KEY_UPDATE_APK_SIZE , 0L ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; group = jsonData . getString ( "group" ) ; time = jsonData . getInt ( "time" ) ; if ( jsonData . has ( "weapons" ) )
test_fetchCurrentOrganization: public void test_fetchCurrentOrganization ( ) throws IOException , NovuNetworkException , InterruptedException { OrganizationResponse organizationResponse = new OrganizationResponse ( ) ; OrganizationResponseData data = new OrganizationResponseData ( ) ; data . setId ( "id" ) ; data . setName ( "name" ) ; data . setLogo ( "logo" ) ; Branding branding = new Branding ( ) ; branding . setDirection ( "direction" ) ; branding . setLogo ( "logo" ) ; branding . setColor ( "color" ) ; branding . setFontColor ( "fontColor" ) ; branding . setContentBackground ( "contentBackground" ) ; branding . setFontFamily ( "fontFamily" ) ; data . setBranding ( branding ) ; PartnerConfigurations partnerConfigurations = new PartnerConfigurations ( ) ; partnerConfigurations . setProjectIds ( List . of ( ) ) ; partnerConfigurations . setAccessToken ( "accessToken" ) ; partnerConfigurations . setConfigurationId ( "configurationId" ) ; partnerConfigurations . setTeamId ( "teamId" ) ; partnerConfigurations . setPartnerType ( "partnerType" ) ; data . setPartnerConfigurations ( List . of ( partnerConfigurations ) ) ; data . setCreatedAt ( "createdAt" ) ; data . setUpdatedAt ( "updatedAt" ) ; data . setVersion ( 1L ) ; organizationResponse . setData ( data ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( organizationResponse ) ) ) ; OrganizationResponse response = organizationHandler . fetchCurrentOrganization ( ) ; assertNotNull ( response ) ; final RecordedRequest recordedRequest = mockWebServer . takeRequest ( ) ; assertEquals ( "/organizations/me" , recordedRequest . getPath ( ) ) ; assertEquals ( "GET" , recordedRequest . getMethod ( ) ) ; assertEquals ( organizationResponse , response ) ;
isPassword: public static boolean isPassword ( String password ) { if ( ! TextUtils . isEmpty ( password ) ) { String regex = "[a-zA-Z0-9]{6,16}" ; return Pattern . matches ( regex , password ) ; } return false ;
onSuccess: public void onSuccess ( ByteBuffer result ) { exitFut . complete ( result ) ;
init: public void init ( ) { if ( ! BrainOut . OnlineEnabled ( ) ) { Gdx . app . postRunnable ( ( ) -> complete ( Request . Result . success , "OK" ) ) ; return ; } final GameUser user = BrainOutClient . Env . getGameUser ( ) ; user . read ( ) ; EnvironmentService environmentService = EnvironmentService . Get ( ) ; if ( environmentService == null ) { CSOnlineInit . this . complete ( Request . Result . dataCorrupted , "No environment service" ) ; return ; } environmentService . getEnvironmentInfo ( ( service , request , result , discoveryLocation , environmentInformation ) ->
getPrimarySlotUpper: public Slot getPrimarySlotUpper ( ) { return primarySlotUpper ;
onClick: public void onClick ( View v ) { mAlertDialog . dismiss ( ) ;
filterStudents: public static List < Student > filterStudents ( List < Student > students , StudentPredicate sp , StudentFunction sf , StudentConsumer sc ) { List < Student > result = new ArrayList < > ( ) ; for ( Student s : students ) { if ( sp . test ( s ) ) { String str = sf . apply ( s ) ; sc . accept ( str ) ; result . add ( s ) ; } } return result ;
addForm: public boolean addForm ( Long formId ) { debug ( "[addForm]" ) ; Form form = repositories . unsecure . form . findOne ( formId ) ; if ( form != null ) { return registerForm ( form ) ; } return false ;
isKeyDown: private boolean isKeyDown ( KeyDirections keyDirections ) { return ! isDisabled ( ) && keyPressed [ keyDirections . ordinal ( ) ] ;
getFrontendResourceAsset: public void getFrontendResourceAsset ( @ PathVariable ( "frontendResourceFileId" ) Long frontendResourceFileId , @ RequestParam ( name = "dl" , required = false , defaultValue = "false" ) boolean download , HttpServletRequest request , HttpServletResponse response ) throws IOException , SQLException { debug ( "[getFrontendResourceAsset] frontendResourceFileId {}" , frontendResourceFileId ) ; File f = request . getRequestURI ( ) . contains ( _HTML ) && hasGlobalPrivilege ( Privilege . isUser ) ? repositories . unsecure . file . findOne ( frontendResourceFileId ) : repositories . unsecure . file . findByIdAndPublicFileTrue ( frontendResourceFileId ) ; if ( f == null ) { response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; return ; } services . file . getFileContentAndPrepareResponse ( f , download , true , response ) ;
getFileType: public String getFileType ( ) { return fileType ;
search: default Page < T > search ( String searchTerm , int page , int size , String sortField , String sortDirection ) { return SearchableFunctionalRepositoryWithLongId . super . search ( DEFAULT_SCOPE , searchTerm , page , size , sortField , sortDirection ) ;
getTotal: public Long getTotal ( ) { return total ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { return rights == PlayerRights . admin ;
source: No method body
updateActiveWinds: private void updateActiveWinds ( ) { if ( getMap ( ) == null ) return ; winds = getMap ( ) . getActivesForTag ( Constants . ActiveTags . WIND , activeData -> activeData . getComponent ( WindComponentData . class ) != null ) ;
contentType: public String contentType ( ) { return "application/json" ;
getLastname: public String getLastname ( ) { return lastname ;
getWaterMass: public double getWaterMass ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
update: public void update ( float dt ) { if ( ! enabled ) return ; while ( dt >= STEPS ) { updatePhysics ( STEPS ) ; dt -= STEPS ; } updatePhysics ( dt ) ;
getWebColor: public int getWebColor ( ) { return mWebColor ;
writeNetscapeExt: protected void writeNetscapeExt ( ) throws IOException { out . write ( 0x21 ) ; out . write ( 0xff ) ; out . write ( 11 ) ; writeString ( "NETSCAPE" + "2.0" ) ; out . write ( 3 ) ; out . write ( 1 ) ; writeShort ( repeat ) ; out . write ( 0 ) ; }
getDataSets: public List < IPieDataSet > getDataSets ( ) { List < IPieDataSet > dataSets = super . getDataSets ( ) ; if ( dataSets . size ( ) < 1 ) { Log . e ( "MPAndroidChart" , "Found multiple data sets while pie chart only allows one" ) ; } return dataSets ;
getUpgradeLevel: public int getUpgradeLevel ( UserProfile profile ) { return MathUtils . clamp ( profile . itemsHave ( this ) , 0 , upgrades . size - 1 ) ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fill ;
getInteractionState: public final InteractionState getInteractionState ( ) { return this . interactionState ;
giveDailyContent: private void giveDailyContent ( ) { Map map = Map . GetDefault ( ) ; if ( map == null ) return ; GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode == null ) return ; switch ( gameMode . getID ( ) ) { case lobby : case free : return ; } long lastDailyClaim = 0 ; String dailyContainer = BrainOutServer . Settings . getDailyContainer ( ) ; if ( dailyContainer == null || dailyContainer . isEmpty ( ) ) return ; if ( profile == null ) return ; if ( profile . getItems ( ) . get ( dailyContainer , 0 ) > 0 ) { return ; } if ( profile . getStats ( ) . get ( Constants . User . NUCLEAR_MATERIAL , 0.0f ) >= Constants . DailyReward . MAX_DAILY_CONTAINERS ) { return ; } lastDailyClaim = profile . getLastDailyClaim ( ) ; long now = System . currentTimeMillis ( ) / 1000L ; if ( now <= lastDailyClaim ) return ; OwnableContent dailyContainerContent = BrainOutServer . ContentMgr . get ( BrainOutServer . Settings . getDailyContainer ( ) , OwnableContent . class ) ; if ( dailyContainerContent == null ) return ; String dailyContentId = "unlock-daily-content-drop-item" ; Item item = BrainOutServer . ContentMgr . get ( dailyContentId , Item . class ) ; if ( item == null ) return ; Array < ConsumableRecord > records = new Array < > ( ) ; records . add ( new ConsumableRecord ( new OwnableConsumableItem ( dailyContainerContent ) , 1 , 0 ) ) ; ActiveData activeData = map . getRandomActiveForTag ( Constants . ActiveTags . SPAWNABLE ) ; if ( activeData == null ) return ; boolean foundOne = false ; for ( Map map_ : Map . All ( ) ) { for ( ObjectMap . Entry < Integer , ActiveData > active : map_ . getActives ( ) ) { ActiveData activeData_ = active . value ; if ( ! activeData_ . getCreator ( ) . getID ( ) . equals ( dailyContentId ) ) continue ; ActiveFilterComponentData filter = activeData_ . getComponent ( ActiveFilterComponentData . class ) ; if ( filter == null ) continue ; if ( filter . filters ( getId ( ) ) ) { foundOne = true ; break ; } } if ( foundOne ) break ; } if ( foundOne ) return ; ItemData itemData = ServerMap . dropItem ( map . getDimension ( ) , item , records , getId ( ) , activeData . getX ( ) , activeData . getY ( ) , activeData . getAngle ( ) , 0 ) ; if ( itemData != null )
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case updated : { break ; } } return false ;
getCompanyId: public String getCompanyId ( Context context ) { companyId = PreferencesUtils . getCompanyIDFromLocal ( context ) ; return companyId ;
begin: public void begin ( ) { if ( drawing ) throw new IllegalStateException ( "end must be called before begin." ) ; Gdx . gl . glDepthMask ( false ) ; shader . bind ( ) ; setupMatrices ( ) ; drawing = true ;
onResponse: public void onResponse ( byte [ ] bytes ) { try {
initData: protected void initData ( ) { EventBus . getDefault ( ) . register ( this ) ; localSeed = User . getInstance ( ) . getSeedString ( mContext ) ; isCreated = User . getInstance ( ) . getCreated ( mContext ) ; isSynced = User . getInstance ( ) . getSynced ( mContext ) ; seedChecked = User . getInstance ( ) . getSeedChecked ( mContext ) ; walletAddress = User . getInstance ( ) . getWalletAddress ( mContext ) ; initWalletType = User . getInstance ( ) . getInitWalletType ( mContext ) ; isStartCreate = User . getInstance ( ) . getStartCreate ( mContext ) ; changePassword ( ) ;
addResource: public void addResource ( @ NonNull Resource resource ) { Assert . isTrue ( this . baseMapper . insert ( resource ) > 0 , "新增资源失败！" ) ;
getX: public float getX ( ) { return activeData . getX ( ) ;
getBasecampToDoListId: public String getBasecampToDoListId ( ) { return basecampToDoListId ;
hasBonesBroken: public boolean hasBonesBroken ( ) { return bones ;
getList: public List < TenantDB > getList ( ) { return list ;
setEnabled: public void setEnabled ( boolean enabled ) { this . enabled = enabled ; if ( ! this . enabled )
setUserId: public void setUserId ( String userId ) { this . userId = userId ;
isChecked: protected boolean isChecked ( ) { return getSettings ( ) . isMyLevelOnly ( ) ;
get: public Object get ( int index ) { checkBoundaries ( index , size - 1 ) ; return getNodeByIndex ( index ) . getPayload ( ) ;
getConversationUID: public ConversationUID getConversationUID ( ) { return conversationUID ;
setCode: public void setCode ( String code ) { this . code = code ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
step: No method body
setAdapter: public void setAdapter ( CommonRecyclerAdapter adapter ) { this . mAdapter = adapter ;
exit: public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { super . exit ( event , x , y , pointer , toActor ) ; chars . clearHoverUpgrade ( ) ; updateChars ( ) ;
read: public void read ( Json json , JsonValue jsonData ) { setValue ( jsonData . getString ( getName ( ) , getValue ( ) ) ) ;
setLabel: public void setLabel ( String label ) { mLabel = label ;
getStatus: public CustomerStatus getStatus ( String shopKey , String countryCode , Identifier customerIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomerStatus > responseModel = ( Class < CustomerStatus > ) ( Class < ? > ) CustomerStatus . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/status" , shopKey , countryCode , customerIdentifier ) , query , null , responseModel ) ;
init: No method body
getCacheDirectory: public static File getCacheDirectory ( Context context , boolean preferExternal ) { File appCacheDir = null ; String externalStorageState ; try { externalStorageState = Environment . getExternalStorageState ( ) ; } catch ( NullPointerException e ) { externalStorageState = "" ; } if ( preferExternal && Environment . MEDIA_MOUNTED . equals ( externalStorageState ) && hasExternalStoragePermission ( context ) ) { appCacheDir = getExternalCacheDir ( context ) ; } if ( appCacheDir == null ) { appCacheDir = context . getCacheDir ( ) ; } if ( appCacheDir == null ) { String cacheDirPath = "/data/data/" + context . getPackageName ( ) + "/cache/" ; LogUtils . e ( TAG , "Can't define system cache directory! " + cacheDirPath + " will be used." ) ; appCacheDir = new File ( cacheDirPath ) ; } return appCacheDir ;
endAction: public void endAction ( MotionEvent me ) { OnChartGestureListener l = mChart . getOnChartGestureListener ( ) ; if ( l != null )
getComponent: public < T extends ContentComponent > T getComponent ( Class < T > classOf ) { return original . getComponent ( classOf ) ;
bindPendingOpenChannelItem: void bindPendingOpenChannelItem ( PendingOpenChannelItem pendingOpenChannelItem ) { bindPendingChannelItem ( pendingOpenChannelItem . getChannel ( ) . getChannel ( ) ) ; setOnRootViewClickListener ( pendingOpenChannelItem , ChannelListItem . TYPE_PENDING_OPEN_CHANNEL ) ;
getPosition: public MPPointF getPosition ( Entry e , AxisDependency axis ) { if ( e == null ) return null ; float [ ] vals = mGetPositionBuffer ; vals [ 0 ] = e . getY ( ) ; vals [ 1 ] = e . getX ( ) ; getTransformer ( axis ) . pointValuesToPixel ( vals ) ; return MPPointF . getInstance ( vals [ 0 ] , vals [ 1 ] ) ;
getList: public List < PaymentEntity > getList ( ) { return list ;
getByVersionNumber: public static ProtocolVersion getByVersionNumber ( final int versionNumber ) { return Arrays . stream ( values ( ) )
CheckEmulatorBuild: public static Boolean CheckEmulatorBuild ( Context context ) { String BOARD = android . os . Build . BOARD ; String BOOTLOADER = android . os . Build . BOOTLOADER ; String BRAND = android . os . Build . BRAND ; String DEVICE = android . os . Build . DEVICE ; String HARDWARE = android . os . Build . HARDWARE ; String MODEL = android . os . Build . MODEL ; String PRODUCT = android . os . Build . PRODUCT ; if ( BOARD == "unknown" || BOOTLOADER == "unknown" || BRAND == "generic" || DEVICE == "generic" || MODEL == "sdk" || PRODUCT == "sdk" || HARDWARE == "goldfish" ) { LogUtils . e ( TAG , "Find Emulator by EmulatorBuild!" ) ; return true ; } LogUtils . e ( TAG , "Not Find Emulator by EmulatorBuild!" ) ; return false ;
getGameMode: public GameMode getGameMode ( ) { PlayState ps = getPlayState ( ) ; if ( ps instanceof PlayStateGame ) { PlayStateGame playStateGame = ( ( PlayStateGame ) ps ) ; return playStateGame . getMode ( ) ; } return null ;
renderQuestReward: private void renderQuestReward ( Table page , Reward reward ) { if ( ! ( reward instanceof ClientReward ) ) return ; ClientReward clientReward = ( ( ClientReward ) reward ) ; Reward . Action action = clientReward . getAction ( ) ; if ( ! ( action instanceof ClientReward . ClientAction ) ) return ; ClientReward . ClientAction clientAction = ( ( ClientReward . ClientAction ) action ) ; { Label title = new Label ( L . get ( "MENU_QUEST_REWARD" ) , BrainOutClient . Skin , "title-small" ) ; page . add ( title ) . pad ( 16 ) . row ( ) ; } Menu . playSound ( MenuSound . contentOwnedEx ) ; { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( clientAction . getLocalizedTitle ( ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . center ( ) . row ( ) ; page . add ( header ) . expandX ( ) . fillX ( ) . row ( ) ; } {
readTask: protected void readTask ( JsonValue jsonData ) { category = jsonData . getString ( "category" ) ;
updateWeaponInfo: private void updateWeaponInfo ( WeaponData weaponData , WeaponSlotComponent slot , WeaponSlotComponent . State state ) { if ( myPlayerData == null ) return ; if ( weaponInfo == null ) return ; PlayerOwnerComponent poc = myPlayerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return ; int stateId ; switch ( state ) { case fetchWait : { stateId = ClientConstants . WeaponState . PULL ; break ; } case misfireWait : { stateId = ClientConstants . WeaponState . MISFIRE ; break ; } case fetching : { stateId = ClientConstants . WeaponState . PULLING ; break ; } case cocking : { stateId = ClientConstants . WeaponState . COCKING ; break ; } case cocked : { stateId = ClientConstants . WeaponState . COCKED ; break ; } case reloading : case reloadingBoth : { stateId = ClientConstants . WeaponState . RELOADING ; break ; } case loadMagazineRound : { stateId = ClientConstants . WeaponState . ADDING_ROUNDS ; break ; } case stuck : case stuckIdle : { stateId = ClientConstants . WeaponState . STUCK ; break ; } case empty : { stateId = ClientConstants . WeaponState . EMPTY ; break ; } default : { if ( slot . getWeaponProperties ( ) . hasChambering ( ) && slot . getChambered ( ) == 0 && slot . getRounds ( ) > 0 ) { stateId = ClientConstants . WeaponState . PULL ; } else { stateId = ClientConstants . WeaponState . NORMAL ; } break ; } } if ( slot . isDetached ( ) ) { stateId = ClientConstants . WeaponState . DETACHED ; } if ( previousWeaponState != stateId )
reset: public void reset ( ) { release ( ) ; init ( ) ;
reverseOrder: protected boolean reverseOrder ( ) { return true ;
idOffset: public int idOffset ( ) { return 1 ; }
hasUpdate: public boolean hasUpdate ( ) { return false ;
getStaticData4: public String getStaticData4 ( ) { return staticData4 ;
found: No method body
enableMyLevelOnlyOption: protected boolean enableMyLevelOnlyOption ( ) { return true ;
error: No method body
removeAndLoadFromDb: public boolean removeAndLoadFromDb ( long schedulerId ) { debug ( "[removeAndLoadFromDb] {}" , schedulerId ) ; if ( remove ( schedulerId ) ) { return loadFromDb ( schedulerId ) ; } return false ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { if ( ! isOver ( ) ) { if ( kick != null ) { kick . setVisible ( true ) ; } stats . setVisible ( true ) ; } super . enter ( event , x , y , pointer , fromActor ) ;
replace: private void replace ( JsonValue parent , JsonValue old , JsonValue new_ ) { if ( old . prev == null ) { parent . child = new_ ; new_ . next = old . next ; new_ . prev = null ; } else { old . prev . next = new_ ; new_ . next = old . next ; new_ . prev = old . prev ; if ( old . next != null ) { old . next . prev = new_ ; } } new_ . parent = parent ; old . setType ( JsonValue . ValueType . nullValue ) ; old . next = null ; old . prev = null ; old . parent = null ; old . name = null ;
parsePath: public Path parsePath ( URI uri ) { return null ;
onRequestPermissionFailureWithAskNeverAgain: public void onRequestPermissionFailureWithAskNeverAgain ( List < String > permissions ) { LogUtils . e ( TAG , "扫码页面摄像头权限拒绝并且勾选不再提示" ) ;
getErrorMessage: private Optional < String > getErrorMessage ( HttpServletRequest request ) { return Optional . ofNullable ( ( String ) request . getAttribute ( "jakarta.servlet.error.message" ) ) ;
thenSet: public < N1 , N2 > Flow < I , Tuple2 < N1 , N2 > , CP > thenSet ( PageAttr < N1 > pa1 , PageAttr < N2 > pa2 , Function < ResultAndModel < O , CP > , Tuple2 < N1 , N2 > > after ) { Objects . requireNonNull ( after ) ; copyTransactionalExecutorProvider ( after ) ; return constructFlow ( params , services , ( ResultAndModel < I , CP > t ) -> t . model . put ( pa1 , pa2 , after . apply ( constructResultAndModel ( t . model , f . apply ( t ) , t . services , params ) ) ) , transactionalExecutorProvider , onThen ) ;
isPreviewMode: public boolean isPreviewMode ( ) { return previewMode ;
parseDeletedMessages: public static List < Message > parseDeletedMessages ( Map < Long , Message > activeMessages , List < Long > deletedIds , List < Message > deletedMessages ) { String mode = Prefs . getString ( PreferenceKeys . ANTI_DELETE_MODE , "Off" ) ; if ( ! mode . startsWith ( "Block Delete" ) ) { return deletedMessages ; } boolean log = mode . equals ( "Block Delete + Log" ) ; try { for ( long deletedId : deletedIds ) { Message message = activeMessages . get ( deletedId ) ; if ( message == null ) { continue ; } message . deleted = true ; if ( deletedMessages == null ) { deletedMessages = new ArrayList < > ( 5 ) ; } RefreshUtils . invalidateMessage ( deletedId ) ; deletedMessages . add ( message ) ; if ( log ) { if ( ! StringUtils . isEmpty ( message . getContent ( ) ) ) { FileLogger . writeWithProfileInfo ( message , "messages" , message . getContent ( ) , "Deleted Messages" , "deleted" ) ; } else if ( message . hasAttachments ( ) ) { for ( MessageAttachment attachment : message . getAttachments ( ) ) { FileLogger . writeWithProfileInfo ( message , "attachments" , attachment . filename + ( attachment . proxyUrl != null ? " (" + attachment . proxyUrl + ")" : "" ) , "Deleted Messages" , "deleted" ) ; } } } } } catch ( Exception e ) { LogUtils . logException ( e ) ; } return deletedMessages ;
onError: public void onError ( Exception e ) { Log . e ( "create error:" , e . toString ( ) ) ; runOnUiThread ( new Runnable ( ) {
clicked: public void clicked ( InputEvent event , float x , float y ) { sendEvent ( GameControllerEvent . obtain ( GameControllerEvent . Action . back ) ) ;
received: public boolean received ( final AchievementCompletedMsg msg ) { BrainOutClient . EventMgr . sendDelayedEvent ( AchievementCompletedEvent . obtain ( msg . achievementId ) ) ; return true ;
read: public void read ( Json json , JsonValue jsonData ) { if ( jsonData . has ( "total" ) )
setDrawSliceText: public void setDrawSliceText ( boolean enabled ) { mDrawEntryLabels = enabled ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pop ( ) ;
intersectsSegment: public boolean intersectsSegment ( FloatArray polygon , float x1 , float y1 , float x2 , float y2 ) { if ( polygon == null ) throw new IllegalArgumentException ( "polygon cannot be null." ) ; float [ ] vertices = polygon . items ; int nn = polygon . size ; float width12 = x1 - x2 , height12 = y1 - y2 ; float det1 = x1 * y2 - y1 * x2 ; float x3 = vertices [ nn - 2 ] , y3 = vertices [ nn - 1 ] ; for ( int ii = 0 ; ii < nn ; ii += 2 ) { float x4 = vertices [ ii ] , y4 = vertices [ ii + 1 ] ; float det2 = x3 * y4 - y3 * x4 ; float width34 = x3 - x4 , height34 = y3 - y4 ; float det3 = width12 * height34 - height12 * width34 ; float x = ( det1 * width34 - width12 * det2 ) / det3 ; if ( ( ( x >= x3 && x <= x4 ) || ( x >= x4 && x <= x3 ) ) && ( ( x >= x1 && x <= x2 ) || ( x >= x2 && x <= x1 ) ) ) { float y = ( det1 * height34 - height12 * det2 ) / det3 ; if ( ( ( y >= y3 && y <= y4 ) || ( y >= y4 && y <= y3 ) ) && ( ( y >= y1 && y <= y2 ) || ( y >= y2 && y <= y1 ) ) ) return true ; } x3 = x4 ; y3 = y4 ; } return false ;
value: private int value ( ) { return this . major * 10000000 + this . minor * 100000 + this . build * 100 + this . revision ;
setBinaryStream: public OutputStream setBinaryStream ( long pos ) throws SQLException { return null ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------paymentsOnError------------------" + e . getMessage ( ) ) ;
getContentWidth: protected float getContentWidth ( ) { return 544 ;
renderLoading: private void renderLoading ( ) { loadingBlock = new Table ( ) ; loadingBlock . add ( new Label ( L . get ( "MENU_LOADING" ) , BrainOutClient . Skin , "title-messages-white" ) ) ; loadingBlock . add ( new LoadingBlock ( ) ) . padLeft ( 16 ) ; loadingBlock . setBounds ( getWidth ( ) - 288 , 32 , 224 , 16 ) ; addActor ( loadingBlock ) ;
notifyFragmentByPosition: public void notifyFragmentByPosition ( int position ) { mTempArray . removeAt ( position ) ; notifyDataSetChanged ( ) ;
getOffsetForDrawingAtPoint: public MPPointF getOffsetForDrawingAtPoint ( float posX , float posY ) { MPPointF offset = getOffset ( ) ; mOffset2 . x = offset . x ; mOffset2 . y = offset . y ; Chart chart = getChartView ( ) ; float width = mSize . width ; float height = mSize . height ; if ( width == 0.f && mDrawable != null ) { width = mDrawable . getIntrinsicWidth ( ) ; } if ( height == 0.f && mDrawable != null ) { height = mDrawable . getIntrinsicHeight ( ) ; } if ( posX + mOffset2 . x < 0 ) { mOffset2 . x = - posX ; } else if ( chart != null && posX + width + mOffset2 . x > chart . getWidth ( ) ) { mOffset2 . x = chart . getWidth ( ) - posX - width ; } if ( posY + mOffset2 . y < 0 ) { mOffset2 . y = - posY ; } else if ( chart != null && posY + height + mOffset2 . y > chart . getHeight ( ) ) { mOffset2 . y = chart . getHeight ( ) - posY - height ; } return mOffset2 ;
init: public void init ( ) { super . init ( ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . updated , this ) ;
notCamelCase: public static Function < String , String > notCamelCase ( ) { return v -> isBlank ( v ) || ! v . matches ( "([a-z]+[a-zA-Z0-9]*)+" ) ? "not.matching.camelCase" : null ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; TextButton save = new TextButton ( L . get ( "MENU_SAVE" ) , BrainOutClient . Skin , "button-default" ) ; Tabs tabs = new Tabs ( BrainOutClient . Skin ) ; tabs . align ( Align . left ) ; data . add ( tabs ) . size ( 800 , 400 ) . row ( ) ; ClientSettings clientSettings = BrainOutClient . ClientSett ; for ( Property property : clientSettings . getProperties ( ) . getProperties ( ) ) { Tabs . Tab tab = tabs . addTab ( L . get ( property . getLocalization ( ) ) , property ) . fillButton ( ) ; renderSettings ( tab , ( Properties ) property ) ; } { Tabs . Tab accountTab = tabs . addTab ( L . get ( "MENU_ACCOUNT" ) ) . fillButton ( ) ; renderAccountTab ( accountTab ) ; } { Tabs . Tab gamePad = tabs . addTab ( L . get ( "MENU_GAMEPAD" ) ) . fillButton ( ) ; renderGamePadSettings ( gamePad ) ; } Table buttons = new Table ( ) ; TextButton help = new TextButton ( L . get ( "MENU_HELP" ) , BrainOutClient . Skin , "button-default" ) ; help . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; GameState gs = getGameState ( ) ; if ( gs == null ) return ; close ( ) ; gs . pushMenu ( new HelpMenu ( ) ) ; } } ) ; buttons . add ( help ) . size ( 192 , 64 ) . pad ( 8 ) . padLeft ( 0 ) . padRight ( 0 ) ; if ( BrainOutClient . ClientController . isLobby ( ) ) { UserProfile userProfile = BrainOutClient . ClientController . getUserProfile ( ) ; if ( userProfile != null ) { OwnableContent editorPass = BrainOutClient . ContentMgr . get ( ClientConstants . Other . MAP_EDITOR_PASS , OwnableContent . class ) ; if ( editorPass != null && ( editorPass . getLockItem ( ) == null || editorPass . getLockItem ( ) . isUnlocked ( userProfile ) ) ) { TextButton mapEditor = new TextButton ( L . get ( "MENU_MAP_EDITOR" ) , BrainOutClient . Skin , "button-default" ) ; mapEditor . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; LoginService loginService = LoginService . Get ( ) ; if ( loginService == null ) throw new RuntimeException ( "No login service!" ) ; RoomSettings partyRoom = new RoomSettings ( ) ; partyRoom . init ( BrainOutClient . ClientController . getUserProfile ( ) , false ) ; partyRoom . setParty ( BrainOutClient . ClientController . getMyAccount ( ) ) ; close ( ) ; BrainOutClient . ClientController . setState ( new CSQuickPlay ( getEditor ( ) , partyRoom , new Matchmaking . FindGameResult ( ) { @ Override public void success ( String roomId ) { BrainOutClient . Env . setCurrentRoom ( roomId ) ; } @ Override public void failed ( Request . Result status , Request request ) { } @ Override public void connectionFailed ( ) { } } , false ) ) ; } } ) ; buttons . add ( mapEditor ) . size ( 192 , 64 ) . pad ( 8 ) . padLeft ( 0 ) ; } } } buttons . add ( save ) . right ( ) . expandX ( ) . size ( 192 , 64 ) . pad ( 8 ) . padRight ( 0 ) ; data . add ( buttons ) . expandX ( ) . fillX ( ) . row ( ) ; save . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; save ( ) ; } } ) ; return data ;
isVerified: public boolean isVerified ( ) { return verified ;
reset: public void reset ( ) { this . team = null ; this . flagData = null ;
setAvatar: public void setAvatar ( String avatar ) { this . avatar = avatar ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case onZeroHealth : { return wound ( ) ; } case activeActivateData : { ActivateActiveEvent ev = ( ( ActivateActiveEvent ) event ) ; return activate ( ev . client , ev . playerData ) ; } case physicsContact : { if ( fp == null ) return false ; PhysicsContactEvent ev = ( ( PhysicsContactEvent ) event ) ; contact ( ev ) ; break ; } } return false ;
setName: public void setName ( String name ) { this . name = name ;
success: No method body
setMenuLayouts: public void setMenuLayouts ( List < View > menuItems ) { int size = menuItems . size ( ) ; mMenuViewArrays . clear ( ) ; for ( int i = 0 ; i < size ; i ++ ) {
shouldInterceptRequest: public WebResourceResponse shouldInterceptRequest ( WebView view , String url ) { return null ;
createOrUpdateBulk: public ApiCollection < Redirect > createOrUpdateBulk ( String shopKey , List < Redirect > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Redirect > responseModel = ( Class < Redirect > ) ( Class < ? > ) Redirect . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "put" , this . resolvePath ( "/shops/%s/redirects/bulk" , shopKey ) , query , null , responseModel , model ) ;
deselected: protected void deselected ( ) { if ( playerAnimation != null )
getItemRank: protected int getItemRank ( ConsumableRecord record ) { ConsumableItem item = record . getItem ( ) ; SortingRankComponent rank = item . getContent ( ) . getComponent ( SortingRankComponent . class ) ; if ( rank != null ) { return rank . getRank ( ) ; } if ( item instanceof InstrumentConsumableItem ) { if ( item . getContent ( ) instanceof Weapon ) { Weapon weapon = ( ( Weapon ) item . getContent ( ) ) ; if ( weapon . getSlot ( ) != null ) { if ( weapon . getSlot ( ) . getID ( ) . equals ( "slot-primary" ) ) { return 30 ; } } } return 20 ; } return 10 ;
getDrawY: public float getDrawY ( ) { return mDrawY ;
validate: public PageBuilderForm validate ( BindingResult br ) { debug ( "[validate]" ) ; return this ;
generate: public static void generate ( ServerFreeRealization free , ConsumableContainer cnt , String dimension , ActiveData owner ) { InstrumentSlotItem slot = free . getRandomPrimaryWeapon ( ) ; if ( slot == null ) return ; Weapon weapon = ( ( Weapon ) slot . getInstrument ( ) ) ; if ( Log . INFO ) Log . info ( "Generated new weapon " + weapon . getID ( ) ) ; WeaponData weaponData = weapon . getData ( dimension ) ; if ( owner != null ) { weaponData . setOwner ( owner ) ; } { weaponData . setSkin ( weapon . getDefaultSkin ( ) ) ; } { ServerWeaponComponentData sw = weaponData . getComponent ( ServerWeaponComponentData . class ) ; if ( sw != null ) { Bullet bullet = BrainOutServer . ContentMgr . get ( weaponData . getWeapon ( ) . getPrimaryProperties ( ) . getBullet ( ) , Bullet . class ) ; if ( bullet != null ) { switch ( MathUtils . random ( 6 ) ) { case 0 : { cnt . putConsumable ( getClipSize ( weapon . getPrimaryProperties ( ) . getClipSize ( ) * 2 ) , new DefaultConsumableItem ( bullet ) ) ; break ; } case 1 : case 2 : case 3 : case 4 : case 5 : { cnt . putConsumable ( getClipSize ( weapon . getPrimaryProperties ( ) . getClipSize ( ) ) , new DefaultConsumableItem ( bullet ) ) ; break ; } } } } } cnt . putConsumable ( 1 , new InstrumentConsumableItem ( weaponData , dimension ) ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoSteamPressure1Off1ItemStateChanged ( evt ) ;
setSalesforceId: public void setSalesforceId ( String salesforceId ) { this . salesforceId = salesforceId ;
done: public void done ( ) { done = true ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcClose5ItemStateChanged ( evt ) ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { getStage ( ) . setScrollFocus ( pane ) ;
drawLabel: protected void drawLabel ( Canvas c , float x , float y , String label ) { c . drawText ( label , x , y , mLegendLabelPaint ) ;
needReconnect: public Builder needReconnect ( boolean val ) { needReconnect = val ; return this ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionDecrement6ActionPerformed ( evt ) ;
removeTagFromCache: private void removeTagFromCache ( Object tag ) { Activity activity = null ; if ( tag instanceof Activity ) { activity = ( Activity ) tag ; } else if ( tag instanceof Fragment ) { activity = ( ( Fragment ) tag ) . getActivity ( ) ; } if ( activity == null ) { return ; } String key = activity . getClass ( ) . getSimpleName ( ) ; LinkedList < Object > tagList = mRequestTagMap . get ( key ) ; if ( tagList != null && tagList . size ( ) > 0 ) { tagList . remove ( tag ) ; LogUtils . d ( TAG , "Dismiss时移除了" + tag . getClass ( ) . getSimpleName ( ) + "之后缓存集合长度" + ( tagList . size ( ) ) ) ; dismissDialog ( activity ) ; } if ( tagList == null || tagList . size ( ) == 0 ) {
init: private FreePlayWeaponUpgradedEvent init ( PlayerClient player ) { this . player = player ; return this ;
canReadFieldInOrganization: default boolean canReadFieldInOrganization ( FrontendMappingFieldDefinition field , LongIdEntity entity , Long organizationId ) { return hasFieldPrivileges ( field . readPrivilege , field . canReadCheck , entity , organizationId ) ;
updatePassword: void updatePassword ( ) throws Exception { assertNotNull ( updatePasswordParam , "updatePasswordParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . put ( "/user/update/password" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( updatePasswordParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "用户密码更新接口测试成功！" ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; showEmpty = jsonData . getBoolean ( "showEmpty" , true ) ;
setBackground: public DatePicker setBackground ( int color ) { super . setBackgroundColor ( color ) ; mYearPicker . setBackground ( color ) ; mMonthPicker . setBackground ( color ) ; mDayOfMonthPicker . setBackground ( color ) ; mHourPicker . setBackground ( color ) ; mMinutePicker . setBackground ( color ) ; return this ;
getPublicFlags: No method body
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( L . get ( "EDITOR2_PUBLISH_WORKSHOP" ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . row ( ) ; data . add ( header ) . size ( 562 , 32 ) . row ( ) ; } { Table contents = new Table ( BrainOutClient . Skin ) ; contents . setBackground ( "form-default" ) ; contents . align ( Align . center ) ; renderContents ( contents ) ; data . add ( contents ) . width ( 564 ) . row ( ) ; } { Table buttons = new Table ( ) ; { TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ; } } ) ; buttons . add ( cancel ) . expandX ( ) . fillX ( ) . uniformX ( ) . height ( 64 ) ; } { saveButton = new Button ( BrainOutClient . Skin , "button-green" ) ; saveButton . setDisabled ( ! validate ( ) ) ; { Image steam = new Image ( BrainOutClient . Skin , "steam-icon" ) ; steam . setScaling ( Scaling . none ) ; saveButton . add ( steam ) . size ( 32 , 32 ) . padRight ( 16 ) ; Label publish = new Label ( L . get ( "EDITOR2_PUBLISH" ) , BrainOutClient . Skin , "title-small" ) ; saveButton . add ( publish ) ; } saveButton . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { if ( ! validate ( ) ) return ; Menu . playSound ( MenuSound . select ) ; save ( ) ; } } ) ; buttons . add ( saveButton ) . expandX ( ) . fillX ( ) . uniformX ( ) . height ( 64 ) ; } data . add ( buttons ) . expandX ( ) . fillX ( ) . row ( ) ; } if ( BrainOutClient . Env . getGameUser ( ) . hasWorkshopLegalTerms ( ) ) { Table legal = new Table ( BrainOutClient . Skin ) ; legal . align ( Align . center ) ; renderLegal ( legal ) ; data . add ( legal ) . width ( 564 ) . padTop ( 16 ) . row ( ) ; } return data ;
updateFrontendName: public void updateFrontendName ( String attributeGroupName , Map < String , String > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "put" , this . resolvePath ( "/attribute-groups/%s/frontend-name" , attributeGroupName ) , query , null , null , model ) ;
getDateByIdCard: public static Short getDateByIdCard ( String idCard ) { Integer len = idCard . length ( ) ; if ( len < CHINA_ID_MIN_LENGTH ) { return null ; } else if ( len == CHINA_ID_MIN_LENGTH ) { idCard = convert15CardTo18 ( idCard ) ; } return Short . valueOf ( idCard . substring ( 12 , 14 ) ) ;
setSellerCompanyTaxNo: public void setSellerCompanyTaxNo ( String sellerCompanyTaxNo ) { this . sellerCompanyTaxNo = sellerCompanyTaxNo ;
checkFilterHeaderMd5Matched: public boolean checkFilterHeaderMd5Matched ( ) { String filePath = downloadDictionaryPath + REG_FILTER_HEADER_FILE_NAME ; String fileCRC32 = manifestInfo . get ( REG_FILTER_HEADER_FILE_NAME ) ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { return FilesUtils . checkFileCRC32Matched ( filePath , fileCRC32 ) ; } return false ;
test_deleteWorkflow: public void test_deleteWorkflow ( ) throws IOException , NovuNetworkException , InterruptedException { DeleteWorkflowResponse deleteWorkflowResponse = new DeleteWorkflowResponse ( ) ; deleteWorkflowResponse . setData ( false ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( deleteWorkflowResponse ) ) ) ; DeleteWorkflowResponse response = workflowHandler . deleteWorkflow ( "workflowId" ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/workflows/workflowId" , request . getPath ( ) ) ; assertEquals ( "DELETE" , request . getMethod ( ) ) ; assertNotNull ( response ) ; assertEquals ( deleteWorkflowResponse , response ) ;
notifyExpired: No method body
setDetails: protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( this . authenticationDetailsSource . buildDetails ( request ) ) ;
runCommandToByteArray: public byte [ ] runCommandToByteArray ( String command ) { return ServerJSProcessRunner . commandToByteArray ( command ) ;
stayOnTop: public boolean stayOnTop ( ) { return onTop ;
allowTeamChange: public boolean allowTeamChange ( ) { return false ;
clear: public void clear ( ) { this . effect . reset ( ) ;
onClick: public void onClick ( View v ) { holder . getView ( R . id . layout_my_invoices_delete ) . setVisibility ( View . VISIBLE ) ;
read: public long read ( @ NonNull Buffer sink , long byteCount ) throws IOException { long bytesRead = super . read ( sink , byteCount ) ; if ( ! mResponse . isSuccessful ( ) ) { return bytesRead ; } if ( contentLength == 0 ) { contentLength = mResponseBody . contentLength ( ) ; } totalBytesRead += bytesRead != - 1 ? bytesRead : 0 ; if ( mCallBack != null ) { mProgress . setComplete ( bytesRead == - 1 ) ; mProgress . setContentLength ( contentLength ) ; mProgress . setReadLength ( totalBytesRead ) ; mProgress . setProgress ( ) ; mCallBack . onProgressInThread ( mContext , mProgress ) ; } return bytesRead ;
renderShape: public void renderShape ( Canvas c , IScatterDataSet dataSet , ViewPortHandler viewPortHandler , float posX , float posY , Paint renderPaint ) { final float shapeHalf = dataSet . getScatterShapeSize ( ) / 2f ; renderPaint . setStyle ( Paint . Style . STROKE ) ; renderPaint . setStrokeWidth ( Utils . convertDpToPixel ( 1f ) ) ; c . drawLine ( posX - shapeHalf , posY - shapeHalf , posX + shapeHalf , posY + shapeHalf , renderPaint ) ; c . drawLine (
getFormattedValue: public String getFormattedValue ( float value , AxisBase axis ) { return makePretty ( value ) + mText ;
invalidSpawn: private void invalidSpawn ( ) { BrainOut . EventMgr . sendDelayedEvent ( SimpleEvent . obtain ( SimpleEvent . Action . invalidSpawn ) ) ;
update: protected void update ( float dt ) { Map myMap = getMap ( ) ; if ( myMap == null ) return ; PlayerData playerData = getPlayerData ( ) ; if ( playerData == null ) return ; Vector2 in = new Vector2 ( ) , out = new Vector2 ( ) ; Array < FoundItem > foundItems = new Array < > ( ) ; for ( Map map : Map . All ( ) ) { if ( ! filterMap ( map ) ) continue ; if ( map == myMap || MapDimensionsGraph . IsNeighbor ( myMap , map ) ) { for ( ActiveData activeData : map . getActivesForTag ( Constants . ActiveTags . ITEM , false ) ) { if ( ! ( activeData instanceof ItemData ) ) continue ; ItemData itemData = ( ( ItemData ) activeData ) ; ConsumableRecord found = null ; int needAmount = 0 ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : itemData . getRecords ( ) . getData ( ) ) { ConsumableRecord record = entry . value ; needAmount = predicate . matches ( itemData , record ) ; if ( needAmount > 0 ) { found = record ; break ; } } if ( found == null ) continue ; float distance ; if ( map == myMap ) { distance = Vector2 . dst ( playerData . getX ( ) , playerData . getY ( ) , activeData . getX ( ) , activeData . getY ( ) ) ; } else { if ( ! WayPointMap . FindDoors ( playerData . getX ( ) , playerData . getY ( ) , myMap , map , in , out ) ) continue ; distance = Vector2 . dst ( playerData . getX ( ) , playerData . getY ( ) , in . x , in . y ) + Vector2 . dst ( out . x , out . y , activeData . getX ( ) , activeData . getY ( ) ) ; } FoundItem foundItem = new FoundItem ( ) ; foundItem . activeData = itemData ; foundItem . distance = distance ; foundItem . record = found ; foundItem . amount = needAmount ; foundItems . add ( foundItem ) ; } } } if ( foundItems . size == 0 ) { pop ( ) ; predicate . notFound ( ) ; return ; } foundItems . sort ( ( o2 , o1 ) -> ( int ) ( o2 . distance - o1 . distance ) ) ; FoundItem best = foundItems . first ( ) ; popMeAndPushTask ( new ApproachItem ( getStack ( ) ,
getReferenceString: public String getReferenceString ( ) { return referenceString ;
getSteamDensity: public double getSteamDensity ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getSteamDensity'" ) ;
setRestartIn: public void setRestartIn ( float restartIn ) { this . restartIn = restartIn ;
getAudioResponse: No method body
showStepOne: private void showStepOne ( View rootView , String invoiceAddr ) { TextView fromNodeAddressTv = rootView . findViewById ( R . id . tv_from_node_address ) ; TextView fromNodeNameTv = rootView . findViewById ( R . id . tv_from_node_name ) ; EditText invoiceEdit = rootView . findViewById ( R . id . edit_invoice ) ; if ( ! StringUtils . isEmpty ( invoiceAddr ) ) { invoiceEdit . setText ( invoiceAddr ) ; } fromNodeAddressTv . setText ( StringUtils . encodePubkey ( mAddress ) ) ; rootView . findViewById ( R . id . layout_back ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; } } ) ; rootView . findViewById ( R . id . layout_next_to_two ) . setOnClickListener ( new View . OnClickListener ( ) {
differentToday: public static int differentToday ( String dateStr , String formatStr ) { try { if ( StringUtils . isEmpty ( formatStr ) ) { formatStr = YYYY_MM_DD ; } SimpleDateFormat format = new SimpleDateFormat ( formatStr , Locale . CHINA ) ; Date date = format . parse ( dateStr ) ; long time1 = date . getTime ( ) ; Date todayDate = format . parse ( dateFormat ( System . currentTimeMillis ( ) , YYYY_MM_DD ) ) ; long time2 = todayDate . getTime ( ) ; long distance = time1 - time2 ; long oneDay = 1000 * 3600 * 24 ; float result = ( float ) distance / ( float ) oneDay ; return ( int ) result ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return 0 ;
testCreateAttribute: public void testCreateAttribute ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/AttributeGroupCreateAttributeRequest.json" ) ; AttributeGroupAttribute requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , AttributeGroupAttribute . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; AttributeGroupAttribute responseEntity = this . api . attributeGroups ( ) . createAttribute ( "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/AttributeGroupCreateAttributeResponse.json" ) ; assertThatJson ( expectedResponseJson )
deleteMacaroonID: public Single < lnrpc . LightningOuterClass . DeleteMacaroonIDResponse > deleteMacaroonID ( lnrpc . LightningOuterClass . DeleteMacaroonIDRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . deleteMacaroonID ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
setIssueDate: public void setIssueDate ( LocalDateTime createdOn ) { this . createdOn = createdOn ;
setPosition: public void setPosition ( float position ) { this . position = position ;
getViewBitmap: public static Bitmap getViewBitmap ( View v ) { if ( null == v ) { return null ; } v . setDrawingCacheEnabled ( true ) ; v . buildDrawingCache ( ) ; if ( Build . VERSION . SDK_INT >= 11 ) { v . measure ( View . MeasureSpec . makeMeasureSpec ( v . getWidth ( ) , View . MeasureSpec . EXACTLY ) , View . MeasureSpec . makeMeasureSpec ( v . getHeight ( ) , View . MeasureSpec . EXACTLY ) ) ; v . layout ( ( int ) v . getX ( ) , ( int ) v . getY ( ) , ( int ) v . getX ( ) + v . getMeasuredWidth ( ) , ( int ) v . getY ( ) + v . getMeasuredHeight ( ) ) ; } else { v . measure ( View . MeasureSpec . makeMeasureSpec ( 0 , View . MeasureSpec . UNSPECIFIED ) , View . MeasureSpec . makeMeasureSpec ( 0 , View . MeasureSpec . UNSPECIFIED ) ) ; v . layout ( 0 , 0 , v . getMeasuredWidth ( ) , v . getMeasuredHeight ( ) ) ; } Bitmap b = Bitmap . createBitmap ( v . getDrawingCache ( ) , 0 , 0 , v . getMeasuredWidth ( ) , v . getMeasuredHeight ( ) ) ; v . setDrawingCacheEnabled ( false ) ; v . destroyDrawingCache ( ) ; return b ;
setName: public void setName ( String name ) { this . name = name ;
applicable: public boolean applicable ( UserProfile profile ) { OwnableContent content = getOwnableContent ( ) ; if ( content instanceof InstrumentSkin ) { InstrumentSkin skin = ( ( InstrumentSkin ) content ) ; InstrumentSlotItem slotItem = skin . getSlotItem ( ) ; if ( slotItem != null && ! slotItem . hasItem ( profile ) ) { return false ; } } else { return false ; } return super . applicable ( profile ) ;
acquireMap: public ServerSettings . MapConditions acquireMap ( ) { return map ;
get: public void get ( final Context context , String url , final Map < String , Object > params , Map < String , String > header , final EngineCallback callBack ) { final String requestUrl = HttpUtils . jointParams ( url , params ) ; Request request = new Request . Builder ( ) . url ( requestUrl ) . tag ( mTag ) . build ( ) ; request = addHeader ( request , header ) ; mOkHttpClient . newCall ( request ) . enqueue ( new Callback ( ) {
error: public void error ( String reason ) { System . out . println ( reason ) ;
getLocale: No method body
generate: public void generate ( ItemData itemData ) { for ( ItemsCollection . Item item : items )
getActiveData: public ActiveData getActiveData ( ) { return activeData ;
getWaterMass: public double getWaterMass ( ) { return waterMass ;
getZIndex: public int getZIndex ( ) { return 0 ;
setColor: public void setColor ( Color color ) { this . color = color ;
getComponent: public SpawnActiveComponentData getComponent ( ComponentObject componentObject ) { return new SpawnActiveComponentData ( componentObject , this ) ;
getBuilder: public static CRUDControllerConfiguration getBuilder ( String key , FrontendMappingDefinition frontendMappingDefinition , ScopedSecureRepository secureRepository , Class formClass ) { return new CRUDControllerConfiguration ( key , frontendMappingDefinition ,
getNote: public String getNote ( ) { return note ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------startOnError------------------" + e . getMessage ( ) ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
newLight: private Light newLight ( ) { ClientMap map = Map . Get ( dimension , ClientMap . class ) ; if ( map == null ) return null ; return map . getLights ( ) != null ? new PointLight ( map . getLights ( ) , entity . getRays ( ) , entity . getColor ( ) ,
uncaughtException: public void uncaughtException ( @ NotNull Thread thread , @ NotNull Throwable throwable ) { try {
initAttr: private void initAttr ( Context context , AttributeSet attrs ) { TypedArray typedArray = context . obtainStyledAttributes ( attrs , R . styleable . CustomLabelLayout ) ; mLabelSpace = typedArray . getDimensionPixelSize ( R . styleable . CustomLabelLayout_labelSpace , 9 ) ; mLabelRowSpace = typedArray . getDimensionPixelSize ( R . styleable . CustomLabelLayout_rowSpace , 10 ) ; mChildLayout = typedArray . getResourceId ( R . styleable . CustomLabelLayout_childLayout , R . layout . layout_item_label_child ) ; mChildClickable = typedArray . getBoolean ( R . styleable . CustomLabelLayout_childClickable , mChildClickable ) ; typedArray . recycle ( ) ; }
getBlock: public BlockData getBlock ( ) { if ( static_ ) { if ( instance == null ) { instance = new ConcreteBD ( this ) ; } return instance ; } return new ConcreteBD ( this ) ;
setShowUpdateDialog: public void setShowUpdateDialog ( boolean showUpdateDialog ) { isShowUpdateDialog = showUpdateDialog ;
addEffect: public EffectData addEffect ( Effect effect , LaunchData launchData , EffectSet . EffectAttacher attacher ) { if ( effect == null || ! effect . isEnabled ( ) ) return null ; return addEffect ( effect . getEffect ( launchData , attacher ) ) ;
remove: public Object remove ( String s ) { if ( ! ClusterHelper . isCluster ( ) ) { return super . remove ( s ) ; } String key = getEntryKey ( s ) ; Object result = ClusterHelper . getHazelcastInstance ( ) . getReplicatedMap ( CACHE_NAME ) . remove ( key ) ; return result ;
saveToSdCard: public static void saveToSdCard ( List < Entry > entries , String path ) { File sdcard = Environment . getExternalStorageDirectory ( ) ; File saved = new File ( sdcard , path ) ; if ( ! saved . exists ( ) ) { try { saved . createNewFile ( ) ; } catch ( IOException e ) { Log . e ( LOG , e . toString ( ) ) ; } } try
setTextSize: public NumberPicker setTextSize ( float textSize ) { mTextSize = textSize ; init ( ) ; invalidate ( ) ; return this ;
getIndexString: public String getIndexString ( ) { return indexString ;
getProperty_id: public String getProperty_id ( ) { return property_id ;
run: public void run ( ) { play ( ) ; updateSound ( ) ;
loadMaps: public Array < ServerMap > loadMaps ( ServerSettings . MapConditions settings , boolean init ) { ServerController C = BrainOutServer . Controller ; if ( C . mapExists ( mapName ) ) return null ; Array < ServerMap > maps = new Array < > ( ) ; ServerMap map = C . createMap ( width , height , "default" ) ; maps . add ( map ) ; map . setName ( new FileHandle ( mapName ) . nameWithoutExtension ( ) ) ; if ( init ) { map . init ( ) ; } return maps ;
isEnabled: public boolean isEnabled ( ) { return enabled ;
read: public void read ( Json json , JsonValue jsonData ) { accessToken = jsonData . getString ( "token" , "" ) ; if ( accessToken == null ) { accessToken = "" ; } String hash = jsonData . getString ( "__S" , "" ) ; if ( hash . isEmpty ( ) )
enforce: public void enforce ( ItemQuery query ) { Array < ItemData > items = query . query ( this . tag , noPlayer ) ; if ( items == null ) return ; int have = find ( items ) ; if ( getAmount ( ) > have )
createDocumentsFromPdfPages: private List < Map < String , String > > createDocumentsFromPdfPages ( final PdDocumentWrapper pdDocumentWrapper ) throws IOException { final PDFTextStripper textStripper = new PDFTextStripper ( ) ; final List < Map < String , String > > documents = new LinkedList < > ( ) ; for ( int pageIndex = 0 ; pageIndex < pdDocumentWrapper . pdDocument . getNumberOfPages ( ) ; pageIndex ++ ) { textStripper . setStartPage ( pageIndex + 1 ) ; textStripper . setEndPage ( pageIndex + 1 ) ; final String pageContent ; try { pageContent = textStripper . getText ( pdDocumentWrapper . pdDocument ) ; } catch ( final IOException innerIoException ) { throw new IllegalStateException ( "error reading page with index " + pageIndex , innerIoException ) ; } final int pageNumber = pageIndex + 1 ; final Map < String , String > pageDocument = new LinkedHashMap < > ( ) ; pageDocument . put ( PromptConstants . CONTENT , pageContent ) ; pageDocument . put ( PromptConstants . SOURCE , String . format ( "%s p.%d" , pdDocumentWrapper . pdDocumentName , pageNumber ) ) ; LogManager . getLogger ( ) . info ( "successfully read page {} of document {}" , pageNumber , pdDocumentWrapper . pdDocumentName ) ; documents . add ( pageDocument ) ; } return documents ;
interceptMethod: private Response interceptMethod ( Chain chain ) throws IOException { Request request = chain . request ( ) ; long startTime = System . currentTimeMillis ( ) ; Response response = chain . proceed ( chain . request ( ) ) ; long endTime = System . currentTimeMillis ( ) ; long duration = endTime - startTime ; ResponseBody responseBody = response . peekBody ( 1024 * 1024 ) ; String content = responseBody . string ( ) ; LogUtils . e ( TAG , "\n" ) ; LogUtils . e ( TAG , "----------Start----------------" ) ; LogUtils . e ( TAG , "| " + request . toString ( ) ) ; Headers headers = request . headers ( ) ; if ( headers != null && headers . size ( ) > 0 ) { LogUtils . e ( TAG , "| RequestHeader:" ) ; int headerSize = headers . size ( ) ; for ( int i = 0 ; i < headerSize ; i ++ ) { LogUtils . e ( TAG , "| " + headers . name ( i ) + ":" + headers . value ( i ) ) ; } } String method = request . method ( ) ; if ( "POST" . equals ( method ) ) { StringBuilder sb = new StringBuilder ( ) ; if ( request . body ( ) instanceof FormBody ) { FormBody body = ( FormBody ) request . body ( ) ; for ( int i = 0 ; i < body . size ( ) ; i ++ ) { sb . append ( body . encodedName ( i ) + "=" + body . encodedValue ( i ) + "," ) ; } sb . delete ( sb . length ( ) - 1 , sb . length ( ) ) ; LogUtils . e ( TAG , "| RequestParams:{" + sb . toString ( ) + "}" ) ; } else { LogUtils . e ( TAG , "| RequestParams:" + bodyToString ( request ) ) ; } } LogUtils . e ( TAG , "| ResponseCode:" + response . code ( ) ) ; LogUtils . e ( TAG , "| Response:" + content ) ; LogUtils . e ( TAG , "----------End:" + duration + "毫秒----------" ) ; return response ;
testAttachWarehouse: public void testAttachWarehouse ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . merchants ( ) . attachWarehouse ( Identifier . fromId ( 1 ) , Identifier . fromId ( 1 ) , options ) ;
hasValue: public boolean hasValue ( ) { return hasValue ;
executeInTransaction: public Object executeInTransaction ( Supplier f ) { debug ( "[executeInTransaction]" ) ; return f . get ( ) ;
setCurrentTime: void setCurrentTime ( ) { time = System . currentTimeMillis ( ) ;
setAutoCountdownFirst: public void setAutoCountdownFirst ( ) { this . mAutoCountdownFirst = true ;
UpdateParamToRole: No method body
getValueTextColor: public int getValueTextColor ( int index ) { return mValueColors . get ( index % mValueColors . size ( ) ) ;
drawXAxisValue: public static void drawXAxisValue ( Canvas c , String text , float x , float y , Paint paint , MPPointF anchor , float angleDegrees ) { float drawOffsetX = 0.f ; float drawOffsetY = 0.f ; final float lineHeight = paint . getFontMetrics ( mFontMetricsBuffer ) ; paint . getTextBounds ( text , 0 , text . length ( ) , mDrawTextRectBuffer ) ; drawOffsetX -= mDrawTextRectBuffer . left ; drawOffsetY += - mFontMetricsBuffer . ascent ; Paint . Align originalTextAlign = paint . getTextAlign ( ) ; paint . setTextAlign ( Paint . Align . LEFT ) ; if ( angleDegrees != 0.f ) { drawOffsetX -= mDrawTextRectBuffer . width ( ) * 0.5f ; drawOffsetY -= lineHeight * 0.5f ; float translateX = x ; float translateY = y ; if ( anchor . x != 0.5f || anchor . y != 0.5f ) { final FSize rotatedSize = getSizeOfRotatedRectangleByDegrees ( mDrawTextRectBuffer . width ( ) , lineHeight , angleDegrees ) ; translateX -= rotatedSize . width * ( anchor . x - 0.5f ) ; translateY -= rotatedSize . height * ( anchor . y - 0.5f ) ; FSize . recycleInstance ( rotatedSize ) ; } c . save ( ) ; c . translate ( translateX , translateY ) ; c . rotate ( angleDegrees ) ; c . drawText ( text , drawOffsetX , drawOffsetY , paint ) ; c . restore ( ) ; } else { if ( anchor . x != 0.f || anchor . y != 0.f ) { drawOffsetX -= mDrawTextRectBuffer . width ( ) * anchor . x ; drawOffsetY -= lineHeight * anchor . y ; } drawOffsetX += x ; drawOffsetY += y ; c . drawText ( text , drawOffsetX , drawOffsetY , paint ) ; } paint . setTextAlign ( originalTextAlign ) ;
init: public static void init ( Context context ) { if ( context == null ) {
onComplete: public Callback < T > onComplete ( final @ NonNull Consumer < T > onComplete ) { this . onCompleteConsumer = onComplete ; return this ;
generateRandom: public double generateRandom ( ) { double ran = Math . random ( ) ; System . out . println ( "ran=" + ran ) ; return ran ;
leaveGuild: public static void leaveGuild ( long guildId ) { try {
getUniqueId: public String getUniqueId ( ) { try
copy: protected void copy ( BubbleDataSet bubbleDataSet ) { bubbleDataSet . mHighlightCircleWidth = mHighlightCircleWidth ; bubbleDataSet . mNormalizeSize = mNormalizeSize ;
cache: public void cache ( Map map , SpriteCache cache ) { if ( sprite != null )
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamInVStop2ItemStateChanged ( evt ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
getCode: public String getCode ( ) { return code ;
onResponseFail: protected void onResponseFail ( Context context , String errorCode , String errorMsg ) { super . onResponseFail ( context , errorCode , errorMsg ) ; User . getInstance ( ) . setToken ( context , "" ) ; User . getInstance ( ) . setUserId ( context , "" ) ; User . getInstance ( ) . setQrCodeLink ( context , "" ) ; User . getInstance ( ) . setCompanyId ( context , "" ) ; if ( mCallback != null ) {
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . vouchers ( ) . delete ( "acme" , "acme" , 1 , options ) ;
getUserNameWithDiscriminator: public static CharSequence getUserNameWithDiscriminator ( User user , @ ColorInt Integer num , @ Nullable Float f ) { final boolean hasDiscriminator = user . getDiscriminator ( ) != 0 ; String name = StringUtils . convertLegacyDiscriminatorToUsername ( user . getUsername ( ) + ( hasDiscriminator ? formatDiscriminator ( user . getDiscriminator ( ) ) : "" ) ) ; if ( num == null && f == null ) { return hasDiscriminator ? name : "@" + name ; } SpannableStringBuilder sb = new SpannableStringBuilder ( ) ; if ( ! hasDiscriminator ) { sb . append ( "@" ) ; } int idx = sb . length ( ) ; sb . append ( name ) ; if ( num != null ) { sb . setSpan ( new ForegroundColorSpan ( num ) , idx , sb . length ( ) , 17 ) ; } if ( f != null ) { sb . setSpan ( new RelativeSizeSpan ( f ) , idx , sb . length ( ) , 17 ) ; } return sb ;
setGroup: public void setGroup ( String group ) { this . group = group ;
release: public void release ( ) { super . release ( ) ; if ( soundEffect . isLoop ( ) )
equals: public boolean equals ( Object other ) { if ( other instanceof ChangeBodyTransformer ) { return this . uuid . equals ( ( ( ChangeBodyTransformer ) other ) . getUuid ( ) ) ; } return false ;
unlocked: No method body
reset: public void reset ( ) { this . aim = false ;
migrateLegacyPrefs: public static void migrateLegacyPrefs ( ) { final SharedPreferences sp = getPreferences ( ) ; if ( sp . contains ( PreferenceKeys . BACKGROUND_ENABLED ) ) { boolean enabled = sp . getBoolean ( PreferenceKeys . BACKGROUND_ENABLED , false ) ; setInt ( PreferenceKeys . BACKGROUND_MODE , enabled ? Background . MODE_FILE : Background . MODE_OFF ) ; remove ( PreferenceKeys . BACKGROUND_ENABLED ) ; } if ( sp . contains ( PreferenceKeys . SHOW_TAG ) ) {
testGetCriterion: public void testGetCriterion ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; VoucherCriterion responseEntity = this . api . vouchers ( ) . getCriterion ( "acme" , "acme" , 1 , 1 , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/VoucherGetCriterionResponse.json" ) ; assertThatJson ( expectedResponseJson )
test_getWorkflowGroup: public void test_getWorkflowGroup ( ) throws NovuNetworkException , IOException , InterruptedException { WorkflowGroupResponse workflowGroupResponse = new WorkflowGroupResponse ( ) ; WorkflowGroupResponseData data = new WorkflowGroupResponseData ( ) ; data . setId ( "id" ) ; data . setName ( "name" ) ; data . setOrganizationId ( "organizationId" ) ; data . setEnvironmentId ( "environmentId" ) ; data . setParentId ( "parentId" ) ; workflowGroupResponse . setData ( data ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( workflowGroupResponse ) ) ) ; WorkflowGroupResponse response = workflowGroupHandler . getWorkflowGroup ( data . getId ( ) ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/notification-groups/id" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( workflowGroupResponse ) , gson . toJson ( response ) ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
getAssignments: public String getAssignments ( ) { return assignments ;
markReadAllNotifications: public Object markReadAllNotifications ( @ PathVariable ( name = ORGANIZATIONID , required = false ) Long organizationId , @ PathVariable ( USERID ) Long userId ) { debug ( "[markReadAllNotifications] UserId: {} OrgId: {}" , userId , organizationId ) ; markAllAsRead ( userId , organizationId ) ; return ResponseEntity . status ( HttpStatus . OK ) . body ( "Successfully marked all user's notifications as read!" ) ;
showStepError: private void showStepError ( ) { TextView fromNodeAddressErrorTv = mAlertDialog . findViewById ( R . id . tv_from_node_address_error ) ; fromNodeAddressErrorTv . setText ( mAddress ) ; RelativeLayout shareLayout = mAlertDialog . findViewById ( R . id . layout_share_error ) ; mAlertDialog . findViewById ( R . id . layout_parent ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { shareLayout . setVisibility ( View . GONE ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_back_to_error ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_one ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_error ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . layout_cancel ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . layout_close ) . setVisibility ( View . GONE ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_share_to_error ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { System . out . println ( shareLayout . toString ( ) ) ; shareLayout . setVisibility ( View . VISIBLE ) ; } } ) ; mAlertDialog . findViewById ( R . id . iv_facebook_share_error ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ToastUtils . showToast ( mContext , "Not yet open, please wait" ) ; shareLayout . setVisibility ( View . GONE ) ; } } ) ; mAlertDialog . findViewById ( R . id . iv_twitter_share_error ) . setOnClickListener ( new View . OnClickListener ( ) {
thenSetDefault: public < N1 , N2 , N3 , N4 , N5 , N6 > Flow < I , Tuple6 < N1 , N2 , N3 , N4 , N5 , N6 > , CP > thenSetDefault ( PageAttr < N1 > pa1 , PageAttr < N2 > pa2 , PageAttr < N3 > pa3 , PageAttr < N4 > pa4 , PageAttr < N5 > pa5 , PageAttr < N6 > pa6 ) { Function < ResultAndModel < O , CP > , Tuple6 < N1 , N2 , N3 , N4 , N5 , N6 > > after = a -> Tuples . of ( pa1 . constructor . get ( ) , pa2 . constructor . get ( ) , pa3 . constructor . get ( ) , pa4 . constructor . get ( ) , pa5 . constructor . get ( ) , pa6 . constructor . get ( ) ) ; return thenSet ( pa1 , pa2 , pa3 , pa4 , pa5 , pa6 , after ) ;
received: public boolean received ( final SingleBlockMsg msg ) { Map map = Map . Get ( msg . d ) ; if ( map == null ) return true ; int x = msg . x , y = msg . y ; String block_ = msg . block ; BrainOutServer . PostRunnable ( ( ) -> { Block block = block_ == null ? null : BrainOutServer . ContentMgr . get ( block_ , Block . class ) ; setBlock ( map , x , y , block ) ; } ) ; return true ;
getWaterLevel: public double getWaterLevel ( ) { return waterLevel ;
get: public static String get ( String id ) { return BrainOut . LocalizationMgr . get ( id ) ;
formatDateLocaleEN: public static String formatDateLocaleEN ( Date date ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( "dd MMM yyyy" , Locale . ENGLISH ) ; return dateFormat . format ( date ) ;
toString: public String toString ( ) { return toList ( ) . toString ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; callback . cancel ( ) ;
getY: public float getY ( ) { return y ;
hasShadows: public boolean hasShadows ( ) { if ( BrainOutClient . ClientController . getGameMode ( ) . getID ( ) == GameMode . ID . free ) { return true ; } return graphicsQuality . getValue ( ) != GRAPHICS_VERY_LOW ;
putLong: protected static boolean putLong ( String name , Context context , String key , long value ) { SharedPreferences settings = context . getSharedPreferences ( name , Context . MODE_PRIVATE ) ; SharedPreferences . Editor editor = settings . edit ( ) ; editor . putLong ( key , value ) ; return editor . commit ( ) ;
remove: public Object remove ( @ PathVariable ( name = ID ) Long objectId , @ PathVariable ( name = ORGANIZATIONID , required = false ) Long organizationId ) { CRUDControllerConfiguration conf = controllers . htmlCrudControllerConfigurationMap . get ( FRONTENDRESOURCE ) ; PrivilegeBase privilege = conf . getPostRemovePrivilege ( ) ; if ( not ( hasGlobalOrOrgPrivilege ( privilege , organizationId ) ) ) { return ResponseEntity . status ( HttpStatus . UNAUTHORIZED ) . build ( ) ; } return Flow . init ( componentProvider , objectId )
hasUpdate: public boolean hasUpdate ( ) { return true ;
getZIndex: public int getZIndex ( ) { return 15 ;
getSteamMass: No method body
setMin: public void setMin ( int min ) { this . min = min ;
render: public Actor render ( Table data ) { return ContentImage . RenderImage ( id , data , getAmount ( ) ) ;
forceSpawn: private void forceSpawn ( ) { if ( getState ( ) != GameModeDuel . DuelState . spawn ) return ; for ( PlayerClient duelist : duelists )
getExpectedInt: protected int getExpectedInt ( long seed ) { return new Random ( seed ) . nextInt ( ) ;
isAttached: public boolean isAttached ( ) { return attached != null ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
JoinFreePlay: public static void JoinFreePlay ( String partyId ) { GameState topState = BrainOutClient . getInstance ( ) . topState ( ) ; if ( topState == null ) return ; Menu topMenu = topState . topMenu ( ) ; if ( topMenu instanceof FreePlayPartnerLobby ) { topMenu . pop ( ) ; } topState . pushMenu ( new FreePlayPartnerLobby ( partyId ) ) ;
process: private void process ( ) { ClientMap map = Map . GetWatcherMap ( ClientMap . class ) ; if ( map == null ) return ; if ( placeInto != null && ! discovery ) { ClientItemComponentData ci = placeInto . getComponent ( ClientItemComponentData . class ) ; if ( ci != null && ci . isDiscover ( ) && ci . hasUndiscoveredRecords ( ) ) { discovery = true ; loading . clearChildren ( ) ; LoadingBlock loadingBlock = new LoadingBlock ( ) ; loading . add ( loadingBlock ) . expandX ( ) . size ( 16 , 16 ) . pad ( 24 ) ; looking = Actions . repeat ( RepeatAction . FOREVER , Actions . sequence ( Actions . delay ( 0.6f ) , Actions . run ( ( ) -> { ConsumableRecord discovered = ci . discoverARecord ( ) ; if ( discovered != null ) { playDiscovered ( discovered ) ; if ( ci . hasUndiscoveredRecords ( ) ) { return ; } } loading . clearChildren ( ) ; removeAction ( looking ) ; looking = null ; } ) ) ) ; addAction ( looking ) ; } } for ( ObjectMap . Entry < ConsumableRecord , RegisteredRecord > entry : registeredRecords ) { entry . value . flag = false ; } map . getListActivesForTag ( ClientConstants . Items . FOUND_DISTANCE , this . playerData . getX ( ) , this . playerData . getY ( ) , ActiveData . class , Constants . ActiveTags . ITEM , this :: processItem ) ; for ( ObjectMap . Entry < ConsumableRecord , RegisteredRecord > entry : registeredRecords )
setVisible: public boolean setVisible ( boolean visible ) { map . getActives ( ) . getRenderLayer ( layer ) . setVisible ( visible ) ; return true ;
u: public long u ( ) { return 0 ; }
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
forcePlayerList: public boolean forcePlayerList ( ) { return false ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { sdvcStop4ActionPerformed ( evt ) ;
release: public void release ( ) { if ( mAlertDialog != null ) {
draw: public void draw ( Batch batch , Skeleton skeleton ) { if ( batch instanceof TwoColorPolygonBatch ) { draw ( ( TwoColorPolygonBatch ) batch , skeleton ) ; return ; } if ( batch instanceof PolygonSpriteBatch ) { draw ( ( PolygonSpriteBatch ) batch , skeleton ) ; return ; } if ( batch == null ) throw new IllegalArgumentException ( "batch cannot be null." ) ; if ( skeleton == null ) throw new IllegalArgumentException ( "skeleton cannot be null." ) ; VertexEffect vertexEffect = this . vertexEffect ; if ( vertexEffect != null ) vertexEffect . begin ( skeleton ) ; boolean pmaColors = this . pmaColors , pmaBlendModes = this . pmaBlendModes ; BlendMode blendMode = null ; float [ ] vertices = this . vertices . items ; Color skeletonColor = skeleton . color ; float r = skeletonColor . r , g = skeletonColor . g , b = skeletonColor . b , a = skeletonColor . a ; Object [ ] drawOrder = skeleton . drawOrder . items ; for ( int i = 0 , n = skeleton . drawOrder . size ; i < n ; i ++ ) { Slot slot = ( Slot ) drawOrder [ i ] ; if ( ! slot . bone . active ) { clipper . clipEnd ( slot ) ; continue ; } Attachment attachment = slot . attachment ; if ( attachment instanceof RegionAttachment ) { RegionAttachment region = ( RegionAttachment ) attachment ; region . computeWorldVertices ( slot . getBone ( ) , vertices , 0 , 5 ) ; Color color = region . getColor ( ) , slotColor = slot . getColor ( ) ; float alpha = a * slotColor . a * color . a * 255 ; float multiplier = pmaColors ? alpha : 255 ; BlendMode slotBlendMode = slot . data . getBlendMode ( ) ; if ( slotBlendMode != blendMode ) { if ( slotBlendMode == BlendMode . additive && pmaColors ) { slotBlendMode = BlendMode . normal ; alpha = 0 ; } blendMode = slotBlendMode ; blendMode . apply ( batch , pmaBlendModes ) ; } float c = NumberUtils . intToFloatColor ( ( int ) alpha << 24 | ( int ) ( b * slotColor . b * color . b * multiplier ) << 16 | ( int ) ( g * slotColor . g * color . g * multiplier ) << 8 | ( int ) ( r * slotColor . r * color . r * multiplier ) ) ; float [ ] uvs = region . getUVs ( ) ; for ( int u = 0 , v = 2 ; u < 8 ; u += 2 , v += 5 ) { vertices [ v ] = c ; vertices [ v + 1 ] = uvs [ u ] ; vertices [ v + 2 ] = uvs [ u + 1 ] ; } if ( vertexEffect != null ) applyVertexEffect ( vertices , 20 , 5 , c , 0 ) ; batch . draw ( region . getRegion ( ) . getTexture ( ) , vertices , 0 , 20 ) ; } else if ( attachment instanceof ClippingAttachment ) { clipper . clipStart ( slot , ( ClippingAttachment ) attachment ) ; continue ; } else if ( attachment instanceof MeshAttachment ) { throw new RuntimeException ( batch . getClass ( ) . getSimpleName ( ) + " cannot render meshes, PolygonSpriteBatch or TwoColorPolygonBatch is required." ) ; } else if ( attachment instanceof SkeletonAttachment ) { Skeleton attachmentSkeleton = ( ( SkeletonAttachment ) attachment ) . getSkeleton ( ) ; if ( attachmentSkeleton != null ) { draw ( batch , attachmentSkeleton ) ; ( ( SkeletonAttachment ) attachment ) . draw ( batch ) ; } } clipper . clipEnd ( slot ) ; } clipper . clipEnd ( ) ; if ( vertexEffect != null ) vertexEffect . end ( ) ;
reset: protected void reset ( ) { if ( rpm < 3250 && condenser . getPressure ( ) < 0.030 && mcc . drum1 . getPressure ( ) > 5 && mcc . drum2 . getPressure ( ) > 5 ) {
renderIcon: public void renderIcon ( WidgetGroup to ) { Image iconImage = new Image ( BrainOutClient . Skin , playerIcon ) ; iconImage . setTouchable ( Touchable . disabled ) ; iconImage . setScaling ( Scaling . none ) ; iconImage . setFillParent ( true ) ; to . addActor ( iconImage ) ;
createOrUpdateCustomDataForKey: public Map < String , Object > createOrUpdateCustomDataForKey ( Identifier variantIdentifier , String key , Map < String , Object > model ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "put" , this . resolvePath ( "/variants/%s/custom-data/%s" , variantIdentifier , key ) , null , null , responseModel , model ) ;
newBlockMatrixData: protected BlockMatrixData newBlockMatrixData ( String dimension ) { return new ClientBlockMatrixData ( dimension ) ;
hasRender: public boolean hasRender ( ) { return false ;
getID: public ID getID ( ) { return ID . assault ;
update: public void update ( float dt ) { super . update ( dt ) ; if ( ! done )
trigger: private void trigger ( ) { BrainOutServer . PostRunnable ( this :: remove ) ;
getAngle: public float getAngle ( ) { return 0 ;
iterator: public MyIterator iterator ( ) { return new MyListIterator ( this ) ;
test: No method body
onEvent: public boolean onEvent ( Event event ) { return false ;
preHandle: public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { boolean result = true ; for ( PreHandler h : preHandlers ) { result &= h . preHandle ( request , response ) ; } return result ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
sendToRouteV2: No method body
getEntityClassName: public String getEntityClassName ( ) { return entityClassName ;
getOutputAsync: default CompletableFuture < Output < Res > > getOutputAsync ( ) { return getOutputAsync ( RequestOptions . DEFAULT ) ;
setGestureStartAngle: public void setGestureStartAngle ( float x , float y ) { mStartAngle = mChart . getAngleForPoint ( x , y ) - mChart . getRawRotationAngle ( ) ;
getSearchableRepositoryMetadata: public static SearchableRepositoryMetadata getSearchableRepositoryMetadata ( Class entityClass ) { return searchableRepositoryMetadataByEntityClass . get ( entityClass ) ;
cache: public void cache ( Map map , SpriteCache cache ) { ActiveData activeData = ( ( ActiveData ) getComponentObject ( ) ) ; SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null )
Decompress: public static byte [ ] Decompress ( byte [ ] bytesToDecompress ) { return Decompress ( bytesToDecompress , 0 , bytesToDecompress . length ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamInVClose3ItemStateChanged ( evt ) ;
doubleClick: private void doubleClick ( ) { gestureDetector . setOnDoubleTapListener ( new GestureDetector . OnDoubleTapListener ( ) {
doConnect: private void doConnect ( int reconnect , Runnable onConnectionFailed ) { Gdx . app . postRunnable ( ( ) ->
release: public void release ( ) { super . release ( ) ; BrainOutServer . EventMgr . unsubscribe ( Event . ID . playerWon , this ) ;
act: public void act ( float delta ) { super . act ( delta ) ; actions . processActions ( delta ) ;
getCache: public boolean getCache ( ) { return cache ;
testDeleteCustomDataForKey: public void testDeleteCustomDataForKey ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shopCountries ( ) . deleteCustomDataForKey ( "acme" , "acme" , "acme" , options ) ;
toString: public String toString ( ) { return "PayloadType{"
getNext: public @ Null TrackEntry getNext ( ) { return next ;
getBoundEffect: public EffectData getBoundEffect ( String key ) { Pair < EffectData , Float > pair = boundEffects . get ( key ) ; if ( pair == null ) return null ; return pair . first ;
setSecond: public void setSecond ( V second ) { this . second = second ;
setName: public void setName ( String name ) { this . name = name ;
setActive: private void setActive ( boolean active ) { if ( active == this . active ) return ; this . active = active ; if ( active )
getLabel: public String getLabel ( ) { return label ;
getFormattedValue: public String getFormattedValue ( float value , AxisBase axis ) { int index = Math . round ( value ) ; if ( index < 0 || index >= mValueCount || index != ( int ) value ) return "" ; return mValues [ index ] ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
awaitIndex: public int awaitIndex ( ) { return ( int ) Util . blockOnResolve ( this . syscalls , this . deferred ( ) ) ;
setAvatarSrc: public void setAvatarSrc ( String avatarSrc ) { this . avatarSrc = avatarSrc ;
onWebViewPageFinish: No method body
check: private void check ( ) { String url = this . url . getText ( ) ; if ( url . isEmpty ( ) ) return ; if ( ! url . endsWith ( ".png" ) && ! url . endsWith ( ".jpg" ) && ! url . endsWith ( ".jpeg" ) ) { failed ( ) ; return ; } WaitLoadingMenu waitLoadingMenu = new WaitLoadingMenu ( "" ) ; pushMenu ( waitLoadingMenu ) ; Avatars . Clear ( url ) ; Avatars . Get ( url ,
connected: public void connected ( Connection connection ) { KryoNetworkConnection newConnection = new KryoNetworkConnection ( connection ) ; connections . put ( connection , newConnection ) ; listener . connected ( newConnection ) ; if ( connectListener != null )
updateWaterOutflow: public void updateWaterOutflow ( double flow , double tempC ) { throw new UnsupportedOperationException ( "Unimplemented method 'updateWaterOutFlow'" ) ;
markAllSubscriberMessagesFeedAs: public Long markAllSubscriberMessagesFeedAs ( final MarkAllMessagesRequest request , final String subscriberId ) throws IOException , NovuNetworkException { Response < Long > response = subscribersApi . markAllSubscriberMessagesFeedAs ( request , subscriberId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
getWorkflowGroups: public GetWorkflowGroupsResponse getWorkflowGroups ( ) throws IOException , NovuNetworkException { try {
activateInstrument: public void activateInstrument ( ) { if ( playerAnimation == null ) { return ; } if ( instrumentData != null && instrumentData . getOwner ( ) != null ) { PlayerComponentData poc = instrumentData . getOwner ( ) . getComponentWithSubclass ( PlayerComponentData . class ) ; if ( poc != null ) { poc . setInstrumentState ( instrumentComponent . getStates ( ) ) ; } } attachTo ( getAttachSlot ( ) , playerAnimation ) ;
getTempCameraImageDir: public static String getTempCameraImageDir ( Context context ) { if ( StorageUtils . SdCardAvailable ( ) && StorageUtils . hasExternalStoragePermission ( context ) ) {
handleIncomingBuffer: private void handleIncomingBuffer ( Buffer buffer ) { if ( this . buffers . isEmpty ( ) && this . subscriberRequest > 0 ) { this . inputMessagesSubscriber . onNext ( buffer . getByteBuf ( ) . nioBuffer ( ) ) ; this . subscriberRequest -- ; return ; } this . buffers . add ( buffer . getByteBuf ( ) . nioBuffer ( ) ) ; tryProgress ( ) ;
hasRender: public boolean hasRender ( ) { return false ;
update: public void update ( float dt ) { uploadTimer += dt ; if ( uploadTimer > ServerConstants . Online . PROFILE_UPLOAD_PERIOD ) { if ( ! locked ) { uploadTimer = 0 ; try { doSave ( ) ; } catch ( JSONException ignored ) { } } } if ( sendProfile )
canZoomOutMoreX: public boolean canZoomOutMoreX ( ) { return mScaleX > mMinScaleX ;
saveAll: public MapSaveResult saveAll ( final Set < String > dimensions , final ActiveData . ComponentWriter componentWriter , boolean addSignature , int owner , String defaultDimension , final MapSaver saver ) { try { final MapSaverHandler handler = new MapSaverHandler ( ) ; handler . header . setVersion ( Constants . Maps . V ) ; Json json = new Json ( ) ; final Map defaultMap ; { Map d = Map . Get ( defaultDimension ) ; if ( d == null ) { for ( Map map : Map . SafeAll ( ) ) { if ( ! dimensions . contains ( map . getDimension ( ) ) ) { continue ; } d = map ; break ; } if ( d == null ) { return null ; } } defaultMap = d ; } saver . postpone ( ( ) -> { StringWriter stringWriter = new StringWriter ( ) ; { BrainOut . R . tag ( json ) ; json . setWriter ( stringWriter ) ; json . writeArrayStart ( ) ; ActiveFilterComponentData filter = defaultMap . getComponents ( ) . getComponent ( ActiveFilterComponentData . class ) ; if ( filter == null || filter . filters ( owner ) ) { json . writeObjectStart ( ) ; defaultMap . write ( json , componentWriter , owner ) ; json . writeObjectEnd ( ) ; } json . writeArrayEnd ( ) ; } String dataDefault = stringWriter . toString ( ) ; if ( addSignature ) { handler . verify = HashUtils . Verify ( ServerConstants . Maps . MAP_KEY , dataDefault . getBytes ( ) ) ; if ( handler . verify == null ) { throw new RuntimeException ( "No verify!" ) ; } } stringWriter . flush ( ) ; handler . compressedDefault = Compressor . Compress ( dataDefault ) ; handler . header . setBodySize ( handler . compressedDefault . length ) ; } ) ; MapSerializer . MapHeader header = handler . header ; Queue < String > extensionNames = new Queue < > ( ) ; Queue < String > mapExtensionNames = new Queue < > ( ) ; handler . offset = 0 ; ObjectMap < String , byte [ ] > mapExtensions = new ObjectMap < > ( ) ; for ( String d : dimensions ) { final String dimension = d ; if ( dimension . equals ( defaultMap . getDimension ( ) ) ) continue ; saver . postpone ( ( ) -> { Map map = Map . Get ( dimension ) ; if ( map == null ) return ; ActiveFilterComponentData filter = map . getComponents ( ) . getComponent ( ActiveFilterComponentData . class ) ; if ( filter != null && ! filter . filters ( owner ) ) return ; StringWriter extWriter = new StringWriter ( ) ; json . setWriter ( extWriter ) ; json . writeObjectStart ( ) ; map . write ( json , componentWriter , owner ) ; json . writeObjectEnd ( ) ; byte [ ] ex = Compressor . Compress ( extWriter . toString ( ) ) ; extWriter . flush ( ) ; if ( ex != null ) { header . addExtension ( dimension , handler . offset , ex . length , true ) ; mapExtensions . put ( dimension , ex ) ; handler . offset += ex . length ; mapExtensionNames . addLast ( dimension ) ; } } ) ; } saver . postpone ( ( ) -> { for ( ObjectMap . Entry < String , byte [ ] > entry : defaultMap . getExtensions ( ) ) { header . addExtension ( entry . key , handler . offset , entry . value . length ) ; handler . offset += entry . value . length ; extensionNames . addLast ( entry . key ) ; } } ) ; return ( ) -> { String headerJson = new Json ( ) . toJson ( header ) ; byte [ ] compressedHeader = Compressor . Compress ( headerJson ) ; if ( compressedHeader == null ) { return null ; } ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; try { if ( handler . verify != null ) { os . write ( handler . verify ) ; } os . write ( Constants . Maps . MAGIC . getBytes ( ) ) ; byte [ ] headerLength = ByteBuffer . allocate ( 4 ) . putInt ( compressedHeader . length ) . array ( ) ; os . write ( headerLength ) ; os . write ( compressedHeader ) ; os . write ( handler . compressedDefault ) ; for ( String extName : mapExtensionNames ) { byte [ ] ex = mapExtensions . get ( extName ) ; os . write ( ex ) ; } for ( String extName : extensionNames ) { byte [ ] ex = defaultMap . getExtension ( extName ) ; os . write ( ex ) ; } BrainOut . ScheduleGC ( ) ; } catch ( IOException e ) { } handler . compressedDefault = null ; handler . header . getExtensions ( ) . clear ( ) ; handler . header = null ; mapExtensions . clear ( ) ; extensionNames . clear ( ) ; mapExtensionNames . clear ( ) ; byte [ ] out = os . toByteArray ( ) ; os . reset ( ) ; return out ; } ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ;
onSave: public boolean onSave ( Object entity , Object id , Object [ ] state , String [ ] propertyNames , Type [ ] types ) { debug ( "[onSave]" ) ; return getAuditInterceptor ( ) . onSave ( auditMap , entity , id , state , propertyNames , types ) ;
getObjectCount: public static int getObjectCount ( ) { return objCount ;
computeAxis: public void computeAxis ( float min , float max , boolean inverted ) { if ( mViewPortHandler != null && mViewPortHandler . contentWidth ( ) > 10 && ! mViewPortHandler . isFullyZoomedOutY ( ) ) { MPPointD p1 = mTrans . getValuesByTouchPoint ( mViewPortHandler . contentLeft ( ) , mViewPortHandler . contentTop ( ) ) ; MPPointD p2 = mTrans . getValuesByTouchPoint ( mViewPortHandler . contentLeft ( ) , mViewPortHandler . contentBottom ( ) ) ; if ( ! inverted ) { min = ( float ) p2 . y ; max = ( float ) p1 . y ; } else { min = ( float ) p1 . y ; max = ( float ) p2 . y ; } MPPointD . recycleInstance ( p1 ) ; MPPointD . recycleInstance ( p2 ) ; } computeAxisValues ( min , max ) ;
reset: public void reset ( ) { super . reset ( ) ; for ( int i = 0 ; i < keyPressed . length ; i ++ ) { keyPressed [ i ] = false ; } updateMoves ( true ) ;
removeAccount: public void removeAccount ( ) { removeAccount ( currentEnvironment ) ;
MonthDay: public static String MonthDay ( String time ) { SimpleDateFormat sdr = new SimpleDateFormat ( "MM/dd" ) ; int i = Integer . parseInt ( time ) ; String times = sdr . format ( new Date ( i * 1000L ) ) ; return times ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
setRegisterApiCrudController: public void setRegisterApiCrudController ( boolean registerApiCrudController ) { this . registerApiCrudController = registerApiCrudController ;
setBlendFunction: public void setBlendFunction ( int srcFunc , int dstFunc ) { setBlendFunctionSeparate ( srcFunc , dstFunc , srcFunc , dstFunc ) ;
size: public static long size ( String filename ) throws IOException { return Files . size ( Paths . get ( filename ) ) ;
clearContents: private void clearContents ( ) { contents . clearChildren ( ) ; if ( loadingBlock != null )
calcMinMax: No method body
testCreateOrUpdateCustomDataForKey: public void testCreateOrUpdateCustomDataForKey ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductVariantCreateOrUpdateCustomDataForKeyRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . productVariants ( ) . createOrUpdateCustomDataForKey ( Identifier . fromId ( 1 ) , "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductVariantCreateOrUpdateCustomDataForKeyResponse.json" ) ; assertThatJson ( expectedResponseJson )
getDimensionId: public int getDimensionId ( ) { return Map . GetDimensionId ( dimension ) ;
getX: public float getX ( ) { return super . getX ( ) + MathUtils . cosDeg ( getFlippedAngle ( ) ) * getLength ( ) ;
getSuitableDimensions: public Set < String > getSuitableDimensions ( Client client ) { GameMode gameMode = getGameMode ( ) ; if ( gameMode == null ) { Set < String > d = new LinkedHashSet < > ( ) ; for ( ObjectMap . Entry < String , ServerMap > entry : Map . SafeAll ( ServerMap . class ) ) { if ( client instanceof PlayerClient ) { if ( entry . value . isPersonalRequestOnly ( ) && ! entry . value . suitableForPersonalRequestFor ( ( ( PlayerClient ) client ) . getAccount ( ) ) ) { continue ; } } d . add ( entry . value . getDimension ( ) ) ; } return d ; } ServerRealization serverRealization = ( ( ServerRealization ) gameMode . getRealization ( ) ) ; return serverRealization . getSuitableDimensions ( client ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case destroy : { destroy ( ( ( DestroyEvent ) event ) ) ; break ; } } return false ;
main: public static void main ( String [ ] args ) throws IOException { printCode ( SpringBootBanner . class . getName ( ) , true ) ;
send: public void send ( List < ReturnItem > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . except ( Arrays . asList ( "companyId" ) ) ; Map < String , Object > headers = new HashMap < String , Object > ( ) ; headers . put ( "X-Company-Id" , options . get ( "companyId" ) ) ; this . request ( "post" , this . resolvePath ( "/fulfillment/return-items" ) , query , headers , null , model ) ;
getLabel: No method body
getHookSlot: public Slot getHookSlot ( ) { return hookSlot ;
contentProperties: public Collection < String > contentProperties ( ) { return contentProperties ;
sortBalance: public void sortBalance ( ) { autobalance . sortRanked ( ) ;
requestData: private void requestData ( ) { if ( ! isClickable ) {
show: public void show ( final View view ) { if ( mBasePopWindow == null ) {
getRunners: public List < SpringApplicationRunListener > getRunners ( ) { List < SpringApplicationRunListener > result = runners . stream ( ) . sorted ( Comparator . comparingInt ( AbstractRunner :: getRank ) . reversed ( ) ) . collect ( Collectors . toList ( ) ) ; logger . info ( "Now register these runner in ordered: {}." , result ) ; return result ;
passwordRecoverForm: public Object passwordRecoverForm ( ) { debug ( "[passwordRecoverForm]" ) ; ModelAndView mav = new ModelAndView ( "password-recovery::password-recovery-form" ) ; return mav ;
logRequest: private void logRequest ( Request request ) { Headers headers = request . headers ( ) ; if ( headers != null && headers . size ( ) > 0 ) { StringBuilder sb = new StringBuilder ( ) ; int headerSize = headers . size ( ) ; for ( int i = 0 ; i < headerSize ; i ++ ) { sb . append ( headers . name ( i ) + " = " + headers . value ( i ) + "," ) ; } sb . delete ( sb . length ( ) - 1 , sb . length ( ) ) ; LogUtils . e ( TAG , "| RequestMethod：" + request . method ( ) ) ; LogUtils . e ( TAG , "| RequestHeader：{" + sb . toString ( ) + "}" ) ; } String requestUrl = request . url ( ) . toString ( ) ; LogUtils . e ( TAG , "| RequestUrl：" + requestUrl ) ; RequestBody requestBody = request . body ( ) ; if ( requestBody != null ) {
received: public boolean received ( PongMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { lastPong = System . currentTimeMillis ( ) ; lastPongNanoTime = System . nanoTime ( ) ; lastPongC = msg . c ; if ( firstPongC == 0 ) { firstPongNanoTime = System . nanoTime ( ) ; firstPongC = msg . c ; } long time = System . currentTimeMillis ( ) - msg . timeStamp ; if ( time > 0 ) { pingMeasures [ currentPingMeasure ] = time ; currentPingMeasure ++ ; if ( currentPingMeasure >= pingMeasures . length ) { currentPingMeasure = 0 ; this . ping = 0 ; for ( long l : pingMeasures ) { this . ping += l ; } this . ping /= pingMeasures . length ; } if ( Log . DEBUG ) Log . debug ( "Client " + getName ( ) + " ping: " + getPing ( ) ) ; } else { this . ping = 0 ; } } ) ; return true ;
switchConsumable: public ConsumableContent switchConsumable ( Class classOf ) { return switchConsumable ( null , classOf ) ;
isCutterEnabled: public boolean isCutterEnabled ( ) { return cutterEnabled ;
hasUpdate: public boolean hasUpdate ( ) { return BrainOutClient . ClientSett . isBackgroundEffectsEnabled ( ) ;
update: public void update ( InstrumentAnimationStates states ) { animations . putAll ( states . animations ) ;
write: public void write ( JsonWriter out , File value ) throws IOException { if ( value == null ) { out . nullValue ( ) ; return ; } out . value ( value . toString ( ) ) ;
autoOpenShopOnSpawn: public boolean autoOpenShopOnSpawn ( ) { return false ;
init: public void init ( ) { super . init ( ) ; updateKeyCodes ( ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . settingsUpdated , event ->
createWorkflow: public SingleWorkflowResponse createWorkflow ( final WorkflowRequest request ) throws IOException , NovuNetworkException { try {
removeParticle: private void removeParticle ( ) { if ( particle != null )
draw: public String draw ( ) { return "standard curve" ;
selected: public void selected ( String region ) { property . data = region ;
init: private Event init ( CardMessage msg ) { this . msg = msg ; return this ;
render: public void render ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ; super . render ( ) ;
logException: public static void logException ( @ Nullable Throwable t ) { log ( "Exception" , "" , t ) ;
runCommandToString: public String runCommandToString ( String command ) { return "" ;
setId: public Long setId ( Long id ) { this . id = id ; return id ;
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( myClan . getStats ( ) . get ( Constants . User . NUCLEAR_MATERIAL , 0.0f ) < getParticipatePrice ( ) ) { Menu . playSound ( MenuSound . denied ) ; return ; } Menu . playSound ( MenuSound . select ) ; participateGroupEvent ( ) ;
getMonthOfYear: public Integer getMonthOfYear ( ) { return monthOfYear ;
test_getNotificationsStats: public void test_getNotificationsStats ( ) throws IOException , NovuNetworkException , InterruptedException { NotificationStatsResponse notificationsResponse = new NotificationStatsResponse ( ) ; NotificationStats notificationStats = new NotificationStats ( ) ; notificationStats . setWeeklySent ( 20L ) ; notificationStats . setMonthlySent ( 200L ) ; notificationsResponse . setData ( notificationStats ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( notificationsResponse ) ) ) ; NotificationStatsResponse response = notificationHandler . getNotificationsStats ( ) ; assertNotNull ( response ) ; final RecordedRequest recordedRequest = mockWebServer . takeRequest ( ) ; assertEquals ( "/notifications/stats" , recordedRequest . getPath ( ) ) ; assertEquals ( "GET" , recordedRequest . getMethod ( ) ) ; assertEquals ( notificationsResponse , response ) ;
setN: public void setN ( final Integer n ) { this . n = n ;
setSubRenderers: public void setSubRenderers ( List < DataRenderer > renderers ) { this . mRenderers = renderers ;
run: public void run ( ) { route = payment . getHtlcs ( 0 ) . getRoute ( ) ; paymentHash = payment . getPaymentHash ( ) ; toNodeAddress = resp . getDestination ( ) ; if ( mAssetId == 0 ) { payAmount = resp . getAmtMsat ( ) ; } else { payAmount = resp . getAmount ( ) ; } feeSats = payAmount / 10000 ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_two ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_one ) . setVisibility ( View . GONE ) ; mLoadingDialog . dismiss ( ) ; showStepTwo ( ) ; deletePaymentProbe ( payment . getPaymentHash ( ) ) ;
setLastname: public void setLastname ( String lastname ) { this . lastname = lastname ;
getSteamMass: public double getSteamMass ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getSteamMass'" ) ;
getMaxScaleY: public float getMaxScaleY ( ) { return mMaxScaleY ;
setHidden: public void setHidden ( boolean hidden ) { this . hidden = hidden ; }
setRequestId: public void setRequestId ( String requestId ) { this . requestId = requestId ;
init: public void init ( final InitCallback done ) { if ( BrainOutServer . Controller . getMapSource ( ) == null ) { throw new RuntimeException ( "Bad map source" ) ; } BrainOutServer . PackageMgr . loadPackages ( ( ) -> packagesLoaded ( done ) ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { start2BActionPerformed ( evt ) ;
getID: public ID getID ( ) { return ID . activeChangeDimension ;
sendMoveEvent: private void sendMoveEvent ( int screenX , int screenY ) { ClientMap . getMouseScale ( screenX - touchPos . x , screenY - touchPos . y , pointPos ) ; pointPos . y = - pointPos . y ; sendEvent ( GameControllerEvent . obtain ( GameControllerEvent . Action . move , pointPos ) ) ; touchPos . set ( screenX , screenY ) ;
search: No method body
getRequiredWritePrivilege: public String getRequiredWritePrivilege ( ) { return null ;
setEmbeddable: public void setEmbeddable ( boolean embeddable ) { this . embeddable = embeddable ;
updateStats: protected void updateStats ( ) { clear ( ) ; switch ( getGameMode ( ) . getPhase ( ) ) { case warmUp : { tookPartInWarmUp = true ; break ; } } if ( topStats != null ) { switch ( getGameMode ( ) . getPhase ( ) ) { case warmUp : { Table counter = new Table ( ) ; Image notice = new Image ( BrainOutClient . getRegion ( "label-warmup" ) ) ; counter . add ( notice ) . padBottom ( - 72 ) . row ( ) ; Label title = new Label ( L . get ( "MENU_WARMUP" ) , BrainOutClient . Skin , "title-small" ) ; title . setAlignment ( Align . left ) ; counter . add ( title ) . padBottom ( 16 ) . row ( ) ; Notify time = new Notify ( String . valueOf ( ( int ) getGameMode ( ) . getTimer ( ) ) , true , 0 ) ; time . addAction ( Actions . repeat ( RepeatAction . FOREVER , Actions . sequence ( Actions . delay ( 1.0f ) , Actions . run ( ( ) -> { float timer = getGameMode ( ) . getTimer ( ) ; time . getTitle ( ) . setText ( String . valueOf ( ( int ) timer ) ) ; if ( timer <= 10 ) { Menu . playSound ( Menu . MenuSound . character ) ; } } ) ) ) ) ; counter . add ( time ) . row ( ) ; topStats . add ( counter ) . row ( ) ; break ; } } } Table points = new Table ( ) ; CSGame game = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( game != null ) { for ( Map map : Map . All ( ) ) { for ( ActiveData entry : map . getActivesForTag ( Constants . ActiveTags . SPAWNABLE , false ) ) { if ( entry instanceof FlagData ) { FlagData flagData = ( ( FlagData ) entry ) ; icons . add ( new FlagIcon ( flagData ) ) ; } } } } icons . sort ( ( o1 , o2 ) -> o1 . getFlagData ( ) . getX ( ) > o2 . getFlagData ( ) . getX ( ) ? 1 : - 1 ) ; for ( FlagIcon icon : icons ) { points . add ( new BorderActor ( icon ) ) ; } renderTimeLeft ( points ) ; if ( stats != null )
render: public void render ( Data from , Table to ) { Label valueLabel = new Label ( L . get ( suffix ) , BrainOutClient . Skin , "title-small" ) ; valueLabel . setAlignment ( Align . right ) ; if ( this . icon != null ) { TextureAtlas . AtlasRegion region = BrainOutClient . getRegion ( this . icon ) ; if ( region != null ) { Image icon = new Image ( region ) ; icon . setScaling ( Scaling . fit ) ; to . add ( icon ) . maxHeight ( 16 ) . expandX ( ) . right ( ) . padRight ( - 8 ) ; } } to . add ( valueLabel ) . right ( ) ;
getStartColor: public int getStartColor ( ) { return getGradientColors ( ) [ 0 ] ;
a: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem7ActionPerformed ( evt ) ;
show: public void show ( String qrCodeCotent ) { if ( mAlertDialog == null ) { mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme ) . setContentView ( R . layout . layout_dialog_qr_code ) . setAnimation ( R . style . popup_anim_style ) . fullWidth ( ) . fullHeight ( ) . create ( ) ; } ImageView qrCodeIv = mAlertDialog . findViewById ( R . id . iv_qrcode ) ; Bitmap mQRBitmap = CodeUtils . createQRCode ( qrCodeCotent , DisplayUtil . dp2px ( mContext , 250 ) ) ; qrCodeIv . setImageBitmap ( mQRBitmap ) ; mAlertDialog . findViewById ( R . id . layout_close ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; } } ) ; if ( mAlertDialog . isShowing ( ) ) { mAlertDialog . dismiss ( ) ; } mAlertDialog . show ( ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
contains: void contains ( ) { assertEquals ( 0 , l . size ( ) ) ; l . add ( "nicola" ) ; assertEquals ( 1 , l . size ( ) ) ; assertTrue ( l . contains ( "nicola" ) ) ; assertFalse ( l . contains ( "marzia" ) ) ;
increaseAttempt: public void increaseAttempt ( ) { this . attempts ++ ;
computeTemplateResource: protected ITemplateResource computeTemplateResource ( IEngineConfiguration configuration , String ownerTemplate , String template , String resourceName , String characterEncoding , Map < String , Object > templateResolutionAttributes ) { trace ( "[computeTemplateResource] ownerTemplate {} template {} resource {}" , ownerTemplate , template , resourceName ) ; if ( StringUtils . startsWith ( template , frontendResourceTemplateNamePrefix ) ) { TenantResolver . TenantedResource tenantedResource = TenantResolver . getTenantedResource ( ) ; FilteredTemplatePath filteredTemplatePath = pathFilteringProcessor . processTemplatePath ( template , resourceName , tenantedResource . accessLevel ) ; boolean isResourceTesting = ( isHttpRequest ( ) && request . getParameter ( URLConstants . RESOURCE ) != null ) ; if ( isResourceTesting ) { return new StringTemplateResource ( getResourceContent ( filteredTemplatePath . getFrontendResourceEntryName ( ) , filteredTemplatePath . getAccessLevel ( ) , tenantedResource . organizationId ) ) ; } FrontendResource . AccessLevel finalAccessLevel = filteredTemplatePath . getAccessLevel ( ) ; List < Object [ ] > entries = queryExecutor . runEntityManagerOperationInTransaction ( em -> em . createQuery ( "select c, case  " + "when c.accessLevel = 'PUBLIC' and c.organizationId is not null then 1 " + "when c.accessLevel = 'PUBLIC' and c.organizationId is null then 2 " + "when c.accessLevel = 'GLOBAL' and c.organizationId is not null then 1 " + "when c.accessLevel = 'GLOBAL' and c.organizationId is null then 2 " + "when c.accessLevel = 'ORGANIZATION' and c.organizationId is not null then 1 " + "when c.accessLevel = 'ORGANIZATION' and c.organizationId is null then 2 " + "when c.accessLevel = 'GLOBAL' and 'ORGANIZATION' = :p3 and c.organizationId is not null then 3 " + "when c.accessLevel = 'GLOBAL' and 'ORGANIZATION' = :p3 and c.organizationId is null then 4 " + "else 10 end as priority " + "from FrontendResource c " + "where " + "c.name = :p1 and " + "(cast (c.accessLevel as text) = :p3 or (cast (c.accessLevel as text) = 'GLOBAL' and 'ORGANIZATION' = :p3)) and " + "(c.organizationId = :p2 OR c.organizationId is NULL) order by priority limit 1" , Object [ ] . class ) . setParameter ( "p1" , filteredTemplatePath . getFrontendResourceEntryName ( ) ) . setParameter ( "p2" , tenantedResource . organizationId ) . setParameter ( "p3" , finalAccessLevel . toString ( ) ) . getResultList ( ) ) ; FrontendResource entry = entries == null || entries . isEmpty ( ) ? null : ( FrontendResource ) entries . get ( 0 ) [ 0 ] ; if ( entry == null ) { entry = ( FrontendResource ) classpathComponentImportService . loadResourceFromFile ( FRONTEND_RESOURCE_ , filteredTemplatePath . getAccessLevel ( ) , tenantedResource . organizationId , filteredTemplatePath . getFrontendResourceEntryName ( ) ) ; if ( entry == null ) { entry = ( FrontendResource ) classpathComponentImportService . loadResourceFromFile ( UI_COMPONENT_ , filteredTemplatePath . getAccessLevel ( ) , tenantedResource . organizationId , filteredTemplatePath . getFrontendResourceEntryName ( ) ) ; if ( entry == null && filteredTemplatePath . getAccessLevel ( ) . equals ( FrontendResource . AccessLevel . ORGANIZATION ) ) { entry = ( FrontendResource ) classpathComponentImportService . loadResourceFromFile ( UI_COMPONENT_ , FrontendResource . AccessLevel . GLOBAL , tenantedResource . organizationId , filteredTemplatePath . getFrontendResourceEntryName ( ) ) ; } } if ( entry == null ) { entry = createEntry ( filteredTemplatePath . getFrontendResourceEntryName ( ) , filteredTemplatePath . getAccessLevel ( ) , tenantedResource . organizationId ) ; if ( entry == null && filteredTemplatePath . getAccessLevel ( ) . equals ( FrontendResource . AccessLevel . ORGANIZATION ) ) { entry = createEntry ( filteredTemplatePath . getFrontendResourceEntryName ( ) , FrontendResource . AccessLevel . GLOBAL , tenantedResource . organizationId ) ; } } if ( entry == null ) { return getErrorTemplate ( configuration , ownerTemplate , template , characterEncoding , templateResolutionAttributes ) ; } } else if ( frontendResourceLoadAlwaysFromResources ) { entry . setContent ( getContentOrNull ( entry . getType ( ) , filteredTemplatePath . getFrontendResourceEntryName ( ) , filteredTemplatePath . getAccessLevel ( ) , tenantedResource . organizationId ) ) ; } else if ( not ( entry . isContentExists ( ) ) ) { entry = fillFrontendResourceEntryContentFromResource ( entry , filteredTemplatePath . getFrontendResourceEntryName ( ) , filteredTemplatePath . getAccessLevel ( ) , tenantedResource . organizationId ) ; } boolean isDraftTesting = ( isHttpRequest ( ) && request . getParameter ( URLConstants . DRAFT ) != null ) ; String content = entry . isDraft ( ) && isDraftTesting ? entry . getDraftContent ( ) : entry . getContent ( ) ; return new StringTemplateResource ( content ) ; } return super . computeTemplateResource ( configuration , ownerTemplate ,
signOutputRaw: public Single < signrpc . SignerOuterClass . SignResp > signOutputRaw ( signrpc . SignerOuterClass . SignReq request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . signOutputRaw ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
getRinging: public List < VoiceState > getRinging ( ) { return null ;
setReadPrivilege: public void setReadPrivilege ( String readPrivilege ) { this . readPrivilege = readPrivilege ;
update: public void update ( ) { controls . update ( ) ; for ( ObjectMap . Entry < String , GamePadKeyProperties > entry : gamePadControls )
init: public void init ( ) { if ( Gdx . audio == null ) return ; try { this . player = Gdx . audio . newAudioDevice ( SAMPLE_RATE , true ) ; this . recorder = Gdx . audio . newAudioRecorder ( SAMPLE_RATE , true ) ; } catch ( GdxRuntimeException | NullPointerException e ) { return ; } updateVolume ( ) ; this . buffer = new short [ SAMPLE_LENGTH ] ; working = true ; this . streamer = new Thread ( ( ) -> { int cnt = 0 ; while ( working ) { if ( ! streaming ) { try { Thread . sleep ( SEND_BURST ) ; continue ; } catch ( InterruptedException e ) { working = false ; } } cnt = 0 ; while ( streaming ) { recorder . read ( buffer , 0 , SAMPLE_LENGTH ) ; if ( sendCallback != null ) sendCallback . sendVoiceData ( buffer , cnt % 4 == 0 ) ; cnt ++ ; } } } ) ; this . streamer . start ( ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . settingsUpdated , this ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . gameController , this ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . simple , this ) ;
getDatabaseValue: default String getDatabaseValue ( ) { return BB_OPEN + name ( ) + BB_CLOSE ;
onRefreshing: public void onRefreshing ( ) { mRefreshDesc . setText ( R . string . text_refreshing ) ; mRefreshIcon . startAnimation ( mRefreshAnimation ) ;
getItemViewType: public int getItemViewType ( int position ) { if ( mMultiTypeSupport != null ) { return mMultiTypeSupport . getLayoutId ( mData . get ( position ) , position ) ; } return super . getItemViewType ( position ) ;
setColor: public void setColor ( float r , float g , float b , float a ) { light . set ( r , g , b , a ) ; lightPacked = light . toFloatBits ( ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
toMB: public static String toMB ( long byteLen ) { double mb = byteLen / 1048576d ; return String . format ( Locale . US , "%.2f MB" , mb ) ;
getTaskActionMatches: public boolean getTaskActionMatches ( String action ) { return action . equals ( weapon . getKillsStat ( ) ) ;
consecutiveSideEffect: No method body
hasProgress: public boolean hasProgress ( ) { return true ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterTemp10ActionPerformed ( evt ) ;
webhookSubscriptions: public WebhookSubscriptionService webhookSubscriptions ( ) { WebhookSubscriptionService service = this . getService ( "com.scayle.adminapi.service.WebhookSubscriptionService" ) ; return service ;
setRedirectUrl: public void setRedirectUrl ( String redirectUrl ) { this . redirectUrl = redirectUrl ;
add: public static String add ( String v1 , String v2 , int scale ) { if ( scale < 0 ) { throw new IllegalArgumentException ( "保留的小数位数必须大于零" ) ; } BigDecimal b1 = new BigDecimal ( v1 ) ; BigDecimal b2 = new BigDecimal ( v2 ) ; return b1 . add ( b2 ) . setScale ( scale , BigDecimal . ROUND_HALF_UP ) . toString ( ) ;
buildConnect: private synchronized void buildConnect ( ) { if ( ! NetWorkHelper . checkNetState ( mContext . get ( ) ) ) { setCurrentStatus ( WsStatus . DISCONNECTED ) ; return ; } switch ( getCurrentStatus ( ) ) {
serviceDiscoveryProtocolVersionToHeaderValue: static String serviceDiscoveryProtocolVersionToHeaderValue ( Discovery . ServiceDiscoveryProtocolVersion version ) { if ( Objects . requireNonNull ( version ) == Discovery . ServiceDiscoveryProtocolVersion . V1 ) { return "application/vnd.restate.endpointmanifest.v1+json" ; } throw new IllegalArgumentException (
validate: private void validate ( String encoded ) { String roomId = RoomIDEncryption . DecryptHumanReadable ( encoded ) ; if ( roomId == null ) { error ( ) ; return ; } join ( roomId ) ;
instantiate: protected Object instantiate ( Class clazz ) { try
prepareBarHighlight: protected void prepareBarHighlight ( float x , float y1 , float y2 , float barWidthHalf , Transformer trans ) { float top = x - barWidthHalf ; float bottom = x + barWidthHalf ; float left = y1 ; float right = y2 ; mBarRect . set ( left , top , right , bottom ) ; trans . rectToPixelPhaseHorizontal ( mBarRect , mAnimator . getPhaseY ( ) ) ;
done: public boolean done ( ) { return true ;
getTags: public int getTags ( ) { return WithTag . TAG ( Constants . ActiveTags . EXIT_DOOR ) ;
getChannelBackupPath: public static String getChannelBackupPath ( Context context ) { return getString ( SETTINGS , context , CHANNEL_BACKUP_PATH_ARRAY ) ;
init: private void init ( ) { mInputMethodManager = ( InputMethodManager ) mContext . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; View rootView = LayoutInflater . from ( mContext ) . inflate ( R . layout . layout_search_view , null ) ; mContentEt = rootView . findViewById ( R . id . et_search_view_content ) ; mContentEt . addTextChangedListener ( new MyTextWatcher ( ) ) ; LayoutParams params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ; rootView . setLayoutParams ( params ) ; addView ( rootView ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; kind = jsonData . getString ( "kind" ) ;
getProperties: private Array < EditorProperty > getProperties ( Inspectable inspectable ) { PropertiesGetter getter = new PropertiesGetter ( ) ; getter . act ( inspectable ) ; return getter . getProperties ( ) ;
getSelectedLabels: public List < SelectEntity > getSelectedLabels ( ) { List < SelectEntity > resultList = new ArrayList < > ( ) ; for ( SelectEntity entity : mLabelsList ) { if ( entity . isSelected ( ) ) { resultList . add ( entity ) ; } } return resultList ;
getWorkflowOverrideResponse: private WorkflowOverrideResponse getWorkflowOverrideResponse ( ) { WorkflowOverrideResponse workflowOverrideResponse = new WorkflowOverrideResponse ( ) ; workflowOverrideResponse . setData ( getWorkflowOverride ( ) ) ; return workflowOverrideResponse ;
getMonthMoney: public String getMonthMoney ( ) { return monthMoney ;
findByGoogleId: No method body
updateWorkflowStatus: public SingleWorkflowResponse updateWorkflowStatus ( final String workflowId , final UpdateWorkflowStatusRequest request ) throws IOException , NovuNetworkException { try {
update: public AttributeGroup update ( String attributeGroupName , AttributeGroup model ) throws ApiErrorException , ConnectionException { Class < AttributeGroup > responseModel = ( Class < AttributeGroup > ) ( Class < ? > ) AttributeGroup . class ; return this . request ( "put" , this . resolvePath ( "/attribute-groups/%s" , attributeGroupName ) , null , null , responseModel , model ) ;
done: No method body
main: public static void main ( String [ ] args ) { long x = 1 ; double i135Count = 0 ; double xe135Count = 0 ; double I135DECAY_MULTIPLIER = Math . pow ( 0.5 , 1.0 / ( 72000.0 * 6.57 ) ) ; double XE135DECAY_MULTIPLIER = Math . pow ( 0.5 , 1.0 / ( 72000.0 * 9.14 ) ) ; double xeThermalUtilizationModifier = 0 ; double neutronPopulation = 4800.0 / 1661.0 / 2.8898254064 * 29986861831.1868724665 ; while ( x < 200 ) { for ( int i = 0 ; i < 3600 * 20 ; i ++ ) { i135Count += 3001050 * neutronPopulation * 0.063 * 0.05 ; xe135Count += i135Count * ( 1 - I135DECAY_MULTIPLIER ) ; i135Count *= I135DECAY_MULTIPLIER ; xe135Count *= XE135DECAY_MULTIPLIER ; xe135Count -= 2000000e-24 * xe135Count * 1661 * neutronPopulation * 0.05 ; if ( xe135Count < 0 ) { xe135Count = 0 ; } if ( i135Count < 0 ) { i135Count = 0 ; } } xeThermalUtilizationModifier = 0.876167866 - ( 3508920.0 / ( 495929.0 + 3508920.0 + ( xe135Count * 1661 * 2000000e-24 ) ) ) ; System . out . println ( x + "h I135: " + i135Count + " Xe135: " + xe135Count + " NCount: " + neutronPopulation ) ; x ++ ; } neutronPopulation = 0 ; while ( x < 400 ) {
getState: public int getState ( ) { return state ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; for ( ObjectMap . Entry < String , Array < String > > entry : upgradeSlotNames )
isToday: public static boolean isToday ( String dateStr , String formatStr ) { try { if ( StringUtils . isEmpty ( formatStr ) ) { formatStr = YYYY_MM_DD ; } SimpleDateFormat format = new SimpleDateFormat ( formatStr , Locale . CHINA ) ; Date date = format . parse ( dateStr ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; Calendar nowCalendar = Calendar . getInstance ( ) ; nowCalendar . setTime ( new Date ( ) ) ; if ( calendar . get ( Calendar . YEAR ) == ( nowCalendar . get ( Calendar . YEAR ) ) ) { int diffDay = calendar . get ( Calendar . DAY_OF_YEAR ) - nowCalendar . get ( Calendar . DAY_OF_YEAR ) ; if ( diffDay == 0 ) { return true ; } } } catch ( ParseException e ) { e . printStackTrace ( ) ; } return false ;
findAllByUserId: No method body
canLaunchEffect: private boolean canLaunchEffect ( String dimension , float x , float y ) { ServerMap map = Map . Get ( dimension , ServerMap . class ) ; if ( map == null ) return false ; ChunkData chunk = map . getChunkAt ( ( int ) x , ( int ) y ) ; return chunk == null || ! chunk . hasFlag ( ChunkData . ChunkFlag . hideOthers ) ;
existsAny: No method body
getCategory: public Category getCategory ( ) { return category ;
coefficients: void coefficients ( ) { assertArrayEquals ( new double [ ] { 1 , 2 , 3 , 4 } , p . coefficients ( ) ) ;
getValueTypeface: public Typeface getValueTypeface ( ) { return mValueTypeface ;
getName: public String getName ( ) { return spawnName . getID ( ) ;
getY: public float getY ( ) { return 0 ;
zero: public final void zero ( ) { set ( 0.0f , 0.0f , 0.0f ) ;
getShadowColor: public int getShadowColor ( ) { return mShadowColor ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights )
setTotal: public void setTotal ( Long total ) { this . total = total ;
initChars: private void initChars ( ) { if ( ( info . instrument instanceof Weapon ) && ! ( ( Weapon ) info . instrument ) . isNoWeaponStats ( ) ) { Weapon weapon = ( ( Weapon ) info . instrument ) ; Weapon . WeaponProperties properties = weapon . getPrimaryProperties ( ) ; add ( "char-accuracy" , "CHAR_ACCURACY" , ( ) -> getProperty ( info , Constants . Properties . ACCURACY ) , new CharacteristicsPanel . ProgressView ( 0 , 100 ) ) ; add ( "char-recoil" , "CHAR_RECOIL" , ( ) -> getProperty ( info , Constants . Properties . RECOIL ) , new CharacteristicsPanel . ProgressView ( 0 , 100 ) ) ; if ( properties . getBullet ( ) != null ) { add ( "char-damage" , "CHAR_DAMAGE" , ( ) -> getProperty ( info , Constants . Properties . DAMAGE ) , new CharacteristicsPanel . ProgressView ( 0 , 100 ) ) ; } if ( ! properties . isPullRequired ( ) && ! properties . getShootModes ( ) . contains ( Weapon . ShootMode . singleCock , true ) ) { add ( "char-fire-rate" , "CHAR_FIRE_RATE" , ( ) -> getProperty ( info , Constants . Properties . FIRE_RATE ) * weapon . getPrimaryProperties ( ) . getBulletAtLaunch ( ) , new CharacteristicsPanel . SimpleView ( "CHAR_SUFFIX_RATE" ) ) ; } if ( getProperty ( info , Constants . Properties . RELOAD_TIME ) > 0.2 ) { add ( "char-reload-speed" , "CHAR_RELOAD_SPEED" , ( ) -> getProperty ( info , Constants . Properties . RELOAD_TIME ) , new CharacteristicsPanel . FloatView ( "CHAR_SUFFIX_SEC" ) ) ; } } ItemComponent item = info . instrument . getComponent ( ItemComponent . class ) ; if ( item != null && item . getWeight ( ) != 0 ) { add ( "char-weight" , "CHAR_WEIGHT" , item :: getWeight , new CharacteristicsPanel . SimpleView ( "CHAR_SUFFIX_KG" ) ) ; } if ( info . instrument instanceof Weapon ) { add ( "char-clip-size" , "CHAR_CLIP_SIZE" , ( ) -> getProperty ( info , Constants . Properties . CLIP_SIZE ) , new CharacteristicsPanel . SimpleView ( ) ) ; if ( info . instrument . getPrimaryProperties ( ) instanceof Weapon . WeaponProperties ) { Weapon . WeaponProperties weaponProperties = ( ( Weapon . WeaponProperties ) info . instrument . getPrimaryProperties ( ) ) ; Bullet bullet = BrainOutClient . ContentMgr . get ( weaponProperties . getBullet ( ) , Bullet . class ) ; if ( bullet != null ) { IconComponent iconComponent = bullet . getComponent ( IconComponent . class ) ; if ( iconComponent != null ) { add ( "char-cartridge" , "CHAR_CARTRIDGE" , ( ) -> 0 , new BulletView ( ) ) ; } } } SecondaryWeaponSlotComponent sws = info . instrument . getComponent ( SecondaryWeaponSlotComponent . class ) ; if ( sws != null ) { Weapon . WeaponProperties weaponProperties = sws . getWeaponProperties ( ) ; Bullet bullet = BrainOutClient . ContentMgr . get ( weaponProperties . getBullet ( ) , Bullet . class ) ; if ( bullet != null ) { IconComponent iconComponent = bullet . getComponent ( IconComponent . class ) ; if ( iconComponent != null ) { add ( null , null , ( ) -> 0 , new IconOnlyView ( bullet . getTitle ( ) . get ( ) , iconComponent . getIconName ( "icon" , null ) ) ) ; } } } else { for ( ObjectMap . Entry < String , Upgrade > entry : info . upgrades ) { SecondaryWeaponSlotComponent swsc = entry . value . getComponent ( SecondaryWeaponSlotComponent . class ) ; if ( swsc != null ) { Weapon . WeaponProperties weaponProperties = swsc . getWeaponProperties ( ) ; Bullet bullet = BrainOutClient . ContentMgr . get ( weaponProperties . getBullet ( ) , Bullet . class ) ; if ( bullet != null ) { IconComponent iconComponent = bullet . getComponent ( IconComponent . class ) ; if ( iconComponent != null ) { add ( null , null , ( ) -> 0 , new IconOnlyView ( bullet . getTitle ( ) . get ( ) , iconComponent . getIconName ( "icon" , null ) ) ) ; } } break ; } } } } if ( ! BrainOutClient . ClientController . isFreePlay ( ) ) { DurabilityComponent dc = info . instrument . getComponentFrom ( DurabilityComponent . class ) ; if ( dc != null ) { add ( "char-wear-resistance" , "CHAR_WEAR_RESISTANCE" , ( ) -> getProperty ( info , Constants . Properties . WEAR_RESISTANCE ) , new CharacteristicsPanel . SimpleIconView ( "CHAR_SUFFIX_ROUNDS" , "char-durability" ) ) ; } if ( dc != null ) { add ( "char-durability" , "CHAR_DURABILITY" , ( ) -> ( float ) Math . ceil ( dc . getDurability ( BrainOutClient . ClientController . getUserProfile ( ) ) ) , new CharacteristicsPanel . NofNView ( dc . getDurability ( ) ) ) ; } } if ( quality != - 1 )
reverse: void reverse ( ) { Reverser r = new ReverserFast ( ) ; assertEquals ( "!dlroW olleH" , r . reverse ( "Hello World!" ) ) ;
shutdown: public static void shutdown ( ) { System . exit ( 0 ) ;
getItemId: public long getItemId ( int position ) { return position ;
run: public void run ( ) { if ( mWaitingDialog == null ) { mWaitingDialog = new WaitingDialog ( context ) ; } mWaitingDialog . showWaitingDialog ( mShowText ) ;
getHeaderUrl: public String getHeaderUrl ( ) { return headerUrl ;
eats: public String eats ( ) { return "grass" ;
getServerLocation: public String getServerLocation ( ) { return serverLocation ;
loadMaps: public Array < ServerMap > loadMaps ( ServerSettings . MapConditions settings , boolean init ) { Array < ServerMap > maps = BrainOutServer . Controller . loadMaps ( new ByteArrayInputStream ( this . map ) , true ) ; if ( maps != null ) { for ( ServerMap map : maps ) { map . setName ( "custom" ) ; map . setCustom ( "workshop-id" , mapId ) ; renderSpawns ( map ) ; } if ( init ) { for ( ServerMap map : maps ) { map . init ( ) ; } } } return maps ;
onClick: public void onClick ( View v ) { mLoadingDialog . show ( ) ; startNode ( ) ;
cancelSubscription: private void cancelSubscription ( ) { LOG . trace ( "Cancelling subscription" ) ; if ( this . outputSubscription != null ) {
run: public void run ( ) { MDC . put ( RequestIdHolder . PARAM_CRON_JOB_ID , RequestIdHolder . generate ( ) ) ; if ( executedScheduler . onMasterOnly && not ( ClusterHelper . isMaster ( ) ) ) { debug ( "[SchedulerTask] {}, not master, skipping." , executedScheduler . notificationMessage ( ) ) ; return ; } debug ( "[SchedulerTask] {}" , executedScheduler . notificationMessage ( ) ) ; if ( ! executedScheduler . isAsync ( ) ) {
measure: public double measure ( String item ) { return item . length ( ) ;
forceLoad: private boolean forceLoad ( ) { if ( weaponProperties . isAutoLoad ( ) ) { return true ; } GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode != null && gameMode . getRealization ( ) instanceof ServerRealization && ( ( ServerRealization ) gameMode . getRealization ( ) ) . forceWeaponAutoLoad ( ) ) { return true ; } return false ;
isSingleRequestAuth: public boolean isSingleRequestAuth ( ) { return isSingleRequestAuth ;
setWritePrivilege: public void setWritePrivilege ( String writePrivilege ) { this . writePrivilege = writePrivilege ;
usePromo: public void usePromo ( String promoCode ) { if ( BrainOut . OnlineEnabled ( ) )
updateResource: void updateResource ( ) throws Exception { assertNotNull ( updateDictParam , "updateDictParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . put ( "/dict/update" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( updateDictParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "更新字典接口测试成功:{}" , map . get ( "data" ) ) ;
onClick: public void onClick ( View v ) { rootView . findViewById ( R . id . lv_create_channel_step_one ) . setVisibility ( View . GONE ) ; rootView . findViewById ( R . id . lv_create_channel_step_two ) . setVisibility ( View . VISIBLE ) ; nodePubkey = localEdit . getText ( ) . toString ( ) ; showStepTwo ( rootView ) ;
addRUButton: private void addRUButton ( int amount ) { Button ru = new Button ( BrainOutClient . Skin , "button-notext" ) ; Table icon = new Table ( ) ; ContentImage . RenderStatImage ( "ru" , amount , icon ) ; ru . add ( icon ) . row ( ) ; ruAvailableLabel = new Label ( String . valueOf ( amount ) , BrainOutClient . Skin , "title-small" ) ; ruAvailableLabel . setAlignment ( Align . center ) ; ru . add ( ruAvailableLabel ) . expandX ( ) . fillX ( ) . row ( ) ; ru . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; addMoreRU ( ) ; } } ) ; ru . setBounds ( BrainOutClient . getWidth ( ) - 212 - 64 , BrainOutClient . getHeight ( ) - 84 , 192 , 64 ) ; Tooltip . RegisterStandardToolTip ( ru , L . get ( "MENU_MARKET_RU_BALANCE" ) , L . get ( "MENU_MARKET_RU_BALANCE_DESC" ) , this ) ; addActor ( ru ) ; Button ex = new Button ( BrainOutClient . Skin , "button-green" ) ; Image exIcon = new Image ( BrainOutClient . Skin , "icon-exchange-ru" ) ; exIcon . setScaling ( Scaling . none ) ; ex . add ( exIcon ) . expand ( ) . fill ( ) ; ex . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; addMoreRU ( ) ; } } ) ; ex . setBounds ( BrainOutClient . getWidth ( ) - 64 - 16 , BrainOutClient . getHeight ( ) - 84 , 64 , 64 ) ; addActor ( ex ) ;
deleteCustomData: public void deleteCustomData ( Integer brandId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/brands/%s/custom-data" , brandId ) , null , null , null ) ;
printIterable: void printIterable ( ) { assertEquals ( "1, 2, 3, " , IterableToString . iterableToString ( new ArrayList < > ( List . of ( 1 , 2 , 3 ) ) ) ) ; assertEquals ( "1, 2, 3, " , IterableToString . iterableToString ( new LinkedList < > ( List . of ( 1 , 2 , 3 ) ) ) ) ; assertEquals ( "a, b, c, " , IterableToString . iterableToString ( new ArrayDeque < > ( List . of ( "a" , "b" , "c" ) ) ) ) ; assertEquals ( "a, b, c, " , IterableToString . iterableToString ( new TreeSet < > ( Set . of ( "b" , "c" , "a" ) ) ) ) ;
setUsingSliceColorAsValueLineColor: public void setUsingSliceColorAsValueLineColor ( boolean enabled ) { setUseValueColorForLine ( enabled ) ;
getServiceOptions: public Object getServiceOptions ( ) { return options ;
getID: public ID getID ( ) { return ID . csGame ;
logError: protected void logError ( String log ) { if ( Log . ERROR ) Log . error ( log ) ;
run: public void run ( ) { while ( ! isInterrupted ( ) ) {
approve: public void approve ( int amount ) { ruAvailable = amount ; ruAvailableLabel . setText ( String . valueOf ( amount ) ) ; ruAvailableIcon . clear ( ) ; ContentImage . RenderStatImage ( "ru" , amount , ruAvailableIcon ) ; Menu . playSound ( MenuSound . itemSold ) ;
setPort: public void setPort ( Integer port ) { this . port = port ;
getWorldRotationX: public float getWorldRotationX ( ) { return atan2 ( c , a ) * radDeg ;
onResponse: public void onResponse ( byte [ ] bytes ) { LogUtils . e ( TAG , "------------------startOnSuccess------------------" ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
testSetPasswordHash: public void testSetPasswordHash ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/CustomerSetPasswordHashRequest.json" ) ; CustomerPasswordHash requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , CustomerPasswordHash . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . customers ( ) . setPasswordHash ( "acme" , "acme" , Identifier . fromId ( 1 ) , requestEntity , options ) ;
getSelectedSkin: public Skin getSelectedSkin ( ) { return info . skin ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
run: public Stream < Map < String , String > > run ( final I input ) { final Stream < Map < String , String > > documents ; try { documents = loadPdDocuments ( input ) . flatMap ( this :: createDocumentFromPdDocumentWrapper ) ; } catch ( final IOException ioException ) { throw new IllegalStateException ( "error loading pdf for input " + input , ioException ) ; } if ( parallel ) { return documents . parallel ( ) ; } return documents ;
setRefreshListener: public void setRefreshListener ( OnRefreshListener mRefreshListener ) { this . mRefreshListener = mRefreshListener ;
initContent: protected void initContent ( Table data ) { title = new Label ( this . text , BrainOutClient . Skin , "title-medium" ) ; title . setWrap ( true ) ; title . setAlignment ( Align . center ) ; data . add ( title ) . pad ( 16 ) . center ( ) . expand ( ) . fill ( ) . row ( ) ; url = new TextField ( "" , BrainOutClient . Skin , "edit-focused" ) ; data . add ( url ) . pad ( 20 ) . fillX ( ) . expandX ( ) . padLeft ( 64 ) . padRight ( 64 ) . height ( 35 ) . row ( ) ; setKeyboardFocus ( url ) ;
setTime: public void setTime ( float time ) { this . time = time ;
hello: public String hello ( String name ) { try { Thread . sleep ( 1000L ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } System . out . println ( "hello " + name ) ; return "hello " + name ;
getNonce: public static String getNonce ( UserProfile userProfile ) { return String . valueOf ( userProfile . getInt ( "nonce" , 0 ) ) ;
onLaunch: No method body
removeRecord: public void removeRecord ( ConsumableRecord record ) { removeRecord ( record , true ) ;
addGlobalOrgRole: public Object addGlobalOrgRole ( @ PathVariable ( ORGANIZATIONID ) Long organizationId , @ Valid GlobalOrgRoleForm globalOrgRoleForm ) { return globalOrgRole ( globalOrgRoleForm , organizationId )
received: public boolean received ( final MultipleBlocksMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; Block block = msg . block == null ? null : BrainOutServer . ContentMgr . get ( msg . block , Block . class ) ; int length = msg . x . length ; if ( msg . y . length != length ) return ; if ( false ) { Queue < MultipleBlocksMsg . Point > points = new Queue < > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int x = msg . x [ i ] ; int y = msg . y [ i ] ; points . addLast ( new MultipleBlocksMsg . Point ( x , y ) ) ; } BrainOutServer . Timer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { BrainOutServer . PostRunnable ( ( ) -> { int size = Math . min ( BATCH_SIZE , points . size ) ; for ( int i = 0 ; i < size ; i ++ ) { MultipleBlocksMsg . Point point = points . removeFirst ( ) ; setBlock ( map , point . getX ( ) , point . getY ( ) , block ) ; } if ( points . size == 0 ) cancel ( ) ; } ) ; } } , 0 , BATCH_PERIOD ) ; } else { for ( int i = 0 ; i < length ; i ++ ) { int x = msg . x [ i ] ; int y = msg . y [ i ] ; setBlock ( map , x , y , block ) ; } } } ) ; return true ;
weaponMagazineAction: public boolean weaponMagazineAction ( final WeaponMagazineActionMsg . Action action , final ConsumableRecord record , String slot , int magazineId ) { if ( playerData == null || record == null ) return false ; if ( isWounded ( ) ) return false ; final PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return false ; ServerMap map = playerData . getMap ( ServerMap . class ) ; if ( map == null ) return false ; ChunkData chunk = map . getChunkAt ( ( int ) playerData . getX ( ) , ( int ) playerData . getY ( ) ) ; boolean syncOthers = chunk == null || ! chunk . hasFlag ( ChunkData . ChunkFlag . hideOthers ) ; InstrumentData instrumentData = poc . getInstrument ( record . getId ( ) ) ; if ( instrumentData instanceof WeaponData ) { final WeaponData weaponData = ( ( WeaponData ) instrumentData ) ; ServerWeaponComponentData sw = weaponData . getComponent ( ServerWeaponComponentData . class ) ; if ( sw != null ) { BrainOutServer . PostRunnable ( ( ) -> { ServerWeaponComponentData . Slot wslot = sw . getSlot ( slot ) ; if ( wslot != null ) { switch ( action ) { case loadOne : { ConsumableRecord bullets = poc . getConsumableContainer ( ) . getConsumable ( wslot . getBullet ( ) ) ; int bulletsId = - 1 ; if ( bullets != null ) { bulletsId = bullets . getId ( ) ; } if ( wslot . loadMagazineBullet ( poc , magazineId ) ) { int weaponId = record . getId ( ) ; ammoLoading ( weaponId , magazineId , bulletsId , 1 ) ; if ( syncOthers ) { sendUDPExceptDistance ( generateMagazineActionMessage ( weaponData , action ) ) ; } } break ; } case unloadAll : { if ( wslot . unloadMagazineBullets ( poc , magazineId ) ) { consumablesUpdated ( ) ; if ( syncOthers ) { sendUDPExceptDistance ( generateMagazineActionMessage ( weaponData , action ) ) ; } } break ; } } } } ) ; } } return false ;
getEndTime: public long getEndTime ( ) { return endTime ;
populateFrom: public IntegrationSlackForm populateFrom ( IntegrationModuleOrganizationConfiguration entity ) { dto . setWebhookUrl ( entity . getSlackWebhookUrl ( ) ) ; return this ;
setLabelText: public void setLabelText ( String labelText ) { this . labelText = labelText ;
onCreate: protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ;
getCachedTexture: public TextureRegion getCachedTexture ( ) { return cachedTexture ;
generate: public static String generate ( ) { return formatter . format ( LocalDateTime . now ( ) ) + "-" + RandomStringUtils . randomAlphanumeric ( 8 ) ;
getVersion: public String getVersion ( ) { return version ;
getReturnAddress: public MerchantReturnAddress getReturnAddress ( Identifier merchantIdentifier , Integer merchantReturnAddressId ) throws ApiErrorException , ConnectionException { Class < MerchantReturnAddress > responseModel = ( Class < MerchantReturnAddress > ) ( Class < ? > ) MerchantReturnAddress . class ; return this . request ( "get" , this . resolvePath ( "/merchants/%s/return-addresses/%s" , merchantIdentifier , merchantReturnAddressId ) , null , null , responseModel ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { filter2InActionPerformed ( evt ) ;
isShowRelatedItemsText: public boolean isShowRelatedItemsText ( ) { return showRelatedItemsText ;
setDrawWeb: public void setDrawWeb ( boolean enabled ) { mDrawWeb = enabled ;
addJavascriptInterface: public void addJavascriptInterface ( Object htmlObject , String string ) { mWebView . addJavascriptInterface ( htmlObject , string ) ;
obtain: public static Event obtain ( int weaponId , int magazineId , int bulletsId , int ammoCount ) { AmmoLoadedEvent e = obtain ( AmmoLoadedEvent . class ) ; if ( e == null ) return null ; return e . init ( weaponId , magazineId , bulletsId , ammoCount ) ;
setEnabled: public boolean setEnabled ( boolean active ) { return false ;
loadContent: public void loadContent ( AssetManager assetManager ) { super . loadContent ( assetManager ) ; assetManager . load ( startFileName , Sound . class ) ; assetManager . load ( loopFileName , Sound . class ) ; assetManager . load ( stopFileName , Sound . class ) ;
canSpawn: public boolean canSpawn ( Spawnable spawnable , Team team ) { if ( spawnable instanceof FlagData ) { return false ; } return super . canSpawn ( spawnable , team ) ;
received: public boolean received ( final VoiceChatMsg msg ) { Gdx . app . postRunnable ( ( ) -> { ClientMap map = Map . Get ( msg . d , ClientMap . class ) ; float volume = 1 ; RemoteClient remoteClient = msg . id >= 0 ? BrainOutClient . ClientController . getRemoteClients ( ) . get ( msg . id ) : null ; ActiveData playerData = msg . object >= 0 && map != null ? map . getActiveData ( msg . object ) : null ; if ( BrainOutClient . ClientController . getMyRemoteClient ( ) == null ) return ; if ( remoteClient == null || remoteClient . getPartyId ( ) == null || ! remoteClient . getPartyId ( ) . equals ( BrainOutClient . ClientController . getMyRemoteClient ( ) . getPartyId ( ) ) ) { volume = msg . volume ; } Event ev = VoiceEvent . obtain ( remoteClient , playerData ) ; if ( ev != null ) { if ( playerData != null ) { BrainOutClient . EventMgr . sendEvent ( playerData , ev , false ) ; } BrainOutClient . EventMgr . sendEvent ( ev , false ) ; ev . free ( ) ; } BrainOutClient . Voice . playAudioData ( volume , msg . data ) ; } ) ; return true ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterTemp19ActionPerformed ( evt ) ;
decStuckIn: private boolean decStuckIn ( ) { if ( stuckIn == null ) return false ; int value = getStuckIn ( ) ; value -- ; stuckIn . set ( value ) ; return value <= 0 ;
getDefaultRingtoneUri: public static Uri getDefaultRingtoneUri ( Context context ) { return RingtoneManager . getActualDefaultRingtoneUri ( context , RingtoneManager . TYPE_NOTIFICATION ) ;
setGetAllPrivilege: public CRUDControllerConfiguration < D , E , F > setGetAllPrivilege ( PrivilegeBase getAllPrivilege ) { this . getAllPrivilege = getAllPrivilege ; return this ;
getID: public ID getID ( ) { return ID . activeAction ;
onRequestPermissionFailureWithAskNeverAgain: public void onRequestPermissionFailureWithAskNeverAgain ( List < String > permissions ) { LogUtils . e ( TAG , "扫码页面摄像头权限拒绝并且勾选不再提示" ) ;
received: public boolean received ( final QuestTaskProgress msg ) { Gdx . app . postRunnable ( ( ) -> { Quest q = BrainOutClient . ContentMgr . get ( msg . quest , Quest . class ) ; if ( q == null ) return ; Task task = q . getTasks ( ) . get ( msg . task ) ; if ( task == null ) return ; task . setProgress ( BrainOutClient . ClientController . getUserProfile ( ) , msg . progress ) ; } ) ; return true ;
error: public void error ( String reason ) { loading . pop ( ) ; failed . run ( ) ;
setFirstCurrency: private void setFirstCurrency ( String currencyCode , Double rate , String symbol ) { mFirstCurrency = new Currency ( currencyCode , rate , symbol ) ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . bottom ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamOutVOpen4ItemStateChanged ( evt ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
withOpenTelemetry: public RestateHttpEndpointBuilder withOpenTelemetry ( OpenTelemetry openTelemetry ) { this . openTelemetry = openTelemetry ; return this ;
setCronExpression: public void setCronExpression ( String cronExpression ) { this . cronExpression = cronExpression ;
findByName: No method body
makeSureIsSpawned: private void makeSureIsSpawned ( float dt ) { spawnTimer -= dt ; if ( spawnTimer > 0 ) return ; spawnTimer = spawnCheckTimer ( ) ; if ( isAlive ( ) ) return ; if ( BrainOutServer . Controller . isQueuedForSpawning ( this ) ) return ; GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode == null ) return ; ServerRealization serverRealization = ( ( ServerRealization ) gameMode . getRealization ( ) ) ; Array < Spawnable > spawnables = new Array < > ( ) ; for ( Map map : Map . All ( ) ) { if ( ! isMapOkayToSpawn ( map ) ) continue ; map . countActivesForTag ( Constants . ActiveTags . SPAWNABLE , activeData -> { if ( ! ( activeData instanceof Spawnable ) ) return false ; Spawnable asSpawnable = ( ( Spawnable ) activeData ) ; if ( ! asSpawnable . canSpawn ( getTeam ( ) ) ) return false ; spawnables . add ( asSpawnable ) ; return true ; } ) ; } if ( spawnables . size == 0 ) return ; Spawnable spawnable = serverRealization . chooseBotSpawnPoint ( spawnables ) ; if ( spawnable == null ) return ; setupShopCart ( ) ; setSpawnAt ( spawnable ) ; boolean extraWave = spawnable instanceof FlagData ; getServerController ( ) . respawn ( this , extraWave ) ; log ( "Respawning myself" ) ;
getConnection: public Connection getConnection ( ) { return connection ;
loadContent: public void loadContent ( AssetManager assetManager ) { super . loadContent ( assetManager ) ; assetManager . load ( fileName , Music . class ) ;
getYesterDate: public static String getYesterDate ( ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . add ( Calendar . DATE , - 1 ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "yyyy-MM-dd" ) ; String yestoday = sdf . format ( calendar . getTime ( ) ) ; return yestoday ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { off8ActionPerformed ( evt ) ;
primitiveOutput: public int primitiveOutput ( Context context ) { var client = PrimitiveTypesClient . fromContext ( context ) ; return client . primitiveOutput ( ) . await ( ) ;
getNumerator: public int getNumerator ( ) { return numerator ;
execute: public String execute ( String [ ] args , Client client ) { client . setName ( args [ 1 ] ) ; return "Done" ;
getVerifyCode: public void getVerifyCode ( String phone , String imageCode ) { this . mNeedCountdown = true ; if ( mHelper != null ) {
calcMinMax: No method body
onDraw: protected void onDraw ( Canvas canvas ) { int maxLeft = Math . max ( leftTopRadius , leftBottomRadius ) ; int maxRight = Math . max ( rightTopRadius , rightBottomRadius ) ; int minWidth = maxLeft + maxRight ; int maxTop = Math . max ( leftTopRadius , rightTopRadius ) ; int maxBottom = Math . max ( leftBottomRadius , rightBottomRadius ) ; int minHeight = maxTop + maxBottom ; if ( width >= minWidth && height > minHeight ) { mPath . reset ( ) ; mPath . moveTo ( leftTopRadius , 0 ) ; mPath . lineTo ( width - rightTopRadius , 0 ) ; mPath . quadTo ( width , 0 , width , rightTopRadius ) ; mPath . lineTo ( width , height - rightBottomRadius ) ; mPath . quadTo ( width , height , width - rightBottomRadius , height ) ; mPath . lineTo ( leftBottomRadius , height ) ; mPath . quadTo ( 0 , height , 0 , height - leftBottomRadius ) ; mPath . lineTo ( 0 , leftTopRadius ) ; mPath . quadTo ( 0 , 0 , leftTopRadius , 0 ) ; canvas . clipPath ( mPath ) ; } super . onDraw ( canvas ) ;
delete: public void delete ( Integer masterCategoryId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/master-categories/%s" , masterCategoryId ) , null , null , null ) ;
onActiveAdded: private void onActiveAdded ( final ActiveData activeData , final ActiveData . ComponentWriter componentWriter ) { getClients ( ) . foreach ( client ->
initChilds: protected void initChilds ( ) { if ( BrainOutClient . ClientSett . isLightsEnabled ( ) ) { int quality = BrainOutClient . ClientSett . getLightDiv ( ) ; try { lights = new RayHandler ( physicWorld , BrainOutClient . getWidth ( ) / quality , BrainOutClient . getHeight ( ) / quality ) ; lights . setAmbientLight ( ambientLight ) ; lights . setBlur ( BrainOutClient . ClientSett . hasSoftShadows ( ) ) ; lights . setShadows ( BrainOutClient . ClientSett . hasShadows ( ) ) ; } catch ( IllegalStateException e ) { } } super . initChilds ( ) ;
getBlock: public BlockData getBlock ( ) { return new SmokeBD ( this ) ;
getTags: No method body
updateSearchIndexes: public void updateSearchIndexes ( ) { for ( String s : SearchableRepositories . getSearchIndexUpdates ( ) ) { entityManager . createNativeQuery ( s ) . executeUpdate ( ) ; } for ( String s : SearchableRepositories . getSearchIndexUpdatesForDynamicEntities ( ) ) {
generateThirst: private void generateThirst ( ) { thirstTimer = fp . getContentComponent ( ) . getThirstTime ( ) ;
put: public int put ( ConsumableItem item , int amount , int quality , String tag , boolean checkDirection ) { putConsumable ( amount , item , quality ) ; return amount ;
setSmtpAuth: public void setSmtpAuth ( Boolean smtpAuth ) { this . smtpAuth = smtpAuth ;
showStepFailed: private void showStepFailed ( String message ) { TextView failedMessageTv = mAlertDialog . findViewById ( R . id . tv_failed_message ) ; failedMessageTv . setText ( message ) ; mAlertDialog . findViewById ( R . id . layout_scan ) . setOnClickListener ( new View . OnClickListener ( ) {
getRank: public int getRank ( ) { return rank ;
getX: public float getX ( ) { return absolutePosition . x ;
getFullName: public String getFullName ( ) { return fullName ;
getInstance: public static MonetaryUtil getInstance ( ) { if ( mInstance == null ) { mInstance = new MonetaryUtil ( ) ; } return mInstance ;
getID: public ID getID ( ) { return ID . setBlock ;
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . attributeGroups ( ) . delete ( "acme" , options ) ;
isActive: public boolean isActive ( ) { if ( ! ( getMenu ( ) . getCurrentMode ( ) instanceof ActivesEditorMode ) ) { return false ; } return ActivesEditorMode . getCurrentLayer ( ) == layer ;
getSelectColor: protected Color getSelectColor ( ) { return Annunciator . BLUEON_COLOR ;
getEndTime: public long getEndTime ( ) { return endTime ;
setVisible: public void setVisible ( boolean visible ) { mVisible = visible ;
load: public void load ( JsonValue jsonValue ) { getJsonLoader ( null ) . readValue ( Skin . class , jsonValue ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { cavit4ActionPerformed ( evt ) ;
getPathToYamlComponentFile: No method body
getCount: public int getCount ( ) { if ( mIndicators != null ) { return mIndicators . length ; } if ( mIndicatorsList != null ) { return mIndicatorsList . size ( ) ; } return 0 ;
getSelectValue: No method body
itemCount: private int itemCount ( ) { int itemsCount = 0 ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : itemData . getRecords ( ) . getData ( ) ) { ConsumableItem item = entry . value . getItem ( ) ; if ( item . isPrivate ( ) && item . getPrivate ( ) != BrainOutClient . ClientController . getMyId ( ) ) { continue ; } Content c = item . getContent ( ) ; { QuestOnlyComponent qc = c . getComponent ( QuestOnlyComponent . class ) ; if ( qc != null ) { GameMode gameMode = BrainOutClient . ClientController . getGameMode ( ) ; if ( gameMode != null && gameMode . getRealization ( ) instanceof ClientFreeRealization ) { ClientFreeRealization free = ( ( ClientFreeRealization ) gameMode . getRealization ( ) ) ; if ( ! free . isQuestActive ( qc . getQuest ( ) ) ) { continue ; } } } } itemsCount ++ ; } return itemsCount ;
getQuest: public Quest getQuest ( ) { if ( quest == null ) return null ; return quest . get ( ) ;
sendMessage: public boolean sendMessage ( String msg ) { return send ( msg ) ;
write: public void write ( Json json ) { json . writeValue ( "pow" , power ) ; json . writeValue ( "mov" , movement ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem3ActionPerformed ( evt ) ;
writeContent: private void writeContent ( AuditedObjectState aos , StringBuilder change ) { debug ( "[writeContent] {} {}" , aos , change ) ; if ( aos . getContent ( ) == null ) { return ; } change . append ( "New values for properties:</br>" ) ; change . append ( "<b>Content</b> </br>" ) ;
hasRender: public boolean hasRender ( ) { return false ;
onClientDeath: public void onClientDeath ( Client client , Client killer , PlayerData playerData , InstrumentInfo info ) { super . onClientDeath ( client , killer , playerData , info ) ; if ( ! getGameMode ( ) . isGameActive ( ) ) return ; boolean trackStats = client instanceof PlayerClient && killer instanceof PlayerClient ; if ( ! trackStats ) { PlayerClient who ; if ( client instanceof PlayerClient ) { who = ( ( PlayerClient ) client ) ; } else if ( killer instanceof PlayerClient ) { who = ( ( PlayerClient ) killer ) ; } else { who = null ; } trackStats = who != null && who . catTrackStatsWithBots ( ) ; } Client fox = getFox ( ) ; if ( fox != null ) { if ( fox == client ) { ModePayload foxPayload = fox . getModePayload ( ) ; if ( foxPayload instanceof FoxHuntPayload ) { FoxHuntPayload foxHuntPayload = ( ( FoxHuntPayload ) foxPayload ) ; foxHuntPayload . setFox ( false ) ; } if ( killer == null || killer == fox ) { setRandomPlayerAsFox ( fox ) ; } else { killer . addScore ( 10 , trackStats ) ; getGameMode ( ) . setTickets ( getGameMode ( ) . getTickets ( ) - 1 ) ; setPlayerAsFox ( killer ) ; } } else { if ( killer == fox ) { killer . addScore ( 20 , trackStats ) ; getGameMode ( ) . setTickets ( getGameMode ( ) . getTickets ( ) - 1 ) ; } } } updated ( ) ;
testUpdateAddressReferenceKey: public void testUpdateAddressReferenceKey ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/CustomerUpdateAddressReferenceKeyRequest.json" ) ; CustomerAddressReferenceKey requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , CustomerAddressReferenceKey . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; CustomerAddress responseEntity = this . api . customers ( ) . updateAddressReferenceKey ( "acme" , "acme" , Identifier . fromId ( 1 ) , 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CustomerUpdateAddressReferenceKeyResponse.json" ) ; assertThatJson ( expectedResponseJson )
getPackageManager: public PackageManager getPackageManager ( int threads ) { return new ClientPackageManager ( threads ) ;
drag: public boolean drag ( DragAndDrop . Source source , DragAndDrop . Payload payload , float x , float y , int i ) { if ( source instanceof CardOnHandSource ) { return true ; } if ( source instanceof DeckDragSource ) { return true ; } if ( source instanceof CardOnTableSource ) { return true ; } return false ;
update: public boolean update ( ) { return false ;
drive: private void drive ( PlayerClient playerClient , FreePayload payload , String drive , String [ ] driveAnimations ) { Map map = getMap ( ) ; if ( map == null ) return ; ActiveData d = map . getActiveNameIndex ( ) . get ( drive ) ; if ( d == null ) return ; GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( ! ( gameMode . getRealization ( ) instanceof ServerFreeRealization ) ) return ; ServerFreeRealization free = ( ( ServerFreeRealization ) gameMode . getRealization ( ) ) ; if ( free == null ) return ; AnimationData animationData = ( ( AnimationData ) d ) ; PlayerClient partner = null ; if ( payload . hasPartyMembers ( ) ) { String partyId = playerClient . getPartyId ( ) ; if ( partyId != null && ! partyId . isEmpty ( ) ) { for ( ObjectMap . Entry < Integer , Client > entry : BrainOutServer . Controller . getClients ( ) ) { if ( ! ( entry . value instanceof PlayerClient ) ) continue ; PlayerClient other = ( ( PlayerClient ) entry . value ) ; if ( other == playerClient ) continue ; if ( ! partyId . equals ( other . getPartyId ( ) ) ) continue ; partner = other ; } } if ( partner != null ) { partner . sendTCP ( new UpdateActiveAnimationMsg ( animationData , driveAnimations , false ) ) ; partner . sendTCP ( new WatchAnimationMsg ( map . getDimension ( ) , animationData , "subroot" , "vehicle-engine-run" ) ) ; } } PlayerClient finalPartner = partner ; payload . questEvent ( FreePlayItemActivatedEvent . obtain ( playerClient , getContentComponent ( ) . getEvent ( ) , getTrunkAmount ( ) ) ) ; if ( finalPartner != null && finalPartner . isAlive ( ) ) { ModePayload modePayload = finalPartner . getModePayload ( ) ; if ( modePayload instanceof FreePayload ) { FreePayload freePayload = ( ( FreePayload ) modePayload ) ; freePayload . questEvent ( FreePlayItemActivatedEvent . obtain ( finalPartner , getContentComponent ( ) . getEvent ( ) , getTrunkAmount ( ) ) ) ; } } playerClient . sendTCP ( new UpdateActiveAnimationMsg ( animationData , driveAnimations , false ) ) ; playerClient . sendTCP ( new WatchAnimationMsg ( map . getDimension ( ) , animationData , "subroot" , "vehicle-engine-run" ) ) ; BrainOutServer . PostRunnable ( ( ) ->
selectNextSpawn: private void selectNextSpawn ( ) { TextButton checked = spawnButtons . getChecked ( ) ; if ( checked != null )
setOnHierarchyChangeListener: public void setOnHierarchyChangeListener ( OnHierarchyChangeListener listener ) { mPassThroughListener . mOnHierarchyChangeListener = listener ;
getChartView: public Chart getChartView ( ) { return mWeakChart == null ? null : mWeakChart . get ( ) ;
search: default Page < T > search ( String searchTerm , Long organizationId , int page , int size , String sortField , String sortDirection ) { return SearchableFunctionalRepositoryWithLongId . super . search ( DEFAULT_SCOPE , searchTerm , organizationId , page , size , sortField , sortDirection ) ;
headerTitleStyle: protected String headerTitleStyle ( ) { return "title-yellow" ;
getIcon: public Drawable getIcon ( ) { return mIcon ;
retryFailed: protected void retryFailed ( ) { switchTo ( new CSError ( L . get ( "MENU_FAILED_TO_CONNECT" ) , ( ) -> switchTo ( new CSGetRegions ( ) ) ) ) ;
checkSDCardState: public static boolean checkSDCardState ( ) { return Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ;
createBarCode: public static Bitmap createBarCode ( String content , BarcodeFormat format , int desiredWidth , int desiredHeight , Map < EncodeHintType , ? > hints , boolean isShowText ) { return createBarCode ( content , format , desiredWidth , desiredHeight , hints , isShowText , 40 , Color . BLACK ) ;
hasRender: public boolean hasRender ( ) { return false ;
login: public AjaxResult login ( @ NonNull String account , @ NonNull String password ) { Map < String , String > params = new HashMap < > ( ) ; params . put ( "client_id" , AuthConstants . SYSTEM_CLIENT_ID ) ; params . put ( "client_secret" , AuthConstants . SYSTEM_CLIENT_SECRET ) ; params . put ( "grant_type" , AuthConstants . OAUTH2_PASSWORD ) ; params . put ( "username" , account ) ; params . put ( "password" , password ) ; AjaxResult accessToken = authFeignClient . getAccessToken ( params ) ; if ( Objects . equals ( accessToken . get ( "code" ) , 500 ) ) throw new PiscesException ( "用户名或密码错误！" ) ; LOGGER . info ( "accessToken 颁发成功:{}" , accessToken ) ; Map < String , String > data = ( Map < String , String > ) accessToken . get ( "data" ) ; redisTemplate . opsForValue ( ) . set ( String . join ( ":" , AuthConstants . SYSTEM_CLIENT_ID , account ) , data . get ( "token" ) ) ; CompletableFuture . runAsync ( RunnableWrapper . of ( ( ) -> { messageSender . sendBark ( String . format ( "时间：%s，用户：%s 登录系统！" , LocalDateTime . now ( ) , account ) ) ; } ) ) ; return accessToken ;
setWho: public void setWho ( int who ) { this . who = who ;
getImageDrawable: public static void getImageDrawable ( Context context , Object path , final LoadDrawableCallback callback ) { Glide . with ( context )
getWebLineWidth: public float getWebLineWidth ( ) { return mWebLineWidth ;
setSize: public void setSize ( float size ) { this . mSize = size ;
toString: public String toString ( ) { return name ;
getPerimeter: public double getPerimeter ( ) { return 2.0 * Math . PI * radius ;
renderLegal: private void renderLegal ( Table legal ) { { Label part1 = new Label ( L . get ( "EDITOR2_SUBMIT_LEGAL_1" ) , BrainOutClient . Skin , "title-small" ) ; legal . add ( part1 ) . row ( ) ; } {
setDrawGridLinesBehindData: public void setDrawGridLinesBehindData ( boolean enabled ) { mDrawGridLinesBehindData = enabled ; }
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/CarrierUpdateRequest.json" ) ; Carrier requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Carrier . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Carrier responseEntity = this . api . carriers ( ) . update ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CarrierUpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
getRoleListPage: void getRoleListPage ( ) throws JsonProcessingException { Integer pageNumber = 1 ; Integer pageSize = 10 ; String queryKey = "" ; List < Role > listPage = roleService . getRoleListPage ( pageNumber , pageSize , queryKey ) ; assertNotNull ( listPage ) ; log . info ( "角色列表（分页）方法测试成功:{}" , objectMapper . writeValueAsString ( listPage ) ) ;
setAndroid6StatusBarLightMode: public static void setAndroid6StatusBarLightMode ( Window window , boolean isDark ) { if ( isDark ) {
init: public void init ( ) { super . init ( ) ; if ( instrumentData . getInfo ( ) . skin != null )
getOrganizationId: public Long getOrganizationId ( ) { return organizationId ;
setOnDrawListener: public void setOnDrawListener ( OnDrawListener drawListener ) { this . mDrawListener = drawListener ;
setVisible: No method body
reset: public void reset ( ) { this . record = null ; this . action = null ;
purchaseItem: private void purchaseItem ( MarketService . MarketOrderEntry entry , ConsumableRecord record ) { pushMenu ( new FulfillOrderMenu ( entry , record , ( ) -> refresh ( false ) , menuCategory ) ) ;
create: public Warehouse create ( Warehouse model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Warehouse > responseModel = ( Class < Warehouse > ) ( Class < ? > ) Warehouse . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/warehouses" ) , query , null , responseModel , model ) ;
findByUserIdAndToken: No method body
getTableHeaderLabel: public String getTableHeaderLabel ( String code , String fieldName ) { String result = accessor . getMessage ( code , NO_MESSAGE ) ; if ( NO_MESSAGE . equals ( result ) ) { if ( fieldName . contains ( "." ) ) { String [ ] fieldNameParts = fieldName . split ( "\\." ) ; if ( fieldNameParts [ 1 ] . contains ( fieldNameParts [ 0 ] ) ) { fieldName = fieldNameParts [ 1 ] ; } } result = WordUtils . capitalize ( Arrays . stream ( StringUtils . splitByCharacterTypeCamelCase ( StringUtils . capitalize ( fieldName ) ) ) . filter ( s -> ! s . equals ( "." ) ) . collect ( Collectors . joining ( " " ) ) ) ; if ( showMessageKeyForDefaultFieldLabel ) { result += " (" + code + ")" ; } } return result ;
checkServerTrusted: public void checkServerTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { InputStream inputStream = getStream ( BaseApplication . applicationContext , "sdic-crit.cer" ) ; CertificateFactory certificateFactory = CertificateFactory . getInstance ( "X.509" ) ; Certificate certificate = certificateFactory . generateCertificate ( inputStream ) ; Principal pubSubjectDN = ( ( X509Certificate ) certificate ) . getSubjectDN ( ) ; Principal pubIssuerDN = ( ( X509Certificate ) certificate ) . getIssuerDN ( ) ; String pubSub = pubSubjectDN . getName ( ) ; String pubIssuer = pubIssuerDN . getName ( ) ; try { TrustManagerFactory tmf = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; tmf . init ( ( KeyStore ) null ) ; for ( TrustManager trustManager : tmf . getTrustManagers ( ) ) { ( ( X509TrustManager ) trustManager ) . checkServerTrusted ( chain , authType ) ; } } catch ( Exception e ) { throw new CertificateException ( e ) ; } if ( ! chain [ 0 ] . getSubjectDN ( ) . getName ( ) . equals ( pubSub ) ) { throw new CertificateException ( "server's SubjectDN is not equals to client's SubjectDN" ) ; } if ( ! chain [ 0 ] . getIssuerDN ( ) . getName ( ) . equals ( pubIssuer ) ) {
setYValuePosition: public void setYValuePosition ( ValuePosition yValuePosition ) { this . mYValuePosition = yValuePosition ;
spoof: public Object spoof ( @ PathVariable ( ID ) Long userId , HttpSession session , HttpServletRequest request , HttpServletResponse response ) { debug ( "[spoof] userId {}" , userId ) ; return spoofUser ( userId , session , request , response )
getWorkingTimeTo: public float getWorkingTimeTo ( ) { return workingTimeTo ;
buildAppInfo: private Map < String , Object > buildAppInfo ( ) { Map < String , Object > map = new HashMap < > ( ) ; DateTimeFormatter date = DateTimeFormatter . ofPattern ( "yyyyMMddHHmmss" ) ; if ( buildProperties != null ) { map . put ( "Artifact" , buildProperties . getArtifact ( ) ) ; map . put ( "Group" , buildProperties . getGroup ( ) ) ; map . put ( "Version" , buildProperties . getVersion ( ) ) ; if ( buildProperties . getTime ( ) != null ) { map . put ( "Timestamp" , date . format ( LocalDateTime . ofInstant ( buildProperties . getTime ( ) , ZoneId . systemDefault ( ) ) ) ) ; } map . put ( "Branch" , buildProperties . get ( "git.branch" ) ) ; map . put ( "CommitId" , buildProperties . get ( "git.commit.id.abbrev" ) ) ; map . put ( "Hostname" , buildProperties . get ( "hostname" ) ) ; } else { map . put ( "Version" , "HEAD" ) ; LocalDateTime now = LocalDateTime . now ( ) ; map . put ( "Timestamp" , date . format ( now ) ) ; map . put ( "Branch" , "local" ) ; map . put ( "Hostname" , "localhost" ) ; } return map ;
onItemClick: public void onItemClick ( View view , ListAssetItemEntity item ) { if ( item . getPropertyid ( ) == 0 ) { assetTypeIv . setImageResource ( R . mipmap . icon_btc_logo_small ) ; assetTypeTv . setText ( "BTC" ) ; amountUnitTv . setText ( "BTC" ) ; amountEdit . setText ( "0" ) ; } else { assetTypeIv . setImageResource ( R . mipmap . icon_usdt_logo_small ) ; assetTypeTv . setText ( "dollar" ) ; amountUnitTv . setText ( "dollar" ) ; amountEdit . setText ( "0" ) ; } mAssetId = item . getPropertyid ( ) ; getChannelBalance ( mAssetId ) ;
getColor: public Color getColor ( ) { return color ;
error: public void error ( Marker marker , String msg ) { logger . error ( marker , msg ) ;
gotBlocksInOurWay: private void gotBlocksInOurWay ( Queue < WayPointMap . BlockCoordinates > blocks ) { if ( getStack ( ) . getTasks ( ) . size > 0 && getStack ( ) . getTasks ( ) . last ( ) instanceof TaskDestroyBlocks ) return ; pushTask ( new TaskDestroyBlocks ( getStack ( ) , blocks ) ) ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . controller , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . gameController , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . error , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
getFileType: public String getFileType ( ) { return fileType ;
hasRender: public boolean hasRender ( ) { return false ;
getBackground: protected TextureRegion getBackground ( ) { return BrainOutClient . getRegion ( "bg-ingame" ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoSteamPressure4OnItemStateChanged ( evt ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { relief2ActionPerformed ( evt ) ;
getBalanceAmount: public static long getBalanceAmount ( Context context ) { return getLong ( SETTINGS , context , KEY_BALANCE_AMOUNT ) ;
addSubscriberToTopic: No method body
cancelOutstandingTask: private synchronized void cancelOutstandingTask ( ) { if ( outstandingTask != null ) {
lessFrequent: public static Map < String , Integer > lessFrequent ( Map < String , Integer > map , int limit ) { return sortAndCut ( map , ( e1 , e2 ) -> e1 . getValue ( ) - e2 . getValue ( ) , limit ) ;
run: public void run ( ) { Bitmap imageBitmap = BitmapUtils . arrayToBitmap ( result ) ; setImageBitmap ( imageBitmap ) ;
getId: public Long getId ( ) { return this . id ;
newObject: protected ExplosiveBulletData newObject ( ) { return new ExplosiveBulletData ( ExplosiveBullet . this , this ) ;
isFailed: public final boolean isFailed ( ) { return this . state == State . Failed ;
convertAndSave: public Form convertAndSave ( FormConversionDto dto , String filePath ) { debug ( "[convertAndSave]" ) ; Form form = getForm ( dto , loadResourceAsString ( dto . getCode ( ) ) ) ; services . dynamicEntity . createDynamicTableIfNotExists ( form . getTableName ( ) ) ; return repositories . secure . form . saveOne ( form ) ;
getFromInt: private static LaserStyle getFromInt ( int value ) { for ( LaserStyle style : LaserStyle . values ( ) ) { if ( style . mValue == value ) { return style ; } } return LaserStyle . LINE ;
listPeers: public Single < lnrpc . LightningOuterClass . ListPeersResponse > listPeers ( lnrpc . LightningOuterClass . ListPeersRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . listPeers ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
cancelReconnect: private void cancelReconnect ( ) { wsMainHandler . removeCallbacks ( reconnectRunnable ) ; reconnectCount = 0 ;
complete: public void complete ( String roomId ) { BrainOutClient . Env . setCurrentRoom ( roomId ) ;
init: public void init ( ) { super . init ( ) ; Bone primaryBone = getSkeleton ( ) . findBone ( PLAYER_HOLDER_PRIMARY ) ; Bone secondaryBone = getSkeleton ( ) . findBone ( PLAYER_HOLDER_SECONDARY ) ; if ( primaryBone != null ) { primaryBonePointData = new BonePointData ( primaryBone , playerData . getLaunchData ( ) ) ; } else { primaryBonePointData = new BonePointData ( getSkeleton ( ) . getRootBone ( ) , playerData . getLaunchData ( ) ) ; } Bone bleedingBone = getSkeleton ( ) . findBone ( "bleeding" ) ; if ( bleedingBone != null ) { this . bleedingBonePointData = new BonePointData ( bleedingBone , playerData . getLaunchData ( ) ) ; } if ( secondaryBone != null )
findAllAsTuple: No method body
getDatePlusMonthsFromCurrent: public static LocalDateTime getDatePlusMonthsFromCurrent ( long months ) { return LocalDateTime . now ( ) . plusMonths ( months ) ;
removeScheduler: public boolean removeScheduler ( long schedulerId ) { debug ( "[removeScheduler] {}" , schedulerId ) ; if ( isCluster ( ) ) { getHazelcastInstance ( ) . getTopic ( CLUSTER_EVENT_TOPIC ) . publish ( new ClusterEvent ( SCHEDULER_REMOVE , schedulerId ) ) ; return true ; } return false ;
getSkeleton: public Skeleton getSkeleton ( ) { return bone . skeleton ;
toPredicate: public Predicate toPredicate ( Root < Notification > root , CriteriaQuery < ? > query , CriteriaBuilder cb ) { Predicate allUserNotificationsPredicate = getAllUserNotificationsPredicate ( root , cb , id , organizationIds ) ; Subquery < Long > sq = query . subquery ( Long . class ) ; Root < ReadNotification > readNotificationRoot = sq . from ( ReadNotification . class ) ; sq . select ( readNotificationRoot . get ( "notificationId" ) ) ; Predicate readPredicate = cb . in ( root . get ( "id" ) ) . value ( sq ) . not ( ) ; return cb . and ( allUserNotificationsPredicate , readPredicate ) ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { dragAndDropTargetActor = new Widget ( ) ; ( ( Widget ) dragAndDropTargetActor ) . setFillParent ( true ) ; data . addActor ( dragAndDropTargetActor ) ; } modePanel = new Table ( ) ; { Table toolbar = new Table ( BrainOutClient . Skin ) ; toolbar . align ( Align . left ) ; renderTopToolbar ( toolbar ) ; data . add ( toolbar ) . pad ( 8 ) . expandX ( ) . fillX ( ) . height ( 32 ) . row ( ) ; } data . add ( ) . expand ( ) . row ( ) ; { Table toolbar = new Table ( BrainOutClient . Skin ) ; toolbar . align ( Align . left ) ; renderBottomToolbar ( toolbar ) ; data . add ( toolbar ) . pad ( 8 ) . expandX ( ) . fillX ( ) . height ( 32 ) . row ( ) ; } return data ;
getFormNewFragment: public String getFormNewFragment ( ) { return formNewFragment ;
getNumbersOperator: public Boolean getNumbersOperator ( ) { return numbersOperator ;
testToString: void testToString ( ) { RationalNumber r1 = new RationalNumber ( 1 , 3 ) ; assertEquals ( "RationalNumber{numerator=1, denominator=3}" , r1 . toString ( ) ) ;
child: public FileHandle child ( String name ) { return new ZipPackageFileHandle ( entryName + "/" + name ) ;
setARotation: public void setARotation ( float arotation ) { this . arotation = arotation ;
test_bulkTriggerEventToSubscriber: public void test_bulkTriggerEventToSubscriber ( ) throws IOException , NovuNetworkException , InterruptedException { BulkTriggerEventRequest bulkTriggerEventRequest = new BulkTriggerEventRequest ( ) ; TriggerEventRequest triggerEventRequest = new TriggerEventRequest ( ) ; triggerEventRequest . setName ( "name" ) ; SubscriberRequest subscriberRequest = new SubscriberRequest ( ) ; subscriberRequest . setFirstName ( "fName" ) ; subscriberRequest . setLastName ( "lName" ) ; subscriberRequest . setEmail ( "mail@sample.com" ) ; subscriberRequest . setSubscriberId ( "subId" ) ; triggerEventRequest . setTo ( subscriberRequest ) ; triggerEventRequest . setPayload ( Collections . singletonMap ( "customVariables" , "Hello" ) ) ; TriggerEventResponseData data = new TriggerEventResponseData ( ) ; data . setAcknowledged ( true ) ; data . setStatus ( "done" ) ; data . setTransactionId ( "id" ) ; BulkTriggerEventResponse bulkTriggerEventResponse = new BulkTriggerEventResponse ( ) ; bulkTriggerEventResponse . setData ( Collections . singletonList ( data ) ) ; bulkTriggerEventRequest . setEvents ( Collections . singletonList ( triggerEventRequest ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( bulkTriggerEventResponse ) ) ) ; BulkTriggerEventResponse response = eventsHandler . bulkTriggerEvent ( bulkTriggerEventRequest ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/events/trigger/bulk" , request . getPath ( ) ) ; assertEquals ( "POST" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( bulkTriggerEventResponse ) , gson . toJson ( response ) ) ;
updateIntegration: No method body
onSubscribe: public void onSubscribe ( Flow . Subscription subscription ) { this . outputSubscription = subscription ; this . outputSubscription . request ( Long . MAX_VALUE ) ;
renderDigits: private void renderDigits ( ) { digitsValue . clear ( ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ )
getPositiveSum: public float getPositiveSum ( ) { return mPositiveSum ;
clicked: public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . back ) ; pop ( ) ;
showImage: public static void showImage ( Context context , Object imagePath , ImageView imageView , int imageWidth , int imageHeight , int placeHolder ) { DrawableRequestBuilder builder = getBuilder ( context , imagePath , placeHolder ) ; if ( imageWidth > 0 && imageHeight > 0 ) { builder . override ( imageWidth , imageHeight ) ; } builder . into ( imageView ) ;
error: public void error ( String reason ) { loadingMenu . pop ( ) ; pushMenu ( new AlertPopup ( L . get ( reason ) ) ) ;
sync: protected void sync ( ) { if ( synced ) { return ; } synced = genAlignment > 48.5 && genAlignment < 51.5 && rpm >= 2997.5 && rpm <= 3002.5 ; if ( synced ) {
getLaunchedBy: public InstrumentInfo getLaunchedBy ( ) { return launchedBy ;
search: default Page < T > search ( String searchTerm , Long organizationId , Specification < T > specification , Pageable pageable ) { return SearchableFunctionalRepositoryWithLongId . super . search ( DEFAULT_SCOPE , searchTerm , organizationId , specification , pageable ) ;
writeString: protected void writeString ( String s ) throws IOException { for ( int i = 0 ; i < s . length ( ) ; i ++ ) {
configure: public void configure ( AuthorizationServerSecurityConfigurer security ) { security . allowFormAuthenticationForClients ( ) ;
getMwidth: public int getMwidth ( ) { return mwidth ;
getName: public String getName ( ) { return this . name ;
setCallback: public void setCallback ( EarnedCallback callback ) { this . callback = callback ;
process: private void process ( ) { GameMode mode = BrainOutServer . Controller . getGameMode ( ) ; if ( mode == null ) return ; switch ( mode . getID ( ) ) { case editor : case editor2 : case free : case lobby : { return ; } } if ( BrainOutServer . Controller . getClients ( ) . size <= 1 ) return ; Map map = Map . GetDefault ( ) ; if ( map == null ) return ; ActiveData at = map . getRandomActiveForTag ( Constants . ActiveTags . SPAWNABLE ) ; if ( at == null ) return ; int amount = map . countActivesForID ( "active-pumpkin" ) ; if ( amount >= 3 ) return ; Active pumpkin = BrainOutServer . ContentMgr . get ( "active-pumpkin" , Active . class ) ; ActiveData data = pumpkin . getData ( map . getDimension ( ) ) ; data . setPosition ( at . getX ( ) , at . getY ( ) ) ; map . addActive ( map . generateServerId ( ) , data , true ) ;
getAmount: public int getAmount ( ConsumableContent consumableContent ) { Integer amount = consumables . get ( consumableContent ) ; if ( amount == null ) { return 0 ; } return amount ;
isValueLineVariableLength: public boolean isValueLineVariableLength ( ) { return mValueLineVariableLength ;
hashCode: public int hashCode ( ) { int result = Objects . hashCode ( spec ) ; result = 31 * result + Objects . hashCode ( runner ) ; return result ;
save: public void save ( ) { try
dictionary: public Map dictionary ( Class entityClass ) { SearchableRepositoryMetadata gsa = SearchableRepositories . getSearchableRepositoryMetadata ( entityClass ) ; return dictionary ( gsa ) ; }
getCubicIntensity: No method body
deleteResource: public void deleteResource ( @ NonNull Long resourceId ) { eventPublisher . publishEvent ( new ClearCacheEvent ( AuthConstants . PERMISSION_RULES_KEY ) ) ; Assert . isTrue ( this . baseMapper . deleteById ( resourceId ) > 0 , "资源假删除失败！" ) ;
render: public void render ( ) { drawFade ( ) ; super . render ( ) ;
showTimePicker: public void showTimePicker ( boolean showTime ) { if ( showTime ) {
trace: default void trace ( String format , Object ... arguments ) { Logger l = getLogger ( ) ; l . trace ( format , arguments ) ; if ( isDebugLogger ( ) ) {
checkTopicSubscriber: public CheckTopicSubscriberResponse checkTopicSubscriber ( final String topicKey , final String externalSubscriberId ) throws IOException , NovuNetworkException { Response < CheckTopicSubscriberResponse > response = topicApi . checkTopicSubscriber ( topicKey , externalSubscriberId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
invalidSideEffectCall: static ProtocolException invalidSideEffectCall ( ) { return new ProtocolException (
saveOrganization: protected PageModelMap saveOrganization ( Long organizationId , OrganizationForm form , BindingResult br ) { debug ( "[saveOrganization] orgId {}" , organizationId ) ; return Flow . init ( )
hashCode: public int hashCode ( ) { return - 1 ;
showIntroMenus: private void showIntroMenus ( ) { pushMenu ( BrainOutClient . Env . createIntroMenu ( ) ) ;
initializeDialUpdateThread: No method body
updateReferenceKey: public Customer updateReferenceKey ( String shopKey , String countryCode , Integer customerId , CustomerReferenceKey model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Customer > responseModel = ( Class < Customer > ) ( Class < ? > ) Customer . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/reference-key" , shopKey , countryCode , customerId ) , query , null , responseModel , model ) ;
getBone: public BonePointData getBone ( String boneName ) { Bone bone = getSkeleton ( ) . findBone ( boneName ) ; if ( bone == null ) return null ; return new BonePointData ( bone , null ) ;
readTask: protected void readTask ( JsonValue jsonData ) { super . readTask ( jsonData ) ; if ( jsonData . has ( "generate-privately" ) ) { generatePrivately = jsonData . getBoolean ( "generate-privately" , false ) ; } if ( jsonData . has ( "generate-tag" ) ) { generateTag = jsonData . getString ( "generate-tag" , "" ) ; } if ( jsonData . has ( "generate-amount" ) )
getEmail: public String getEmail ( ) { return email ;
read: public void read ( Json json , JsonValue jsonValue ) { key = jsonValue . getString ( "key" , key ) ;
initWallet: No method body
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case setInstrument : { SetInstrumentEvent e = ( ( SetInstrumentEvent ) event ) ; if ( e . playerData == instrumentData . getOwner ( ) ) { setActive ( instrumentData == e . selected ) ; } break ; } case simple : { SimpleEvent e = ( ( SimpleEvent ) event ) ; if ( e . getAction ( ) == SimpleEvent . Action . deselected ) { setActive ( false ) ; break ; } break ; } case ownerChanged : { OwnerChangedEvent e = ( ( OwnerChangedEvent ) event ) ; if ( e . newOwner == null ) { setActive ( false ) ; } } } return false ;
contains: void contains ( ) { assertTrue ( circle . contains ( new Point ( 0 , 0 ) ) ) ; assertTrue ( circle . contains ( new Point ( 10 , 10 ) ) ) ; assertFalse ( circle . contains ( new Point ( 15 , 15 ) ) ) ; assertFalse ( circle . contains ( new Point ( - 5 , - 5 ) ) ) ;
getNetworkInfo: No method body
getUpgradeScript: default void getUpgradeScript ( T entity , List < String > dbUpgradeEntries ) { return ;
markMessageActionAsSeen: public SubscriberNotificationResponse markMessageActionAsSeen ( final MarkMessageActionAsSeenRequest request , final String subscriberId , final String messageId , final String type ) throws IOException , NovuNetworkException { Response < SubscriberNotificationResponse > response = subscribersApi . markMessageActionAsSeen ( request , subscriberId , messageId , type ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
get: public Actor get ( ) { Table tooltip = new Tooltip . TooltipTable ( ) ; tooltip . align ( Align . top | Align . center ) ; Table content = new Table ( ) ; content . setBackground ( new NinePatchDrawable ( BrainOutClient . getNinePatch ( "form-default" ) ) ) ; Label title = new Label ( getTitle ( ) , BrainOutClient . Skin , "title-level" ) ; title . setAlignment ( Align . center ) ; title . setWrap ( true ) ; tooltip . add ( new BorderActor ( title , 540 , "form-gray" ) ) . expandX ( ) . fillX ( ) . row ( ) ; tooltip . add ( content ) . expand ( ) . fill ( ) . row ( ) ; boolean addBottomLine = false ; if ( item == null || userProfile == null || item . hasItem ( userProfile ) || ! item . isLocked ( userProfile ) ) { renderItem ( content , item ) ; } else { ContentLockTree . LockItem lockItem = item . getLockItem ( ) ; TextureRegion locked = BrainOutClient . getRegion ( getLockedIcon ( lockItem ) ) ; Image lockedImage = new Image ( locked ) ; lockedImage . setScaling ( Scaling . none ) ; content . add ( lockedImage ) . padBottom ( 8 ) . expandX ( ) . fillX ( ) . row ( ) ; if ( ! lockItem . isValid ( ) ) { Label lockedText = new Label ( lockItem . isUnlockTitleValid ( ) ? lockItem . getUnlockTitle ( ) : L . get ( "MENU_LOCKED" ) , BrainOutClient . Skin , "title-small" ) ; lockedText . setAlignment ( Align . center ) ; lockedText . setWrap ( true ) ; content . add ( lockedText ) . expandX ( ) . fillX ( ) . row ( ) ; addBottomLine = false ; } else { String f = lockItem . getUnlockFor ( ) ; Label taskText = new Label ( L . get ( "MENU_TASK" ) , BrainOutClient . Skin , "title-gray" ) ; taskText . setAlignment ( Align . center ) ; taskText . setWrap ( true ) ; content . add ( taskText ) . expandX ( ) . fillX ( ) . row ( ) ; String text ; if ( f . equals ( Constants . User . LEVEL ) ) { Levels levels = BrainOutClient . ClientController . getLevels ( Constants . User . LEVEL ) ; if ( levels != null ) { Levels . Level level = levels . getLevel ( lockItem . getParam ( ) ) ; text = L . get ( "MENU_TASK_REACH_LEVEL" , level . toShortString ( ) ) ; } else { text = "???" ; } } else if ( f . equals ( Constants . User . TECH_LEVEL ) ) { Levels levels = BrainOutClient . ClientController . getLevels ( Constants . User . TECH_LEVEL ) ; Levels . Level level = levels . getLevel ( lockItem . getParam ( ) ) ; text = L . get ( "MENU_TASK_REACH_TECH_LEVEL" , level . toShortString ( ) ) ; } else { text = lockItem . isUnlockTitleValid ( ) ? lockItem . getUnlockTitle ( lockItem . getParam ( ) ) : L . get ( "MENU_LOCKED" ) ; } addBottomLine = true ; Label reachLevel = new Label ( text , BrainOutClient . Skin , "title-small" ) ; reachLevel . setAlignment ( Align . center ) ; reachLevel . setWrap ( true ) ; content . add ( reachLevel ) . expandX ( ) . fillX ( ) . row ( ) ; } } if ( ! removeBottomLine ( ) && ( addBottomLine || forceBottomLine ( ) ) ) { Actor progress = renderBottomLine ( ) ; if ( progress != null ) { BorderActor ba = new BorderActor ( progress , 512 ) ; ba . getCell ( ) . height ( 20 ) ; tooltip . add ( ba ) . expandX ( ) . fillX ( ) . row ( ) ; } } tooltip . setSize ( 544 , 290 ) ; return tooltip ;
getSecondaryDisplayUnit: public String getSecondaryDisplayUnit ( ) { if ( PrefsUtil . isFirstCurrencyPrimary ( ) ) {
isSuccess: public final boolean isSuccess ( ) { return this . state == State . Succeeded ;
success: public void success ( JSONObject response ) { GameState gs = getGameState ( ) ; if ( gs == null ) return ; loadingMenu . pop ( ) ; reset ( ) ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Label header = new Label ( this . header , BrainOutClient . Skin , "title-small" ) ; header . setAlignment ( Align . center ) ; data . add ( header ) . expandX ( ) . fillX ( ) . pad ( 32 ) . row ( ) ; } { Label title = new Label ( L . get ( "MENU_FRIEND_LIST" ) , BrainOutClient . Skin , "title-yellow" ) ; title . setAlignment ( Align . center ) ; BorderActor borderActor = new BorderActor ( title , "form-gray" ) ; borderActor . getCell ( ) . expandX ( ) . fillX ( ) ; data . add ( borderActor ) . expandX ( ) . fillX ( ) . row ( ) ; } { Table contents = new Table ( ) ; contents . setSkin ( BrainOutClient . Skin ) ; contents . setBackground ( "form-default" ) ; contents . align ( Align . center ) ; renderFriends ( contents ) ; data . add ( contents ) . row ( ) ; } { TextButton close = new TextButton ( L . get ( "MENU_CLOSE" ) , BrainOutClient . Skin , "button-default" ) ; close . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ; } } ) ; data . add ( close ) . center ( ) . size ( 192 , 64 ) . pad ( 32 ) . row ( ) ; } return data ;
bytesToLong: public static long bytesToLong ( final byte [ ] b ) { long result = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { result <<= 8 ; result |= ( b [ i ] & 0xFF ) ; } return result ;
setSingleChoiceItems: public SafeDialogBuilder setSingleChoiceItems ( ListAdapter adapter , int checkedItem , DialogInterface . OnClickListener listener ) { super . setSingleChoiceItems ( adapter , checkedItem , listener ) ; return this ;
updateWorkflow: public SingleWorkflowResponse updateWorkflow ( final String workflowId , final UpdateWorkflowRequest request ) throws IOException , NovuNetworkException { Response < SingleWorkflowResponse > response = workflowApi . updateWorkflow ( workflowId , request ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
hashCode: public int hashCode ( ) { return Objects . hash ( name , lastname , phone , average ) ;
getCurrentTime: private long getCurrentTime ( ) { return BrainOut . getInstance ( ) . getController ( ) . getCurrentTime ( ) ;
getRecord: public ConsumableRecord getRecord ( ) { return record ;
write: public void write ( Json json ) { json . writeObjectStart ( getName ( ) ) ; json . writeValue ( "value" , getValue ( ) ) ; json . writeValue ( "stick" , isStick ( ) ) ; json . writeObjectEnd ( ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; onHitValue = jsonData . get ( "onHit" ) ;
getCenter: public Point getCenter ( ) { return center ;
asmTest2: public void asmTest2 ( ) throws IOException , InterruptedException { ChangeBodyMessage msg = new ChangeBodyMessage ( ) ; msg . setClassName ( "w.core.ChangeTarget" ) ; msg . setMethod ( "add" ) ; msg . setMode ( 1 ) ; msg . setParamTypes ( Arrays . asList ( "int" , "double" ) ) ; msg . setBody ( "{return $1 + $2 + 100; }" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; System . out . println ( target . add ( 1 , 1 ) ) ; Assertions . assertEquals ( 102.0 , target . add ( 1 , 1 ) ) ;
pause: public void pause ( ) { currentlyPlaying . forEach ( playingClip -> {
sendAndSaveEmail: public Email sendAndSaveEmail ( User recipient , String emailTemplateName ) { debug ( "[sendAndSaveEmail] Sends {} to {}" , emailTemplateName , recipient ) ; return repositories . unsecure . email . save ( services . emailConstructor . prepareEmailWithTitleFromTemplate ( recipient , emailTemplateName ) ) ;
dp2px: public static int dp2px ( Context context , float dpValue ) { float scale = context . getResources ( ) . getDisplayMetrics ( ) . density ; return dip2px ( dpValue , scale ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem12ActionPerformed ( evt ) ;
hasRender: public boolean hasRender ( ) { return false ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; BrainOutClient . Env . openProbabilitiesMenu ( getGameState ( ) ) ;
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { return ; } try {
lineToWords: public static List < String > lineToWords ( String line ) { return Arrays . asList ( line . replaceAll ( "[^a-zA-Z ]" , "" ) . toLowerCase ( ) . split ( "\\s+" ) ) ;
testSplitDocumentsByTokenCount: void testSplitDocumentsByTokenCount ( ) { final TextSplitter tiktokenTextSplitter = new JtokkitTextSplitter ( Encodings . newDefaultEncodingRegistry ( ) . getEncoding ( EncodingType . CL100K_BASE ) , 10 ) ; final SplitDocumentsChain splitDocumentsChain = new SplitDocumentsChain ( tiktokenTextSplitter ) ; final List < Map < String , String > > splitDocuments = splitDocumentsChain . run ( documents . stream ( ) ) . collect ( Collectors . toList ( ) ) ; System . out . println ( splitDocuments ) ; assertNotNull ( splitDocuments , "null result" ) ; assertEquals ( 3 , splitDocuments . size ( ) , "wrong result size" ) ; final Map < String , String > firstDocument = splitDocuments . get ( 0 ) ; assertEquals ( "This is a short text. " , firstDocument . get ( PromptConstants . CONTENT ) , "wrong first chunk of split document" ) ; assertEquals ( "book of john" , firstDocument . get ( PromptConstants . SOURCE ) , "wrong source for firstDocument" ) ; final Map < String , String > secondDocument = splitDocuments . get ( 1 ) ; assertEquals ( "This is another short text." , secondDocument . get ( PromptConstants . CONTENT ) , "wrong second chunk of split document" ) ; assertEquals ( "book of john" , secondDocument . get ( PromptConstants . SOURCE ) , "wrong source for secondDocument" ) ; final Map < String , String > thirdDocument = splitDocuments . get ( 2 ) ; assertEquals ( "This is a short text." , thirdDocument . get ( PromptConstants . CONTENT ) , "wrong content for thirdDocument" ) ; assertEquals ( "book of jane" , thirdDocument . get ( PromptConstants . SOURCE ) , "wrong source for thirdDocument" ) ;
getTextLengthContainsChinese: private int getTextLengthContainsChinese ( String text ) { if ( TextUtils . isEmpty ( text ) ) { return 0 ; } int length = 0 ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( text . charAt ( i ) > 255 ) { length += 2 ; } else { length ++ ; } } return length ;
getLdapUser: public LDAPUser getLdapUser ( ) { return ldapUser ;
getLineSpacing: public static float getLineSpacing ( Paint paint ) { return getLineSpacing ( paint , mFontMetrics ) ;
initComponents: public void initComponents ( ) { Component it = fistComponent ; while ( it != null )
getForUser: public static String getForUser ( User user , boolean allowAnimated ) { return null ;
getSpawnPlayer: protected Player getSpawnPlayer ( ) { return BrainOutServer . ContentMgr . get ( "player-fp-bot" , FreePlayPlayer . class ) ;
onCancelRefresh: public void onCancelRefresh ( ) { mRefreshDesc . setText ( R . string . text_load_pull ) ; mRefreshIcon . clearAnimation ( ) ;
setSpeed: public void setSpeed ( float speed ) { speed = Math . min ( 1.0F , speed ) ; for ( ServerMap map : Map . All ( ServerMap . class ) ) { map . setSpeed ( speed ) ; } getClients ( ) . sendTCP ( new SetGameSpeedMsg ( speed ) ) ;
release: public void release ( ) { if ( cache != null )
deleteSubscriberCredentials: No method body
createOrder: private void createOrder ( ) { WaitLoadingMenu waitLoadingMenu = new WaitLoadingMenu ( "" ) ; pushMenu ( waitLoadingMenu ) ; JSONObject args = new JSONObject ( ) ; args . put ( "market" , "freeplay" ) ; args . put ( "item" , marketInventoryRecord . getMarketEntry ( ) . name ) ; args . put ( "payload" , marketInventoryRecord . getMarketEntry ( ) . payload ) ; args . put ( "price" , price ) ; args . put ( "amount" , amount ) ; BrainOutClient . SocialController . sendRequest ( "new_market_order" , args ,
getFreeSpace: public Long getFreeSpace ( String partition ) { return freePartitionSpace . get ( partition ) ;
calculateHash: No method body
matches: public int matches ( ItemData itemData , ConsumableRecord record ) { return itemData . getComponent ( ServerCampfireActivatorComponentData . class ) != null ? 1 : 0 ;
printBanner: No method body
info: public void info ( Marker marker , String format , Object arg1 , Object arg2 ) { logger . info ( marker , format , arg1 , arg2 ) ;
setStaticData2: public void setStaticData2 ( String staticData2 ) { this . staticData2 = staticData2 ;
onScrollFinish: private void onScrollFinish ( boolean isForceFinish ) { if ( mIsAutoRefresh && ! isForceFinish ) {
disconnected: public void disconnected ( NetworkConnection connection ) { Gdx . app . log ( "connection" , "Disconnected from server" ) ; Gdx . app . postRunnable ( clientController :: onDisconnect ) ;
getBase64FromBitmap: public static String getBase64FromBitmap ( Bitmap bitmap ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; bitmap . compress ( Bitmap . CompressFormat . JPEG , 100 , bos ) ; return Base64 . encodeToString ( bos . toByteArray ( ) , Base64 . DEFAULT ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jRadioButtonMenuItem3ActionPerformed ( evt ) ;
setConsumerCategory: public void setConsumerCategory ( String consumerCategory ) { this . consumerCategory = consumerCategory ;
getParallaxData: public ParallaxData getParallaxData ( ) { return parallax ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( Menu . MenuSound . select ) ; currentBlock = block ;
init: private void init ( ) { CardGroup cardGroup = cardData . getCard ( ) . getGroup ( ) ; IconComponent cardGroupIcon = cardGroup . getComponent ( IconComponent . class ) ; setTransform ( true ) ; setOrigin ( 96 , 128 ) ; Image bg = new Image ( cardGroupIcon . getIcon ( "icon-back" ) ) ; bg . setFillParent ( true ) ; addActor ( bg ) ; setColor ( 1 , 1 , 1 , 0 ) ; addListener ( new ClickOverListener ( )
jdkVersion: private static String jdkVersion ( ) { try {
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { Bone bone = skeleton . bones . get ( boneIndex ) ; if ( ! bone . active ) return ; if ( time < frames [ 0 ] ) { switch ( blend ) { case setup : bone . rotation = bone . data . rotation ; return ; case first : bone . rotation += ( bone . data . rotation - bone . rotation ) * alpha ; } return ; } float r = getCurveValue ( time ) ; switch ( blend ) {
hasBeenCompleted: public boolean hasBeenCompleted ( UserProfile userProfile , String account ) { return hasItem ( userProfile , false ) ;
isAutoReconnect: No method body
getSound: private Sound getSound ( ) { return isEnclosed ( ) ? soundEffect . getReverbSound ( ) : soundEffect . getSound ( ) ;
update: public Merchant update ( Identifier merchantIdentifier , Merchant model ) throws ApiErrorException , ConnectionException { Class < Merchant > responseModel = ( Class < Merchant > ) ( Class < ? > ) Merchant . class ; return this . request ( "put" , this . resolvePath ( "/merchants/%s" , merchantIdentifier ) , null , null , responseModel , model ) ;
acquireSpawn: public SpawnMode acquireSpawn ( Client client , Team team ) { ModePayload modePayload = client . getModePayload ( ) ; if ( ! ( modePayload instanceof DuelPayload ) ) return SpawnMode . disallowed ; DuelPayload duelPayload = ( ( DuelPayload ) modePayload ) ; DuelRoom room = rooms . get ( duelPayload . getRoom ( ) ) ; if ( room == null ) return SpawnMode . disallowed ; switch ( room . getState ( ) )
onClick: public void onClick ( View v ) { if ( callBack != null ) {
setX: public void setX ( float x ) { this . x = x ;
getNickname: public String getNickname ( ) { return nickname ;
all: public ApiCollection < ShopCountryPriceRounding > all ( String shopKey , String countryCode ) throws ApiErrorException , ConnectionException { Class < ShopCountryPriceRounding > responseModel = ( Class < ShopCountryPriceRounding > ) ( Class < ? > ) ShopCountryPriceRounding . class ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries/%s/price-roundings" , shopKey , countryCode ) , null , null , responseModel ) ;
fillArray: public static double [ ] fillArray ( int size , double value , boolean addNoise ) { double [ ] dst = new double [ size ] ; Arrays . fill ( dst , value ) ; if ( addNoise ) { RandomGenerator rnd = RandomGenerator . getDefault ( ) ; for ( int i = 0 ; i < dst . length ; i ++ ) { dst [ i ] += rnd . nextDouble ( - value , value ) * 0.05 ; } } return dst ;
getComponent: public BlockAnimationComponentData getComponent ( ComponentObject componentObject ) { return new BlockAnimationComponentData ( componentObject , this ) ;
hasIcon: public boolean hasIcon ( ) { return icon != null ;
getOffsetRotation: public float getOffsetRotation ( ) { return offsetRotation ;
run: public void run ( ) { while ( ! isInterrupted ( ) ) {
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { mFW1CloseItemStateChanged ( evt ) ;
touchDown: public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { if ( menus . empty ( ) ) return false ; for ( int i = menus . size ( ) - 1 ; i >= 0 ; i -- ) { Menu menu = menus . get ( i ) ; if ( menu . touchDown ( screenX , screenY , pointer , button ) ) return true ; if ( menu . lockInput ( ) ) return true ; } return false ;
applySlowMo: public void applySlowMo ( float time ) { for ( Map map : Map . All ( ) )
isRed: private boolean isRed ( ) { if ( itemData instanceof RoundLockSafeData && ( ( RoundLockSafeData ) itemData ) . isLocked ( ) ) return true ; return ! itemData . hasItems ( ) ;
setAccessLevel: public void setAccessLevel ( FrontendResource . AccessLevel accessLevel ) { this . accessLevel = accessLevel ;
shouldNotCreateBackupWithEmptyOptions: public void shouldNotCreateBackupWithEmptyOptions ( ) { Set < BackupOption > backupOptions = emptySet ( ) ; boolean result = testObject . doBackup ( backupOptions ) ; assertFileDoesNotExist ( testObject . getDatabaseBackupFile ( ) ) ; assertFileDoesNotExist ( testObject . getTarBackupFile ( ) ) ; assertFalse ( result ) ;
getValueFormatter: No method body
getComponent: public UserSpriteWithBlocksComponentData getComponent ( ComponentObject componentObject ) { return new UserSpriteWithBlocksComponentData ( componentObject , this ) ;
runCommandToStream: public InputStream runCommandToStream ( String command ) { return ServerJSProcessRunner . commandToInputStream ( command ) ;
setPackedDarkColor: public void setPackedDarkColor ( float packedColor ) { Color . rgba8888ToColor ( dark , NumberUtils . floatToIntColor ( packedColor ) ) ; this . darkPacked = packedColor ;
changeInstrument: public ConsumableRecord changeInstrument ( int id ) { if ( playerData == null ) return null ; if ( isWounded ( ) ) return null ; final PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { if ( poc . getCurrentInstrument ( ) != null ) { if ( poc . getCurrentInstrument ( ) . getInstrument ( ) . isForceSelect ( ) ) { return null ; } } ConsumableRecord record = poc . setCurrentInstrument ( id ) ; if ( record != null ) { final PlayerRemoteComponent prc = playerData . getComponent ( PlayerRemoteComponent . class ) ; prc . setCurrentInstrument ( poc . getCurrentInstrument ( ) ) ; prc . setHookedInstrument ( poc . getHookedInstrument ( ) ) ; BrainOutServer . PostRunnable ( ( ) -> { if ( poc . getCurrentInstrument ( ) != null ) { Client client = getClient ( ) ; Instrument instrument = poc . getCurrentInstrument ( ) . getInstrument ( ) ; if ( client != null && instrument . hasComponent ( ServerSelectFreeplayEventComponent . class ) ) { if ( client instanceof PlayerClient ) { PlayerClient playerClient = ( ( PlayerClient ) client ) ; ModePayload payload = playerClient . getModePayload ( ) ; if ( payload instanceof FreePayload ) { FreePayload freePayload = ( ( FreePayload ) payload ) ; freePayload . questEvent ( FreePlayItemUsedEvent . obtain ( playerClient , instrument , 1 ) ) ; } } } BrainOutServer . Controller . getClients ( ) . sendTCP ( new RemoteUpdateInstrumentMsg ( playerData , poc . getCurrentInstrument ( ) , poc . getHookedInstrument ( ) ) ) ; } } ) ; updateAttachments ( ) ; return record ; } } return null ;
fibonacci: public static long [ ] fibonacci ( int n ) { long [ ] sequence ; if ( n == 1 ) { sequence = new long [ ] { 0 } ; } else if ( n == 2 ) { sequence = new long [ ] { 0 , 1 } ; } else { sequence = new long [ n ] ; sequence [ 0 ] = 0 ; sequence [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { sequence [ i ] = sequence [ i - 1 ] + sequence [ i - 2 ] ; } } return sequence ;
createUI: public Table createUI ( ) { Table root = new Table ( BrainOutClient . Skin ) ; { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( L . get ( "MENU_CLAN_DONATE" ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . expandX ( ) . center ( ) ; root . add ( header ) . height ( 32 ) . expandX ( ) . fillX ( ) . row ( ) ; } Table data = new Table ( BrainOutClient . Skin ) ; data . setBackground ( "form-border-red" ) ; { Label description = new Label ( L . get ( "MENU_CLAN_DONATE_AMOUNT" ) , BrainOutClient . Skin , "title-small" ) ; description . setWrap ( true ) ; description . setAlignment ( Align . center ) ; data . add ( description ) . expandX ( ) . fillX ( ) . pad ( 32 ) . padBottom ( 16 ) . row ( ) ; } { Image nuclearMaterial = new Image ( BrainOutClient . Skin , "icon-clan-resources" ) ; nuclearMaterial . setScaling ( Scaling . none ) ; data . add ( nuclearMaterial ) . size ( 32 ) . center ( ) . pad ( 12 ) . row ( ) ; } { LabeledSlider slider = new LabeledSlider ( this . amount , 1 , this . max , 1 ) { @ Override protected void onChanged ( int newValue ) { SendResourcesToClanMenu . this . amount = newValue ; } } ; data . add ( slider ) . width ( 256 ) . padBottom ( 32 ) . row ( ) ; } root . add ( data ) . minWidth ( 530 ) . expandX ( ) . fillX ( ) . row ( ) ; { Table buttons = new Table ( ) ; { TextButton close = new TextButton ( L . get ( "MENU_CLOSE" ) , BrainOutClient . Skin , "button-default" ) ; close . addListener ( new ClickListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; callback . cancel ( ) ; } } ) ; buttons . add ( close ) . uniformX ( ) . expandX ( ) . fillX ( ) . height ( 64 ) ; } { TextButton donate = new TextButton ( L . get ( "MENU_CLAN_DONATE" ) , BrainOutClient . Skin , "button-green" ) ; donate . addListener ( new ClickListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pop ( ) ; callback . approve ( amount ) ; } } ) ; buttons . add ( donate ) . uniformX ( ) . expandX ( ) . fillX ( ) . height ( 64 ) . row ( ) ; } root . add ( buttons ) . expandX ( ) . fillX ( ) . colspan ( 2 ) . row ( ) ; } return root ;
setDirty: public void setDirty ( ) { setDirty ( false ) ;
getFormattedValue: public String getFormattedValue ( float value , Entry entry , int dataSetIndex , ViewPortHandler viewPortHandler ) { return mFormat . format ( value ) ;
getRadius: void getRadius ( ) { assertEquals ( circle . getRadius ( ) , 10 ) ;
getMusic: public Music getMusic ( ) { return sound ;
getUpgradesLevel: private static int getUpgradesLevel ( String key , Array < Upgrade > upgrades , InstrumentInfo info ) { Upgrade upgrade = info . upgrades . get ( key ) ; int i = 1 ; for ( final Upgrade test : upgrades ) { if ( test == upgrade ) { return i ; } i ++ ; } return 0 ;
runOnUiThread: public static void runOnUiThread ( Runnable runnable ) { runOnUiThread ( DiscordTools . HANDLER , runnable ) ;
newActives: protected ActiveDataMap newActives ( int layerCount , String dimension ) { return new ActiveDataMap ( layerCount , dimension ) ;
removeMember: public boolean removeMember ( PlayerClient playerClient ) { String account = playerClient . getAccount ( ) ; synchronized ( members )
render: public void render ( ) { draw ( ) ;
hideCallButton: public static boolean hideCallButton ( boolean currentlyVisible ) { if ( currentlyVisible ) {
isAuditableClass: No method body
asFunction: default Function < T , R > asFunction ( ) { return t -> {
zoomOut: public Matrix zoomOut ( float x , float y ) { Matrix save = new Matrix ( ) ; zoomOut ( x , y , save ) ; return save ;
parse: private static FrontLightMode parse ( String modeString ) { return modeString == null ? OFF : valueOf ( modeString ) ;
updateOrCreate: public void updateOrCreate ( List < ProductSorting > model ) throws ApiErrorException , ConnectionException { this . request ( "post" , this . resolvePath ( "/product-sortings" ) , null , null , null , model ) ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; data . align ( Align . center ) ; header = new Table ( ) ; renderHeader ( ) ; data . add ( header ) . pad ( 8 ) . expandX ( ) . fillX ( ) . row ( ) ; eventInfoUi = new Table ( ) ; renderEventInfo ( ) ; data . add ( eventInfoUi ) . pad ( 8 ) . expand ( ) . fill ( ) . row ( ) ; if ( event . getEvent ( ) . group ) { Label notice = new Label ( L . get ( "MENU_EVENT_WEEKLY_INFO" ) , BrainOutClient . Skin , "title-small" ) ; notice . setAlignment ( Align . center ) ; data . add ( notice ) . pad ( 8 ) . expand ( ) . fillX ( ) . bottom ( ) . row ( ) ; } else { if ( isShootingRange ( event ) ) { Table whoa = new Table ( ) ; Label notice = new Label ( L . get ( "MENU_TRAINING_RANGE_EVENT" ) , BrainOutClient . Skin , "title-small" ) ; whoa . add ( notice ) . row ( ) ; data . add ( whoa ) . pad ( 8 ) . expandY ( ) . bottom ( ) . row ( ) ; } else { Label notice = new Label ( L . get ( "MENU_EVENT_INFO" ) , BrainOutClient . Skin , "title-small" ) ; notice . setAlignment ( Align . center ) ; data . add ( notice ) . pad ( 8 ) . expand ( ) . fillX ( ) . bottom ( ) . row ( ) ; } } return data ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton1ActionPerformed ( evt ) ;
getTitle: public String getTitle ( ) { return L . get ( "MENU_PROMO_TITLE" ) ;
getMaxGuildFileSize: public static long getMaxGuildFileSize ( Long channelId ) { if ( channelId == null ) { LogUtils . log ( TAG , "could not find current channel id" ) ; return - 1 ; } Channel channel = getChannelById ( channelId ) ; if ( channel == null ) { LogUtils . log ( TAG , "could not find channel by id " + channelId ) ; return - 1 ; } if ( channel . i ( ) <= 0 ) { return - 1 ; } Guild guild = getGuildById ( channel . i ( ) ) ; if ( guild == null ) { LogUtils . log ( TAG , "could not locate guild with ID " + channel . i ( ) ) ; return - 1 ; } long maxFileSize = PremiumUtils . INSTANCE . getGuildMaxFileSizeMB ( guild . getPremiumTier ( ) ) * 1048576L ; return maxFileSize ;
init: public void init ( ActionPhaseMenu menu ) { super . init ( menu ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . freePlaySummary , this ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . activeAction , this ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . simple , this ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . gameController , this ) ;
getFailedConditionLocalizedText: public String getFailedConditionLocalizedText ( ) { GameMode gameMode = BrainOutClient . ClientController . getGameMode ( ) ; if ( gameMode instanceof GameModeLobby ) { GameModeRealization realization = gameMode . getRealization ( ) ; if ( realization instanceof ClientLobbyRealization ) { if ( ( ( ClientLobbyRealization ) realization ) . isInShootingRangeMode ( ) ) { return "" ; } } } return L . get ( "MENU_DOOR_LOCKED_UP" ) ;
isCanBeStarted: public boolean isCanBeStarted ( ) { return canBeStarted ;
getID: public ID getID ( ) { return ID . endgame ;
received: public boolean received ( RespawnTimeMsg msg ) { BrainOut . EventMgr . sendDelayedEvent ( RespawnTimeEvent . obtain ( msg . time ) ) ; return true ;
getByRoleId: void getByRoleId ( ) throws Exception { Long roleId = 2L ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . get ( "/menu/getId/role/" + roleId ) . contentType ( MediaType . APPLICATION_JSON ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "根据角色 id 查询菜单 id 列表接口测试成功:{}" , map . get ( "data" ) ) ;
getAngle: No method body
newInstance: public Object newInstance ( String className ) { Class clazz = forName ( className ) ; if ( clazz != null ) { return instantiate ( clazz ) ; } return null ;
renderPartners: private void renderPartners ( ) { topStats . clear ( ) ; if ( ! hasPartner ( ) ) return ; RemoteClient me = BrainOutClient . ClientController . getMyRemoteClient ( ) ; if ( me == null ) return ; String myPartyId = me . getPartyId ( ) ; Table stats = new Table ( BrainOutClient . Skin ) ; stats . setBackground ( "form-default" ) ; topStats . add ( stats ) . pad ( 16 ) . expandX ( ) . left ( ) . top ( ) . row ( ) ; for ( ObjectMap . Entry < Integer , RemoteClient > entry : BrainOutClient . ClientController . getRemoteClients ( ) )
getFilteredResourceName: public String getFilteredResourceName ( ) { return filteredResourceName ;
read: public void read ( Json json , JsonValue jsonData ) { doorSprite = jsonData . getString ( "door-sprite" , "" ) ;
setReplenishPercentage: public void setReplenishPercentage ( float percentage ) { float p = percentage ; if ( p > 1 ) { p = 1 ; } else if ( p < 0f ) { p = 0f ; } this . replenishPercentage = p ;
init: public void init ( ) { BrainOutClient . EventMgr . subscribe ( Event . ID . badgeRead , this ) ;
compressBitmap: private static Bitmap compressBitmap ( String path ) { BitmapFactory . Options newOpts = new BitmapFactory . Options ( ) ; newOpts . inJustDecodeBounds = true ; BitmapFactory . decodeFile ( path , newOpts ) ; int w = newOpts . outWidth ; int h = newOpts . outHeight ; float width = 800f ; float height = 480f ; int be = 1 ; if ( w > h && w > width ) { be = ( int ) ( newOpts . outWidth / width ) ; } else if ( w < h && h > height ) { be = ( int ) ( newOpts . outHeight / height ) ; } if ( be <= 0 ) be = 1 ; newOpts . inSampleSize = be ; newOpts . inJustDecodeBounds = false ; return BitmapFactory . decodeFile ( path , newOpts ) ;
getDimension: public String getDimension ( ) { return animationData . getDimension ( ) ;
getForm: No method body
render: protected void render ( Table row ) { CheckBox checkBox = new CheckBox ( getTitle ( isChecked ( ) ) , BrainOutClient . Skin , "checkbox-default" ) ; checkBox . setChecked ( isChecked ( ) ) ; checkBox . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { setChecked ( checkBox . isChecked ( ) ) ; checkBox . setText ( getTitle ( checkBox . isChecked ( ) ) ) ; } } ) ; row . add ( checkBox ) . height ( 32 ) . padLeft ( - 4 ) . expandX ( ) . left ( ) . row ( ) ;
drawFade: protected void drawFade ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ;
createReactActivityDelegate: protected ReactActivityDelegate createReactActivityDelegate ( ) { return new DefaultReactActivityDelegate (
update: public ShopCountryWarehouse update ( String shopKey , String countryCode , Identifier warehouseIdentifier , ShopCountryWarehouse model ) throws ApiErrorException , ConnectionException { Class < ShopCountryWarehouse > responseModel = ( Class < ShopCountryWarehouse > ) ( Class < ? > ) ShopCountryWarehouse . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/warehouses/%s" , shopKey , countryCode , warehouseIdentifier ) , null , null , responseModel , model ) ;
setCropGridColor: public void setCropGridColor ( @ ColorInt int color ) { options . putInt ( EXTRA_CROP_GRID_COLOR , color ) ;
init: public static < A1 , A2 , A3 , CP > Flow < Tuple3 < A1 , A2 , A3 > , Tuple3 < A1 , A2 , A3 > , CP > init ( CP services , PageAttr < A1 > a1 , PageAttr < A2 > a2 , PageAttr < A3 > a3 , Tuple3 < A1 , A2 , A3 > t ) { return Flow . init ( services , t ) . thenSet ( a1 , a2 , a3 , a -> a . result ) ;
getResourceCategoryDict: No method body
setLaserStyle: public void setLaserStyle ( LaserStyle laserStyle ) { this . laserStyle = laserStyle ;
reset: public void reset ( ) { this . client = null ;
updateIcon: private void updateIcon ( ) { CSGame game = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( flagData . getTeam ( ) == null )
checkIfPrivilegeNameAlreadyExists: public boolean checkIfPrivilegeNameAlreadyExists ( String name , BindingResult br ) { throw new NotImplementedException ( NO_IMPLEMENTATION_IN_CORE_OPENKODA ) ;
setAuthenticationManager: public void setAuthenticationManager ( @ Lazy AuthenticationManager authenticationManager ) { super . setAuthenticationManager ( authenticationManager ) ;
hasGlobalOrOrgPrivilege: default boolean hasGlobalOrOrgPrivilege ( User u , String p , Long orgId ) { Collection < UserRole > urs = u . getRoles ( ) ; for ( UserRole ur : urs ) { if ( ur . isGlobal ( ) && ur . getRole ( ) . hasPrivilege ( p ) ) { return true ; } if ( ! ur . isGlobal ( ) && ur . getOrganizationId ( ) . equals ( orgId ) && ur . getRole ( ) . hasPrivilege ( p ) ) { return true ; } } return false ;
sendChanges: No method body
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
init: public void init ( ) { super . init ( ) ; updateSprite ( ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . simple , this ) ;
getAppType: public String getAppType ( ) { return appType ;
reloadClusterAware: public boolean reloadClusterAware ( long formId ) { debug ( "[reloadClusterAware] {}" , formId ) ; if ( ClusterHelper . isCluster ( ) ) { return clusterEventSenderService . reloadForm ( formId ) ; } return reloadForm ( formId ) ;
getWatchY: public float getWatchY ( ) { return playerData . getY ( ) + aimOffsetFolowing . y ;
onEvent: public boolean onEvent ( Event event ) { return realization . onEvent ( event ) ;
yes: public void yes ( ) { leaveClan ( ) ;
get: public Object get ( Object key ) { int bucket = getBucket ( key ) ; Entry entry = getElement ( key , table [ bucket ] ) ; if ( entry != null ) { return entry . getValue ( ) ; } return null ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem2ActionPerformed ( evt ) ;
getPostRemovePrivilege: public PrivilegeBase getPostRemovePrivilege ( ) { return postRemovePrivilege != null ? postRemovePrivilege : defaultControllerPrivilege ;
onResourceReady: public void onResourceReady ( Bitmap bitmap , GlideAnimation < ? super Bitmap > glideAnimation ) { if ( context instanceof Activity && ( ( Activity ) context ) . isDestroyed ( ) ) { return ; } if ( callback != null ) {
UpdateParamToWhile: No method body
getComponent: public < T extends ContentComponent > T getComponent ( Class < T > classOf ) { return componentsIndex != null ? ( T ) componentsIndex . get ( classOf ) : null ;
containsBruteForce: public static boolean containsBruteForce ( String [ ] strings , String searched ) { for ( String string : strings ) { if ( string . equals ( searched ) ) { return true ; } } return false ;
hasLocalizedName: public boolean hasLocalizedName ( ) { return true ;
build: public DefaultNavigationBar build ( ) { return new DefaultNavigationBar ( P ) ;
registerMethodAdapter: public void registerMethodAdapter ( MethodAdapter methodAdapter ) { methodAdapterMap . put ( methodAdapter . getClassName ( ) , methodAdapter ) ; necessaryClasses . add ( methodAdapter . getClassName ( ) ) ;
setQRCode: public void setQRCode ( String QRCode ) { this . QRCode = QRCode ;
received: public boolean received ( RemoveRemoteClientMsg remoteCliemtMsg ) { removeRemoteClient ( remoteCliemtMsg . id ) ; return true ;
mouseDown: public boolean mouseDown ( Vector2 position , int button ) { spawnPosition . set ( position ) ; validatePosition ( ) ; if ( ! spawnValid ) return false ; BrainOutClient . ClientController . sendTCP ( new SpawnEditor2Msg ( spawnPosition . x , spawnPosition . y , Map . GetDimensionId ( getMenu ( ) . getDimension ( ) ) ) ) ; return true ;
setBezier: public void setBezier ( int bezier , int frame , int value , float time1 , float value1 , float cx1 , float cy1 , float cx2 , float cy2 , float time2 , float value2 ) { float [ ] curves = this . curves ; int i = getFrameCount ( ) + bezier * BEZIER_SIZE ; if ( value == 0 ) curves [ frame ] = BEZIER + i ; float tmpx = ( time1 - cx1 * 2 + cx2 ) * 0.03f , tmpy = cy2 * 0.03f - cy1 * 0.06f ; float dddx = ( ( cx1 - cx2 ) * 3 - time1 + time2 ) * 0.006f , dddy = ( cy1 - cy2 + 0.33333333f ) * 0.018f ; float ddx = tmpx * 2 + dddx , ddy = tmpy * 2 + dddy ; float dx = ( cx1 - time1 ) * 0.3f + tmpx + dddx * 0.16666667f , dy = cy1 * 0.3f + tmpy + dddy * 0.16666667f ; float x = time1 + dx , y = dy ; for ( int n = i + BEZIER_SIZE ; i < n ; i += 2 ) {
onFailure: public void onFailure ( TerminalException t ) { exitFut . completeExceptionally ( t ) ;
generate: private void generate ( ) { if ( instrumentComponent == null ) return ; if ( ! generated )
getAutoPlayGifs: public final boolean getAutoPlayGifs ( ) { return this . autoPlayGifs ;
getViewById: public < T extends View > T getViewById ( int mViewId ) { View view = null ; WeakReference < View > weakView = mViews . get ( mViewId ) ; if ( weakView != null ) { view = weakView . get ( ) ; } if ( view == null && mViewId != 0 ) { view = mContentView . findViewById ( mViewId ) ; } return ( T ) view ;
setLoadNoData: public void setLoadNoData ( boolean isNoData ) { this . mIsLoadNoData = isNoData ; setLoadEnable ( false ) ; if ( mLoadCreator != null ) {
setTakeSpeed: public void setTakeSpeed ( float takeSpeed ) { this . takeSpeed = takeSpeed ;
setUp: void setUp ( ) { m = new MyHashMap ( ) ; m . put ( 1 , "Nicola" ) ; m . put ( 2 , "Agata" ) ; m . put ( 3 , "Marzia" ) ;
logGetFail: private void logGetFail ( @ NonNull Call call , @ NonNull IOException e , Map < String , Object > params ) { LogUtils . e ( TAG , "\n" ) ; LogUtils . e ( TAG , "*\n" ) ; LogUtils . e ( TAG , "  | ===============================================================start" + "================================================================" ) ; LogUtils . e ( TAG , "  | Get请求失败：" + e . getMessage ( ) ) ; LogUtils . e ( TAG , "  | RequestUrl：" + call . request ( ) . url ( ) ) ; LogUtils . e ( TAG , "  | RequestParams：" + params . toString ( ) ) ; LogUtils . e ( TAG , "  | ===============================================================end" + "================================================================" ) ; LogUtils . e ( TAG , "*\n" ) ; LogUtils . e ( TAG , "\n" ) ;
init: public void init ( ) { super . init ( ) ; final Map map = Map . Get ( BlockData . CURRENT_DIMENSION ) ; if ( map == null ) return ; BlockData blockData = ( ( BlockData ) getComponentObject ( ) ) ; if ( blockData == null ) return ; final int blockX = BlockData . CURRENT_X , blockY = BlockData . CURRENT_Y , blockLayer = BlockData . CURRENT_LAYER ; checkBlocks ( map , blockData , blockX , blockY ) ; BrainOutServer . Timer . schedule ( new TimerTask ( )
getTarget: public BoneData getTarget ( ) { return target ;
run: public void run ( ) { EventBus . getDefault ( ) . post ( new CloseChannelEvent ( ) ) ; if ( mBasePopWindow != null ) { mBasePopWindow . dismiss ( ) ; } if ( mLoadingDialog != null ) { mLoadingDialog . dismiss ( ) ; } mSendSuccessDialog . show ( mContext . getString ( R . string . channel_close_success ) ) ;
getZIndex: public int getZIndex ( ) { return 15 ;
getMenuDictHandler: private List < MenuDictDto > getMenuDictHandler ( @ NonNull List < MenuDto > menuDtoList ) { return menuDtoList . stream ( ) . map ( menuDto -> {
getName: public String getName ( ) { return name ;
existsOne: No method body
divisionTest: void divisionTest ( ) { assertThrows ( IllegalArgumentException . class , ( ) -> Division . division ( - 1 , 0 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> Division . division ( 1 , 0 ) ) ; assertEquals ( 2.0 , Division . division ( 4.0 , 2.0 ) , 0.001 ) ; assertEquals ( - 2.0 , Division . division ( - 8.0 , 4.0 ) , 0.001 ) ;
addFakeActor: public < T extends Actor > Cell < T > addFakeActor ( T actor ) { return buttons . add ( actor ) ;
checkMacaroonPermissions: public Single < lnrpc . LightningOuterClass . CheckMacPermResponse > checkMacaroonPermissions ( lnrpc . LightningOuterClass . CheckMacPermRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . checkMacaroonPermissions ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
setShowCandleBar: public void setShowCandleBar ( boolean showCandleBar ) { mShowCandleBar = showCandleBar ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; if ( ! isEnoughRU ( ) ) { addMoreRU ( ) ; return ; } if ( getItemsWeight ( ) > maxWeight ) { Menu . playSound ( MenuSound . denied ) ; return ; } fulfillOrder ( ) ;
getContentView: public View getContentView ( ) { return mContentView ;
show: public void show ( ) { if ( mAlertDialog == null ) { mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme_loading ) . setWidthAndHeight ( MATCH_PARENT , MATCH_PARENT ) . setContentView ( com . omni . wallet . R . layout . layout_dialog_login_loading ) . setCanceledOnTouchOutside ( false ) . setCancelable ( mCancelable ) . setOnDismissListener ( mDismissListener ) . create ( ) ; } long syncedHeight = blockData . getInt ( "currentBlockHeight" , 0 ) ; updateSyncDataView ( mAlertDialog , syncedHeight ) ; TextView blockNumSyncTextView = mAlertDialog . getViewById ( R . id . block_num_sync ) ; blockNumSyncTextView . setText ( String . format ( "%.0f" , totalBlock ) ) ; new Thread ( ( ) -> { obdLogFileObserver . startWatching ( ) ; } ) . run ( ) ; new Thread ( ( ) -> { blockData . registerOnSharedPreferenceChangeListener ( currentBlockSharePreferenceChangeListener ) ; } ) ; ImageView waitingIcon = mAlertDialog . getViewById ( R . id . iv_dialog_loading ) ; if ( ! mAlertDialog . isShowing ( ) ) { mAlertDialog . show ( ) ; } waitingIcon . setLayerType ( View . LAYER_TYPE_HARDWARE , null ) ; mRotationAnimator = ObjectAnimator . ofFloat ( waitingIcon , "rotation" , 0 , 359f ) ; mRotationAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mRotationAnimator . setDuration ( 4000 ) ; mRotationAnimator . setRepeatCount ( ObjectAnimator . INFINITE ) ; mRotationAnimator . start ( ) ;
onDeath: public void onDeath ( Client client ) { deathsRate . onDeath ( ) ;
getFileName: public String getFileName ( ) { return fileName ;
clear: private static void clear ( ) { Global . activeTransformers . getOrDefault ( EXEC_CLASS , new HashMap < > ( ) ) . values ( ) . forEach ( baseClassTransformers -> { baseClassTransformers . forEach ( transformer -> { Global . instrumentation . removeTransformer ( transformer ) ; Global . transformers . remove ( transformer ) ; } ) ; } ) ; Global . activeTransformers
getWCD: public ClientWeaponComponentData getWCD ( ) { return ClientWeaponComponentData . this ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { tgValvesStopItemStateChanged ( evt ) ;
obtain: public static Event obtain ( RemoteClient remoteClient ) { RemoteClientUpdatedEvent e = obtain ( RemoteClientUpdatedEvent . class ) ; if ( e == null ) return null ; return e . init ( remoteClient ) ;
createNewRoleByTypeAnyTestException: public void createNewRoleByTypeAnyTestException ( ) { EventListenerEntry listenerEntry = new EventListenerEntry ( "com.openkoda.core.service.event.ApplicationEvent" , "USER_CREATED" , "com.openkoda.model.User" , "com.openkoda.core.service.event.EventListenerService" , "printSth" ) ; listenerEntry . setId ( 123L ) ; doCallRealMethod ( ) . when ( applicationEventService ) . registerEventListener ( any ( ) , any ( EventConsumer . class ) , any ( ) , any ( ) , any ( ) , any ( ) , any ( ) ) ; when ( eventListenerRepository . findOne ( 123L ) ) . thenReturn ( listenerEntry ) ; eventListenerService . loadFromDb ( listenerEntry . getId ( ) ) ;
close: public void close ( ) throws Exception { if ( t != null ) t . interrupt ( ) ;
d: private String d ( ) { ItemData itemData = ( ( ItemData ) getComponentObject ( ) ) ; return itemData . getDimension ( ) ;
clipEnd: public void clipEnd ( ) { if ( clipAttachment == null ) return ; clipAttachment = null ; clippingPolygons = null ; clippedVertices . clear ( ) ; clippedTriangles . clear ( ) ; clippingPolygon . clear ( ) ;
hasCache: public boolean hasCache ( ) { return spriteData . isCache ( ) ;
findAll: public List < DynamicPrivilege > findAll ( ) { return dynamicPrivilegeRepository . findAll ( ) ;
getOwner: public ActiveData getOwner ( ) { InstrumentData instrumentData = ( ( InstrumentData ) getComponentObject ( ) ) ; if ( instrumentData == null ) return null ; return instrumentData . getOwner ( ) ;
getRewardTaskKey: private String getRewardTaskKey ( ) { return "rw_" + taskKey ;
getBio: public final String getBio ( ) { return null ; }
play: protected void play ( ) { if ( soundId == - 1 )
addExtension: public void addExtension ( String name , int dataStart , int length , boolean map ) { Extension ex = new Extension ( ) ; ex . dataStart = dataStart ; ex . length = length ; ex . map = map ; extensions . put ( name , ex ) ;
releaseClientTeam: public void releaseClientTeam ( Client client ) { if ( client . getTeam ( ) != null )
release: public void release ( ) { if ( mBasePopWindow != null ) {
createOrganization: public Organization createOrganization ( String organizationName , Integer assignedDatasource ) { debug ( "[createOrganization] {}" , organizationName ) ; Organization result = repositories . unsecure . organization . save ( new Organization ( organizationName , assignedDatasource ) ) ; multitenancyService . createTenant ( result . getId ( ) ) ; services . applicationEvent . emitEvent ( ApplicationEvent . ORGANIZATION_CREATED , new OrganizationDto ( result ) ) ; return result ;
stringToAppearencesMap: private static Map < Character , Integer > stringToAppearencesMap ( String string ) { Map < Character , Integer > appearances = new HashMap < > ( ) ; for ( Character c : string . toLowerCase ( ) . toCharArray ( ) ) { int numOfAppearances = appearances . getOrDefault ( c , 0 ) ; appearances . put ( c , numOfAppearances + 1 ) ; } return appearances ;
onRequestPermissionFailure: public void onRequestPermissionFailure ( List < String > permissions ) { LogUtils . e ( TAG , "扫码页面摄像头权限拒绝" ) ;
init: private Event init ( Action action , Vector2 data , boolean flag ) { this . action = action ; this . data = data ; this . flag = flag ; return this ;
getMixX: public float getMixX ( ) { return mixX ;
renderFilters: private void renderFilters ( Table filters ) { { SelectBox < ClientController . RegionWrapper > checkBox = new SelectBox < > ( BrainOutClient . Skin , "select-badged" ) ; ClientController . RegionWrapper select = anyRegion ; Array < ClientController . RegionWrapper > items = new Array < > ( ) ; items . add ( anyRegion ) ; for ( ClientController . RegionWrapper region : BrainOutClient . ClientController . getRegions ( ) ) { items . add ( region ) ; } if ( filter . getRegion ( ) != null ) { for ( ClientController . RegionWrapper region : BrainOutClient . ClientController . getRegions ( ) ) { if ( region . region . name . equals ( filter . getRegion ( ) ) ) { select = region ; break ; } } } checkBox . setItems ( items ) ; checkBox . setSelected ( select ) ; filters . add ( checkBox ) . height ( 32 ) . expandX ( ) . fillX ( ) . pad ( 8 ) . padRight ( 0 ) ; Image regionIcon = new Image ( ) ; regionIcon . setScaling ( Scaling . none ) ; regionIcon . setTouchable ( Touchable . disabled ) ; filters . add ( regionIcon ) . padLeft ( - 40 ) . padRight ( 0 ) . size ( 24 , 16 ) ; if ( select != anyRegion ) { String flag = select . region . settings != null ? select . region . settings . optString ( "flag" , null ) : null ; if ( flag != null ) { TextureAtlas . AtlasRegion flagRegion = BrainOutClient . getRegion ( flag ) ; if ( flagRegion != null ) { regionIcon . setDrawable ( new TextureRegionDrawable ( flagRegion ) ) ; } } } checkBox . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { Menu . playSound ( MenuSound . select ) ; if ( checkBox . getSelected ( ) != anyRegion ) { filter . setRegion ( checkBox . getSelected ( ) . region . name ) ; String flag = checkBox . getSelected ( ) . region . settings != null ? checkBox . getSelected ( ) . region . settings . optString ( "flag" , null ) : null ; if ( flag != null ) { regionIcon . setDrawable ( new TextureRegionDrawable ( BrainOutClient . getRegion ( flag ) ) ) ; } } else { filter . setRegion ( null ) ; regionIcon . setDrawable ( null ) ; } refreshRooms ( ) ; } } ) ; } if ( mode == Mode . standard ) { CheckBox checkBox = new CheckBox ( L . get ( "MENU_MY_LEVEL_ONLY" ) , BrainOutClient . Skin , "checkbox-default" ) ; checkBox . setChecked ( filter . isMyLevelOnly ( ) ) ; checkBox . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; filter . setMyLevelOnly ( checkBox . isChecked ( ) ) ; refreshRooms ( ) ; } } ) ; filters . add ( checkBox ) . pad ( 8 ) ; } filter . setIgnoreMyLevelOnly ( mode == Mode . workshop ) ; {
received: public boolean received ( final MoveObjectsMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; ObjectSet < ActiveData > items = new ObjectSet < > ( ) ; for ( int objectId : msg . o ) { ActiveData activeData = map . getActives ( ) . get ( objectId ) ; if ( activeData == null ) return ; if ( activeData . getComponent ( SpriteWithBlocksComponentData . class ) == null && activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) == null ) return ; items . add ( activeData ) ; } for ( ActiveData activeData : items ) { SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; int x = ( int ) ( activeData . getX ( ) + msg . x ) , y = ( int ) ( activeData . getY ( ) + msg . y ) ; if ( ! sp . validateBlocksForAdding ( map , x , y , items ) ) return ; } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { int x = ( int ) ( activeData . getX ( ) + msg . x ) , y = ( int ) ( activeData . getY ( ) + msg . y ) ; if ( ! us . validateBlocksForAdding ( map , x , y , items ) ) return ; } else { return ; } } } for ( ActiveData activeData : items ) { SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; int layer = sp . getBlocksLayer ( ) ; int x_ = ( int ) activeData . getX ( ) , y_ = ( int ) activeData . getY ( ) ; for ( int j = 0 ; j < sp . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < sp . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; map . setBlock ( x , y , null , layer , false , false ) ; } } } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { UserSpriteWithBlocksComponent sp = us . getContentComponent ( ) ; int layer = sp . getBlocksLayer ( ) ; int x_ = ( int ) activeData . getX ( ) , y_ = ( int ) activeData . getY ( ) ; for ( int j = 0 ; j < us . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < us . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; map . setBlock ( x , y , null , layer , false , false ) ; } } } } } for ( ActiveData activeData : items ) { SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; int layer = sp . getBlocksLayer ( ) ; int x_ = ( int ) ( activeData . getX ( ) + msg . x ) , y_ = ( int ) ( activeData . getY ( ) + msg . y ) ; activeData . setLayer ( sp . getBlocksLayer ( ) ) ; activeData . setzIndex ( sp . getzIndex ( ) ) ; activeData . setPosition ( x_ , y_ ) ; activeData . updated ( ) ; for ( int j = 0 ; j < sp . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < sp . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; BlockData b ; if ( sp . hasOnlyOneUnderlyingBlock ( ) ) { Block underlyingBlock = sp . getUnderlyingBlock ( ) ; b = underlyingBlock . getBlock ( ) ; } else { Block underlyingBlock = sp . getUnderlyingBlockAt ( i , j ) ; b = underlyingBlock . getBlock ( ) ; } SpriteBlockComponentData sbc = b . getComponent ( SpriteBlockComponentData . class ) ; if ( sbc != null ) { sbc . setSprite ( activeData ) ; } map . setBlock ( x , y , b , sp . getBlocksLayer ( ) , false , false ) ; } } } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; UserSpriteWithBlocksComponent sp = us . getContentComponent ( ) ; int layer = sp . getBlocksLayer ( ) ; Block underlyingBlock = sp . getUnderlyingBlock ( ) ; int x_ = ( int ) ( activeData . getX ( ) + msg . x ) , y_ = ( int ) ( activeData . getY ( ) + msg . y ) ; activeData . setLayer ( sp . getBlocksLayer ( ) ) ; activeData . setzIndex ( sp . getzIndex ( ) ) ; activeData . setPosition ( x_ , y_ ) ; activeData . updated ( ) ; for ( int j = 0 ; j < us . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < us . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; BlockData b = underlyingBlock . getBlock ( ) ; SpriteBlockComponentData sbc = b . getComponent ( SpriteBlockComponentData . class ) ; if ( sbc != null ) { sbc . setSprite ( activeData ) ; } map . setBlock ( x , y , b , sp . getBlocksLayer ( ) , false , false ) ; } } } } } ) ; return true ;
encode: static public String encode ( final byte [ ] bytes ) { StringBuffer base32 = new StringBuffer ( ( bytes . length * 8 + 4 ) / 5 ) ; int currByte , digit , i = 0 ; while ( i < bytes . length ) { currByte = bytes [ i ++ ] & 255 ; base32 . append ( base32Chars . charAt ( currByte > > 3 ) ) ; digit = ( currByte & 7 ) << 2 ; if ( i >= bytes . length ) { base32 . append ( base32Chars . charAt ( digit ) ) ; break ; } currByte = bytes [ i ++ ] & 255 ; base32 . append ( base32Chars . charAt ( digit | ( currByte > > 6 ) ) ) ; base32 . append ( base32Chars . charAt ( ( currByte > > 1 ) & 31 ) ) ; digit = ( currByte & 1 ) << 4 ; if ( i >= bytes . length ) { base32 . append ( base32Chars . charAt ( digit ) ) ; break ; } currByte = bytes [ i ++ ] & 255 ; base32 . append ( base32Chars . charAt ( digit | ( currByte > > 4 ) ) ) ; digit = ( currByte & 15 ) << 1 ; if ( i >= bytes . length ) { base32 . append ( base32Chars . charAt ( digit ) ) ; break ; } currByte = bytes [ i ++ ] & 255 ; base32 . append ( base32Chars . charAt ( digit | ( currByte > > 7 ) ) ) ; base32 . append ( base32Chars . charAt ( ( currByte > > 2 ) & 31 ) ) ; digit = ( currByte & 3 ) << 3 ; if ( i >= bytes . length ) { base32 . append ( base32Chars . charAt ( digit ) ) ; break ; } currByte = bytes [ i ++ ] & 255 ; base32 . append ( base32Chars . charAt ( digit | ( currByte > > 5 ) ) ) ; base32 . append ( base32Chars . charAt ( currByte & 31 ) ) ; } return base32 . toString ( ) ;
getLayer: public int getLayer ( ) { return 0 ;
show: public void show ( ) { showWaitingDialog ( "" ) ;
getFormatter: public static DateTimeFormatter getFormatter ( ) { return DateTimeFormatter . ofPattern ( "yyyy-MM-dd_HH-mm-ss" ) ;
error: default void error ( String message , Throwable throwable ) { getLogger ( ) . error ( message , throwable ) ; logToDebugStack ( throwable , message ) ;
getClearAndGet: protected TestInvocationBuilder getClearAndGet ( ) { return testDefinitionForVirtualObject (
init: public void init ( ) { instrumentData . init ( ) ;
readFile: public static byte [ ] readFile ( File file ) { if ( file == null ) { return new byte [ 0 ] ; } try ( FileInputStream fileInputStream = new FileInputStream ( file ) ; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ) { byte [ ] b = new byte [ 1024 ] ; int n ; while ( ( n = fileInputStream . read ( b ) ) != - 1 ) { byteArrayOutputStream . write ( b , 0 , n ) ; } return byteArrayOutputStream . toByteArray ( ) ; } catch ( Exception e ) { logger . error ( "Convert binary file to byte array fail." , e ) ; } return new byte [ 0 ] ;
playMusic: public com . badlogic . gdx . audio . Music playMusic ( String id ) { return playMusic ( id , false ) ;
Write: public static void Write ( FileHandle handle , Pixmap pix ) throws IOException { ImageIO . write ( pixmapToBufferedImage ( pix ) , "JPG" , handle . file ( ) ) ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; shareLayout . setVisibility ( View . GONE ) ;
bg: public boolean bg ( ) { return true ;
createWithJson: No method body
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; if ( jsonData . has ( "cards" ) )
sendPayment: No method body
renderGrid: private void renderGrid ( Batch batch , RenderContext context ) { Editor2Map map = Map . Get ( getDimension ( ) , Editor2Map . class ) ; if ( map == null ) return ; int w = map . getWidth ( ) , h = map . getHeight ( ) ; batch . end ( ) ; Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; Gdx . gl20 . glLineWidth ( 2 ) ; ShapeRenderer shapes = BrainOutClient . ShapeRenderer ; shapes . setProjectionMatrix ( map . getProjectionMatrix ( ) ) ; shapes . begin ( ShapeRenderer . ShapeType . Filled ) ; shapes . setColor ( background ) ; shapes . rect ( 0 , 0 , w , h ) ; shapes . end ( ) ; shapes . begin ( ShapeRenderer . ShapeType . Line ) ; shapes . setProjectionMatrix ( map . getProjectionMatrix ( ) ) ; shapes . setColor ( dashes ) ; for ( int j = 1 ; j <= h ; j += 2 ) { shapes . line ( 0 , j , w , j ) ; } for ( int j = 1 ; j <= w ; j += 2 ) { shapes . line ( j , 0 , j , h ) ; } shapes . setColor ( lines ) ; for ( int j = 0 ; j <= h ; j += 2 ) { shapes . line ( 0 , j , w , j ) ; } for ( int j = 0 ; j <= w ; j += 2 ) { shapes . line ( j , 0 , j , h ) ; } shapes . setColor ( lines ) ; for ( int j = 0 ; j <= h ; j += 2 ) { shapes . line ( 0 , j , w , j ) ; } for ( int j = 0 ; j <= w ; j += 2 ) { shapes . line ( j , 0 , j , h ) ; } shapes . setColor ( 0.5f , 1 , 0.5f , 0.5f ) ; int bw = map . getBlocks ( ) . getBlockWidth ( ) , bh = map . getBlocks ( ) . getBlockHeight ( ) ; for ( int j = 0 ; j <= bh ; j ++ ) { shapes . line ( 0 , j * Constants . Core . CHUNK_SIZE , bw * Constants . Core . CHUNK_SIZE , j * Constants . Core . CHUNK_SIZE ) ; } for ( int j = 0 ; j <= bw ; j ++ ) { shapes . line ( j * Constants . Core . CHUNK_SIZE , 0 , j * Constants . Core . CHUNK_SIZE , bh * Constants . Core . CHUNK_SIZE ) ; } shapes . end ( ) ; batch . begin ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; addMoreRU ( ) ;
clearAssetManagers: private void clearAssetManagers ( ) { for ( AssetManager manager : assetManagers ) { manager . dispose ( ) ; manager . clear ( ) ; } bound . clear ( ) ;
detachCarrier: public void detachCarrier ( Identifier merchantIdentifier , Identifier carrierIdentifier , String countryCode ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/merchants/%s/carriers/%s/countries/%s" , merchantIdentifier , carrierIdentifier , countryCode ) , null , null , null ) ;
setPath: public void setPath ( String path ) { this . path = path ;
end: private void end ( SyscallsInternal syscalls , @ Nullable Throwable exception ) { if ( exception == null || Util . containsSuspendedException ( exception ) ) {
received: public boolean received ( final FlipCard msg ) { notifyCardEvent ( msg ) ; return true ;
setHullLength: public void setHullLength ( int hullLength ) { this . hullLength = hullLength ;
getKeepMode: public BooleanOption getKeepMode ( ) { return keepMode ;
getTitleViewByIndex: No method body
init: public void init ( ) { super . init ( ) ; BrainOutClient . EventMgr . subscribeAt ( Event . ID . setMyPlayer , this , true ) ;
setSuffix: public void setSuffix ( String [ ] suffix ) { this . mSuffix = suffix ;
getFormattedValue: public String getFormattedValue ( float value , Entry entry , int dataSetIndex , ViewPortHandler viewPortHandler ) { return mFormat . format ( value ) + " %" ;
getSteamInflow: public double getSteamInflow ( ) { return lastStepSteamInflow ;
delete: public void delete ( String attributeGroupName ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/attribute-groups/%s" , attributeGroupName ) , null , null , null ) ;
FindDoors: public static boolean FindDoors ( float fromX , float fromY , Map from , Map to , Vector2 in , Vector2 out ) { Array < ActiveData > actives = from . getActivesForTag ( Constants . ActiveTags . PORTAL , activeData -> { ServerPortalComponentData sp = activeData . getComponent ( ServerPortalComponentData . class ) ; if ( sp == null ) return false ; PortalData otherPortal = sp . getOtherPortal ( ) ; if ( otherPortal == null ) return false ; return otherPortal . getMap ( ) == to ; } ) ; if ( actives . size <= 0 ) { return false ; } actives . sort ( ( o1 , o2 ) -> { float d1 = Vector2 . dst2 ( fromX , fromY , o1 . getX ( ) , o1 . getY ( ) ) ; float d2 = Vector2 . dst2 ( fromX , fromY , o2 . getX ( ) , o2 . getY ( ) ) ; return ( int ) ( d1 - d2 ) ; } ) ; ActiveData door = actives . first ( ) ; ServerPortalComponentData sp = door . getComponent ( ServerPortalComponentData . class ) ; if ( sp == null ) return false ; PortalData otherPortal = sp . getOtherPortal ( ) ; if ( otherPortal == null ) return false ; in . set ( door . getX ( ) , door . getY ( ) ) ; out . set ( otherPortal . getX ( ) , otherPortal . getY ( ) ) ; return true ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { filter1RegItemStateChanged ( evt ) ;
getSource: public JRPCServerChannelHandler getSource ( ) { return source ;
getGitHubRepoOwner: public String getGitHubRepoOwner ( ) { return gitHubRepoOwner ;
checkNetState: public HttpUtils checkNetState ( boolean checked ) { this . mCheckNetState = checked ; return this ;
getComponent: public AutoRemoveComponentData getComponent ( ComponentObject componentObject ) { return new AutoRemoveComponentData ( ( ActiveData ) componentObject , this ) ;
validate: No method body
setOffsetShearY: public void setOffsetShearY ( float offsetShearY ) { this . offsetShearY = offsetShearY ;
setRightText: public void setRightText ( CharSequence rightText ) { D params = ( D ) getParams ( ) ; addRightTextView ( params ) ; setVisibility ( R . id . rl_right , View . VISIBLE ) ; setText ( R . id . tv_right , String . valueOf ( rightText ) ) ;
update: public void update ( float dt ) { super . update ( dt ) ; if ( SteamAPI . isSteamRunning ( ) )
getBlock: No method body
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/PromotionV1UpdateRequest.json" ) ; PromotionV1 requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , PromotionV1 . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; PromotionV1 responseEntity = this . api . promotionV1s ( ) . update ( "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/PromotionV1UpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
addDropOff: public void addDropOff ( DropOff dropOff ) { this . dropOffs . add ( dropOff ) ;
deleteSlackConfig: public Object deleteSlackConfig ( @ PathVariable ( ORGANIZATIONID ) Long orgId ) { debug ( "[deleteSlackConfig] OrgId: {}" , orgId ) ; integrationService . cleanOrgConfig ( _SLACK , orgId ) ; String configUrl = services . url . moduleSettings ( INTEGRATION , null , orgId ) ; return "generic-forms::go-to(url='" + configUrl + "')" ;
init: private Event init ( PlayerClient player , InstrumentData instrumentData ) { this . player = player ; this . instrumentData = instrumentData ; return this ;
applyChanges: No method body
getContentRect: No method body
getChip: public ServerChipComponentData getChip ( ) { for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : itemData . getRecords ( ) . getData ( ) ) { ConsumableRecord record = entry . value ; ServerChipComponentData chip = checkRecord ( record ) ; if ( chip != null ) { return chip ; } } return null ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { coolingCavitActionPerformed ( evt ) ;
discard: public void discard ( ) { this . setVisible ( false ) ;
getTime: public String getTime ( ) { return time ;
apiV2SecurityFilterChain: public SecurityFilterChain apiV2SecurityFilterChain ( HttpSecurity http ) throws Exception { return apiV2HttpSecurity ( http ) . build ( ) ;
findSchedulersFlow: protected PageModelMap findSchedulersFlow ( String schedulerSearchTerm , Specification < Scheduler > schedulerSpecification , Pageable schedulerPageable ) { debug ( "[findSchedulersFlow] search {}" , schedulerSearchTerm ) ; return Flow . init ( )
applyView: public void applyView ( ) { D params = ( D ) getParams ( ) ; setBackGroundResource ( R . id . layout_title_parent , params . mTitleBgColorRes ) ; setBackgroundColor ( R . id . view_top_bar , params . mTopViewBgColorRes ) ; setTitleBgAlpha ( R . id . layout_title_parent , params . mTitleBgAlpha ) ; setBackGroundResource ( R . id . iv_back , params . mLeftIcon ) ; setText ( R . id . tv_title , params . mTitleText ) ; if ( params . mTitleTextColor != 0 ) { setTextColor ( R . id . tv_title , params . mTitleTextColor ) ; } setText ( R . id . tv_left_title , params . mLeftTitleText ) ; if ( params . mShowContentTopShadow ) { setContentTopShadow ( params ) ; } if ( params . mAddRightText ) { addRightTextView ( params ) ; setText ( R . id . tv_right , params . mRightText ) ; if ( params . mRightTextColor != 0 ) { setTextColor ( R . id . tv_right , params . mRightTextColor ) ; } } if ( params . mAddRightView ) { addRightView ( params . mRightView ) ; } setVisibility ( R . id . rl_right , params . mRightVisibility ) ; setClickListener ( R . id . rl_right , params . mRightClickListener ) ; setClickListener ( R . id . iv_back , params . mLeftClickListener ) ; setVisibility ( R . id . iv_back , params . mLeftIconVisible ) ; setVisibility ( R . id . rg_middle_tab , params . mMiddleTabVisible ) ; setVisibility ( R . id . bottom_line , params . mBottomLineVisibility ) ; setImage ( 0 , params . mTitleImage ) ; if ( params . mMiddleTabVisible == View . VISIBLE ) { initMiddleView ( params ) ; } if ( params . mIsImmersive ) {
write: public void write ( Json json ) { json . writeValue ( "id" , id ) ; json . writeValue ( "password" , password ) ; super . write ( json ) ;
update: public void update ( float dt ) { super . update ( dt ) ; if ( particle == null ) return ; WeaponAnimationComponentData wac = instrumentData . getComponent ( WeaponAnimationComponentData . class ) ; if ( wac != null ) { float offset = wac . getAngle ( ) ; if ( wac . getFlipX ( ) ) offset = - offset ; particle . setAngleOffset ( offset ) ; } if ( ! instrumentData . getDimension ( ) . equals ( initialDimension ) )
show: public void show ( final View view ) { if ( mBasePopWindow == null ) {
populateTo: No method body
getProfilePicture: public String getProfilePicture ( ) { return profilePicture ;
findFile: protected PageModelMap findFile ( Long organizationId , long fileId ) { debug ( "[findFile] fileId: {}" , fileId ) ; return Flow . init ( fileId )
getReadNotifications: public List < ReadNotification > getReadNotifications ( ) { return readNotifications ;
onError: public void onError ( Exception e ) { if ( e . getMessage ( ) . equals ( "EOF" ) ) { return ; } LogUtils . e ( TAG , "------------------sendPaymentOnError------------------" + e . getMessage ( ) ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
getUVs: public float [ ] getUVs ( ) { return uvs ;
attach: default Res attach ( ) throws IngressException { return attach ( RequestOptions . DEFAULT ) ;
setVisibleYRangeMinimum: public void setVisibleYRangeMinimum ( float minYRange , AxisDependency axis ) { float yScale = getAxisRange ( axis ) / minYRange ; mViewPortHandler . setMaximumScaleX ( yScale ) ;
reverseOrder: protected boolean reverseOrder ( ) { return true ;
resetMissionControl: No method body
getID: public ID getID ( ) { return ID . killedBy ;
getTextColor: public int getTextColor ( ) { return textColor ;
stopLoad: public void stopLoad ( ) { if ( mCurrentLoadStatus == LOAD_STATUS_NORMAL ) { return ; } if ( mIsLoadNoData ) { mCurrentLoadStatus = LOAD_STATUS_LOAD_NO_DATA ; } else { mCurrentLoadStatus = LOAD_STATUS_NORMAL ; } restoreLoadView ( ) ; if ( mLoadCreator != null ) {
getWaterInflow1Temp: public double getWaterInflow1Temp ( ) { return waterInflowTemperature1 ;
find: private boolean find ( ) { ServerMap map = getMap ( ServerMap . class ) ; if ( map == null ) return false ; for ( ActiveData chip : map . getActivesForTag ( Constants . ActiveTags . CHIP , false ) ) { if ( chip instanceof ItemData ) { ItemData itemData = ( ( ItemData ) chip ) ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : itemData . getRecords ( ) . getData ( ) ) { ConsumableRecord record = entry . value ; if ( checkRecord ( record ) ) { setOwner ( null ) ; return true ; } } } } for ( ActiveData player : map . getActivesForTag ( Constants . ActiveTags . PLAYERS , false ) ) { PlayerOwnerComponent poc = player . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : poc . getConsumableContainer ( ) . getData ( ) ) { ConsumableRecord record = entry . value ; if ( checkRecord ( record ) ) { setOwner ( player . getTeam ( ) ) ; return true ; } } } } return false ;
getWorkflowOverrides: public BulkWorkflowOverridesResponse getWorkflowOverrides ( final GetWorkflowOverrideRequest request ) throws IOException , NovuNetworkException { try {
mouseMove: public boolean mouseMove ( Vector2 position ) { mouseBlockX = ( int ) ( position . x ) ; mouseBlockY = ( int ) ( position . y ) ; processPlacement ( position ) ; return true ;
setReGetText: public void setReGetText ( String mReGetText ) { this . mReGetText = mReGetText ;
formatMessage: default String formatMessage ( String format , Object ... arguments ) { FormattingTuple ft = MessageFormatter . arrayFormat ( format , arguments ) ; return ft . getMessage ( ) ;
downloadFile: private void downloadFile ( View view , String fileName , String filePath , String downloadUrl , OnDownloadListener onDownloadListener ) { downloadingRequest = PRDownloader . download ( downloadUrl , filePath , fileName ) . build ( ) . setOnStartOrResumeListener ( ( ) -> { double total = fileName . equals ( MANIFEST_FILE_NAME ) ? ( double ) downloadingRequest . getTotalBytes ( ) / 1024 : ( double ) downloadingRequest . getTotalBytes ( ) / 1024 / 1024 ; switch ( fileName ) { case BLOCK_HEADER_FILE_NAME : setStartViewText ( view , total , mContext . getString ( R . string . download_header ) , fileName ) ; break ; case REG_FILTER_HEADER_FILE_NAME : setStartViewText ( view , total , mContext . getString ( R . string . download_filter_header ) , fileName ) ; break ; case NEUTRINO_FILE_NAME : setStartViewText ( view , total , mContext . getString ( R . string . download_db ) , fileName ) ; break ; case MANIFEST_FILE_NAME : setStartViewText ( view , total , mContext . getString ( R . string . download_manifest ) , fileName ) ; break ; } } ) . setOnProgressListener ( ( progress ) -> { double total = fileName . equals ( MANIFEST_FILE_NAME ) ? ( double ) progress . totalBytes / 1024 : ( double ) progress . totalBytes / 1024 / 1024 ; double current = fileName . equals ( MANIFEST_FILE_NAME ) ? ( double ) progress . currentBytes / 1024 : ( double ) progress . currentBytes / 1024 / 1024 ; setProgressViewText ( view , total , current ) ; } ) . setOnPauseListener ( ( ) -> ToastUtils . showToast ( mContext , fileName + " downloading is paused!" ) ) . setOnCancelListener ( ( ) -> ToastUtils . showToast ( mContext , fileName + " downloading is canceled!" ) ) ; switch ( fileName ) { case MANIFEST_FILE_NAME : downloadingId = 1 ; break ; case BLOCK_HEADER_FILE_NAME : downloadingId = 2 ; break ; case REG_FILTER_HEADER_FILE_NAME : downloadingId = 3 ; break ; case NEUTRINO_FILE_NAME : downloadingId = 4 ; break ; case PEER_FILE_NAME : downloadingId = 5 ; break ; } downloadingRequest . start ( onDownloadListener ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVStop2ActionPerformed ( evt ) ;
getComponent: public ClientLightComponentData getComponent ( ComponentObject componentObject ) { return new ClientLightComponentData ( ( ActiveData ) componentObject , this ) ;
setIndexString: public void setIndexString ( String indexString ) { this . indexString = indexString ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
recycleInstances: public static void recycleInstances ( List < MPPointF > instances ) { pool . recycle ( instances ) ;
isSysstatEnabled: private boolean isSysstatEnabled ( ) { debug ( "[isSysstatEnabled]" ) ; try { ProcessBuilder pBuilder = new ProcessBuilder ( catExecutable , "/etc/default/sysstat" ) ; Process p = pBuilder . start ( ) ; p . waitFor ( ) ; String sysstat = IOUtils . toString ( p . getInputStream ( ) ) ; if ( sysstat . contains ( "ENABLED=\"true\"" ) ) { return true ; } } catch ( IOException | InterruptedException e ) { error ( "Error occurred when trying to check if sysstat enabled" , e ) ; } return false ;
setPaymentType: public void setPaymentType ( PaymentType paymentType ) { this . paymentType = paymentType ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; start = assetManager . get ( startFileName , Sound . class ) ; loop = assetManager . get ( loopFileName , Sound . class ) ; stop = assetManager . get ( stopFileName , Sound . class ) ;
getSkeleton: public Skeleton getSkeleton ( ) { return skeleton ;
selectExistDepartByUserId: No method body
getCameraManager: public CameraManager getCameraManager ( ) { return mCaptureHelper . getCameraManager ( ) ;
execute: public String execute ( String [ ] args , Client client ) { PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( playState . getID ( ) != PlayState . ID . game ) return "Not in game" ; GameMode mode = ( ( ServerPSGame ) playState ) . getMode ( ) ; if ( mode . getID ( ) != GameMode . ID . free ) return "Not in freeplay" ; ServerFreeRealization free = ( ( ServerFreeRealization ) mode . getRealization ( ) ) ; int offset ; try { offset = args . length > 1 ? Integer . parseInt ( args [ 1 ] ) : 0 ; } catch ( NumberFormatException ignored ) { offset = 0 ; } long seconds = System . currentTimeMillis ( ) / 1000L ; long rainCycle = Constants . Core . SECONDS_IN_A_DAY * 5 ; long off = seconds % rainCycle ; free . setTimeOfDayOffset ( ( int ) - off + offset ) ; return "Done" ;
error: public static AjaxResult error ( ) { return AjaxResult . error ( "操作失败" ) ;
adjustSpanSize: public void adjustSpanSize ( RecyclerView recycler ) { if ( recycler . getLayoutManager ( ) instanceof GridLayoutManager ) {
init: private Event init ( String messageId ) { this . messageId = messageId ; return this ;
getEvent: No method body
hasUpdate: public boolean hasUpdate ( ) { return false ;
setStartNumber: public NumberPicker setStartNumber ( int startNumber ) { mStartNumber = startNumber ; verifyNumber ( ) ; initTextYAxisArray ( ) ; invalidate ( ) ; return this ;
peekPromise: No method body
received: public boolean received ( final EditorGetActivePropertiesMsg msg ) { final PlayerClient messageClient = getMessageClient ( ) ; BrainOutServer . PostRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; ActiveData activeData = map . getActiveData ( msg . activeId ) ; if ( activeData != null ) { messageClient . sendTCP ( new EditorSetActivePropertiesMsg ( activeData , getProperties ( activeData ) ) ) ; } } ) ; return true ;
onFlushDirty: public boolean onFlushDirty ( Map < Object , AuditedObjectState > auditMap , Object entity , Object id , Object [ ] currentState , Object [ ] previousState , String [ ] propertyNames , Type [ ] types ) { debug ( "[onFlushDirty] entity {} id {}" , entity , id ) ; if ( this . isEntitySpecificListenerRegistered ( entity . getClass ( ) ) ) { computeChanges ( auditMap , entity , currentState , previousState , propertyNames ) ; } return false ;
getUid: public String getUid ( ) { return uid ;
definitions: public Stream < TestDefinition > definitions ( ) { return Stream . concat (
initView: private void initView ( ) { setOrientation ( LinearLayout . VERTICAL ) ; mTitleLayout = new LinearLayout ( mContext ) ; mTitleLayout . setOrientation ( HORIZONTAL ) ; mTitleLayout . setLayoutParams ( new LayoutParams ( LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; mTitleLayout . setBackgroundColor ( ContextCompat . getColor ( mContext , R . color . color_white ) ) ; addView ( mTitleLayout , mChildIndex ) ; mChildIndex ++ ; if ( mShowLine ) { View lineView = new View ( mContext ) ; lineView . setBackgroundColor ( ContextCompat . getColor ( mContext , R . color . color_eaeaea ) ) ; lineView . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , DisplayUtil . dp2px ( mContext , 0.5f ) ) ) ; addView ( lineView , mChildIndex ) ; mChildIndex ++ ; } mMenuView = new MenuView ( mContext ) ; mMenuView . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; mMenuView . setCallback ( new MyMenuViewCallback ( ) ) ; addView ( mMenuView , mChildIndex ) ;
setTarget: public void setTarget ( BoneData target ) { if ( target == null ) throw new IllegalArgumentException ( "target cannot be null." ) ; this . target = target ;
getSubscriberPreferences: No method body
getRoot: public View getRoot ( ) { return a ; }
isPlayersHasWalkietalkieContact: public static boolean isPlayersHasWalkietalkieContact ( PlayerData firstPlayer , PlayerData secondPlayer ) { PlayerOwnerComponent myPoc = firstPlayer . getComponent ( PlayerOwnerComponent . class ) ; PlayerOwnerComponent otherPoc = secondPlayer . getComponent ( PlayerOwnerComponent . class ) ; if ( myPoc != null && otherPoc != null ) { Walkietalkie walkietalkie = BrainOutServer . ContentMgr . get ( "consumable-item-walkietalkie" , Walkietalkie . class ) ; ConsumableRecord myRecord = myPoc . getConsumableContainer ( ) . getConsumable ( walkietalkie ) ; if ( myRecord != null ) { ConsumableRecord otherRecord = otherPoc . getConsumableContainer ( ) . getConsumable ( walkietalkie ) ; if ( otherRecord != null ) { WalkietalkieConsumableItem myWT = ( WalkietalkieConsumableItem ) myRecord . getItem ( ) ; WalkietalkieConsumableItem otherWT = ( WalkietalkieConsumableItem ) otherRecord . getItem ( ) ; if ( myWT . getFrequency ( ) == otherWT . getFrequency ( ) ) { return true ; } } } } return false ;
setId: public void setId ( String id ) { this . id = id ;
roundtrip: < T > void roundtrip ( T value , Serde < T > serde ) { assertThat ( serde . deserialize ( serde . serialize ( value ) ) ) . isEqualTo ( value ) ;
refreshBtnClick: public void refreshBtnClick ( ) { Log . d ( "Click refresh" , "Click refresh" ) ; startOBMobile ( ) ;
getMagazinesCount: No method body
putConsumable: public ConsumableRecord putConsumable ( int amount , ConsumableItem item ) { return putConsumable ( amount , item , - 1 ) ;
assertFileExists: private void assertFileExists ( String stringPath ) { Assertions . assertTrue ( fileExists ( stringPath ) ) ;
isLocalApplicationCommand: public final boolean isLocalApplicationCommand ( ) { return false ; }
update: public void update ( float dt ) { counter += dt ;
getSteamInflowRate: No method body
getPlaceBlock: public PlaceBlock getPlaceBlock ( ) { return placeBlock ;
tryParse: private void tryParse ( int entryIndex ) { Protocol . CompletionMessage completionMessage = this . completions . get ( entryIndex ) ; if ( completionMessage == null ) { return ; } Function < Protocol . CompletionMessage , Result < ? > > parser = this . completionParsers . remove ( entryIndex ) ; if ( parser == null ) { return ; } this . completions . remove ( entryIndex , completionMessage ) ; Result < ? > readyResult = parser . apply ( completionMessage ) ; this . results . put ( completionMessage . getEntryIndex ( ) , readyResult ) ; this . consumeCallback ( this :: tryProgress ) ;
getApiKey: public ApiKey getApiKey ( ) { return apiKey ;
getGlobalRoleName: public String getGlobalRoleName ( ) { List < Role > globals = roles . stream ( ) . map ( a -> a . getRole ( ) ) . filter ( role -> role . getType ( ) . equals ( "GLOBAL" ) ) . collect ( Collectors . toList ( ) ) ; return globals . isEmpty ( ) ? null : globals . get ( 0 ) . getName ( ) ;
getTenant: No method body
selected: public void selected ( Spawnable spawnable ) { gameController . setLastSpawnPoint ( spawnable ) ; gameController . saveSelection ( gameController . getShopCart ( ) ) ;
setScaleX: public void setScaleX ( float scaleX ) { this . scaleX = scaleX ;
saveBalanceAmount: public static void saveBalanceAmount ( Context context , long value ) { putLong ( SETTINGS , context , KEY_BALANCE_AMOUNT , value ) ;
getMaxHeapMemory: public long getMaxHeapMemory ( ) { return maxHeapMemory ;
hashCode: public int hashCode ( ) { return Objects . hash ( sessionId , externalSessionId , timestamp , isWidget , requestURI ) ;
decConsumable: public void decConsumable ( ConsumableContent type ) { decConsumable ( type , 1 ) ;
putItemIntoRealEstateItem: private boolean putItemIntoRealEstateItem ( ConsumableRecord record , int amount , RealEstateItemInventoryPanel rsPanel ) { String rsItemKey = rsPanel . getRealEstateItemKey ( ) ; if ( rsItemKey == null ) { return false ; } FreePlayMap map = rsPanel . getRsItem ( ) . getMap ( FreePlayMap . class ) ; if ( map == null ) return false ; JSONObject args = new JSONObject ( ) ; args . put ( "map" , map . getDimension ( ) ) ; args . put ( "key" , rsItemKey ) ; args . put ( "id" , record . getId ( ) ) ; args . put ( "amount" , amount ) ; BrainOutClient . SocialController . sendRequest ( "put_market_rs_item" , args , new SocialController . RequestCallback ( ) { @ Override public void success ( JSONObject response ) { InventoryMoveSoundComponent snd = record . getItem ( ) . getContent ( ) . getComponent ( InventoryMoveSoundComponent . class ) ; if ( snd != null ) { snd . play ( playerData ) ; } rsPanel . refresh ( ) ; } @ Override public void error ( String reason ) { if ( Log . ERROR ) Log . error ( reason ) ; Menu . playSound ( MenuSound . denied ) ; } } ) ; return true ;
getMap: public Map getMap ( ) { return Map . Get ( this . dimension ) ;
hasRender: public boolean hasRender ( ) { return true ;
subscribe: public void subscribe ( Flow . Subscriber < ? super ByteBuffer > subscriber ) { LOG . trace ( "Start processing invocation" ) ; this . output . subscribe ( subscriber ) ; stateMachine . startAndConsumeInput (
setWidth: public void setWidth ( float width ) { this . width = width ;
reset: public void reset ( ) { this . events = null ;
getContentStream: public InputStream getContentStream ( ) throws IOException , SQLException , RuntimeException { switch ( storageType ) {
getLocalizedName: public String getLocalizedName ( ) { return L . get ( "QUEST_TASK_PAINT_ITEM_OF_CATEGORY" , L . get ( categoryName ) , String . valueOf ( getTarget (
voice: private void voice ( ) { if ( voiceIcon == null ) { voiceIcon = addIcon ( "icon-voice-chat" ) ; } else { voiceIcon . clearActions ( ) ; } if ( voiceIcon == null ) return ; voiceIcon . addAction ( Actions . sequence (
subscribe: public void subscribe ( Event . ID eventID , EventReceiver receiver ) { subscribeAt ( eventID , receiver , false ) ;
GetTaskIDKey: public static String GetTaskIDKey ( UserProfile userProfile , long day , int index ) { return GetTaskIDKey ( GetTaskKey ( userProfile , day , index ) ) ;
isInvoiceExpired: public boolean isInvoiceExpired ( LightningOuterClass . Invoice invoice ) { return invoice . getCreationDate ( ) + invoice . getExpiry ( ) < System . currentTimeMillis ( ) / 1000 ;
release: public void release ( ) { if ( selectNodeBasePopWindow != null ) {
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; stat = jsonData . getString ( "stat" ) ;
visitMethod: public MethodVisitor visitMethod ( int i , String s , String s1 , String s2 , String [ ] strings ) { MethodVisitor mv = super . visitMethod ( i , s , s1 , s2 , strings ) ; if ( Objects . equals ( s , "<init>" ) ) { return new RunMethod ( ASM5 , mv ) ; } return mv ;
delete: public Object delete ( @ PathVariable ( ORGANIZATIONID ) Long organizationId ) { debug ( "[delete] orgId {}" , organizationId ) ; return deleteOrganization ( organizationId ) ;
createAlphaPatternShader: public static Shader createAlphaPatternShader ( int size ) { size /= 2 ; size = Math . max ( 8 , size * 2 ) ; return new BitmapShader ( createAlphaBackgroundPattern ( size ) , Shader . TileMode . REPEAT , Shader . TileMode . REPEAT ) ;
of: public static < CTX extends Context , REQ > HandlerRunner < REQ , Void > of ( BiConsumer < CTX , REQ > runner ) { return new HandlerRunner < > (
assertNegative: public static void assertNegative ( short n , @ NotNull String message ) { if ( n >= 0 ) throw new AssertionError ( message ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { pushMenu ( new ConfirmationPopup ( L . get ( "EDITOR_UNLOAD_CONFIRM" ) )
updateMyClan: public void updateMyClan ( Clan clan ) { myClan = clan ;
lockInput: public boolean lockInput ( ) { return true ;
update: public void update ( float dt ) { act ( dt ) ;
onResponse: public void onResponse ( byte [ ] bytes ) { Log . d ( TAG , "onResponse: Channel changed" ) ; try {
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; GameState gs = getGameState ( ) ; if ( gs == null ) return ; close ( ) ; gs . pushMenu ( new BrowseClansMenu ( ) ) ;
getBodyStyle: private String getBodyStyle ( TaskState state ) { switch ( state )
getRenderOption: No method body
onItemRangeInserted: public void onItemRangeInserted ( int positionStart , int itemCount ) { if ( mAdapter == null ) return ; if ( mWrapRecyclerAdapter != mAdapter )
updateGridPhase: protected static void updateGridPhase ( ) { gridPhase += 900.0f ; gridPhase %= 360.0f ;
isResult: public boolean isResult ( ) { return result ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; uses = jsonData . getInt ( "uses" , uses ) ; max = jsonData . getInt ( "max" , max ) ;
hasOrgPrivilege: default boolean hasOrgPrivilege ( PrivilegeBase p , Long orgId ) { if ( p == null ) { return false ; } return hasOrgPrivilege ( p . name ( ) , orgId ) ;
registerAtlases: public void registerAtlases ( JsonValue jsonData , AssetManager assetManager ) { if ( jsonData . isObject ( ) )
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; if ( jsonData . has ( "cardContent" ) ) { cardContent = ( ( OwnableContent ) BrainOut . ContentMgr . get ( jsonData . getString ( "cardContent" ) ) ) ; } amount = jsonData . getInt ( "amount" , 1 ) ;
getNewPassMd5String: public static String getNewPassMd5String ( Context context ) { return getString ( SETTINGS , context , KEY_NEW_PASS_MD5_STRING ) ;
setEventCategory: public void setEventCategory ( String category ) { this . eventCategory = category ;
reset: public void reset ( ) { Global . reset ( ) ;
copyStrings: public static void copyStrings ( List < String > from , String [ ] to ) { int count = to . length < from . size ( ) ? to . length : from . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) {
finishActivity: public void finishActivity ( String className ) { if ( StringUtils . isEmpty ( className ) ) { return ; } if ( activityStack != null ) {
hasNoDragOffset: public boolean hasNoDragOffset ( ) { return mTransOffsetX <= 0 && mTransOffsetY <= 0 ;
setTextSizeSP: public static void setTextSizeSP ( TextView textView , int sp ) { textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , sp ) ;
setTLS_KEY_PATH: public void setTLS_KEY_PATH ( String TLS_KEY_PATH ) { this . TLS_KEY_PATH = TLS_KEY_PATH ;
next: public void next ( PlayState . InitCallback callback ) { currentSettings = mapSource . next ( ) ; mapSource . processConditions ( currentSettings ) ; currentSettings . init ( callback ) ;
saveNetworkToLocal: public static void saveNetworkToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_NETWORK , value ) ;
setCanFix: public void setCanFix ( boolean canFix ) { this . canFix = canFix ;
getX: public float getX ( ) { return activeData . getX ( ) ;
readTask: protected void readTask ( JsonValue jsonData ) { item = jsonData . getString ( "item" ) ;
init: public void init ( ) { PlayerClient client = getClient ( ) ; if ( client == null ) return ; client . profileInited ( this ) ;
getTarget: public SpawnTarget getTarget ( ) { return target ;
toAuditString: public String toAuditString ( ) { return "ID: " + this . getId ( ) ;
getEditorLayer: public ActiveLayer getEditorLayer ( ) { return ActiveLayer . values ( ) [ layer ] ;
getEditedStringWithTimestamp: public static String getEditedStringWithTimestamp ( Message message , Context context ) { if ( ! QuickAccessPrefs . isEditTimestampEnabled ( ) || message . getEditedTimestamp ( ) == null ) return EditedMessageNode . Companion . getEditedString ( context ) ; return " (" +
get: public State get ( ByteString key ) { return this . map . getOrDefault ( key , isPartial ? Unknown . INSTANCE : Empty . INSTANCE ) ;
getInterpolation: public float getInterpolation ( float input ) { return - ( ( float ) Math . sqrt ( 1f - input * input ) - 1f ) ;
onTouchEvent: public boolean onTouchEvent ( MotionEvent event ) { if ( isCanScroll ) { return super . onTouchEvent ( event ) ; } return false ;
getInetAddress: public InetSocketAddress getInetAddress ( ) { return new InetSocketAddress ( remoteAddress , remotePort ) ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer < 0 )
handle: public void handle ( HttpServerRequest request ) { URI uri = URI . create ( request . uri ( ) ) ; if ( DISCOVER_PATH . equalsIgnoreCase ( uri . getPath ( ) ) ) { this . handleDiscoveryRequest ( request ) ; return ; } String [ ] pathSegments = SLASH . split ( uri . getPath ( ) ) ; if ( pathSegments . length < 3 ) { LOG . warn ( "Path doesn't match the pattern /invoke/ServiceName/HandlerName nor /discover: '{}'" , request . path ( ) ) ; request . response ( ) . setStatusCode ( NOT_FOUND . code ( ) ) . end ( ) ; return ; } String serviceName = pathSegments [ pathSegments . length - 2 ] ; String handlerName = pathSegments [ pathSegments . length - 1 ] ; final io . opentelemetry . context . Context otelContext = openTelemetry . getPropagators ( ) . getTextMapPropagator ( ) . extract ( io . opentelemetry . context . Context . current ( ) , request . headers ( ) , OTEL_TEXT_MAP_GETTER ) ; Context vertxCurrentContext = ( ( HttpServerRequestInternal ) request ) . context ( ) ; ResolvedEndpointHandler handler ; try { handler = restateEndpoint . resolve ( request . getHeader ( CONTENT_TYPE ) , serviceName , handlerName , request :: getHeader , otelContext , ContextualData :: put , currentContextExecutor ( vertxCurrentContext ) ) ; } catch ( ProtocolException e ) { LOG . warn ( "Error when handling the request" , e ) ; request . response ( ) . setStatusCode ( e . getCode ( ) ) . putHeader ( CONTENT_TYPE , "text/plain" ) . putHeader ( X_RESTATE_SERVER_KEY , X_RESTATE_SERVER_VALUE ) . end ( e . getMessage ( ) ) ; return ; } LOG . debug ( "Handling request to " + serviceName + "/" + handlerName ) ; HttpServerResponse response = request . response ( ) ; response . setStatusCode ( OK . code ( ) ) ; response . putHeader ( CONTENT_TYPE , handler . responseContentType ( ) ) . putHeader ( X_RESTATE_SERVER_KEY , X_RESTATE_SERVER_VALUE ) ; response . setChunked ( true ) ; HttpRequestFlowAdapter requestFlowAdapter = new HttpRequestFlowAdapter ( request ) ; HttpResponseFlowAdapter responseFlowAdapter = new HttpResponseFlowAdapter ( response ) ; requestFlowAdapter . subscribe ( handler ) ; handler . subscribe ( responseFlowAdapter ) ;
getRegion: public TextureRegion getRegion ( ) { if ( region == null ) throw new IllegalStateException ( "Region has not been set: " + this ) ; return region ;
init: private Event init ( PlayerData playerData ) { this . playerData = playerData ; return this ;
deliverResource: protected void deliverResource ( ActiveData activeData ) { HealthComponentData hcd = activeData . getComponent ( HealthComponentData . class ) ; if ( hcd != null && hcd . getHealth ( ) < hcd . getInitHealth ( ) )
getT8: public Tuple8 getT8 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] , list [ 5 ] , list [ 6 ] , list [ 7 ] ) ;
GetDesktopSettings: public static ClientSettings GetDesktopSettings ( ClientEnvironment environment ) { File file = new File ( "settings.json" ) ; DesktopSettings clientSettings = new DesktopSettings ( environment ) ; clientSettings . init ( ) ; FileHandle fileHandle = new FileHandle ( file ) ; if ( fileHandle . exists ( ) ) { JsonReader jsonReader = new JsonReader ( ) ; JsonValue value = jsonReader . parse ( fileHandle ) ; clientSettings . read ( new Json ( ) , value ) ; } return clientSettings ;
GetPlayersAlive: public static int GetPlayersAlive ( ) { int amount = 0 ; for ( Map map : Map . All ( ) ) { amount += map . countActivesForTag ( Constants . ActiveTags . PLAYERS , new Map . Predicate ( ) { @ Override public boolean match ( ActiveData activeData ) { int ownerId = activeData . getOwnerId ( ) ; if ( ownerId < 0 ) { return false ; } return activeData . isAlive ( ) ; } } ) ; } return amount ;
setPhase: public void setPhase ( float phase ) { this . phase = phase ;
getDimension: public String getDimension ( ) { return initialDimension ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; root . read ( json , jsonData ) ; if ( jsonData . has ( "game-pads" ) ) { gamePadControls . clear ( ) ; for ( JsonValue value : jsonData . get ( "game-pads" ) ) { getGamePadControls ( value . name ) . read ( json , value ) ; } } update ( ) ;
getPathToYamlComponentFile: public String getPathToYamlComponentFile ( Form entity ) { return getYamlDefaultFilePath ( EXPORT_CONFIG_PATH_ + FORM_ , entity . getName ( ) , entity . getOrganizationId ( ) ) ;
getPromptTemplate: protected final String getPromptTemplate ( ) { return promptTemplate ;
setUsername: public void setUsername ( String username ) { this . username = username ;
searchGuildMessages: public Observable < ModelSearchResponse > searchGuildMessages ( long guildId , Long maxId , List < String > authorId , List < String > mentions , List < String > channelId , List < String > has , List < String > content , Integer attempts , Boolean include_nsfw ) { return null ;
haveKnife: protected boolean haveKnife ( ) { WeaponData currentWeapon = getCurrentWeapon ( ) ; if ( currentWeapon != null ) { ServerWeaponComponentData sw = currentWeapon . getComponent ( ServerWeaponComponentData . class ) ; if ( sw != null ) { ServerWeaponComponentData . Slot slot = sw . getSlot ( Constants . Properties . SLOT_PRIMARY ) ; if ( slot != null && slot . getBullet ( ) != null ) { Bullet bullet = slot . getBullet ( ) ; if ( bullet instanceof LimitedBullet ) { return ( ( LimitedBullet ) bullet ) . getMaxDistance ( ) <= 5 ; } } } } return false ;
getModel: public String getModel ( ) { return model ;
turnOffDebugModeForLoggerClassname: public boolean turnOffDebugModeForLoggerClassname ( String classname ) { this . debug ( "[turnOffDebugModeForLoggerClassname] {}" , new Object [ ] { classname } ) ; Iterator var2 = loggers . entrySet ( ) . iterator ( ) ; Map . Entry e ; do { if ( ! var2 . hasNext ( ) ) { return false ; } e = ( Map . Entry ) var2 . next ( ) ; } while ( ! classname . equals ( ( ( Class ) e . getKey ( ) ) . getName ( ) ) ) ; return this . turnOffDebugModeForLoggerClass ( ( Class ) e . getKey ( ) ) ;
getPhone: public String getPhone ( ) { return phone ;
startActivityMonitor: public void startActivityMonitor ( Consumer < Long > onAFK , Consumer < Long > onBack ) { this . onAFK = onAFK ; this . onBack = onBack ; if ( t != null ) t . interrupt ( ) ; t = new Thread ( ( ) -> { try { Point lastMousePosition = MouseInfo . getPointerInfo ( ) . getLocation ( ) ; while ( true ) { boolean keyPressed = com . sun . jna . platform . KeyboardUtils . isPressed ( KeyEvent . KEY_PRESSED ) ; Point currentMousePosition = MouseInfo . getPointerInfo ( ) . getLocation ( ) ; boolean mouseMoved = ! currentMousePosition . equals ( lastMousePosition ) ; lastMousePosition = currentMousePosition ; long now = System . currentTimeMillis ( ) ; if ( keyPressed || mouseMoved ) { if ( wasAFK && onBack != null ) { onBack . accept ( lastActivityTime ) ; } lastActivityTime = now ; wasAFK = false ; } else if ( ! wasAFK && now - lastActivityTime > INACTIVITY_THRESHOLD ) { onAFK . accept ( lastActivityTime ) ; wasAFK = true ; } Thread . sleep ( 500 ) ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; t . start ( ) ;
isValid: default boolean isValid ( ) { return this . getInvalidReason ( ) == null ;
onEntryMoved: No method body
equalsHashCode: void equalsHashCode ( ) { Rent r1 = new Rent ( new Book ( "Big Java" , 2019 , 1350 ) , new Person ( "Nicola" , "Bicocchi" , "ID1456" ) , LocalDate . of ( 2023 , 3 , 1 ) , LocalDate . of ( 2023 , 7 , 1 ) ) ; Rent r2 = new Rent ( new Book ( "Big Java" , 2019 , 1350 ) , new Person ( "Nicola" , "Bicocchi" , "ID1456" ) , LocalDate . of ( 2023 , 3 , 1 ) , LocalDate . of ( 2023 , 7 , 1 ) ) ; Rent r3 = new Rent ( new Book ( "Big Java" , 2019 , 1350 ) , new Person ( "Nicola" , "Bicocchi" , "ID1456" ) , LocalDate . of ( 2022 , 3 , 1 ) , LocalDate . of ( 2022 , 7 , 1 ) ) ; assertEquals ( r1 , r2 ) ; assertNotEquals ( r1 , r3 ) ; assertEquals ( r1 . hashCode ( ) , r2 . hashCode ( ) ) ; assertNotEquals ( r1 . hashCode ( ) , r3 . hashCode ( ) ) ;
howManyTimes: public static long howManyTimes ( String filename , String word ) throws IOException { List < String > book = getLines ( filename ) ; return book . stream ( ) . flatMap ( line -> Arrays . stream ( line . replaceAll ( "[^a-zA-Z ]" , "" ) . toLowerCase ( ) . split ( "\\s+" ) ) ) . filter ( w -> w . equals ( word ) ) . count ( ) ;
pause: public void pause ( ) { super . pause ( ) ;
onJsAlert: public boolean onJsAlert ( WebView view , String url , String message , final JsResult result ) { new JSAlertUtils ( mContext ) . showAlertDialog ( message , result ) ; return true ;
destroy: private void destroy ( DestroyBlockEvent e ) { Map map = e . map ; if ( map == null ) return ; BrainOut . EventMgr . sendDelayedEvent ( this , LaunchEffectEvent . obtain ( LaunchEffectEvent . Kind . destroy , new PointLaunchData ( e . x + 0.5f , e . y + 0.5f , 0 , getDimension ( ) ) ) ) ; final int x = e . x , y = e . y , layer = e . layer ; map . postRunnable ( ( ) -> map . setBlock ( x , y , null , layer , true , false ) ) ;
equals: public boolean equals ( Object object ) { if ( this == object ) return true ; if ( object == null || getClass ( ) != object . getClass ( ) ) return false ; Target target = ( Target ) object ; return Objects . equals ( service , target . service )
renderTakenContent: private void renderTakenContent ( Table page , Content content , int amount ) { Menu . playSound ( MenuSound . contentOwned ) ; { Label complete = new Label ( L . get ( "MENU_FREEPLAY_TAKEN" ) , BrainOutClient . Skin , "title-small" ) ; page . add ( complete ) . pad ( 16 ) . row ( ) ; } { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( content . getTitle ( ) . get ( ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . center ( ) . row ( ) ; page . add ( header ) . expandX ( ) . fillX ( ) . row ( ) ; } {
error: default void error ( Throwable throwable , String format , Object ... arguments ) { getLogger ( ) . error ( format , arguments ) ; getLogger ( ) . error ( "[error] cause:" , throwable ) ; logToDebugStack ( throwable , format , arguments ) ;
init: private Event init ( ActiveData sender , BlockData block , int x , int y , int dimension , int damage ) { this . sender = sender ; this . block = block ; this . damage = damage ; this . x = x ; this . y = y ; this . dimension = dimension ; return this ;
setX: public void setX ( float x ) { this . x = x ;
requiredArgs: public int requiredArgs ( ) { return 0 ;
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { return ; } runOnUiThread ( new Runnable ( ) {
setSubscriptionId: public void setSubscriptionId ( String subscriptionId ) { this . subscriptionId = subscriptionId ;
setCricleColor: public void setCricleColor ( int cricleColor ) { this . roundColor = cricleColor ;
init: private void init ( Context context , AttributeSet attrs ) { if ( context != null && attrs != null ) { TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . SideIndexBar , 0 , 0 ) ; mLetterSize = a . getDimension ( R . styleable . SideIndexBar_letterSize , mLetterSize ) ; mLetterColor = a . getColor ( R . styleable . SideIndexBar_letterColor , mLetterColor ) ; mSelectLetterColor = a . getColor ( R . styleable . SideIndexBar_selectLetterColor , mSelectLetterColor ) ; mSelectBackground = a . getDrawable ( R . styleable . SideIndexBar_selectBackground ) ; mIsBoldface = a . getBoolean ( R . styleable . SideIndexBar_isBoldface , mIsBoldface ) ; mIsLetterCenter = a . getBoolean ( R . styleable . SideIndexBar_isLetterCenter , mIsLetterCenter ) ; a . recycle ( ) ; } mPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mPaint . setTypeface ( mIsBoldface ? Typeface . DEFAULT_BOLD : Typeface . DEFAULT ) ; mPaint . setTextSize ( mLetterSize ) ; mPaint . setAntiAlias ( true ) ; setClickable ( true ) ; mBackground = getBackground ( ) ;
render: public void render ( Batch batch , RenderContext context ) { Editor2Map map = Map . Get ( getDimension ( ) , Editor2Map . class ) ; if ( map == null || map . isPreviewMode ( ) ) return ; CSGame csGame = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( csGame != null ) { if ( csGame . getPlayerData ( ) != null ) { return ; } } if ( gridEnabled )
init: private FreePlayItemsTakenOutEvent init ( PlayerClient player , ObjectMap < ConsumableContent , Integer > items ) { this . player = player ; this . items . putAll ( items ) ; return this ;
updateResourceCategory: void updateResourceCategory ( ) throws Exception { assertNotNull ( updateResourceCategoryParam , "updateResourceCategoryParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . put ( "/resource/category/update" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( updateResourceCategoryParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "更新资源类别接口测试成功:{}" , map . get ( "data" ) ) ;
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { Bone bone = skeleton . bones . get ( boneIndex ) ; if ( ! bone . active ) return ; float [ ] frames = this . frames ; if ( time < frames [ 0 ] ) { switch ( blend ) { case setup : bone . x = bone . data . x ; return ; case first : bone . x += ( bone . data . x - bone . x ) * alpha ; } return ; } float x = getCurveValue ( time ) ; switch ( blend ) {
getTabButton: public Button getTabButton ( ) { return tabButton ;
stayOnTop: public boolean stayOnTop ( ) { return false ;
getStaticData3: public String getStaticData3 ( ) { return staticData3 ;
getStatus: public PaymentStatus getStatus ( ) { return status ;
isEditorSelectable: public boolean isEditorSelectable ( ) { return true ;
getFormLineDashEffect: public DashPathEffect getFormLineDashEffect ( ) { return mFormLineDashEffect ;
getRequestId: public String getRequestId ( ) { return requestId ;
getSessionId: public String getSessionId ( ) { return sessionId ;
generateClientId: public int generateClientId ( ) { return actives . generateClientId ( ) ;
setSysstatInstalled: public void setSysstatInstalled ( boolean systatEnabled ) { this . sysstatInstalled = systatEnabled ;
update: public void update ( ) { final float flowratio1 = ( float ) ( waterMass1 / ratedFlow1 ) ; final float flowRatio2 = ( float ) ( waterMass2 / ratedFlow2 ) ; float effectiveFlowRatio = flowratio1 <= flowRatio2 ? flowRatio2 / flowratio1 : flowratio1 / flowRatio2 ; if ( Double . isNaN ( effectiveFlowRatio ) ) { effectiveFlowRatio = 1 ; } final float realEfficiency = 1 - ( ( 1 - efficiency ) / effectiveFlowRatio ) ; final double specificHeat = NPPMath . calculateSpecificHeatWater ( ( waterInflowTemperature1 + waterInflowTemperature2 ) / 2 ) ; final double lowestWaterMass = waterMass1 < waterMass2 ? waterMass1 : waterMass2 ; final double transferredEnergy = ( waterInflowTemperature1 - waterInflowTemperature2 ) * specificHeat * lowestWaterMass * realEfficiency ; final double temperature1 = waterInflowTemperature1 - ( transferredEnergy / ( specificHeat * waterMass1 ) ) ; final double temperature2 = waterInflowTemperature2 + ( transferredEnergy / ( specificHeat * waterMass2 ) ) ; waterOutflowTemperature1 = Double . isNaN ( temperature1 ) ? waterOutflowTemperature1 - ( ( waterOutflowTemperature1 - waterOutflowTemperature2 ) * 0.0001 ) : temperature1 ; waterOutflowTemperature2 = Double . isNaN ( temperature2 ) ? waterOutflowTemperature2 - ( ( waterOutflowTemperature2 - waterOutflowTemperature1 ) * 0.0001 ) : temperature2 ; drain1 . updateWaterInflow ( waterMass1 , waterOutflowTemperature1 ) ; drain2 . updateWaterInflow ( waterMass2 , waterOutflowTemperature2 ) ;
testCreateOrUpdateCustomData: public void testCreateOrUpdateCustomData ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/BrandCreateOrUpdateCustomDataRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . brands ( ) . createOrUpdateCustomData ( 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/BrandCreateOrUpdateCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
setLabelTextSize: public void setLabelTextSize ( float textSize ) { this . labelTextSize = textSize ;
isStacks: public boolean isStacks ( ) { return false ;
run: public void run ( ) { CardGroup cardGroup = cardData . getCard ( ) . getGroup ( ) ; ClientCardGroupComponent ccg = cardGroup . getComponent ( ClientCardGroupComponent . class ) ; ClientCardComponent ccc = cardData . getCard ( ) . getComponentFrom ( ClientCardComponent . class ) ; if ( ccg != null ) { ccg . getFlipEffect ( ) . play ( ) ; } if ( ccc != null ) { ccc . flip ( cardData , CardActor . this ) ; } addAction ( Actions . sequence (
init: public void init ( ) { super . init ( ) ; File mainMenu = new File ( PackageManager . getPackagePath ( ClientConstants . Client . MAINMENU_PACKAGE ) ) ; FileHandle internal = Gdx . files . internal ( PackageManager . packageFilename ( ClientConstants . Client . MAINMENU_PACKAGE ) ) ; if ( ! mainMenu . exists ( ) )
lockInput: public boolean lockInput ( ) { return true ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; amount = jsonData . getFloat ( "amount" , 0 ) ;
onJsConfirm: public boolean onJsConfirm ( WebView view , String url , String message , final JsResult result ) { new JSAlertUtils ( mContext ) . showConfirmDialog ( message , result ) ; return true ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; playAgain ( ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case promoCodeResult : { promoResult ( ( ( PromoCodeResultEvent ) event ) . result ) ; break ; } } return false ;
queryAssetLastDataByPropertyId: List < AssetsDataItem > queryAssetLastDataByPropertyId ( String propertyId ) { List < AssetsDataItem > queryList = new ArrayList < > ( ) ; SQLiteDatabase db = mInstance . getWritableDatabase ( ) ; String sql = "select * from assets_data where property_id=? order by update_date desc limit 1" ; Cursor cursor = db . rawQuery ( sql , new String [ ] { propertyId } ) ; while ( cursor . moveToNext ( ) ) { long update_date ; int update_date_index = cursor . getColumnIndex ( "update_date" ) ; if ( update_date_index >= 0 ) { update_date = cursor . getLong ( update_date_index ) ; } else { update_date = 0 ; } double price ; int price_index = cursor . getColumnIndex ( "price" ) ; if ( price_index >= 0 ) { price = cursor . getDouble ( price_index ) ; } else { price = 0 ; } double amount ; int amount_index = cursor . getColumnIndex ( "amount" ) ; if ( amount_index >= 0 ) { amount = cursor . getDouble ( amount_index ) ; } else { amount = 0 ; } double channel_amount ; int channel_amount_index = cursor . getColumnIndex ( "channel_amount" ) ; if ( channel_amount_index >= 0 ) { channel_amount = cursor . getDouble ( channel_amount_index ) ; } else { channel_amount = 0 ; } AssetsDataItem row = new AssetsDataItem ( propertyId , price , amount , channel_amount , update_date ) ; queryList . add ( row ) ; } cursor . close ( ) ; return queryList ;
getPassword: public String getPassword ( ) { return password ;
getPostSavePrivilege: public PrivilegeBase getPostSavePrivilege ( ) { return postSavePrivilege != null ? postSavePrivilege : defaultControllerPrivilege ;
onFailure: public void onFailure ( WebSocket webSocket , final Throwable t , final Response response ) { tryReconnect ( ) ; if ( wsStatusListener != null ) {
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; fileName = jsonData . getString ( "sound" ) ;
withInputAccept: public Builder withInputAccept ( String inputAccept ) { this . inputAccept = inputAccept ; return this ;
drawExtras: No method body
create: No method body
main: public static void main ( String ... args ) { Greeter greetings = Greetings . class . getAnnotation ( Greeter . class ) ; System . err . println ( "Hello there, " + greetings . greet ( ) + " !!" ) ; Greeter targetValue = new DynamicGreeter ( "Good evening" ) ; alterAnnotationValueJDK7 ( Greetings . class , Greeter . class , targetValue ) ; greetings = Greetings . class . getAnnotation ( Greeter . class ) ; System . err . println ( "Hello there, " + greetings . greet ( ) + " !!" ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
getMessage: public String getMessage ( ) { return message ;
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "hi" , records . size ( ) > 0 ) ; records . write ( json ) ; if ( props != null ) { json . writeObjectStart ( "prop" ) ; for ( ObjectMap . Entry < String , String > entry : props ) { json . writeValue ( entry . key , entry . value ) ; } json . writeObjectEnd ( ) ; } if ( openSound != null ) json . writeValue ( "open-sound" , openSound ) ; if ( closeSound != null ) json . writeValue ( "close-sound" , closeSound ) ; json . writeValue ( "tag" , tag ) ;
render: float render ( ) { float res = 0 ; Label requiredToAssemble = new Label ( L . get ( "MENU_REQUIRED_TO_ASSEMBLE" ) , BrainOutClient . Skin , "title-gray" ) ; requiredToAssemble . setAlignment ( Align . center ) ; add ( requiredToAssemble ) . padTop ( 16 ) . expandX ( ) . fillX ( ) . row ( ) ; Table quantities = new Table ( ) ; add ( quantities ) . expandX ( ) . fillX ( ) . row ( ) ; for ( ObjectMap . Entry < Resource , Integer > entry : recipeComponent . getRequiredItems ( ) ) { IconComponent iconComponent = entry . key . getComponent ( IconComponent . class ) ; if ( iconComponent == null ) continue ; TextureAtlas . AtlasRegion region = iconComponent . getIcon ( "icon-medium" ) ; if ( region != null ) { Image image = new Image ( region ) ; image . setScaling ( Scaling . none ) ; quantities . add ( image ) . size ( 32 ) . padRight ( 8 ) ; } Label title = new Label ( entry . key . getTitle ( ) . get ( ) , BrainOutClient . Skin , "title-small" ) ; quantities . add ( title ) . expandX ( ) . fillX ( ) ; Label amounts = new Label ( String . valueOf ( entry . value ) , BrainOutClient . Skin , resources . get ( entry . key , 0 ) >= entry . value ? "title-green" : "title-gray" ) ; quantities . add ( amounts ) . padLeft ( 8 ) . row ( ) ; res += 42 ; } return res ;
getAxisMaximum: public float getAxisMaximum ( ) { return mAxisMaximum ;
needsPermissionForKey: public static boolean needsPermissionForKey ( String key ) { if ( StringUtils . isEmpty ( key ) ) return false ; return PreferenceKeys . ANTI_DELETE_MODE . equals ( key ) || PreferenceKeys . ANTI_EDIT_MODE . equals ( key ) ;
addSlot: public WeaponSlotComponent addSlot ( Weapon . WeaponProperties properties , String name ) { WeaponSlotComponent slot = new ServerBotWeaponSlotComponent ( data , record , properties , name , this :: getSlot ) ; slots . put ( name , slot ) ; slot . init ( ) ; return slot ;
getSteamVolume: public double getSteamVolume ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getSteamVolume'" ) ;
doOpenMap: private void doOpenMap ( ) { String maps = System . getenv ( "BRAINOUT_MAPS" ) ; FileHandle directory ; if ( maps != null ) { directory = Gdx . files . absolute ( maps ) ; } else { directory = Gdx . files . external ( "brainout-maps" ) ; } if ( ! directory . exists ( ) ) directory . mkdirs ( ) ; pushMenu ( new SelectMapMenu ( SelectMapMenu . Mode . open , directory , new SelectMapMenu . SelectCallback ( )
canDropConsumable: public boolean canDropConsumable ( ConsumableRecord record ) { return false ;
DropWeapon: private static void DropWeapon ( Task task , ConsumableRecord weaponRecord , IntSet weaponBlackList ) { ItemData itemData = task . getController ( ) . dropConsumable ( weaponRecord . getId ( ) , task . getPlayerData ( ) . getAngle ( ) , 1 ) ; if ( itemData != null )
getRequiredReadPrivilege: No method body
toggleFriendly: public void toggleFriendly ( ) { BrainOutClient . ClientController . sendTCP ( new SetFriendlyStatusMsg ( ! isFriendly ( ) ) ) ;
getVerifyCodeNoImageNotCountdown: public void getVerifyCodeNoImageNotCountdown ( String phone ) { this . mNeedCountdown = false ; if ( mHelper != null ) {
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "exitTime" , exitTime ) ;
getY: public float getY ( ) { return this . y ;
getAccessToken: public CommonResult < Oauth2Token > getAccessToken ( Principal principal , @ RequestParam Map < String , String > parameters ) throws HttpRequestMethodNotSupportedException { if ( ! allowedRequestMethods . contains ( HttpMethod . GET ) ) { throw new HttpRequestMethodNotSupportedException ( "GET" ) ; } return postAccessToken ( principal , parameters ) ;
getRealEstate: public RealEstateContent getRealEstate ( ) { return realEstate ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
setFriendName: public void setFriendName ( String name ) { this . friendName = name ;
registerApiCrudController: No method body
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; WebhookSubscription responseEntity = this . api . webhookSubscriptions ( ) . get ( 1 , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/WebhookSubscriptionGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
getTotalAmount: public int getTotalAmount ( ConsumableContent content ) { int amount = 0 ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : data ) { if ( entry . value . getItem ( ) . getContent ( ) == content ) { amount += entry . value . getAmount ( ) ; } } return amount ;
setMeshTriangles: public void setMeshTriangles ( boolean meshTriangles ) { this . drawMeshTriangles = meshTriangles ;
setLeftIcon: public void setLeftIcon ( int iconId ) { ( ( ImageView ) getView ( R . id . iv_back ) ) . setImageResource ( iconId ) ;
requiredArgs: public int requiredArgs ( ) { return 2 ;
getLanguage: public StringEnumProperty getLanguage ( ) { return language ;
setPicture: public void setPicture ( String picture ) { this . picture = picture ;
onResponse: public void onResponse ( byte [ ] bytes ) { try {
setDrawEntryLabels: public void setDrawEntryLabels ( boolean enabled ) { mDrawEntryLabels = enabled ;
getEntity: public E getEntity ( ) { return entity ;
decode: public static byte [ ] decode ( String s ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { decode ( s , bos ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } byte [ ] decodedBytes = bos . toByteArray ( ) ; try { bos . close ( ) ; bos = null ; } catch ( IOException ex ) { System . err . println ( "Error while decoding Base64: " + ex . toString ( ) ) ; } return decodedBytes ;
run: public void run ( ) { mLoadingDialog . dismiss ( ) ; deletePaymentProbe ( payment . getPaymentHash ( ) ) ; CreateChannelTipDialog mCreateChannelTipDialog = new CreateChannelTipDialog ( mContext ) ; mCreateChannelTipDialog . show ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoSteamPressure1OnActionPerformed ( evt ) ;
getLayer: public int getLayer ( ) { return 0 ;
fail: private boolean fail ( ) { failCounter -- ; if ( failCounter >= 0 ) { return true ; } failCounter = MathUtils . random ( 1 , 3 ) ; return false ;
count: public long count ( ) { return dynamicPrivilegeRepository . count ( ) ;
getAngle: public float getAngle ( ) { return phy . getAngle ( ) + ( roteteByX != 0 ? ( - 360.0f * ( ( phy . getX ( ) % roteteByX ) / roteteByX ) ) : 0 ) ;
getContentLength: public long getContentLength ( ) { return contentLength ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { stop2AActionPerformed ( evt ) ;
getContentView: protected int getContentView ( ) { return R . layout . activity_scan ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { sdvcOpen3ActionPerformed ( evt ) ;
showPopup: public void showPopup ( String title , String data ) { sendTCP ( new PopupMsg ( title , data ) ) ;
setMixShearY: public void setMixShearY ( float mixShearY ) { this . mixShearY = mixShearY ;
onEvent: public boolean onEvent ( Event event ) { return false ;
location: public static void location ( Activity activity , PermissionCallback permissionCallback ) { requestPermission ( activity , permissionCallback , Manifest . permission . ACCESS_COARSE_LOCATION ,
changeResultByASM: private byte [ ] changeResultByASM ( byte [ ] origin ) throws CompileException , IOException { ClassReader cr = new ClassReader ( origin ) ; ClassNode classNode = new ClassNode ( ) ; cr . accept ( classNode , ClassReader . EXPAND_FRAMES ) ; MethodNode [ ] nodes = getOuterAndReplacementMethodNode ( classNode ) ; MethodNode outerNode = nodes [ 0 ] , replacementNode = nodes [ 1 ] ; InsnList list = new InsnList ( ) ; int curMaxLocals = outerNode . maxLocals ; for ( AbstractInsnNode instruction : outerNode . instructions ) { if ( instruction instanceof MethodInsnNode ) { MethodInsnNode mnode = ( MethodInsnNode ) instruction ; if ( mnode . name . equals ( innerMethod ) && ( mnode . owner . replace ( "/" , "." ) . equals ( innerClassName ) || "*" . equals ( innerClassName ) ) ) { int [ ] indexes = transArgsToVars ( replacementNode . desc , curMaxLocals , list ) ; int resVarIndex = indexes [ indexes . length - 1 ] ; Map < LabelNode , LabelNode > labels = new HashMap < > ( ) ; for ( AbstractInsnNode repInsn : replacementNode . instructions ) { if ( repInsn instanceof LabelNode ) labels . put ( ( LabelNode ) repInsn , new LabelNode ( ) ) ; } LabelNode endLabel = new LabelNode ( ) ; for ( AbstractInsnNode repInsn : replacementNode . instructions ) { if ( repInsn instanceof LineNumberNode ) continue ; if ( repInsn . getOpcode ( ) == RETURN ) { list . add ( new JumpInsnNode ( GOTO , endLabel ) ) ; continue ; } if ( repInsn instanceof LabelNode ) { LabelNode t = labels . get ( repInsn ) ; list . add ( t ) ; continue ; } if ( repInsn instanceof VarInsnNode ) { VarInsnNode newInsn = ( VarInsnNode ) repInsn . clone ( labels ) ; newInsn . var += curMaxLocals ; list . add ( newInsn ) ; continue ; } if ( repInsn instanceof IincInsnNode ) { IincInsnNode newInsn = ( IincInsnNode ) repInsn . clone ( labels ) ; newInsn . var += curMaxLocals ; list . add ( newInsn ) ; continue ; } if ( repInsn instanceof MethodInsnNode ) { MethodInsnNode cur = ( MethodInsnNode ) repInsn ; if ( cur . owner . equals ( "w/InlineWrapper" ) && cur . name . equals ( "$proceed" ) ) { Type [ ] argumentTypes = Type . getArgumentTypes ( replacementNode . desc ) ; for ( int i = 0 ; i < argumentTypes . length - 1 ; i ++ ) { list . add ( loadVar ( argumentTypes [ i ] , indexes [ i ] ) ) ; } list . add ( instruction . clone ( null ) ) ; continue ; } } list . add ( repInsn . clone ( labels ) ) ; } list . add ( endLabel ) ; Type resType = Type . getReturnType ( mnode . desc ) ; list . add ( loadVar ( resType , resVarIndex ) ) ; curMaxLocals += replacementNode . maxLocals ; replacementNode . tryCatchBlocks . stream ( ) . map ( it -> new TryCatchBlockNode ( labels . get ( it . start ) , labels . get ( it . end ) , labels . get ( it . handler ) , it . type ) ) . forEach ( b -> { if ( outerNode . tryCatchBlocks == null ) { outerNode . tryCatchBlocks = new ArrayList < > ( ) ; } outerNode . tryCatchBlocks . add ( b ) ; } ) ; continue ; } } list . add ( instruction ) ; } outerNode . instructions . clear ( ) ; outerNode . instructions . add ( list ) ; ClassWriter classWriter = new ClassWriter ( ClassWriter . COMPUTE_FRAMES | ClassWriter . COMPUTE_MAXS ) { @ Override protected ClassLoader getClassLoader ( ) { return Global . getClassLoader ( ) ; } } ; classNode . accept ( classWriter ) ; byte [ ] result = classWriter . toByteArray ( ) ; return result ;
whenCreateOrganizationNotificationAndNoUsersNoEmailSent: public void whenCreateOrganizationNotificationAndNoUsersNoEmailSent ( ) { long organizationId = 1L ; NotificationDto notificationDto = new NotificationDto ( "message" , Notification . NotificationType . SUCCESS , organizationId , null ) ; notificationDto . propagate = Boolean . TRUE ; Organization organization = new Organization ( "Test Organization" ) ; organization . setId ( organizationId ) ; when ( userRoleRepository . getUsersInOrganization ( organizationId ) ) . thenReturn ( Collections . emptySet ( ) ) ; when ( organizationRepository . findOne ( organizationId ) ) . thenReturn ( organization ) ; pushNotificationService . createEmailNotification ( notificationDto ) ; verify ( userRoleRepository , times ( 1 ) ) . getUsersInOrganization ( anyLong ( ) ) ; verify ( emailRepository , never ( ) ) . saveAll ( any ( List . class ) ) ;
onClick: public void onClick ( View v ) { requestData ( ) ;
inputMessage: public static Protocol . InputEntryMessage inputMessage ( int value ) { return inputMessage ( TestSerdes . INT , value ) ;
error: public void error ( Marker marker , String format , Object arg ) { logger . error ( marker , format , arg ) ;
getWidth: public int getWidth ( ) { return width ;
obtain: public static Event obtain ( int slot ) { SelectSlotEvent e = obtain ( SelectSlotEvent . class ) ; if ( e == null ) return null ; return e . init ( slot , null ) ;
findAll: No method body
setIconsOffset: No method body
asEnumArray: public < T extends Enum < T > > Array < T > asEnumArray ( Class < T > tClass ) { Array < T > array = new Array < > ( ) ; for ( String s : value . split ( "," ) ) { array . add ( Enum . valueOf ( tClass , s ) ) ; } return array ;
getCustomDataForKey: public Map < String , Object > getCustomDataForKey ( Integer brandId , String key , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/brands/%s/custom-data/%s" , brandId , key ) , query , null , responseModel ) ;
getRemoteAddress: public InetSocketAddress getRemoteAddress ( ) { return ( InetSocketAddress ) channel . remoteAddress ( ) ;
deleteAllPayments: No method body
run: public void run ( ) { Gdx . app . postRunnable ( ClanMenu . this :: reset ) ;
updateCamera: public void updateCamera ( RenderContext context ) { if ( Watcher == null ) return ; if ( ! Watcher . getDimension ( ) . equals ( getDimension ( ) ) ) return ; getCamera ( ) . position . set ( ( int ) ( ( Watcher . getWatchX ( ) + offset . x + context . x ) * Constants . Graphics . RES_SIZE ) , ( int ) ( ( Watcher . getWatchY ( ) + offset . y + context . y ) * Constants . Graphics . RES_SIZE ) , 0 ) ; getCamera ( ) . rotate ( context . angle ) ;
write: public void write ( Json json ) { if ( getTitle ( ) . isValid ( ) ) { json . writeValue ( "name" , name . getID ( ) ) ; } if ( getDescription ( ) . isValid ( ) ) { json . writeValue ( "description" , description . getID ( ) ) ; } json . writeValue ( "class" , BrainOut . R . getClassName ( getClass ( ) ) ) ;
getBullet: public Bullet getBullet ( ) { return bullet ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; sound = assetManager . get ( fileName , Music . class ) ;
getYamlDefaultFilePath: String getYamlDefaultFilePath ( String filePath , String entityName , Long organizationId ) { debug ( "[getYamlDefaultFilePath]" ) ; return organizationId == null ? String . format ( "%s%s.yaml" , filePath , entityName ) : String . format ( "%s%s_%s.yaml" , filePath , entityName , organizationId ) ;
setListHook: public void setListHook ( ListUtils . ListUtilsHook < T > listHook ) { this . mListHook = listHook ;
setCallback: public void setCallback ( FilterMenuViewCallback callback ) { this . mCallback = callback ;
getShortestPath: Queue < MapDimensionGraphPoint > getShortestPath ( MapDimensionGraphPoint map ) { MapDistanceEntry entry = get ( map , null ) ; if ( entry == null ) { return null ; } return entry . shortestPath ;
sendUDP: public int sendUDP ( UdpMessage object ) { if ( connection == null ) return - 1 ; int sent = connection . sendUDP ( object ) ; statistics . udp ( sent , object . getClass ( ) . getName ( ) ) ; return sent ;
done: private void done ( ) { if ( autoPop )
getId: public Long getId ( ) { return id ;
getTableName: public String getTableName ( ) { return tableName ;
sortBone: private void sortBone ( Bone bone ) { if ( bone . sorted ) return ; Bone parent = bone . parent ; if ( parent != null ) sortBone ( parent ) ; bone . sorted = true ; updateCache . add ( bone ) ;
setTypeface: public void setTypeface ( Typeface tf ) { mTypeface = tf ;
getBlockTime: public long getBlockTime ( ) { return blockTime ;
onClientSpawn: public void onClientSpawn ( Client client , PlayerData player ) { super . onClientSpawn ( client , player ) ; if ( ! getGameMode ( ) . isGameActive ( true , true ) ) return ; giveRankWeapon ( client , false ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
saveRestoredChannel: public static void saveRestoredChannel ( Context context , boolean value ) { putBoolean ( SETTINGS , context , RESTORED_CHANNEL , value ) ;
getPlayerData: public PlayerData getPlayerData ( ) { return playerData ;
getMenuItem: public String getMenuItem ( ) { return menuItem ;
draw: public String draw ( Curve curve ) { return "i'm a brush drawing a " + curve . draw ( ) ;
isInverted: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton2ActionPerformed ( evt ) ;
testDeleteContact: public void testDeleteContact ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . merchants ( ) . deleteContact ( Identifier . fromId ( 1 ) , 1 , options ) ;
getMaximumEntryWidth: public float getMaximumEntryWidth ( Paint p ) { float max = 0f ; float maxFormSize = 0f ; float formToTextSpace = Utils . convertDpToPixel ( mFormToTextSpace ) ; for ( LegendEntry entry : mEntries ) { final float formSize = Utils . convertDpToPixel ( Float . isNaN ( entry . formSize ) ? mFormSize : entry . formSize ) ; if ( formSize > maxFormSize ) maxFormSize = formSize ; String label = entry . label ; if ( label == null ) continue ; float length = ( float ) Utils . calcTextWidth ( p , label ) ; if ( length > max ) max = length ; } return max + maxFormSize + formToTextSpace ;
getMinWidth: public float getMinWidth ( ) { return mMinWidth ;
addRunner: public void addRunner ( AbstractRunner runner ) { if ( runner != null ) {
next: public Settings next ( ) { return this ;
resumeDownloading: public void resumeDownloading ( ) { PRDownloader . resume ( downloadingId ) ;
setComplete: public void setComplete ( boolean complete ) { isComplete = complete ;
setDrawValues: No method body
getEffect: public EffectData getEffect ( LaunchData launchData , EffectSet . EffectAttacher attacher ) { return new GunshotTailSoundEffectData ( this , launchData , attacher ) ;
getTableViewWebEndpoint: public String getTableViewWebEndpoint ( ) { return tableViewWebEndpoint ;
delete: public void delete ( String shopKey , Integer redirectId , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/shops/%s/redirects/%s" , shopKey , redirectId ) , query , null , null ) ;
showPromptDialog: void showPromptDialog ( String message , String defaultValue , final JsPromptResult result ) { final AlertDialog dialog = new AlertDialog . Builder ( mContext ) . setContentView ( R . layout . view_prompt_dialog ) . setText ( R . id . tv_title , message ) . setText ( R . id . et_dialog_content , message ) . fullWidth ( ) . create ( ) ; final EditText editText = dialog . getViewById ( R . id . et_dialog_content ) ; editText . setHint ( defaultValue ) ; dialog . getViewById ( R . id . tv_dialog_cancel_btn ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { result . cancel ( ) ; dialog . dismiss ( ) ; } } ) ; dialog . getViewById ( R . id . tv_dialog_confirm_btn ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { String value = editText . getText ( ) . toString ( ) . trim ( ) ; result . confirm ( value ) ; dialog . dismiss ( ) ; } } ) ; dialog . show ( ) ;
getStyleName: private static String getStyleName ( boolean checkable ) { return checkable ? "button-inventory-checkable" : "button-inventory" ;
getInterpolation: public float getInterpolation ( float input ) { float s = 7.5625f ; if ( input < ( 1f / 2.75f ) ) { return s * input * input ; } else if ( input < ( 2f / 2.75f ) ) { return s * ( input -= ( 1.5f / 2.75f ) ) * input + 0.75f ; } else if ( input < ( 2.5f / 2.75f ) ) { return s * ( input -= ( 2.25f / 2.75f ) ) * input + 0.9375f ; } return s * ( input -= ( 2.625f / 2.75f ) ) * input + 0.984375f ;
onEvent: public boolean onEvent ( Event event ) { if ( event . getID ( ) == Event . ID . playerWon ) { playerWon ( ( ( PlayerWonEvent ) event ) . client ) ; } return false ;
hasConsumable: public boolean hasConsumable ( ConsumableItem type ) { for ( ConsumableRecord record : data . values ( ) ) { ConsumableItem item = record . getItem ( ) ; if ( item == type ) { if ( record . getAmount ( ) > 0 ) { return true ; } } } return false ;
getInput: No method body
testDeleteCustomDataForKey: public void testDeleteCustomDataForKey ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . products ( ) . deleteCustomDataForKey ( Identifier . fromId ( 1 ) , "acme" , options ) ;
getComponent: public WindAnimationComponentData getComponent ( ComponentObject componentObject ) { return new WindAnimationComponentData ( componentObject , this ) ;
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { json . writeValue ( "tickets" , tickets ) ; json . writeValue ( "intickets" , initialTickets ) ; super . write ( json , componentWriter , owner ) ;
getLastName: public String getLastName ( ) { return lastName ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . mapListReceived , this ) ;
setContent: public void setContent ( Content content ) { this . content = content ;
setChatId: public void setChatId ( String chatId ) { TgConfiguration . chatId = chatId ;
read: public void read ( Json json , JsonValue jsonData ) { Array < Integer > toRemove = new Array < Integer > ( ) ; Array < Integer > found = new Array < Integer > ( ) ; if ( jsonData . has ( "records" ) )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoWaterLevel4OnActionPerformed ( evt ) ;
shouldErrorLogException: private boolean shouldErrorLogException ( Exception exception , HttpServletRequest request ) { boolean exceptionIsNotNull = exception != null ; String userAgent = request . getHeader ( "User-Agent" ) ; boolean isExcludedUserAgent = isExcludedUserAgent ( userAgent ) ; boolean hasCause = exceptionIsNotNull && exception . getCause ( ) != null ; boolean isClientAbortException = exceptionIsNotNull && hasCause && ( exception instanceof ClientAbortException ) && ( exception . getCause ( ) instanceof IOException ) ; debug ( "[exceptionToLog] is not null {} class {} cause {} agent [{}]" , exceptionIsNotNull , exceptionIsNotNull ? exception . getClass ( ) . getSimpleName ( ) : "" , hasCause ? exception . getCause ( ) . getClass ( ) . getSimpleName ( ) : "" , userAgent ) ; return not ( isExcludedUserAgent || isClientAbortException ) ;
isComplete: public boolean isComplete ( PlayStateEndGame . GameResult gameResult ) { return false ;
testGetAddress: public void testGetAddress ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; CustomerAddress responseEntity = this . api . customers ( ) . getAddress ( "acme" , "acme" , Identifier . fromId ( 1 ) , Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CustomerGetAddressResponse.json" ) ; assertThatJson ( expectedResponseJson )
deleteWorkflow: No method body
setAccountAddress: public void setAccountAddress ( String accountAddress ) { this . accountAddress = accountAddress ;
getWatchY: public float getWatchY ( ) { updateOffset ( ) ; return playerData . getY ( ) + offset . y ;
getWorldY: public float getWorldY ( ) { return worldY ;
replaceNumberString: public static String replaceNumberString ( String str , String nullStr ) { if ( "0" . equals ( nullString2Number ( str ) ) ) {
get: void get ( ) { assertEquals ( "Nicola" , m . get ( 1 ) ) ; assertEquals ( "Agata" , m . get ( 2 ) ) ; assertEquals ( "Marzia" , m . get ( 3 ) ) ;
addItem: public void addItem ( UserProfile userProfile , int amount ) { UpgradeChain . this . addItem ( userProfile , amount ) ;
compareTo: public int compareTo ( DbVersion obj ) { return Integer . compare ( this . value ( ) , obj . value ( ) ) ;
showLayoutBg: public static void showLayoutBg ( final Context context , Object imagePath , final ViewGroup layout , Drawable placeHolder ) { Glide . with ( context )
activate: private boolean activate ( ) { ActiveProgressVisualComponentData pvc = getPlayerData ( ) . getComponent ( ActiveProgressVisualComponentData . class ) ; if ( pvc != null ) { if ( pvc . isActive ( ) && pvc . isCancellable ( ) ) { BrainOutClient . ClientController . sendTCP ( new CancelPlayerProgressMsg ( ) ) ; return true ; } } return activateClosestActive ( ) ;
getID: public ID getID ( ) { return ID . loading ;
build: public ApiOptions build ( ) { return new ApiOptions ( this . options ) ;
getSessionAttribute: public Object getSessionAttribute ( String id ) { return getSession ( true ) . getAttribute ( id ) ;
buffered: No method body
getProvinceByIdCard: public static String getProvinceByIdCard ( String idCard ) { int len = idCard . length ( ) ; String sProvince ; String sProvNum = "" ; if ( len == CHINA_ID_MIN_LENGTH || len == CHINA_ID_MAX_LENGTH ) { sProvNum = idCard . substring ( 0 , 2 ) ; } sProvince = cityCodes . get ( sProvNum ) ; return sProvince ;
findEvent: public @ Null EventData findEvent ( String eventDataName ) { if ( eventDataName == null ) throw new IllegalArgumentException ( "eventDataName cannot be null." ) ; for ( EventData eventData : events ) if ( eventData . name . equals ( eventDataName ) ) return eventData ; return null ;
removeListener: public void removeListener ( AnimationStateListener listener ) { listeners . removeValue ( listener , true ) ;
deposit: void deposit ( ) { assertThrows ( IllegalArgumentException . class , ( ) -> bankAccount . deposit ( - 100 ) ) ; bankAccount . deposit ( 1000 ) ; assertEquals ( 2000 , bankAccount . getBalance ( ) ) ;
showLayoutRoundBg: public static void showLayoutRoundBg ( final Context context , Object imagePath , final View layout , int placeHolder , int rounddp ) { Glide . with ( context )
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; if ( jsonData . has ( "mode" ) )
getInterpolation: public float getInterpolation ( float input ) { input -- ; return - ( ( float ) Math . pow ( input , 4 ) - 1f ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case voice : { VoiceEvent ev = ( ( VoiceEvent ) event ) ; if ( ev . remoteClient != null ) { EventReceiver receiver = remoteClientsMap . get ( ev . remoteClient . getId ( ) ) ; if ( receiver != null ) { if ( receiver . onEvent ( event ) ) { return true ; } } } break ; } case newRemoteClient : case remoteClientUpdated : case remoteClientLeft : { updateStats ( ) ; updateClients ( ) ; break ; } case simple : { SimpleEvent ev = ( ( SimpleEvent ) event ) ; switch ( ev . getAction ( ) ) { case modeUpdated : { modeUpdated ( ) ; break ; } case pingUpdated : { updateClients ( ) ; break ; } } break ; } } return false ;
getTotalSize: private static long getTotalSize ( String path ) { StatFs fileStats = new StatFs ( path ) ; fileStats . restat ( path ) ; return ( long ) fileStats . getBlockCount ( ) * fileStats . getBlockSize ( ) ;
getTime: public String getTime ( ) { return time ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesOpen14ActionPerformed ( evt ) ;
getUsdtPriceFromLocal: public static String getUsdtPriceFromLocal ( Context context ) { return getString ( SETTINGS , context , KEY_USDT_PRICE ) ;
lockInput: public boolean lockInput ( ) { return true ;
getCard: No method body
getMap: public String getMap ( ) { return masterMap + map ;
getInstance: public static MyBatisAgentService getInstance ( ) { return MyBatisAgentServiceHolder . instance ;
getMicrophoneVolume: public float getMicrophoneVolume ( ) { return microphoneVolume ;
getMin: public int getMin ( ) { return min ;
getMagazines: public IntMap < Magazine > getMagazines ( ) { return magazines ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVOpen1ActionPerformed ( evt ) ;
getSound: public String getSound ( ) { return sound ;
targetType: public MessageBuilder < JRPCMessage > targetType ( final @ NonNull Message . TargetType targetType ) { this . targetType = targetType ; return this ;
getComponent: public PhysicsContactEffectComponentData getComponent ( ComponentObject componentObject ) { return new PhysicsContactEffectComponentData ( componentObject , this ) ;
clientInitialized: public void clientInitialized ( Client client , boolean reconnected ) { super . clientInitialized ( client , reconnected ) ; if ( client instanceof PlayerClient )
startZombieEvent: private void startZombieEvent ( ClientEvent event ) { RoomSettings roomSettings = new RoomSettings ( ) ; roomSettings . init ( BrainOutClient . ClientController . getUserProfile ( ) , false ) ; roomSettings . setRegion ( BrainOutClient . ClientController . getMyRegion ( ) ) ; WaitLoadingMenu waitLoadingMenu = new WaitLoadingMenu ( "" ) ; pushMenu ( waitLoadingMenu ) ; Matchmaking . FindGame ( "zombie" , roomSettings , new Matchmaking . FindGameResult ( )
update: public Product update ( Identifier productIdentifier , Product model ) throws ApiErrorException , ConnectionException { Class < Product > responseModel = ( Class < Product > ) ( Class < ? > ) Product . class ; return this . request ( "put" , this . resolvePath ( "/products/%s" , productIdentifier ) , null , null , responseModel , model ) ;
getPort: public Integer getPort ( ) { return port ;
bindRequestParameters: protected void bindRequestParameters ( WebDataBinder binder , NativeWebRequest nativeWebRequest ) { Object target = binder . getTarget ( ) ; Class < ? > targetClass = target . getClass ( ) ; if ( ! targetClass . isAssignableFrom ( MapEntityForm . class ) ) { super . bindRequestParameters ( binder , nativeWebRequest ) ; } if ( ! replaceMap . containsKey ( targetClass ) ) { Map < String , String > mapping = analyzeClass ( ( Class < MapEntityForm > ) targetClass ) ; replaceMap . put ( targetClass , mapping ) ; } Map < String , String > mapping = replaceMap . get ( targetClass ) ;
initView: protected void initView ( ) { GridView seedGridView = ( GridView ) findViewById ( R . id . seed_grid_view ) ; EventBus . getDefault ( ) . register ( this ) ; mLoadingDialog = new LoadingDialog ( mContext ) ; seedGridView . setAdapter ( seedsAdapter = new SeedsAdapter ( this , seedArray ) ) ;
findConsumersByEventType: List < EventConsumer > findConsumersByEventType ( Class c ) { debug ( "[findConsumersByEventType] type: {}" , c ) ; List < EventConsumer > result = new ArrayList < > ( ) ; for ( Map . Entry < Class , List < EventConsumer > > e : consumers . entrySet ( ) ) { if ( e . getKey ( ) . isAssignableFrom ( c ) ) { result . addAll ( e . getValue ( ) ) ; } } return result ;
hasRadioWarning: public boolean hasRadioWarning ( ) { return this . radio >= getContentComponent ( ) . getRadioMax ( ) * 0.1f ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { ejector1StartItemStateChanged ( evt ) ;
checkSpawn: public void checkSpawn ( Spawnable spawnable ) { for ( Array < Client > wave : waves ) { checkWave ( wave , spawnable ) ; } getClients ( ) . sendTCP ( new SimpleMsg ( SimpleMsg . Code . updateSpawn ) ) ;
afterAll: static void afterAll ( ) throws IOException { directory . close ( ) ; Files . walk ( tempIndexPath ) . sorted ( Comparator . reverseOrder ( ) ) . map ( Path :: toFile ) . forEach ( File :: delete ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { mFW1StopItemStateChanged ( evt ) ;
fetchAvatar: protected void fetchAvatar ( String avatar , Table avatarInfo ) { Avatars . Get ( avatar , ( has , avatarTexture ) ->
read: public void read ( JSONObject obj , String key ) { if ( obj . has ( key ) )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem3ActionPerformed ( evt ) ;
component1: @ NonNull public final EmojiNode . EmojiIdAndType . Custom component1 ( ) { return null ; }
getSubscriptionStatus: public String getSubscriptionStatus ( ) { return subscriptionStatus ;
done: private void done ( ) { getController ( ) . stopFollowing ( ) ; pop ( ) ;
getChannelBalance: private void getChannelBalance ( long propertyid ) { LightningOuterClass . ChannelBalanceRequest channelBalanceRequest = LightningOuterClass . ChannelBalanceRequest . newBuilder ( ) . setAssetId ( ( int ) propertyid ) . build ( ) ; Obdmobile . channelBalance ( channelBalanceRequest . toByteArray ( ) , new Callback ( ) {
getAppVersionName: public static String getAppVersionName ( Context context ) { try { PackageManager pm = context . getPackageManager ( ) ; PackageInfo pi = pm . getPackageInfo ( context . getPackageName ( ) , 0 ) ; return pi . versionName ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return "" ;
getStoreSearchQuery: public final StoreSearchQuery getStoreSearchQuery ( ) { return new StoreSearchQuery ( ) ;
getAuditChangeFactory: private AuditChangeFactory getAuditChangeFactory ( ) { return getContext ( ) . getBean ( AuditChangeFactory . class ) ;
toString: public String toString ( ) { return a1 . name + "->" + a2 . name ;
getLoad: public WeaponLoad getLoad ( String slot ) { return loads . get ( slot ) ;
getQuality: public int getQuality ( ) { return quality ;
newPathAttachment: public PathAttachment newPathAttachment ( Skin skin , String name ) { return null ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------listTranscationsOnError------------------" + e . getMessage ( ) ) ;
isThreadStarterMessage: public final boolean isThreadStarterMessage ( ) { return this . isThreadStarterMessage ;
create: public ShopCategoryPropertyKey create ( ShopCategoryPropertyKey model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCategoryPropertyKey > responseModel = ( Class < ShopCategoryPropertyKey > ) ( Class < ? > ) ShopCategoryPropertyKey . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shop-category-property-keys" ) , query , null , responseModel , model ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( profileRU == 0 ) { profileButton . setChecked ( true ) ; Menu . playSound ( MenuSound . denied ) ; return ; } Menu . playSound ( MenuSound . select ) ; max = profileRU ; refreshSlider ( ) ; arrow . setDrawable ( BrainOutClient . Skin , "icon-exchange-right" ) ; title . setText ( L . get ( "MENU_MARKET_TRANSFER_RU_INTO_MARKET" ) ) ; in = true ;
onCreate: protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Process . killProcess ( getIntent ( ) . getIntExtra ( KEY_MAIN_PROCESS_PID , - 1 ) ) ; ArrayList < Intent > intents = getIntent ( ) . getParcelableArrayListExtra ( KEY_RESTART_INTENTS ) ; setContentView ( new FrameLayout ( this ) ) ; m_itLaunchs = intents . toArray ( new Intent [ 0 ] ) ;
prepareContentForHtml: public String prepareContentForHtml ( String html , Map < String , Object > model ) { debug ( "[prepareContentForHtml]" ) ; if ( model . containsKey ( errorMessage . name ) ) { html = "<span th:text=\"${errorMessage}\"></span>" ; } else if ( StringUtils . isBlank ( html ) ) { return StringUtils . EMPTY ; } TemplateEngine stringTemplateEngine = new TemplateEngine ( ) ; stringTemplateEngine . addTemplateResolver ( stringTemplateResolver ) ; final Context ctx = new Context ( LocaleContextHolder . getLocale ( ) ) ; for ( Map . Entry < String , Object > entry : model . entrySet ( ) ) { ctx . setVariable ( entry . getKey ( ) , entry . getValue ( ) ) ; } stringTemplateEngine . getTemplateResolvers ( ) ; try {
getHighlightCircleStrokeAlpha: public int getHighlightCircleStrokeAlpha ( ) { return mHighlightCircleStrokeAlpha ;
addWayPoint: private WayPoint addWayPoint ( int chunkX , int chunkY , float x , float y ) { WayPoint wayPoint = new WayPoint ( map , x , y , nextWayPointId ++ ) ; this . wayPoints . put ( wayPoint . getId ( ) , wayPoint ) ; int chunkIndex = chunkX + chunkY * map . getBlocks ( ) . getBlockWidth ( ) ; Queue < WayPoint > wp = this . chunkWayPoints . get ( chunkIndex ) ; if ( wp == null ) { wp = new Queue < > ( ) ; this . chunkWayPoints . put ( chunkIndex , wp ) ; } wp . addLast ( wayPoint ) ; return wayPoint ;
getNameGroup: Integer getNameGroup ( ) { return nameGroup ;
notifyAll: private void notifyAll ( CardMessage message ) { IntSet . IntSetIterator lit = listeners . iterator ( ) ; while ( lit . hasNext )
getY: public float getY ( ) { return phy . getY ( ) + offsetY ;
convertDtoValue: protected Object convertDtoValue ( FrontendMappingFieldDefinition ffd , Object dtoValue ) { return dtoValue ;
getRefillAnimation: public String getRefillAnimation ( ) { return refillAnimation ;
findMaxAndMin: public Map < String , Double > findMaxAndMin ( List < AssetTrendEntity > result ) { Map < String , Double > maxAndMinMap = new HashMap < > ( ) ; if ( result . size ( ) == 0 || result == null ) { maxAndMinMap . put ( "max" , 0.0 ) ; maxAndMinMap . put ( "min" , 0.0 ) ; } else { List < Double > values = new ArrayList < > ( ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { double value = Double . parseDouble ( result . get ( i ) . getAsset ( ) ) ; values . add ( value ) ; } double min = Collections . min ( values ) ; double max = Collections . max ( values ) ; maxAndMinMap . put ( "max" , max ) ; maxAndMinMap . put ( "min" , min ) ; } return maxAndMinMap ;
generate: No method body
calculateSound: protected void calculateSound ( ) { ClientMap map = ( ( ClientMap ) getMap ( ) ) ; if ( map == null ) return ; this . volume = 1 ; this . pan = 0 ; Watcher watcher = Map . GetWatcher ( ) ; if ( watcher != null && watcher . getDimension ( ) . equals ( getDimension ( ) ) )
isThrowable: public boolean isThrowable ( ) { return false ;
getDurabilityNormalized: public float getDurabilityNormalized ( ) { return durability / getContentComponent ( ) . getDurability ( ) ;
switchConsumable: public ConsumableContent switchConsumable ( ConsumableContent old , Class classOf ) { int index ; if ( old != null ) { index = container . getIndex ( old ) + 1 ; } else { index = 0 ; } for ( int i = index ; i < container . size ( ) ; i ++ ) { ConsumableRecord at = container . getByIndex ( i ) ; if ( BrainOut . R . instanceOf ( classOf , at . getItem ( ) . getContent ( ) ) ) { return ( ( ConsumableContent ) at . getItem ( ) . getContent ( ) ) ; } } for ( int i = 0 ; i < container . size ( ) ; i ++ ) { ConsumableRecord at = container . getByIndex ( i ) ; if ( BrainOut . R . instanceOf ( classOf , at . getItem ( ) . getContent ( ) ) ) { return ( ( ConsumableContent ) at . getItem ( ) . getContent ( ) ) ; } } return null ;
getGroup: public CardGroup getGroup ( ) { return group ;
getAppMetaData: public static String getAppMetaData ( Context ctx , String key ) { if ( ctx == null || TextUtils . isEmpty ( key ) ) { return null ; } String resultData = null ; try { PackageManager packageManager = ctx . getPackageManager ( ) ; if ( packageManager != null ) { ApplicationInfo applicationInfo = packageManager . getApplicationInfo ( ctx . getPackageName ( ) , PackageManager . GET_META_DATA ) ; if ( applicationInfo != null ) { if ( applicationInfo . metaData != null ) { resultData = applicationInfo . metaData . getString ( key ) ; } } } } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } return resultData ;
execute: public String execute ( String [ ] args , Client client ) { PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( playState . getID ( ) != PlayState . ID . game ) return "Not in game" ; GameMode mode = ( ( ServerPSGame ) playState ) . getMode ( ) ; if ( mode . getID ( ) == GameMode . ID . free ) return "Not allowed in freeplay" ; if ( mode . getID ( ) == GameMode . ID . assault ) { GameModeAssault assault = ( GameModeAssault ) mode ; GameModeAssault . State state = assault . getState ( ) ; if ( state == GameModeAssault . State . waiting ) return "Not allowed while equipping" ; } if ( client . getState ( ) != Client . State . spawned ) { return "player is not spawned" ; } if ( client . getPlayerData ( ) == null ) { return "player is not inited" ; } client . kill ( ) ; return "done" ;
received: public boolean received ( final UserProfileMsg msg ) { Gdx . app . postRunnable ( ( ) -> { String decompressed = Compressor . DecompressToString ( msg . data ) ; if ( decompressed == null ) return ; JSONObject o = new JSONObject ( decompressed ) ; getController ( ) . getUserProfile ( ) . read ( o ) ; updateUserProfile ( ) ; } ) ; return true ;
contact: private void contact ( PhysicsContactEvent e ) { if ( e . speed . len2 ( ) > 8 * 8 )
setHeight: public void setHeight ( float height ) { this . height = height ;
getSteamOutflowRate: public double getSteamOutflowRate ( ) { return steamOutflowRate * 20 ;
decConsumable: public void decConsumable ( ConsumableRecord record , int amount ) { if ( record != null )
isDrawBarShadowEnabled: public boolean isDrawBarShadowEnabled ( ) { return mDrawBarShadow ;
iShouldSeeMessageOnPage: public void iShouldSeeMessageOnPage ( String message ) { Assert . assertTrue ( registerPage . waitFor ( registerPage . registeredMessage ) . getText ( ) . contains ( message ) ) ;
getContactTo: public Array < String > getContactTo ( ) { return contactTo ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; if ( jsonData . has ( "fixture" ) ) { fixture = jsonData . getBoolean ( "fixture" ) ; } editor = jsonData . getBoolean ( "editor" , true ) ;
all: public ApiCollection < EmailKey > all ( String shopKey , String countryCode ) throws ApiErrorException , ConnectionException { Class < EmailKey > responseModel = ( Class < EmailKey > ) ( Class < ? > ) EmailKey . class ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries/%s/emails/keys" , shopKey , countryCode ) , null , null , responseModel ) ;
put: public V put ( K key , V value ) { throw new UnsupportedOperationException ( ) ; }
setY: public void setY ( float y ) { this . y = y ;
fullWeaponUloading: public ObjectMap < Bullet , UnloadResult > fullWeaponUloading ( ) { ObjectMap < Bullet , UnloadResult > ammo = new ObjectMap ( ) ; for ( Slot slot : getSlots ( ) . values ( ) ) { Bullet bullet = slot . getBullet ( ) ; putAmmoAmountToAmmoMap ( ammo , bullet , slot . getChambered ( ) , slot . getChamberedQuality ( ) ) ; slot . setChambered ( 0 , - 1 ) ; if ( slot . attachedMagazine != null ) { putAmmoAmountToAmmoMap ( ammo , bullet , slot . attachedMagazine . rounds , slot . attachedMagazine . quality ) ; slot . attachedMagazine . rounds = 0 ; } if ( slot . getMagazines ( ) != null ) { for ( Slot . Magazine magazine : slot . getMagazines ( ) . values ( ) ) { putAmmoAmountToAmmoMap ( ammo , bullet , magazine . rounds , magazine . quality ) ; magazine . rounds = 0 ; } } } return ammo ;
insertAssetValueData: void insertAssetValueData ( double value , long date ) { SQLiteDatabase db = mInstance . getWritableDatabase ( ) ; if ( ! db . isOpen ( ) ) { return ; } ContentValues values = new ContentValues ( ) ; values . put ( "value" , value ) ; values . put ( "update_date" , date ) ; db . insert ( "assets_value_data" , null , values ) ;
shouldNotParseTextWithoutPoint: public void shouldNotParseTextWithoutPoint ( ) { String point = "(11 -97.0352)" ; Executable parsePointExecutable = ( ) -> MapService . parsePoint ( point ) ; RuntimeException exception = assertThrows ( RuntimeException . class , parsePointExecutable ) ; String expectedMessage = "com.vividsolutions.jts.io.ParseException: Unknown geometry type: ( (line 1)" ; String actualMessage = exception . getMessage ( ) ; assertEquals ( expectedMessage , actualMessage ) ;
getGroupWidth: public float getGroupWidth ( float groupSpace , float barSpace ) { return mDataSets . size ( ) * ( mBarWidth + barSpace ) + groupSpace ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; soundEffect = jsonData . getString ( "sound" ) ;
notFound: public void notFound ( ) { dropWeapon ( weaponRecord ) ;
sneakyThrow: private static < E extends Throwable > void sneakyThrow ( Throwable e ) throws E { throw ( E ) e ;
showImageCenterCrop: public static void showImageCenterCrop ( Context context , Object imagePath , ImageView imageView , int placeHolder , int width , int height ) { DrawableRequestBuilder builder = getBuilder ( context , imagePath , placeHolder ) ; builder . centerCrop ( ) ; if ( width > 0 && height > 0 ) { builder . override ( width , height ) ; } builder . into ( imageView ) ;
acquireMap: public ServerSettings . MapConditions acquireMap ( ) { return map ;
getWaterLevel: public double getWaterLevel ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getWaterLevel'" ) ;
getFlowRate: public double getFlowRate ( ) { return flowRate * 20 ;
toPredicate: public Predicate toPredicate ( Root < FrontendResource > root , CriteriaQuery < ? > query , CriteriaBuilder cb ) { return cb . equal ( root . get ( "resourceType" ) , resourceType ) ;
getFrontendMappingDefinition: public static FrontendMappingDefinition getFrontendMappingDefinition ( String name , String readPrivilege , String writePrivilege , String code ) { String finalScript = "let form = new com.openkoda.core.service.FrontendMappingDefinitionService().createFrontendMappingDefinition(\"" + name + "\",\"" + readPrivilege + "\",\"" + writePrivilege + "\"," + code + ");\nform" ; ServerJs serverJs = new ServerJs ( finalScript , StringUtils . EMPTY , null ) ; Map < String , Object > model = new HashMap ( ) ; return new ServerJSRunner ( ) . evaluateServerJs ( serverJs , model , null , FrontendMappingDefinition . class ) ;
getEvent: No method body
getTarget: public int getTarget ( ) { return target ;
hasRender: public boolean hasRender ( ) { return false ;
showGifCenterCrop: public static void showGifCenterCrop ( Context context , Object imagePath , ImageView imageView , int placeHolder ) { Glide . with ( context ) . load ( imagePath )
onInit: public void onInit ( ) { super . onInit ( ) ; BrainOutClient . EventMgr . subscribeAt ( Event . ID . notify , this , true ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . caseOpenResult , this ) ;
destroyItem: public void destroyItem ( ViewGroup container , int position , Object object ) { container . removeView ( ( View ) object ) ; mConvertViews . add ( ( View ) object ) ;
setName: public void setName ( String name ) { this . name = name ;
isDrawLabelsEnabled: public boolean isDrawLabelsEnabled ( ) { return mDrawLabels ;
setApiKey: public void setApiKey ( String apiKey ) { this . apiKey = apiKey ;
batchOpenChannel: public Single < lnrpc . LightningOuterClass . BatchOpenChannelResponse > batchOpenChannel ( lnrpc . LightningOuterClass . BatchOpenChannelRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . batchOpenChannel ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
newSkeleton: No method body
read: public void read ( Json json , JsonValue jsonData ) { this . amount = jsonData . getInt ( "bulletA" , 0 ) ; this . chambered = jsonData . getInt ( "ch" , 0 ) ; this . quality = jsonData . has ( "q" ) ? jsonData . getInt ( "q" ) : - 1 ; if ( jsonData . has ( "mg" ) )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoControlMain1ActionPerformed ( evt ) ;
setIntegerMark: public void setIntegerMark ( boolean integerMark ) { this . integerMark = integerMark ;
getDiscarded: public String [ ] getDiscarded ( ) { String [ ] res = new String [ discard . size ] ; for ( int i = 0 ; i < discard . size ; i ++ ) { res [ i ] = discard . get ( i ) ; } return res ;
GetSteamSettings: public static ClientSettings GetSteamSettings ( ClientEnvironment environment ) { File file = new File ( "settings.json" ) ; SteamSettings clientSettings = new SteamSettings ( environment ) ; clientSettings . init ( ) ; FileHandle fileHandle = new FileHandle ( file ) ; if ( fileHandle . exists ( ) ) { JsonReader jsonReader = new JsonReader ( ) ; JsonValue value = jsonReader . parse ( fileHandle ) ; clientSettings . read ( new Json ( ) , value ) ; } return clientSettings ;
setDetails: protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( this . authenticationDetailsSource . buildDetails ( request ) ) ;
getOwnerLevel: public int getOwnerLevel ( ) { return ownerLevel ;
gotShotFrom: public void gotShotFrom ( ActiveData shooter ) { if ( stack . getTasks ( ) . size > 0 )
getDefaultWidth: protected int getDefaultWidth ( ) { return 0 ;
getInstanceByEntityKey: public static DynamicEntityDescriptor getInstanceByEntityKey ( String entityKey ) { return map . get ( entityKey ) ;
calculateSpeedCoefficient: public float calculateSpeedCoefficient ( ) { float coef = 1.0f ; if ( isThirsty ( ) ) { coef *= 0.8f ; } if ( hasBonesBroken ( ) ) { coef *= 0.8f ; } return coef ;
getId: public final long getId ( ) { return 0 ; }
getContentView: protected int getContentView ( ) { return R . layout . activity_forget_pwd_next ;
notifyAddBullet: private void notifyAddBullet ( ServerPlayerControllerComponentData pc , WeaponData weaponData , ServerWeaponComponentData . Slot primary ) { OtherPlayerMagazineActionMsg msg = pc . generateMagazineActionMessage ( weaponData , WeaponMagazineActionMsg . Action . loadOne ) ; msg . setDataFloat ( primary . getMagAddRoundTime ( ) . asFloat ( ) , 0 ) ; BrainOutServer . Controller . getClients ( ) . sendUDP ( msg , client -> pc . validPlayer ( client , 2 ) ) ; pushTask ( new DelayTask ( getStack ( ) , weaponData . getWeapon ( ) . getPrimaryProperties ( ) . getMagazineAddRoundTime ( ) ) ) ;
getAssetId: public long getAssetId ( ) { return assetId ;
getUpdate_date: public long getUpdate_date ( ) { return update_date ;
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { return ; } try {
getSteamVolume: public double getSteamVolume ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getSteamVolume'" ) ;
setPing: public void setPing ( long ping ) { this . ping = ping ;
create: public Product create ( Product model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Product > responseModel = ( Class < Product > ) ( Class < ? > ) Product . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/products" ) , query , null , responseModel , model ) ;
collectLoggerNames: public String [ ] collectLoggerNames ( ) { return ( String [ ] ) availableLoggers . stream ( ) . map ( ( a ) -> {
getUser: public User getUser ( ) { return null ; }
onUpdateState: protected void onUpdateState ( ) { ActiveData playerData = getData ( ) . getOwner ( ) ; BrainOut . EventMgr . sendDelayedEvent ( WeaponStateUpdatedEvent . obtain (
decrypt: public String decrypt ( String sSrc ) { String decodeString = "" ; try { byte [ ] raw = sKey . getBytes ( StandardCharsets . US_ASCII ) ; SecretKeySpec skeySpec = new SecretKeySpec ( raw , "AES" ) ; @ SuppressLint ( "GetInstance" ) Cipher cipher = Cipher . getInstance ( "AES" ) ; IvParameterSpec iv = new IvParameterSpec ( ivParameter . getBytes ( ) ) ; cipher . init ( Cipher . DECRYPT_MODE , skeySpec , iv ) ; byte [ ] encrypted1 = Base64 . decode ( sSrc ) ; byte [ ] original = cipher . doFinal ( encrypted1 ) ; decodeString = new String ( original , StandardCharsets . UTF_8 ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return decodeString ;
error: public void error ( String reason ) { System . out . println ( reason ) ;
deserialize: public T deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { JsonObject jsonObject = json . getAsJsonObject ( ) ; String discriminatorValue = jsonObject . getAsJsonPrimitive ( this . discriminator ) . getAsString ( ) ; String modelName = this . classMap . get ( discriminatorValue ) ; try { Class < ? > clazz = Class . forName ( modelName ) ; return context . deserialize ( json , clazz ) ; } catch ( Exception e ) { System . err . println ( "Error while deserializing: " + e . getMessage ( ) ) ; } return null ;
canWriteFieldInOrganization: default boolean canWriteFieldInOrganization ( FrontendMappingFieldDefinition field , LongIdEntity entity , Long organizationId ) { return hasFieldPrivileges ( field . writePrivilege , field . canWriteCheck , entity , organizationId ) ;
getSteamMass: public double getSteamMass ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getSteamMass'" ) ;
setLetters: public void setLetters ( String letters ) { this . mLetters = letters ; requestLayout ( ) ; invalidate ( ) ;
getOrder: public int getOrder ( ) { return order ;
getPaintRender: public Paint getPaintRender ( ) { return mRenderPaint ;
getEntityPageAttribute: public PageAttr < Page < E > > getEntityPageAttribute ( ) { return ( PageAttr < Page < E > > ) entityPageAttribute ;
write: public void write ( JSONObject o ) { o . put ( "u" , uses ) ; o . put ( "c" , cnt . getID ( ) ) ;
setId: public void setId ( Long id ) { this . id = id ;
changeCode: private void changeCode ( ) { safe . setLocked ( true ) ; int [ ] code = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { code [ i ] = MathUtils . random ( 0 , 99 ) ; } StringJoiner sj = new StringJoiner ( "," ) ; IntStream . of ( code ) . forEach ( x -> sj . add ( String . valueOf ( x ) ) ) ; if ( Log . INFO ) Log . info ( "Round lock code for " + getMap ( ) . getDimension ( ) + ": " + safe . getCode ( ) ) ; safe . setCode ( sj . toString ( ) ) ;
getMaxTokens: public Integer getMaxTokens ( ) { return maxTokens ;
setData: public void setData ( ScatterData data ) { mScatterData = data ; notifyDataChanged ( ) ;
getVersion: public Single < verrpc . Verrpc . Version > getVersion ( verrpc . Verrpc . VersionRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . getVersion ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
setOrientation: public void setOrientation ( int orientation ) { if ( orientation < 0 || orientation > 2 ) throw new IllegalArgumentException ( "invalid orientation" ) ; mOrientation = orientation ;
hasJustCompleteTasks: public boolean hasJustCompleteTasks ( Quest quest ) { for ( Task task : justCompleteTasks ) { if ( task . getQuest ( ) == quest ) { return true ; } } return false ;
saveForm: public < S extends T > S saveForm ( S entity , AbstractEntityForm form ) { return wrapped . saveForm ( scope , entity , form ) ;
newAction: private Action newAction ( String actionType , JSONObject data ) { ActionType action ; try { action = ActionType . valueOf ( actionType ) ; } catch ( IllegalArgumentException ignored ) { return null ; } return newAction ( action , data ) ;
dismissDialog: private void dismissDialog ( Activity activity ) { if ( activity == null ) { return ; } String key = activity . getClass ( ) . getSimpleName ( ) ; if ( ! needDismissDialog ( key ) ) { LogUtils . d ( TAG , "Dialog无需Dismiss" ) ; return ; } LogUtils . d ( TAG , "Dialog Dismiss" ) ; AlertDialog dialog = mDialogMap . get ( key ) ; if ( dialog != null ) { dialog . dismiss ( ) ; mDialogMap . remove ( key ) ; } ObjectAnimator animator = mDialogAnimatorMap . get ( key ) ; if ( animator != null ) {
onItemRangeChanged: public void onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( mAdapter == null ) return ; if ( mWrapRecyclerAdapter != mAdapter )
getGameProgress: public float getGameProgress ( ) { return 1.0f - ( float ) tickets / ( float ) initialTickets ;
getAudioPath: public @ Null String getAudioPath ( ) { return audioPath ;
getUpdatedTasks: public void getUpdatedTasks ( Consumer < Task > tasks , Quest ofQuest ) { for ( Task task : updatedTasks )
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case setInstrument : { setCurrentInstrument ( ( ( SetInstrumentEvent ) event ) . selected ) ; break ; } case hookInstrument : { setHookedInstrument ( ( ( HookInstrumentEvent ) event ) . selected ) ; break ; } case damaged : { DamagedEvent damaged = ( ( DamagedEvent ) event ) ; tmp . set ( damaged . x , damaged . y , damaged . angle ) ; tmp . setDimension ( getDimension ( ) ) ; super . onEvent ( LaunchEffectEvent . obtain ( LaunchEffectEvent . Kind . custom , tmp , damaged . damageKind ) ) ; break ; } } if ( super . onEvent ( event ) ) { return true ; } if ( currentInstrument != null ) { if ( currentInstrument . onEvent ( event ) ) { return true ; } } return false ;
onDraw: protected void onDraw ( Canvas canvas ) { canvas . drawColor ( mBackgroundColor ) ; canvas . drawLine ( 0 , mHighLightRect . top , mWidth , mHighLightRect . top , mDividerLinePaint ) ; canvas . drawLine ( 0 , mHighLightRect . bottom , mWidth , mHighLightRect . bottom , mDividerLinePaint ) ; for ( int i = 0 ; i < mTextYAxisArray . length ; i ++ ) { if ( mTextYAxisArray [ i ] . mmIndex >= 0 && mTextYAxisArray [ i ] . mmIndex <= mEndNumber - mStartNumber ) { String text ; if ( mTextArray != null ) { text = mTextArray [ mTextYAxisArray [ i ] . mmIndex ] ; } else { text = String . valueOf ( mNumberArray [ mTextYAxisArray [ i ] . mmIndex ] ) ; } canvas . drawText ( text + mFlagText , mWidth / 2 , mTextYAxisArray [ i ] . mmPos + mTextBounds . height ( ) / 2 , mTextPaint ) ; } } canvas . drawRect ( 0 , 0 , mWidth , mHighLightRect . top , mShaderPaintTop ) ; canvas . drawRect ( 0 , mHighLightRect . bottom , mWidth , mHeight , mShaderPaintBottom ) ; if ( MotionEvent . ACTION_UP == mTouchAction && mFlingScroller . isFinished ( ) ) {
clicked: public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; check ( ) ;
getPhysicalY: public float getPhysicalY ( ) { return y + ( ( x % 2 == 0 ) ? 0.5f : 0 ) ;
getTestCaseName: No method body
setIndexString: public void setIndexString ( String indexString ) { this . indexString = indexString ;
onInit: public void onInit ( ) { super . onInit ( ) ; pushMenu ( new EndGameMenu ( endGame ) ) ; pushMenu ( new FadeOutMenu ( ClientConstants . Menu . Flash . FLASH , Color . WHITE ) ) ; BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . popup , this ) ;
getInterpolation: public float getInterpolation ( float input ) { input *= 2f ; if ( input < 1f ) { return - 0.5f * ( ( float ) Math . sqrt ( 1f - input * input ) - 1f ) ; } return 0.5f * ( ( float ) Math . sqrt ( 1f - ( input -= 2f ) * input ) + 1f ) ;
setIsForceUpdate: public void setIsForceUpdate ( String isForceUpdate ) { this . isForceUpdate = isForceUpdate ;
GetRandomItem: public static < T extends Content > T GetRandomItem ( Array < T > items ) { return GetRandomItem ( items , MathUtils . random ( 0xFFFFFFFFL ) ) ;
saveForm: public SearchableOrganizationRelatedEntity saveForm ( AbstractOrganizationRelatedEntityForm form ) { return saveForm ( form , null ) ;
onRequestPermissionSuccess: public void onRequestPermissionSuccess ( ) { mBasePopWindow . dismiss ( ) ; Intent intent = new Intent ( mContext , ScanActivity . class ) ; mContext . startActivity ( intent ) ;
get: public ShopCategory get ( String shopKey , Integer shopCategoryId , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCategory > responseModel = ( Class < ShopCategory > ) ( Class < ? > ) ShopCategory . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/categories/%s" , shopKey , shopCategoryId ) , query , null , responseModel ) ;
read: private void read ( JSONObject data ) { if ( data == null ) return ; this . name = data . optString ( "name" ) ; this . avatar = data . optString ( "avatar" ) ; this . credential = data . optString ( "credential" ) ; this . rating = data . optInt ( "rating" , 0 ) ; JSONObject stats = data . optJSONObject ( "stats" ) ; if ( stats != null )
getRepliedUser: public final Boolean getRepliedUser ( ) { return this . repliedUser ;
getStarMark: public float getStarMark ( ) { return starMark ;
asmStoreParamsString: protected int asmStoreParamsString ( MethodVisitor mv , int printFormat ) { loadArgArray ( ) ; if ( printFormat == 1 ) { mv . visitMethodInsn ( INVOKESTATIC , "java/util/Arrays" , "toString" , "([Ljava/lang/Object;)Ljava/lang/String;" , false ) ; } else if ( printFormat == 2 ) { mv . visitMethodInsn ( INVOKESTATIC , "w/Global" , "toJson" , "(Ljava/lang/Object;)Ljava/lang/String;" , false ) ; } else { mv . visitMethodInsn ( INVOKESTATIC , "w/Global" , "toString" , "(Ljava/lang/Object;)Ljava/lang/String;" , false ) ; } int paramsVarIndex = newLocal ( Type . getType ( String . class ) ) ; mv . visitVarInsn ( ASTORE , paramsVarIndex ) ; return paramsVarIndex ;
setGradientColors: public void setGradientColors ( int startColor , int endColor ) { this . mGradientColors = new int [ ] { startColor , endColor } ;
write: public void write ( Json json ) { for ( ObjectMap . Entry < String , String > entry : objectMap )
replyDirectly: public < TRequest extends Packet > void replyDirectly ( final @ NonNull TRequest response ) { replyDirectly ( response , null ) ;
applicable: public boolean applicable ( UserProfile profile ) { if ( statsFilters != null ) { if ( ! statsFilters . checkFilters ( profile ) ) { return false ; } } if ( itemsFilters != null ) { if ( ! itemsFilters . checkFilters ( profile ) ) { return false ; } } if ( limited ) return ! content . hasItem ( profile ) ; return true ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , String datalistId , FieldType type , BiFunction < DtoAndEntity , SecureEntityDictionaryRepository , Object > datalistSupplier , PrivilegeBase requiredReadPrivilege , PrivilegeBase requiredWritePrivilege ) { return new FrontendMappingFieldDefinition ( formName , name , type , null , null , requiredReadPrivilege ,
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; accepted ( ) ;
getTenant: public TenantResponse getTenant ( final String identifier ) throws IOException , NovuNetworkException { try {
close: private void close ( ) { pop ( ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
onResponse: public void onResponse ( byte [ ] bytes ) { try {
getTeamNames: public Array < String > getTeamNames ( ) { return teamNames ;
min: public static < T > T min ( List < T > list , Comparator < ? super T > cmp ) { T candidate = list . get ( 0 ) ; for ( T next : list ) { if ( cmp . compare ( candidate , next ) > 0 ) { candidate = next ; } } return candidate ;
getEnabled: public int getEnabled ( ) { return enabled ;
popIfFocusOut: public boolean popIfFocusOut ( ) { return true ;
init: private Event init ( String message , int repeat ) { this . message = message ; this . repeat = repeat ; return this ;
create: public ShopCountryWarehouse create ( String shopKey , String countryCode , ShopCountryWarehouse model ) throws ApiErrorException , ConnectionException { Class < ShopCountryWarehouse > responseModel = ( Class < ShopCountryWarehouse > ) ( Class < ? > ) ShopCountryWarehouse . class ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/warehouses" , shopKey , countryCode ) , null , null , responseModel , model ) ;
isServer: public boolean isServer ( ) { return false ;
onPagerDrawComplete: No method body
getY: public float getY ( ) { return activeData . getY ( ) ;
getAutoState: public int getAutoState ( ) { return autoState ;
getBarData: public BarData getBarData ( ) { return mData ;
onPreExecute: public void onPreExecute ( Context context , Map < String , Object > params ) { params . put ( KEY_USER_ID , User . getInstance ( ) . getUserId ( context ) ) ; params . put ( KEY_TOKEN , User . getInstance ( ) . getToken ( context ) ) ; params . put ( KEY_VERSION , AppUtils . getAppVersionName ( context ) ) ; params . put ( KEY_SERVER_TYPE , Constants . SERVER_TYPE_ANDROID ) ; params . put ( KEY_REQUEST_TIME , System . currentTimeMillis ( ) ) ; params . put ( KEY_IMEI , AppUtils . getPhoneIMEI ( context ) ) ; onPreExecute ( context ) ;
setWounded: public void setWounded ( boolean wounded ) { this . wounded = wounded ; updateWounded ( ) ;
populateFrom: public EventListenerForm populateFrom ( EventListenerEntry entity ) { dto . consumer = entity . getConsumerString ( ) ; dto . event = entity . getEventString ( ) ; dto . staticData1 = entity . getStaticData1 ( ) ; dto . staticData2 = entity . getStaticData2 ( ) ; dto . staticData3 = entity . getStaticData3 ( ) ; dto . staticData4 = entity . getStaticData4 ( ) ; dto . organizationId = entity . getOrganizationId ( ) ; return this ;
xPerMode: public PaintHolder xPerMode ( PorterDuff . Mode mode ) { this . paint . setXfermode ( new PorterDuffXfermode ( mode ) ) ; return this ;
obtain: public static Event obtain ( InstrumentInfo info , int destroyer , float x , float y , float angle , boolean notify ) { DestroyEvent e = obtain ( DestroyEvent . class ) ; if ( e == null ) return null ; return e . init ( info , destroyer , x , y , angle , notify ) ;
draw: public void draw ( TextureRegion region , float x , float y , float width , float height ) { if ( ! drawing ) throw new IllegalStateException ( "begin must be called before draw." ) ; final short [ ] triangles = this . triangles ; final float [ ] vertices = this . vertices ; Texture texture = region . getTexture ( ) ; if ( texture != lastTexture ) switchTexture ( texture ) ; else if ( triangleIndex + 6 > triangles . length || vertexIndex + SPRITE_SIZE > vertices . length ) flush ( ) ; int triangleIndex = this . triangleIndex ; final int startVertex = vertexIndex / VERTEX_SIZE ; triangles [ triangleIndex ++ ] = ( short ) startVertex ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 1 ) ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 2 ) ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 2 ) ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 3 ) ; triangles [ triangleIndex ++ ] = ( short ) startVertex ; this . triangleIndex = triangleIndex ; final float fx2 = x + width ; final float fy2 = y + height ; final float u = region . getU ( ) ; final float v = region . getV2 ( ) ; final float u2 = region . getU2 ( ) ; final float v2 = region . getV ( ) ; float light = this . lightPacked ; float dark = this . darkPacked ; int idx = this . vertexIndex ; vertices [ idx ++ ] = x ; vertices [ idx ++ ] = y ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u ; vertices [ idx ++ ] = v ; vertices [ idx ++ ] = x ; vertices [ idx ++ ] = fy2 ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u ; vertices [ idx ++ ] = v2 ; vertices [ idx ++ ] = fx2 ; vertices [ idx ++ ] = fy2 ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u2 ; vertices [ idx ++ ] = v2 ; vertices [ idx ++ ] = fx2 ; vertices [ idx ++ ] = y ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u2 ; vertices [ idx ++ ] = v ; this . vertexIndex = idx ;
lockInput: public boolean lockInput ( ) { return true ;
drawLineScanner: private void drawLineScanner ( Canvas canvas , Rect frame ) { LinearGradient linearGradient = new LinearGradient ( frame . left , scannerStart , frame . left , scannerStart + SCANNER_LINE_HEIGHT , shadeColor ( laserColor ) , laserColor , Shader . TileMode . MIRROR ) ; paint . setShader ( linearGradient ) ; if ( scannerStart <= scannerEnd ) {
isInExpandedBlockedMessageChunk: public boolean isInExpandedBlockedMessageChunk ( ) { return false ;
removeLoadView: public void removeLoadView ( ) { if ( mLoadView != null ) {
log: public boolean log ( Object logEntry ) throws IOException , InterruptedException { log ( logEntry + "" ) ; return true ;
updateSteamOutflow: public void updateSteamOutflow ( double flow , double tempC ) { steamOutflow += flow ;
disableAttachment: public void disableAttachment ( String attachment ) { if ( disabledAttachments == null ) { disabledAttachments = new ObjectSet < > ( ) ; } disabledAttachments . add ( attachment ) ; resetAnimation ( ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcClose4ItemStateChanged ( evt ) ;
isRuleValid: public static boolean isRuleValid ( String rule ) { SpelExpressionParser parser = new SpelExpressionParser ( ) ; try {
setUp: protected void setUp ( ) { mockWebServer = new MockWebServer ( ) ; NovuConfig novuConfig = new NovuConfig ( "1234" ) ; novuConfig . setBaseUrl ( mockWebServer . url ( "" ) . toString ( ) ) ; RestHandler restHandler = new RestHandler ( novuConfig ) ; blueprintsHandler = new BlueprintsHandler ( restHandler ) ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . gameController , this ) ;
changeFlashMode: private void changeFlashMode ( ) { if ( camera == null ) { return ; } Camera cameraObject = camera . getCamera ( ) ; if ( cameraObject == null ) { return ; } Camera . Parameters parameters = cameraObject . getParameters ( ) ; if ( mFlashMode == CameraConfig . FLASH_MODE_TORCH ) { parameters . setFlashMode ( Camera . Parameters . FLASH_MODE_TORCH ) ; } else if ( mFlashMode == CameraConfig . FLASH_MODE_OFF ) { parameters . setFlashMode ( Camera . Parameters . FLASH_MODE_OFF ) ; } else if ( mFlashMode == CameraConfig . FLASH_MODE_AUTO ) { parameters . setFlashMode ( Camera . Parameters . FLASH_MODE_AUTO ) ; } else { parameters . setFlashMode ( Camera . Parameters . FLASH_MODE_AUTO ) ; } cameraObject . setParameters ( parameters ) ;
warn: default void warn ( String message , Throwable throwable ) { logToDebugStack ( throwable , message , false ) ; message = appendRequestId ( message ) ; getLogger ( ) . warn ( message , throwable ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jRadioButtonMenuItem6ActionPerformed ( evt ) ;
inspect: No method body
transform: public void transform ( Vector2 position , Vector2 uv , Color light , Color dark ) { float x = position . x - worldX ; float y = position . y - worldY ; float dist = ( float ) Math . sqrt ( x * x + y * y ) ; if ( dist < radius ) {
getStayAnimationTimeScale: public RandomValue getStayAnimationTimeScale ( ) { return stayAnimationTimeScale ;
setup: void setup ( ) { dvd = new Dvd ( "Moon" , 2011 , 130 ) ;
info: public static void info ( Object content ) { log ( 1 , "" + content ) ;
setLinkedinUser: public void setLinkedinUser ( LinkedinUser linkedinUser ) { this . linkedinUser = linkedinUser ;
obtain: public static Event obtain ( PlayerData playerData ) { EarnEvent e = obtain ( EarnEvent . class ) ; if ( e == null ) return null ; return e . init ( playerData ) ;
showLayoutBgWithSize: public static void showLayoutBgWithSize ( final Context context , Object imagePath , final ViewGroup layout , int width , int height , final int placeHolder ) { Glide . with ( context )
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights )
getTextColor: public int getTextColor ( ) { return mTextColor ;
getName: public String getName ( ) { return name ;
updateButton: public void updateButton ( boolean on ) { SpriteData data = getButtonSprite ( ) ; if ( data == null ) return ; data . spriteName = on ? getContentComponent ( ) . getButtonOn ( ) : getContentComponent ( ) . getButtonOff ( ) ; data . updated ( ) ;
isDrawCenterTextEnabled: public boolean isDrawCenterTextEnabled ( ) { return mDrawCenterText ;
getUpdatedOn: public LocalDateTime getUpdatedOn ( ) { return updatedOn ;
getComponent: public SpriteComponentData getComponent ( ComponentObject componentObject ) { return new SpriteComponentData ( ( SpriteData ) componentObject , this ) ;
getInputAccept: public String getInputAccept ( ) { return inputAccept ;
resize: public void resize ( float width , float height ) { this . width = width ; this . height = height ;
isComplete: public boolean isComplete ( PlayStateEndGame . GameResult gameResult ) { return false ;
getText: public String getText ( ) { return text ;
getHookTo: public Bone getHookTo ( ) { return hookTo ;
removeEntryByXValue: public boolean removeEntryByXValue ( float xValue ) { T e = getEntryForXValue ( xValue , Float . NaN ) ; return removeEntry ( e ) ;
getHolder: public Button getHolder ( ) { return ( ( Button ) getActor ( ) ) ;
findById: public Optional < DynamicPrivilege > findById ( Long id ) { return dynamicPrivilegeRepository . findById ( id ) ;
onHiddenChanged: public void onHiddenChanged ( boolean hidden ) { super . onHiddenChanged ( hidden ) ; this . mIsVisibility = ! hidden ; if ( mIsVisibility ) {
registerActive: public void registerActive ( ActiveData activeData , Client client ) { actives . put ( activeData , client ) ;
reset: private void reset ( InstrumentAnimationComponentData iac ) { dispose ( ) ; generate ( iac ) ;
setValueTextColor: No method body
received: public boolean received ( NewRemoteClientMsg msg ) { JSONObject info = null ; try { info = new JSONObject ( msg . info ) ; } catch ( Exception ignored ) { return true ; } addRemoteClient ( msg . id , msg . name , msg . avatar , msg . clanAvatar , msg . clanId , msg . team , msg . rights , info ) ; return true ;
getArea: void getArea ( ) { assertEquals ( 100 , rectangle . getArea ( ) , DELTA ) ;
isCompleted: public boolean isCompleted ( ) { return readyResult != null ;
CheckDeviceIDS: public static Boolean CheckDeviceIDS ( Context context ) { if ( PermissionChecker . checkReadPhoneStatePermission ( context ) ) { TelephonyManager telephonyManager = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; String deviceIds = telephonyManager . getDeviceId ( ) ; for ( String knowDevicesId : mKnownDeviceIds ) { if ( knowDevicesId . equalsIgnoreCase ( deviceIds ) ) { LogUtils . e ( TAG , "Find ids: 000000000000000!" ) ; return true ; } } } LogUtils . e ( TAG , "Not Find ids: 000000000000000!" ) ; return false ;
saveOne: default < S extends T > S saveOne ( S entity ) { return SearchableFunctionalRepositoryWithLongId . super . saveOne ( DEFAULT_SCOPE , entity ) ;
newProgressDialog: public static ProgressDialog newProgressDialog ( Context context ) { ProgressDialog pd = new ProgressDialog ( context , AlertDialog . THEME_DEVICE_DEFAULT_DARK ) ; pd . setIcon ( Constants . APP_ICON ) ; return pd ;
buildAndListen: public int buildAndListen ( ) { return handleStart ( build ( ) . listen ( ) ) ;
getWaterInflow2Temp: public double getWaterInflow2Temp ( ) { return waterInflowTemperature2 ;
setReadPrivilege: public void setReadPrivilege ( PrivilegeBase readPrivilege ) { this . readPrivilege = readPrivilege ; this . readPrivilegeStringTimestamp = System . nanoTime ( ) ; if ( readPrivilege != null ) {
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case activeActivateData : { ActivateActiveEvent ev = ( ( ActivateActiveEvent ) event ) ; unlock ( ev . client , ev . playerData , ev . payload ) ; return true ; } } return false ;
TAG: static int TAG ( int tag ) { return 1 << tag ;
exchange: public void exchange ( InventoryPanel . InventoryRecord record , InventoryPanel from , InventoryPanel to ) { if ( split ( record . getRecord ( ) ) )
getPercent: public double getPercent ( ) { return percent ;
maxServiceProtocolVersion: static Protocol . ServiceProtocolVersion maxServiceProtocolVersion ( boolean experimentalContextEnabled ) { return experimentalContextEnabled
setName: public void setName ( String name ) { this . name = name ;
mouseMoved: public boolean mouseMoved ( InputEvent event , float x , float y ) { return true ;
bakeMacaroon: public Single < lnrpc . LightningOuterClass . BakeMacaroonResponse > bakeMacaroon ( lnrpc . LightningOuterClass . BakeMacaroonRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . bakeMacaroon ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
applyAbsoluteLocal: private void applyAbsoluteLocal ( ) { float mixRotate = this . mixRotate , mixX = this . mixX , mixY = this . mixY , mixScaleX = this . mixScaleX , mixScaleY = this . mixScaleY , mixShearY = this . mixShearY ; Bone target = this . target ; Object [ ] bones = this . bones . items ; for ( int i = 0 , n = this . bones . size ; i < n ; i ++ ) {
getWaterOutflowRate: No method body
getRequiredWritePrivilege: No method body
delete: public void delete ( String shopKey , String countryCode , Integer packageGroupId , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/package-groups/%s" , shopKey , countryCode , packageGroupId ) , query , null , null ) ;
setEmail: public void setEmail ( boolean isEmail ) { this . email = isEmail ;
getBadgeId: public String getBadgeId ( ) { return "event-" + id ;
notFound: public void notFound ( ) { pop ( ) ;
getType: No method body
toString: public String toString ( ) { return name ;
notificationMessage: public String notificationMessage ( ) { return String . format ( "Organization %s" , name ) ;
getModulesForNames: public List < Module > getModulesForNames ( @ NotNull List < String > moduleNames ) { return modules . stream ( ) . filter ( a -> moduleNames . contains ( a . getName ( ) ) ) . collect ( Collectors . toList ( ) ) ;
setAdapter: public void setAdapter ( Adapter adapter ) { if ( mAdapter != null ) { mAdapter . unregisterAdapterDataObserver ( mDataObserver ) ; mAdapter = null ; } this . mAdapter = adapter ; if ( adapter instanceof WrapRecyclerAdapter ) { mWrapRecyclerAdapter = ( WrapRecyclerAdapter ) adapter ; } else { mWrapRecyclerAdapter = new WrapRecyclerAdapter ( adapter ) ; } super . setAdapter ( mWrapRecyclerAdapter ) ; mAdapter . registerAdapterDataObserver ( mDataObserver ) ; mWrapRecyclerAdapter . adjustSpanSize ( this ) ;
stats: public Single < wtclientrpc . Wtclient . StatsResponse > stats ( wtclientrpc . Wtclient . StatsRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . stats ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
onTouchEvent: public void onTouchEvent ( MotionEvent event ) { final int Action = event . getActionMasked ( ) ; switch ( Action ) {
getWaterTemperature: public double getWaterTemperature ( ) { return waterTemperature ;
getID: public ID getID ( ) { return ID . activeActivateData ;
handleHttpResponse: public void handleHttpResponse ( Net . HttpResponse httpResponse ) { byte [ ] result = httpResponse . getResult ( ) ; Gdx . app . postRunnable ( ( ) ->
getId: public Long getId ( ) { return id ;
installAPKFile: public void installAPKFile ( Context context , File file , String provider ) { this . mApkFile = file ; if ( file == null ) { LogUtils . e ( TAG , "APK File Is Null" ) ; return ; } if ( ! file . exists ( ) ) { LogUtils . e ( TAG , "APK File Not Exists" ) ; return ; } LogUtils . e ( TAG , "安装文件：" + file . getAbsolutePath ( ) ) ; try {
updateAppliedTransform: public void updateAppliedTransform ( ) { Bone parent = this . parent ; if ( parent == null ) { ax = worldX - skeleton . x ; ay = worldY - skeleton . y ; float a = this . a , b = this . b , c = this . c , d = this . d ; arotation = atan2 ( c , a ) * radDeg ; ascaleX = ( float ) Math . sqrt ( a * a + c * c ) ; ascaleY = ( float ) Math . sqrt ( b * b + d * d ) ; ashearX = 0 ; ashearY = atan2 ( a * b + c * d , a * d - b * c ) * radDeg ; return ; } float pa = parent . a , pb = parent . b , pc = parent . c , pd = parent . d ; float pid = 1 / ( pa * pd - pb * pc ) ; float dx = worldX - parent . worldX , dy = worldY - parent . worldY ; ax = ( dx * pd * pid - dy * pb * pid ) ; ay = ( dy * pa * pid - dx * pc * pid ) ; float ia = pid * pd ; float id = pid * pa ; float ib = pid * pb ; float ic = pid * pc ; float ra = ia * a - ib * c ; float rb = ia * b - ib * d ; float rc = id * c - ic * a ; float rd = id * d - ic * b ; ashearX = 0 ; ascaleX = ( float ) Math . sqrt ( ra * ra + rc * rc ) ; if ( ascaleX > 0.0001f ) {
setForceSelect: public void setForceSelect ( boolean forceSelect ) { this . forceSelect = forceSelect ;
onBuildUp: protected void onBuildUp ( ) { BrainOutClient . ClientController . sendTCP ( new WeaponActionMsg ( getRecord ( ) , WeaponActionMsg . Action . buildUp , getSlot ( ) ) ) ; BrainOut . EventMgr . sendDelayedEvent ( getData ( ) . getOwner ( ) ,
getServerName: private String getServerName ( ) { switch ( getMode ( ) )
test_triggerEventToSubscriber: public void test_triggerEventToSubscriber ( ) throws IOException , NovuNetworkException , InterruptedException { TriggerEventRequest triggerEventRequest = new TriggerEventRequest ( ) ; triggerEventRequest . setName ( "name" ) ; SubscriberRequest subscriberRequest = new SubscriberRequest ( ) ; subscriberRequest . setFirstName ( "fName" ) ; subscriberRequest . setLastName ( "lName" ) ; subscriberRequest . setEmail ( "mail@sample.com" ) ; subscriberRequest . setSubscriberId ( "subId" ) ; triggerEventRequest . setTo ( subscriberRequest ) ; triggerEventRequest . setPayload ( Collections . singletonMap ( "customVariables" , "Hello" ) ) ; triggerEventRequest . setActor ( "actor" ) ; triggerEventRequest . setTenant ( "tenant" ) ; TriggerEventResponse triggerEventResponse = new TriggerEventResponse ( ) ; TriggerEventResponseData data = new TriggerEventResponseData ( ) ; data . setAcknowledged ( true ) ; data . setStatus ( "done" ) ; data . setTransactionId ( "id" ) ; triggerEventResponse . setData ( data ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( triggerEventResponse ) ) ) ; TriggerEventResponse response = eventsHandler . triggerEvent ( triggerEventRequest ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/events/trigger" , request . getPath ( ) ) ; assertEquals ( "POST" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( triggerEventResponse ) , gson . toJson ( response ) ) ;
getID: public ID getID ( ) { return ID . instrumentAction ;
findRadioButton: public RadioButton findRadioButton ( ViewGroup group ) { RadioButton resBtn = null ; int len = group . getChildCount ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( group . getChildAt ( i ) instanceof RadioButton ) { resBtn = ( RadioButton ) group . getChildAt ( i ) ; } else if ( group . getChildAt ( i ) instanceof ViewGroup ) { findRadioButton ( ( ViewGroup ) group . getChildAt ( i ) ) ; } } return resBtn ;
handleMessage: public void handleMessage ( Message msg ) { super . handleMessage ( msg ) ; if ( mAdapter == null ) { return ; } if ( mAdapter . getPageCount ( ) > 1 ) { setCurrentItem ( getCurrentItem ( ) + 1 ) ; } startRollDelayed ( ) ;
getUserSettingDirectory: public String getUserSettingDirectory ( Context context ) { String channelBackupPath = User . getInstance ( ) . getChannelBackupPathArray ( context ) ; return channelBackupPath ;
showKeyboard: public static void showKeyboard ( View view ) { InputMethodManager imm = ( InputMethodManager ) view . getContext ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; if ( imm != null ) {
run: public void run ( ) { ps . popAllUntil ( ActionPhaseMenu . class ) ; ps . pushMenu ( new FreePlayFollowFriendMenu ( finalFollow . getMap ( ) , finalFollow , this :: done ) ) ;
sendTCP: public int sendTCP ( Object object ) { return connection . sendTCP ( object ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
getFloat: public float getFloat ( ) { return floatValue ;
escape: public boolean escape ( ) { done ( ) ; pop ( ) ; return true ;
isSilent: public boolean isSilent ( ) { return silent . asBoolean ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( option . isChecked ( ) )
apply: public void apply ( PlayerClient playerClient , boolean notify ) { float add = this . amount * multiply ; float have = playerClient . getProfile ( ) . getStats ( ) . get ( id , 0.0f ) ; if ( max >= 0 ) { if ( have + add > max ) { add = Math . max ( max - have , 0 ) ; } } switch ( id ) { case Constants . User . NUCLEAR_MATERIAL : { playerClient . notify ( NotifyAward . nuclearMaterial , add , NotifyReason . nuclearMaterialReceived , NotifyMethod . message , null ) ; break ; } case Constants . User . SKILLPOINTS : { playerClient . notify ( NotifyAward . skillpoints , add , NotifyReason . skillPointsEarned , NotifyMethod . message , null ) ; break ; } case "ch" : { playerClient . notify ( NotifyAward . ch , add , NotifyReason . chEarned , NotifyMethod . message , null ) ; break ; } case "ru" : { playerClient . notify ( NotifyAward . ru , add , NotifyReason . ruEarned , NotifyMethod . message , null ) ; break ; } case "gears" : { playerClient . notify ( NotifyAward . gears , add , NotifyReason . gearsEarned , NotifyMethod . message , null ) ; break ; } } playerClient . addStat ( id , add ) ; playerClient . sendUserProfile ( ) ;
calculatePosition: public void calculatePosition ( RenderContext context ) { Watcher watcher = Map . GetWatcher ( ) ; float offsetX = 0 , offsetY = 0 ; if ( watcher != null ) { if ( ! watcher . getDimension ( ) . equals ( getParallaxData ( ) . getDimension ( ) ) ) return ; float s ; if ( isScale ( ) ) { s = textureSize . y < context . height ? context . height / textureSize . y : 1.0f ; } else { s = 1.0f ; } float w = textureSize . x * s ; offsetX = - getPlayerX ( watcher ) * Constants . Graphics . RES_SIZE * getCoefX ( ) % w - w ; if ( top ) { offsetY = BrainOutClient . getHeight ( ) - textureSize . y ; } offsetY -= watcher . getWatchY ( ) * Constants . Graphics . RES_SIZE * getCoefY ( ) ; } position . set ( getX ( ) + getCameraX ( ) + offsetX , getCameraY ( ) + getY ( ) + offsetY ) ;
init: private Event init ( String [ ] maps ) { this . maps = maps ; return this ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem2ActionPerformed ( evt ) ;
readTimeline: private Timeline readTimeline ( JsonValue keyMap , CurveTimeline2 timeline , String name1 , String name2 , float defaultValue , float scale ) { float time = keyMap . getFloat ( "time" , 0 ) ; float value1 = keyMap . getFloat ( name1 , defaultValue ) * scale , value2 = keyMap . getFloat ( name2 , defaultValue ) * scale ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) {
getInstance: public static WalletState getInstance ( ) { if ( mInstance == null ) { synchronized ( WalletState . class ) { if ( mInstance == null ) { mInstance = new WalletState ( ) ; } } } return mInstance ;
setCubicIntensity: public void setCubicIntensity ( float intensity ) { if ( intensity > 1f ) intensity = 1f ; if ( intensity < 0.05f ) intensity = 0.05f ; mCubicIntensity = intensity ;
updateChanStatus: No method body
checkCancelReloading: public void checkCancelReloading ( ) { if ( state == State . reloading )
startNodeInternal: public ProfilingNode startNodeInternal ( final String nodeName ) { final ProfilingNode parent ; synchronized ( currentNodes ) {
setBoolean: public static void setBoolean ( String key , boolean value ) { getPreferences ( ) . edit ( ) . putBoolean ( key , value ) . commit ( ) ;
putPoints: public void putPoints ( Team team , int pointsValue ) { ObjectMap < Team , Integer > points = getGameMode ( ) . getScores ( ) ; Integer have = points . get ( team ) ; points . put ( team , have != null ? have + pointsValue : pointsValue ) ;
unloadPlayers: private void unloadPlayers ( ServerElevatorFloorComponentData floor ) { for ( PlayerData playerData : aboard )
onMessageDeleted: public void onMessageDeleted ( String messageId , String sender , int gamespace ) { playerClient . socialMessageDeleted ( messageId , sender ) ;
returnArrTest: public void returnArrTest ( ) { WatchMessage msg = new WatchMessage ( ) ; msg . setSignature ( "w.core.WatchTarget#toString" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; System . out . println ( new WatchTarget ( ) . toString ( ) ) ; new WatchTarget ( ) ; DecompileMessage msg2 = new DecompileMessage ( ) ; msg2 . setClassName ( "w.core.WatchTarget" ) ; Assertions . assertTrue ( swapper . swap ( msg2 ) ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
loadBarEntriesFromAssets: public static List < BarEntry > loadBarEntriesFromAssets ( AssetManager am , String path ) { List < BarEntry > entries = new ArrayList < BarEntry > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( am . open ( path ) , "UTF-8" ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { String [ ] split = line . split ( "#" ) ; entries . add ( new BarEntry ( Float . parseFloat ( split [ 1 ] ) , Float . parseFloat ( split [ 0 ] ) ) ) ; line = reader . readLine ( ) ; } } catch ( IOException e ) { Log . e ( LOG , e . toString ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { Log . e ( LOG , e . toString ( ) ) ; } } } return entries ;
isInsideSideEffect: No method body
testAllProperties: public void testAllProperties ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < ShopCategoryProperty > responseEntity = this . api . shopCategories ( ) . allProperties ( "acme" , "acme" , 1 , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCategoryAllPropertiesResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( ShopCategoryProperty entity : responseEntity . getEntities ( ) ) {
reverseCharAt: public static String reverseCharAt ( String string ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = string . length ( ) - 1 ; i >= 0 ; i -- ) { sb . append ( string . charAt ( i ) ) ; } return sb . toString ( ) ;
setLocation: public void setLocation ( String location ) { this . location = location ;
getAction: public String getAction ( ) { return action ;
i_should_see_form_alert: public void i_should_see_form_alert ( String formAlertMessage , String alertType ) { switch ( alertType ) {
createDefaultObjectMapper: public static ObjectMapper createDefaultObjectMapper ( ) { return new ObjectMapper ( ) . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ;
onClick: public void onClick ( View v ) { switchActivityFinish ( AccountLightningActivity . class ) ;
limitFrom: public void limitFrom ( int from ) { if ( from < 0 ) from = 0 ; mFrom = from ;
cancel: No method body
component3: public final boolean component3 ( ) { return this . isTouchedSinceLastJump ;
getDimension: public String getDimension ( ) { return launchData . getDimension ( ) ;
getInstance: public static MyBatisBeanReloader getInstance ( ) { return MyBatisBeanReloaderHolder . instance ;
getAmount: public int getAmount ( ) { return amount ;
setCompress: public void setCompress ( boolean compress ) { this . compress = compress ;
updateAssetDataAmount: private void updateAssetDataAmount ( String propertyId , double amount ) { try {
render: public void render ( Batch batch , RenderContext renderContext ) { this . batch = batch ; if ( state != null )
isEnum: public boolean isEnum ( ) { return inSQL [ 0 ] . equals ( "ENUM" ) ;
attachBestLoadedMagazine: public boolean attachBestLoadedMagazine ( int except ) { int bestId = getBestLoadedMagazine ( except ) ; if ( bestId == - 1 ) { return false ; } return attach ( bestId ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new ShieldComponentData ( ( ( InstrumentData ) componentObject ) , this ) ;
fitSystemWindows: protected final boolean fitSystemWindows ( Rect insets ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . KITKAT ) { mInsets [ 0 ] = insets . left ; mInsets [ 1 ] = insets . top ; mInsets [ 2 ] = insets . right ; insets . left = 0 ; insets . top = 0 ; insets . right = 0 ; } return super . fitSystemWindows ( insets ) ;
mouseMoved: public boolean mouseMoved ( InputEvent event , float x , float y ) { if ( ordersPane == null ) return super . mouseMoved ( event , x , y ) ; updateHoveredRow ( ) ; return super . mouseMoved ( event , x , y ) ;
setLabels: public void setLabels ( List < SelectEntity > labels ) { this . mLabelsList = labels ; removeAllViews ( ) ; if ( mLabelsList != null && mLabelsList . size ( ) > 0 ) {
onReceive: public void onReceive ( final @ NonNull MessageContext < T > context ) { final ErrorInformationResponse errorPacket = ( ErrorInformationResponse ) context . getRequest ( ) ; client . getLogger ( ) . warn ( "Received error message from the server. Error code: {}, Description: {}" , errorPacket . getErrorCode ( ) , errorPacket . getErrorDescription ( ) ) ;
onResponseError: protected void onResponseError ( Context context , String errorCode , String errorMsg ) { super . onResponseError ( context , errorCode , errorMsg ) ; if ( callback != null ) {
run: public String run ( WorkflowContext context , String request ) { return null ;
success: No method body
findByLinkedinId: No method body
createFile: public static void createFile ( String src ) throws IOException { Files . createFile ( Paths . get ( src ) ) ;
deleteReductions: public void deleteReductions ( String shopKey , Integer campaignId , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/shops/%s/campaigns/%s/reductions" , shopKey , campaignId ) , query , null , null ) ;
isActiveProfile: public static boolean isActiveProfile ( String profile ) { String profilesCommaSeparated = System . getProperty ( SPRING_PROFILES_ACTIVE_PROP ) ; if ( profilesCommaSeparated == null ) { Matcher m = PROFILE_PATTERN . matcher ( System . getProperty ( "sun.java.command" ) ) ; if ( m . matches ( ) ) { profilesCommaSeparated = m . group ( 1 ) ; } } if ( profilesCommaSeparated == null ) { profilesCommaSeparated = System . getenv ( SPRING_PROFILES_ACTIVE_ENV ) ; } if ( profilesCommaSeparated == null ) { return false ; } return ArrayUtils . contains ( StringUtils . split ( profilesCommaSeparated , ',' ) , profile ) ;
extractClassPath: public static String extractClassPath ( final JsonObject json ) { return json . get ( "packetCls" ) . getAsString ( ) ;
getZIndex: public int getZIndex ( ) { return 1 ;
getPageCount: public int getPageCount ( ) { return mBannerData == null ? 0 : mBannerData . size ( ) ;
onClickTitle: public void onClickTitle ( int index , boolean showMenu , View titleView ) { if ( titleView == null ) { return ; } if ( showMenu ) { mMenuView . showMenuByIndex ( index ) ; } if ( mCallback != null ) {
getStatementSearchSelectedBox: public Object getStatementSearchSelectedBox ( @ PathVariable ( ORGANIZATIONID ) Long organizationId , @ RequestParam ( "fieldName" ) String fieldName , @ RequestParam ( "selectedId" ) String selectedId , @ RequestParam ( "imgUrl" ) String imgUrl , @ RequestParam ( "label" ) String label , @ RequestParam ( "url" ) String url ) { debug ( "[getStatementSearchSelectedBox] orgId {}" , organizationId ) ; return new ModelAndView ( "forms::selected-searchable(selectedId=" + selectedId + ", fieldName=" + fieldName
setEditorWatcher: public void setEditorWatcher ( EditorWatcher editorWatcher ) { this . editorWatcher = editorWatcher ;
getFrequency: public int getFrequency ( ) { return frequency ;
onlineInitialized: public void onlineInitialized ( boolean newPlayerClient ) { Medal ambassador = BrainOutServer . ContentMgr . get ( "medal-embassador" , Medal . class ) ; Medal skinMaker = BrainOutServer . ContentMgr . get ( "medal-skin-maker" , Medal . class ) ; Medal steamMedal = BrainOutServer . ContentMgr . get ( "medal-steam" , Medal . class ) ; if ( ambassador != null && skinMaker != null && steamMedal != null ) { if ( profile != null && ( profile . hasItem ( ambassador ) || profile . hasItem ( skinMaker ) || profile . hasItem ( steamMedal ) ) ) { setSpecial ( ) ; } } if ( newPlayerClient ) { GameMode gameMode = getServerController ( ) . getGameMode ( ) ; if ( gameMode != null ) { ModePayload payload = ( ( ServerRealization ) gameMode . getRealization ( ) ) . newPlayerPayload ( this ) ; setModePayload ( payload ) ; } PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( BrainOut . R . instanceOf ( PlayStateGame . class , playState ) ) { PlayStateGame game = ( ( PlayStateGame ) playState ) ; GameMode mode = game . getMode ( ) ; if ( mode != null ) { ServerRealization serverRealization = ( ServerRealization ) mode . getRealization ( ) ; serverRealization . newPlayerClient ( this ) ; } } } sendServerInfo ( ) ;
getAppendAndGet: No method body
extractingHandler: public ObjectAssert < Handler > extractingHandler ( String handlerName ) { Optional < Handler > handler = this . actual . getHandlers ( ) . stream ( ) . filter ( s -> s . getName ( ) . equals ( handlerName ) ) . findFirst ( ) ; if ( handler . isEmpty ( ) ) { fail ( "Expecting service {} manifest to contain handler {}. Available handler: {}" , this . actual . getName ( ) , handlerName , this . actual . getHandlers ( ) . stream ( ) . map ( Handler :: getName ) . collect ( Collectors . toList ( ) ) ) ; } return assertThat ( handler . get ( ) ) ;
selectedStandard: public void selectedStandard ( String name ) { settings . getMap ( ) . define ( name ) ; callback . changed ( "main" ) ; button . setText ( L . get ( "MAP_" + name . toUpperCase ( ) ) ) ;
onResume: protected void onResume ( ) { super . onResume ( ) ; if ( isStopApp ( ) ) {
getCustomDataKeyForCountry: public Map < String , Object > getCustomDataKeyForCountry ( String shopKey , Integer shopCategoryId , String countryCode , String key ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "get" , this . resolvePath ( "/shops/%s/categories/%s/countries/%s/custom-data/%s" , shopKey , shopCategoryId , countryCode , key ) , null , null , responseModel ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; limit = jsonData . getInt ( "limit" , limit ) ;
addImpulse: public void addImpulse ( float x , float y ) { speed . add ( x , y ) ;
calculatePermissions: private Set < String > calculatePermissions ( ) { return permissions ;
exit: public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { change . setVisible ( false ) ;
clearEtFocus: public void clearEtFocus ( ) { mContentEt . clearFocus ( ) ;
obtain: public static Event obtain ( ) { DestroyEvent e = obtain ( DestroyEvent . class ) ; if ( e == null ) return null ; return e . init ( ) ;
isDiskFullException: private boolean isDiskFullException ( Throwable throwable ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { Throwable cause = throwable ; while ( ( cause = cause . getCause ( ) ) != null ) { if ( throwable instanceof SQLiteFullException ) { return true ; } else if ( throwable instanceof SQLiteDiskIOException ) { return true ; } else if ( throwable instanceof SQLiteException ) { String message = throwable . getMessage ( ) ; if ( message == null ) { continue ; } if ( message . contains ( "No space left on device" ) || message . contains ( "SQLITE_IOERR_SHMSIZE" ) || message . contains ( "SQLITE_FULL" ) ) { return true ; } } } } return false ;
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . productVariantPrices ( ) . delete ( Identifier . fromId ( 1 ) , "acme" , options ) ;
p: public String p ( ) { return name ; }
run: public void run ( ) { if ( e . getMessage ( ) . contains ( "self-payments not allowed" ) ) { updateInvoiceList ( ) ; } EventBus . getDefault ( ) . post ( new PayInvoiceFailedEvent ( ) ) ; ToastUtils . showToast ( mContext , e . getMessage ( ) ) ; mLoadingDialog . dismiss ( ) ;
pauseTimer: public void pauseTimer ( ) { mWebView . pauseTimers ( ) ;
getTags: public int getTags ( ) { return WithTag . TAG ( Constants . ActiveTags . RESOURCE_RECEIVER ) ;
statAdded: No method body
getNewValue: public Long getNewValue ( ) { return newValue ;
getAvatarKey: public String getAvatarKey ( ) { return avatarKey ;
getScanner: public ClassPathBeanDefinitionScanner getScanner ( ) { return scanner ;
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { Bone bone = skeleton . bones . get ( boneIndex ) ; if ( ! bone . active ) return ; float [ ] frames = this . frames ; if ( time < frames [ 0 ] ) { switch ( blend ) { case setup : bone . y = bone . data . y ; return ; case first : bone . y += ( bone . data . y - bone . y ) * alpha ; } return ; } float y = getCurveValue ( time ) ; switch ( blend ) {
evaluateServerJsScript: private < T > T evaluateServerJsScript ( ServerJs serverJs , Map < String , Object > externalModel , List < String > externalArguments , Class < T > resultType ) { if ( serverJs == null ) { error ( "[evaluateServerJsScript] ServerJs is null" ) ; throw new RuntimeException ( "No entry" ) ; } String script = serverJs . getCode ( ) ; try {
fillPath: public void fillPath ( Canvas c , Path path , Paint paint , @ Nullable RectF clipRect ) { switch ( mType )
checkIfMadeOfDigits: public static void checkIfMadeOfDigits ( String string ) { for ( char c : string . toCharArray ( ) ) {
getRoleName: public String getRoleName ( ) { return Optional . ofNullable ( getRole ( ) ) . map ( a -> a . getName ( ) ) . orElse ( "N/A" ) ;
setValue: public TimerDetails setValue ( @ Nullable Timestamp day ) { removeAll ( ) ; var txt = text ( "Showing 0 logged timers" ) . sizeL ( ) . grow ( 1 ) ; add ( horizontal ( ) . add ( button ( "" ) . add ( Icon . solid_arrows_rotate ( ) ) . onClick ( e -> { setValue ( day ) ; } ) , txt ) ) ; add ( ly = new PageLayout ( ) . grow ( 1 ) ) ; ly . setDataProvider ( 0 , 50 , ( details ) -> { List < Component < ? , ? > > comps = new ArrayList < > ( ) ; var currentDateTime = day . toLocalDateTime ( ) ; var startOfDay = currentDateTime . with ( LocalTime . MIDNIGHT ) ; var endOfDay = currentDateTime . with ( LocalTime . MAX ) ; List < Timer > timers = Timer . whereId ( ) . biggerOrEqual ( details . iStart ) . and ( Timer . whereStart ( ) . between ( Timestamp . valueOf ( startOfDay ) , Timestamp . valueOf ( endOfDay ) ) . or ( Timer . whereEnd ( ) . between ( Timestamp . valueOf ( startOfDay ) , Timestamp . valueOf ( endOfDay ) ) ) ) . get ( ) . reversed ( ) ; if ( ! timers . isEmpty ( ) ) ly . iStart = timers . getLast ( ) . id ; var timersAndTasks = new HashMap < Timer , List < TimerTask > > ( ) ; for ( Timer timer : timers ) { timersAndTasks . put ( timer , TimerTask . whereTimerId ( ) . is ( timer . id ) . get ( ) ) ; } txt . setValue ( "Showing " + timers . size ( ) + " logged timers" ) ; DateTimeFormatter df = DateTimeFormatter . ofPattern ( "d MMM uuu HH:mm" ) ; timersAndTasks . forEach ( ( timer , tasks ) -> { tasks . sort ( ( o1 , o2 ) -> Double . compare ( o2 . percentageOfTimer , o1 . percentageOfTimer ) ) ; var hl = horizontal ( ) . padding ( false ) ; String start = timer . start == Timer . NULL ? "?" : df . format ( timer . start . toLocalDateTime ( ) ) ; String end = timer . end == Timer . NULL ? "?" : df . format ( timer . end . toLocalDateTime ( ) ) ; hl . add ( button ( "" ) . add ( Icon . solid_gear ( ) ) . onClick ( e -> { add ( new SlidersPopup ( false , timer ) ) ; } ) ) ; hl . add ( new Html ( "pre" ) . add ( text ( "Timer from '" + start + "' to '" + end + "'" + " took " + ( timer . start == Timer . NULL || timer . end == Timer . NULL ? "?" : toSimpleString ( Duration . of ( timer . end . getTime ( ) - timer . start . getTime ( ) , ChronoUnit . MILLIS ) ) ) + " doing mainly '" + ( tasks . isEmpty ( ) ? "-" : Task . whereId ( ) . is ( tasks . getFirst ( ) . id ) . getFirstOrNull ( ) . name ) + "'" ) ) . grow ( 1 ) ) ; comps . add ( hl ) ; } ) ; return comps ; } ) ; return super . setValue ( day ) ;
isEnoughRU: private boolean isEnoughRU ( ) { return getRUAvailable ( ) >= calculateCreationPrice ( ) ;
applicable: No method body
getWindWaveDirection: private float getWindWaveDirection ( ) { for ( ActiveData wind : winds ) { if ( wind . isAlive ( ) ) { WindComponentData windComp = wind . getComponent ( WindComponentData . class ) ; if ( windComp == null ) continue ; float power = windComp . func ( getSkeleton ( ) . getX ( ) , getSkeleton ( ) . getY ( ) ) ; if ( power != 0 ) return power * Math . signum ( windComp . getMovement ( ) ) ; } } return 0 ;
onEvent: public boolean onEvent ( Event event ) { return false ;
disableUpgrade: public void disableUpgrade ( String key ) { info . upgrades . remove ( key ) ; resetAnimation ( ) ;
count: public long count ( String fieldName , Object value ) { return wrapped . count ( scope , fieldName , value ) ;
touchDown: public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { sendEvent ( GameControllerEvent . obtain ( GameControllerEvent . Action . beginLaunch , button ) ) ; return super . touchDown ( event , x , y , pointer , button ) ;
roundtrip: < T > void roundtrip ( String testName , Serde < T > serde , T value ) throws Throwable { assertThat ( serde . deserialize ( serde . serialize ( value ) ) ) . isEqualTo ( value ) ;
getJson: No method body
getNotificationGraphStats: public NotificationGraphStatsResponse getNotificationGraphStats ( ) throws IOException , NovuNetworkException { try {
intercept: No method body
getTags: public int getTags ( ) { return WithTag . TAG ( Constants . ActiveTags . SHOOTING_RANGE ) ;
getPosition: public Vector2 getPosition ( ) { return position ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
getTargetType: public Message . TargetType getTargetType ( ) { return targetType ;
nullNonWriteableDtoFields: private void nullNonWriteableDtoFields ( SearchableOrganizationRelatedEntity entity ) { prepareFieldsReadWritePrivileges ( entity ) ; dto . forEach ( ( fieldName , fieldValue ) -> {
getCalculatedLabelSizes: public List < FSize > getCalculatedLabelSizes ( ) { return mCalculatedLabelSizes ;
onEvent: public boolean onEvent ( Event event ) { return false ;
selected: public void selected ( String name , RoomSettings settings , QuickPlayOptionsMenu menu ) { engageConflict ( settings , ( ( EngageConflictMenu ) menu ) . getConflictSize ( ) ) ;
getDataByIndex: public BarLineScatterCandleBubbleData getDataByIndex ( int index ) { return getAllData ( ) . get ( index ) ;
notFound: No method body
getLong: protected static long getLong ( String name , Context context , String key ) { return getLong ( name , context , key , - 1 ) ;
postScore: private void postScore ( ) { EventService eventService = EventService . Get ( ) ; if ( eventService == null ) return ; JSONObject leaderboard_info = new JSONObject ( ) ; JSONObject profile = new JSONObject ( ) ; if ( group ) { leaderboard_info . put ( "display_name" , client . getClanName ( ) ) ; if ( ! client . getClanAvatar ( ) . isEmpty ( ) ) { profile . put ( "avatar" , client . getClanAvatar ( ) ) ; } } else { leaderboard_info . put ( "display_name" , client . getName ( ) ) ; profile . put ( "level" , client . getProfile ( ) . getLevel ( Constants . User . LEVEL ) ) ; if ( client . getAvatar ( ) != null ) profile . put ( "avatar" , client . getAvatar ( ) ) ; if ( client . getAccessTokenCredential ( ) != null ) profile . put ( "credential" , client . getAccessTokenCredential ( ) ) ; } leaderboard_info . put ( "expire_in" , "241920" ) ; leaderboard_info . put ( "profile" , profile ) ; if ( isGroup ( ) )
shouldCreateFullBackup_nonWindowsEnv: public void shouldCreateFullBackup_nonWindowsEnv ( ) throws IOException { Set < BackupOption > backupOptions = Set . of ( BACKUP_PROPERTIES , BACKUP_DATABASE ) ; boolean result = testObject . doBackup ( backupOptions ) ; assertFileExists ( testObject . getDatabaseBackupFile ( ) ) ; assertFileExists ( testObject . getTarBackupFile ( ) ) ; assertTarContains ( testObject . getDatabaseBackupFile ( ) , testObject . getApplicationPropertiesFilePath ( ) ) ; Assertions . assertTrue ( result ) ;
getSpeedCoef: public float getSpeedCoef ( ) { return super . getSpeedCoef ( ) * speedCoef ;
changeStatus: public void changeStatus ( @ NonNull Long userId , @ NonNull Boolean status ) { Assert . isTrue ( this . baseMapper . updateStatusById ( userId , Boolean . TRUE . equals ( status ) ? 1 : 0 ) > 0 , "更改用户可用状态失败！" ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new InstrumentEffectsComponentData ( componentObject , this ) ;
getT4: public Tuple4 getT4 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] , list [ 3 ] ) ;
updateStatus: public CustomerStatus updateStatus ( String shopKey , String countryCode , Identifier customerIdentifier , CustomerStatus model ) throws ApiErrorException , ConnectionException { Class < CustomerStatus > responseModel = ( Class < CustomerStatus > ) ( Class < ? > ) CustomerStatus . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/status" , shopKey , countryCode , customerIdentifier ) , null , null , responseModel , model ) ;
getStop: public Set < String > getStop ( ) { return stop ;
watchPostProcess: public static void watchPostProcess ( long startTime , int minCost , String uuid , String traceId , String methodSignature , String params , String result , String exception ) { long cost = System . currentTimeMillis ( ) - startTime ; if ( cost >= minCost ) {
login: void login ( ) throws Exception { assertNotNull ( loginParam , "loginParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/user/login" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( loginParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "登录接口测试成功:{}" , map . get ( "data" ) ) ;
getChildDepart: private List < DepartDto > getChildDepart ( @ NonNull Long departId , @ NonNull List < DepartDto > departDtoList ) { List < DepartDto > departDtos = departDtoList . stream ( ) . filter ( departDto -> departDto . getParentId ( ) == departId ) . collect ( Collectors . toList ( ) ) ; departDtos . forEach ( departDto -> { List < DepartDto > childDepart = getChildDepart ( departDto . getId ( ) , departDtoList ) ; departDto . setChildren ( childDepart ) ; } ) ; return departDtos ;
addHealth: public float addHealth ( float health ) { float freezeHealth = 0 ; TemperatureComponentData tcd = getComponentObject ( ) . getComponent ( TemperatureComponentData . class ) ; if ( tcd != null ) freezeHealth = tcd . getFreezing ( ) ; float newValue = Math . min ( health + getHealth ( ) , getInitHealth ( ) - freezeHealth ) ; float oldValue = this . health ; this . health = newValue ; return newValue - oldValue ;
createOrUpdateCustomDataForKey: public Map < String , Object > createOrUpdateCustomDataForKey ( String shopKey , Integer shopCategoryId , String key , Map < String , Object > model ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/categories/%s/custom-data/%s" , shopKey , shopCategoryId , key ) , null , null , responseModel , model ) ;
onError: public void onError ( Exception e ) { if ( e . getMessage ( ) . equals ( "EOF" ) ) { return ; } LogUtils . e ( TAG , "------------------noRouterOB_SendPaymentV2OnError------------------" + e . getMessage ( ) ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
getAddChangeDescription: private String getAddChangeDescription ( AuditedObjectState aos , String entityClass , StringBuilder change ) { debug ( "[getAddChangeDescription] entityClass: {}" , entityClass ) ; change . append ( " created with:<br/>" ) ; writeProperties ( aos , change ) ; writeContent ( aos , change ) ; return change . toString ( ) ;
hasGlobalOrOrgPrivilege: default boolean hasGlobalOrOrgPrivilege ( PrivilegeBase p , Long orgId ) { return hasGlobalOrOrgPrivilege ( p . name ( ) , orgId ) ;
removeTemperature: public void removeTemperature ( float t ) { this . temperature = Math . max ( this . temperature - t , 0 ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
setCompanyId: public void setCompanyId ( String companyId ) { this . companyId = companyId ;
getWaterOutflow: public double getWaterOutflow ( ) { return waterOutflow ;
lockInstance: private static boolean lockInstance ( final String lockFile ) { try { final File file = new File ( lockFile ) ; final RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "rw" ) ; final FileLock fileLock = randomAccessFile . getChannel ( ) . tryLock ( ) ; if ( fileLock != null ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { public void run ( ) { try { fileLock . release ( ) ; randomAccessFile . close ( ) ; file . delete ( ) ; } catch ( Exception e ) { Log . error ( "Unable to remove lock file: " + lockFile ) ; } } } ) ; return true ; } } catch ( Exception e ) { Log . error ( "Unable to create and/or lock file: " + lockFile ) ; } return false ;
create: public static void create ( String formName , String tableName , Collection < FrontendMappingFieldDefinition > fields , Long timeMillis ) { DynamicEntityDescriptor ded = new DynamicEntityDescriptor ( toEntityClassName ( formName ) , tableName , toEntityKey ( formName ) , toRepositoryName ( formName ) , fields , timeMillis ) ; map . put ( ded . getEntityKey ( ) , ded ) ;
getStoreEnvironment: public void getStoreEnvironment ( Map < String , String > env ) { super . getStoreEnvironment ( env ) ;
beforeAll: public void beforeAll ( ExtensionContext context ) { deployer . run ( ) ; context . getStore ( NAMESPACE ) . put ( DEPLOYER_KEY , deployer ) ;
isQuestActive: public boolean isQuestActive ( Quest quest ) { return activeQuests . contains ( quest , true ) ;
init: public void init ( ) { super . init ( ) ; ClientWeaponComponentData cw = getComponentObject ( ) . getComponent ( ClientWeaponComponentData . class ) ; if ( cw != null )
readImageDegree: public static int readImageDegree ( String path ) { int degree = 0 ; try { ExifInterface exifInterface = new ExifInterface ( path ) ; int orientation = exifInterface . getAttributeInt ( ExifInterface . TAG_ORIENTATION , ExifInterface . ORIENTATION_NORMAL ) ; switch ( orientation ) { case ExifInterface . ORIENTATION_ROTATE_90 : degree = 90 ; break ; case ExifInterface . ORIENTATION_ROTATE_180 : degree = 180 ; break ; case ExifInterface . ORIENTATION_ROTATE_270 : degree = 270 ; break ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return degree ;
acquireMap: public ServerSettings . MapConditions acquireMap ( ) { return new ServerSettings . MapConditions ( mapId ) ;
hasRender: public boolean hasRender ( ) { return false ;
checkVisibility: public boolean checkVisibility ( float x , float y , Map . IgnoreCheck ignoreCheck ) { return CheckVisibility ( getMap ( ) , getPlayerData ( ) , x , y , ignoreCheck ) ;
getX: public float getX ( ) { return x ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVStop3ActionPerformed ( evt ) ;
getCurrentItem: protected RoomSettings . BooleanOption getCurrentItem ( ) { if ( ! option . isDefined ( ) ) return RoomSettings . BooleanOption . UNSET ; return option . getValue ( ) ? RoomSettings . BooleanOption . YES : RoomSettings . BooleanOption . NO ;
queryProbability: No method body
dropConsumable: public ItemData dropConsumable ( int recordId , float angle , int amount ) { if ( isWounded ( ) ) return null ; PlayerData playerData = getPlayerData ( ) ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; ConsumableRecord record = poc . getConsumableContainer ( ) . get ( recordId ) ; if ( record == null || record . getAmount ( ) == 0 ) return null ; { Map map = getMap ( ) ; if ( map == null ) return null ; ChunkData chunk = map . getChunkAt ( ( int ) playerData . getX ( ) , ( int ) playerData . getY ( ) ) ; if ( chunk != null && chunk . hasFlag ( ChunkData . ChunkFlag . shootingDisabled ) ) return null ; } if ( poc != null ) { if ( record != null && record . getAmount ( ) >= amount ) { ConsumableItem item = record . getItem ( ) ; GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode != null ) { GameModeRealization realization = gameMode . getRealization ( ) ; if ( realization instanceof ServerRealization ) { Client client = BrainOutServer . Controller . getClients ( ) . get ( playerData . getOwnerId ( ) ) ; if ( client != null ) { if ( ! ( ( ServerRealization ) realization ) . canDropConsumable ( client , item ) ) return null ; } } } boolean currentInstrument = false ; Item dropItem = null ; if ( item instanceof InstrumentConsumableItem ) { InstrumentData instrumentData = ( ( InstrumentConsumableItem ) item ) . getInstrumentData ( ) ; currentInstrument = instrumentData == playerData . getCurrentInstrument ( ) ; Instrument instrument = instrumentData . getInstrument ( ) ; if ( instrument . hasComponent ( ItemComponent . class ) ) { dropItem = instrument . getComponent ( ItemComponent . class ) . getDropItem ( ) ; } } AutoConvertConsumable auto = item . getContent ( ) . getComponent ( AutoConvertConsumable . class ) ; if ( auto != null ) { item = auto . getConvertTo ( ) . acquireConsumableItem ( ) ; } Array < ConsumableRecord > records = new Array < > ( ) ; records . add ( new ConsumableRecord ( item , amount , 0 ) ) ; ItemData itemData = ServerMap . dropItem ( playerData . getDimension ( ) , dropItem , records , playerData . getOwnerId ( ) , playerData . getX ( ) , playerData . getY ( ) , angle ) ; poc . getConsumableContainer ( ) . decConsumable ( record , amount ) ; BrainOutServer . Controller . getClients ( ) . sendTCP ( new InventoryItemMovedMsg ( playerData , item . getContent ( ) ) ) ; if ( currentInstrument ) { selectFirstInstrument ( poc ) ; } updateAttachments ( ) ; consumablesUpdated ( ) ; return itemData ; } } return null ;
clearAll: No method body
setMissionControlConfig: No method body
CheckVisibility: public static boolean CheckVisibility ( Map map , PlayerData playerData , float x , float y , Map . IgnoreCheck ignoreCheck ) { if ( ! GetCheckVisibilityLaunchData ( map , playerData , tmp ) ) return false ; tmp . sub ( x , y ) ; if ( ! map . trace ( x , y , Constants . Layers . BLOCK_LAYER_UPPER , tmp . angleDeg ( ) , tmp . len ( ) , null ) && ! map . trace ( x , y , Constants . Layers . BLOCK_LAYER_FOREGROUND , tmp . angleDeg ( ) , tmp . len ( ) , tmp , ignoreCheck ) ) { return true ; } return false ;
newReward: protected Reward newReward ( ) { return new ClientReward ( ) ;
promise: No method body
delete: public void delete ( String attributeGroupName , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/attribute-groups/%s" , attributeGroupName ) , query , null , null ) ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { if ( fromActor != null && fromActor . isDescendantOf ( actor ) ) { return ; } if ( pointer == - 1 && ! Gdx . input . isButtonPressed ( Input . Buttons . LEFT ) ) { show ( ) ; } super . enter ( event , x , y , pointer , fromActor ) ;
crop: public static void crop ( Activity activity , Uri src , Uri dest , int requestCode , boolean freeStyle , int compression , int initialChoice , AspectRatio ... ratios ) { UCropBuilder builder = new UCropBuilder ( ) ; builder . setCompressionQuality ( compression ) ; builder . setFreeStyleCropEnabled ( freeStyle ) ; if ( initialChoice >= 0 && ratios != null && ratios . length > 0 ) { builder . setAspectRatioOptions ( initialChoice , ratios ) ; } b . q . a . a ucrop = new b . q . a . a ( src , dest ) ; ucrop . b . putAll ( builder . getOptions ( ) ) ; startUCrop ( activity , ucrop , requestCode ) ;
UpdateParamToDepart: No method body
getPetrol: public Instrument getPetrol ( ) { return getGenerator ( ) . getPetrol ( ) ;
getForm: public AbstractOrganizationRelatedEntityForm getForm ( String frontendMappingName ) { return getForm ( frontendMappingName , null ) ;
validate: public EditUserForm validate ( BindingResult br ) { BasicUserForm . validate ( dto , br ) ; return this ;
acquireConsumableItem: public ArmorConsumableItem acquireConsumableItem ( ) { return new ArmorConsumableItem ( this ) ;
getName: public String getName ( ) { return name ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ;
createOrUpdateCustomDataForKey: public Map < String , Object > createOrUpdateCustomDataForKey ( Identifier variantIdentifier , String key , Map < String , Object > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/variants/%s/custom-data/%s" , variantIdentifier , key ) , query , null , responseModel , model ) ;
getAvatarString: public String getAvatarString ( ) { return avatarString ;
isComplete: public boolean isComplete ( UserProfile profile ) { for ( Contract task : tasks ) { if ( ! task . getLockItem ( ) . isUnlocked ( profile ) ) { return false ; } } return true ;
getBoilingPoint: public double getBoilingPoint ( ) { return boilingPoint ;
getOperationFee: No method body
getSubscribers: No method body
getGuildsInternal$app_productionGoogleRelease: public final Map < Long , Guild > getGuildsInternal$app_productionGoogleRelease ( ) { return guilds ; }
getLayout: public GetLayoutResponse getLayout ( final String layoutId ) throws IOException , NovuNetworkException { try {
getNick: public final String getNick ( ) { return null ; }
getCurrentShape: public Shape getCurrentShape ( ) { return currentShape ;
getContent: public Content getContent ( ) { return content ;
chain: default < B > ChainLink < I , O , B > chain ( final Chain < O , B > next ) { return new ChainLink < > ( this , next ) ;
cook: public boolean cook ( float timer ) { if ( state == State . ready ) { this . state = State . cooked ; this . timer = timer ; return true ; } return false ;
hasRender: public boolean hasRender ( ) { return true ;
subTrace: public static void subTrace ( String uuid , String key , long duration ) { Map < String , int [ ] > map = traceCtx . get ( ) . computeIfAbsent ( uuid , k -> new TraceCtx ( ) ) . traceContent ; int [ ] arr = map . computeIfAbsent ( key , k -> new int [ 2 ] ) ; arr [ 0 ] += ( int ) duration ; arr [ 1 ] += 1 ;
setQuery: public void setQuery ( String query ) { this . query = query ;
setOrganizationId: public void setOrganizationId ( Long organizationId ) { this . organizationId = organizationId ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterInVOpen1ActionPerformed ( evt ) ;
updateOffset: public void updateOffset ( float x , float y ) { for ( UpdateOffsetCallback callback : offsetCallbacks )
create: public Campaign create ( String shopKey , Campaign model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Campaign > responseModel = ( Class < Campaign > ) ( Class < ? > ) Campaign . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shops/%s/campaigns" , shopKey ) , query , null , responseModel , model ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
getSuperPropertiesStringBase64: public final String getSuperPropertiesStringBase64 ( ) { return "" ;
get: public Voucher get ( String shopKey , String countryCode , Integer voucherId ) throws ApiErrorException , ConnectionException { Class < Voucher > responseModel = ( Class < Voucher > ) ( Class < ? > ) Voucher . class ; return this . request ( "get" , this . resolvePath ( "/shops/%s/countries/%s/vouchers/%s" , shopKey , countryCode , voucherId ) , null , null , responseModel ) ;
hasRender: public boolean hasRender ( ) { return false ;
getAnimation: public String getAnimation ( State state ) { return getAnimation ( state . toString ( ) ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
getCode: public int getCode ( ) { return code ;
autoOpenShopOnSpawn: public boolean autoOpenShopOnSpawn ( ) { return false ;
write: public void write ( Json json ) { json . writeValue ( "krm" , karma ) ;
lockInput: public boolean lockInput ( ) { return true ;
getClassLoader: protected ClassLoader getClassLoader ( ) { return Global . getClassLoader ( ) ;
getID: public ID getID ( ) { return ID . instrumentAnimationAction ;
updateOriginalAttachments: private void updateOriginalAttachments ( ) { if ( dynamic )
getContentType: public String getContentType ( ) { return this . contentType ;
checkRecord: private ServerChipComponentData checkRecord ( ConsumableRecord record ) { if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; InstrumentData instrumentData = ici . getInstrumentData ( ) ; if ( instrumentData instanceof ChipData ) { ChipData chipData = ( ( ChipData ) instrumentData ) ; ServerChipComponentData s = chipData . getComponent ( ServerChipComponentData . class ) ; return s ; } } return null ;
defaultConflictAccount: private String defaultConflictAccount ( ) { return "4" ;
getMonth: public int getMonth ( ) { return mCalendar . get ( Calendar . MONTH ) + 1 ;
installAPKFile: public void installAPKFile ( Context context , String provider ) { installAPKFile ( context , mApkFile , provider ) ;
set: void set ( int slotIndex , String name ) { if ( slotIndex < 0 ) throw new IllegalArgumentException ( "slotIndex must be >= 0." ) ; if ( name == null ) throw new IllegalArgumentException ( "name cannot be null." ) ; this . slotIndex = slotIndex ; this . name = name ; hashCode = name . hashCode ( ) + slotIndex * 37 ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem3ActionPerformed ( evt ) ;
isShowResultPoint: public boolean isShowResultPoint ( ) { return isShowResultPoint ;
isClaimed: public boolean isClaimed ( ) { return claimed ;
deleteOne: No method body
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoControlWaterLevelItemStateChanged ( evt ) ;
createUser: public User createUser ( String firstName , String lastName , String email , boolean userEnabled , String [ ] globalRoles , Tuple2 < String , Long > [ ] orgRoles ) { User user = services . user . createUser ( firstName , lastName , email , userEnabled , globalRoles , orgRoles ) ; user . setLoginAndPassword ( firstName , lastName , true ) ; return repositories . unsecure . user . save ( user ) ;
getRoundsQuality: public int getRoundsQuality ( ) { if ( weaponProperties . isUnlimited ( ) ) return - 1 ; return source . getRoundsQuality ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ;
redeliverMap: public void redeliverMap ( ) { BrainOutServer . Controller . playStateChanged ( ) ;
getEntries: public SortedSet < String > getEntries ( ) { return entries ;
getWorldFlipY: public boolean getWorldFlipY ( ) { return getWorldScaleY ( ) < 0 ;
getComponent: public ActiveParticleComponentData getComponent ( ComponentObject componentObject ) { return new ActiveParticleComponentData ( ( ActiveData ) componentObject , this ) ;
getGroup: public PrivilegeGroup getGroup ( ) { return null ;
getSelectionShift: public float getSelectionShift ( ) { return mShift ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fill ;
calculateSimple: private int calculateSimple ( ) { Component it = getFistComponent ( ) ; if ( it != null ) { if ( it instanceof Json . Serializable ) { return - 1 ; } it = it . getNext ( ) ; } Map map = Map . Get ( CURRENT_DIMENSION ) ; if ( map == null ) return - 1 ; Block creator = getCreator ( ) ; int index = map . getContentIndex ( ) . getIndex ( creator ) ; if ( index != 0 )
onRequestPermissionFailureWithAskNeverAgain: public void onRequestPermissionFailureWithAskNeverAgain ( List < String > permissions ) { LogUtils . e ( TAG , "扫码页面摄像头权限拒绝并且勾选不再提示" ) ;
dragStart: public DragAndDrop . Payload dragStart ( InputEvent event , float x , float y , int pointer ) { if ( menu . getScale ( ) != 1.0f ) { return null ; } Group object = new Group ( ) ; object . setTouchable ( Touchable . disabled ) ; Group invalid = new Group ( ) ; invalid . setTouchable ( Touchable . disabled ) ; Group valid = new Group ( ) ; valid . setTouchable ( Touchable . disabled ) ; float offsetX = - sprite . getWidth ( ) * Constants . Graphics . BLOCK_SIZE * 0.5f + Constants . Graphics . BLOCK_SIZE * 0.5f , offsetY = - sprite . getHeight ( ) * Constants . Graphics . BLOCK_SIZE * 0.5f + Constants . Graphics . BLOCK_SIZE * 0.5f ; SpritePayload payload = new SpritePayload ( offsetX , offsetY ) ; { Group entry = renderSprite ( sprite ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; object . addActor ( entry ) ; } { Image border = new Image ( BrainOutClient . Skin , "form-drag-good" ) ; border . setBounds ( offsetX - 2 , offsetY - 2 , sprite . getWidth ( ) * Constants . Graphics . BLOCK_SIZE + 4 , sprite . getHeight ( ) * Constants . Graphics . BLOCK_SIZE + 4 ) ; valid . addActor ( border ) ; Group entry = renderSprite ( sprite ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; valid . addActor ( entry ) ; payload . addOffsetCallback ( ( x1 , y1 ) -> { border . setPosition ( offsetX - 2 + x1 , offsetY - 2 + y1 ) ; entry . setPosition ( offsetX + x1 , offsetY + y1 ) ; } ) ; } { Image border = new Image ( BrainOutClient . Skin , "form-border-red" ) ; border . setBounds ( offsetX - 2 , offsetY - 2 , sprite . getWidth ( ) * Constants . Graphics . BLOCK_SIZE + 4 , sprite . getHeight ( ) * Constants . Graphics . BLOCK_SIZE + 4 ) ; invalid . addActor ( border ) ; Group entry = renderSprite ( sprite ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; invalid . addActor ( entry ) ; payload . addOffsetCallback ( ( x1 , y1 ) -> { border . setPosition ( offsetX - 2 + x1 , offsetY - 2 + y1 ) ; entry . setPosition ( offsetX + x1 , offsetY + y1 ) ; } ) ; } payload . setDragActor ( object ) ; payload . setObject ( sprite ) ; payload . setValidDragActor ( valid ) ; payload . setInvalidDragActor ( invalid ) ; return payload ;
round: public static double round ( double v , int scale ) { if ( scale < 0 ) { throw new IllegalArgumentException ( "保留的小数位数必须大于零" ) ; } BigDecimal b = new BigDecimal ( Double . toString ( v ) ) ; return b . setScale ( scale , BigDecimal . ROUND_HALF_UP ) . doubleValue ( ) ;
getIsForceUpdate: public String getIsForceUpdate ( ) { return isForceUpdate ;
createOrganization: public Organization createOrganization ( String name ) { return services . organization . createOrganization ( name , 0 ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
distance: public float distance ( float x , float y ) { return Math . abs ( dy * x - dx * y + sxey - exsy ) / length ;
moveViewToAnimated: public void moveViewToAnimated ( float xValue , float yValue , AxisDependency axis , long duration ) { MPPointD bounds = getValuesByTouchPoint ( mViewPortHandler . contentLeft ( ) , mViewPortHandler . contentTop ( ) , axis ) ; float yInView = getAxisRange ( axis ) / mViewPortHandler . getScaleY ( ) ; Runnable job = AnimatedMoveViewJob . getInstance ( mViewPortHandler , xValue , yValue + yInView / 2f , getTransformer ( axis ) , this , ( float ) bounds . x , ( float ) bounds . y , duration ) ; addViewportJob ( job ) ; MPPointD . recycleInstance ( bounds ) ;
updateStats: protected void updateStats ( ) { super . updateStats ( ) ; if ( stats != null )
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( zoneData . getStatus ( ) == GlobalConflict . ZoneStatus . full ) { Menu . playSound ( MenuSound . denied ) ; return ; } pop ( ) ; if ( zoneData . getStatus ( ) == GlobalConflict . ZoneStatus . ongoing )
setAccessLevel: public void setAccessLevel ( AccessLevel accessLevel ) { this . accessLevel = accessLevel ;
setScatterShapeSize: public void setScatterShapeSize ( float size ) { mShapeSize = size ;
dropWeapon: private void dropWeapon ( ConsumableRecord weaponRecord ) { ItemData itemData = getController ( ) . dropConsumable ( weaponRecord . getId ( ) , getPlayerData ( ) . getAngle ( ) , 1 ) ; if ( itemData != null )
setGitHubRepoName: public void setGitHubRepoName ( String gitHubRepoName ) { this . gitHubRepoName = gitHubRepoName ;
getHeaderFromLocal: public static String getHeaderFromLocal ( Context context ) { return getString ( SETTINGS , context , KEY_HEADER ) ;
setPlainApiKey: public void setPlainApiKey ( String plainApiKey ) { this . apiKey = passwordEncoder . encode ( plainApiKey ) ;
start: No method body
isGameActive: public boolean isGameActive ( boolean countFinished , boolean countWarmUp ) { switch ( getPhase ( ) )
awaitResult: public Result < U > awaitResult ( ) throws TerminalException { if ( mappedResult == null ) { this . mappedResult = this . mapper . apply ( this . inner . awaitResult ( ) ) ; } return this . mappedResult ;
getPhoneIMEI: public static String getPhoneIMEI ( Context mContext ) { if ( PermissionChecker . checkReadPhoneStatePermission ( mContext ) ) { TelephonyManager telephonyManager = ( TelephonyManager ) mContext . getSystemService ( Context . TELEPHONY_SERVICE ) ; return telephonyManager . getDeviceId ( ) ; } return "" ;
assignPackageGroupToWarehouses: public void assignPackageGroupToWarehouses ( String shopKey , String countryCode , Integer packageGroupId , List < PackageGroupWarehouse > model ) throws ApiErrorException , ConnectionException { this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/package-groups/%s" , shopKey , countryCode , packageGroupId ) , null , null , null , model ) ;
getAnimationState: public AnimationState getAnimationState ( ) { return state ;
setLoginAndPassword: public void setLoginAndPassword ( LoginAndPassword loginAndPassword ) { this . loginAndPassword = loginAndPassword ;
forceSync: public void forceSync ( float x , float y , float angle , float speedX , float speedY ) { if ( phy == null ) return ; ActiveData activeData = ( ( ActiveData ) getComponentObject ( ) ) ; activeData . setPosition ( x , y ) ; activeData . setAngle ( angle ) ; phy . getSpeed ( ) . set ( speedX , speedY ) ; correctionEnabled = false ; correctedPosition . set ( 0 , 0 ) ; correctPosition . set ( x , y ) . sub ( activeData . getX ( ) , activeData . getY ( ) ) ;
setColor: void setColor ( ) { assertDoesNotThrow ( ( ) -> rectangle . setColor ( "#000000" ) ) ; assertDoesNotThrow ( ( ) -> rectangle . setColor ( "#123456" ) ) ; assertDoesNotThrow ( ( ) -> rectangle . setColor ( "#ABCDEF" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> rectangle . setColor ( "#ABCDEFF" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> rectangle . setColor ( "#ABCDEG" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> rectangle . setColor ( "#ABCDE" ) ) ;
changePasswordTest: public void changePasswordTest ( ) { reset ( userRepository ) ; User user = mock ( User . class ) ; LoginAndPassword loginAndPassword = mock ( LoginAndPassword . class ) ; String newPassword = "new-password" ; when ( user . getLoginAndPassword ( ) ) . thenReturn ( loginAndPassword ) ; when ( userRepository . saveAndFlush ( any ( User . class ) ) ) . thenReturn ( user ) ; userService . changePassword ( user , newPassword ) ; verify ( loginAndPassword ) . setPassword ( anyString ( ) ) ; verify ( userRepository ) . saveAndFlush ( any ( User . class ) ) ;
sendMessageToGPTWithPrompt: No method body
checkAlarms: private void checkAlarms ( ) { if ( mcc . drum1 . getWaterLevel ( ) < - 25 ) { annunciator . trigger ( drum1Low ) ; } else { annunciator . reset ( drum1Low ) ; } if ( mcc . drum2 . getWaterLevel ( ) < - 25 ) { annunciator . trigger ( drum2Low ) ; } else { annunciator . reset ( drum2Low ) ; } if ( mcc . drum1 . getWaterLevel ( ) > 25 ) { annunciator . trigger ( drum1High ) ; } else { annunciator . reset ( drum1High ) ; } if ( mcc . drum2 . getWaterLevel ( ) > 25 ) { annunciator . trigger ( drum2High ) ; } else { annunciator . reset ( drum2High ) ; } if ( feedwaterMixer1 . getWaterTemperature ( ) < 150 || feedwaterMixer2 . getWaterTemperature ( ) < 150 ) { annunciator . trigger ( FWTemp ) ; } else { annunciator . reset ( FWTemp ) ; } boolean mainCavitation = false ; for ( Pump pump : mainFeedwaterPumps ) { if ( pump . isCavitating ) { mainCavitation = true ; break ; } } annunciator . setTrigger ( mainCavitation , mainCavit ) ; boolean auxCavitation = false ; for ( Pump pump : auxFeedwaterPumps ) { if ( pump . isCavitating ) { auxCavitation = true ; break ; } } annunciator . setTrigger ( auxCavitation , auxCavit ) ;
getAdditionalSettings: public ServerSettings . BaseConditions getAdditionalSettings ( ) { return null ;
triggerEvent: public TriggerEventResponse triggerEvent ( final TriggerEventRequest request ) throws IOException , NovuNetworkException { try {
all: public ApiCollection < ShopCountry > all ( String shopKey , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCountry > responseModel = ( Class < ShopCountry > ) ( Class < ? > ) ShopCountry . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries" , shopKey ) , query , null , responseModel ) ;
exportServerJsToZippedYaml: public byte [ ] exportServerJsToZippedYaml ( @ PathVariable ( ID ) long serverJsId ) { debug ( "[exportServerJsToZippedYaml]" ) ; return services . componentExport . exportToZip ( Arrays . asList ( repositories . secure . serverJs . findOne ( serverJsId ) ) ) . toByteArray ( ) ;
update: public static void update ( Actor actor ) { float x ; float y ; float my = BrainOutClient . getHeight ( ) - Gdx . input . getY ( ) + 16 ; float mx = Gdx . input . getX ( ) + 16 ; if ( mx > BrainOutClient . getWidth ( ) - actor . getWidth ( ) - 32 ) { x = Math . max ( mx - actor . getWidth ( ) - 32 , 32 ) ; } else { x = mx ; } if ( my > BrainOutClient . getHeight ( ) - actor . getHeight ( ) - 32 ) { y = Math . max ( my - actor . getHeight ( ) - 32 , 32 ) ; } else { y = my ; } actor . setPosition ( x , y ) ;
removeFirstTwoCharsCharAt: public static String removeFirstTwoCharsCharAt ( String string ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 2 ; i < string . length ( ) ; i ++ ) { sb . append ( string . charAt ( i ) ) ; } return sb . toString ( ) ;
tenRun: void tenRun ( ) { assertArrayEquals ( new int [ ] { 2 , 10 , 10 , 10 , 20 , 20 } , TenRun . tenRun ( new int [ ] { 2 , 10 , 3 , 4 , 20 , 5 } ) ) ; assertArrayEquals ( new int [ ] { 10 , 10 , 20 , 20 } , TenRun . tenRun ( new int [ ] { 10 , 1 , 20 , 2 } ) ) ; assertArrayEquals ( new int [ ] { 10 , 10 , 10 , 20 } , TenRun . tenRun ( new int [ ] { 10 , 1 , 9 , 20 } ) ) ;
setDrawOrder: public void setDrawOrder ( Array < Slot > drawOrder ) { if ( drawOrder == null ) throw new IllegalArgumentException ( "drawOrder cannot be null." ) ; this . drawOrder = drawOrder ;
prepareContent: public String prepareContent ( String templateName , Map < String , Object > model ) { debug ( "[prepareContent] {}" , templateName ) ; final Context ctx = new Context ( LocaleContextHolder . getLocale ( ) ) ; ctx . setVariable ( ThymeleafEvaluationContext . THYMELEAF_EVALUATION_CONTEXT_CONTEXT_VARIABLE_NAME , new ThymeleafEvaluationContext ( context , null ) ) ; for ( Map . Entry < String , Object > entry : model . entrySet ( ) ) { ctx . setVariable ( entry . getKey ( ) , entry . getValue ( ) ) ; } return templateEngine . process ( templateName , ctx ) ;
setCode: public void setCode ( String code ) { this . code = code ;
getRunningActivityName: private String getRunningActivityName ( ) { ActivityManager activityManager = ( ActivityManager ) getSystemService ( Context . ACTIVITY_SERVICE ) ; String runningActivity = activityManager . getRunningTasks ( 1 ) . get ( 0 ) . topActivity . getClassName ( ) ; return runningActivity ;
hasPostEffectShaders: public boolean hasPostEffectShaders ( ) { switch ( graphicsQuality . getValue ( ) )
removeWs: public static void removeWs ( NanoWSD . WebSocket ws ) { webSockets . remove ( ws ) ;
getOffsetX: public float getOffsetX ( ) { return offsetX ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { tgValvesOpen6ItemStateChanged ( evt ) ;
createTokenForRefresher: public Token createTokenForRefresher ( String refresherTokenBase64 ) { debug ( "[createTokenForRefresher]" ) ; refresherTokenBase64 = Objects . requireNonNull ( refresherTokenBase64 ) ; Tuple2 < Token , String > tokenTuple = repositories . unsecure . token . findByBase64UserIdTokenIsValidTrue ( refresherTokenBase64 ) ; Optional < Token > tokenRefresher = Optional . ofNullable ( tokenTuple . getT1 ( ) ) ; return tokenRefresher . filter ( token -> token . getPrivilegesSet ( ) . equals ( REFRESHER_PRIVILEGE_SET ) ) . map ( token -> {
printTable: public static void printTable ( Connection conn , String tableName , int maxRows ) { printTable ( conn , tableName , maxRows , DEFAULT_MAX_TEXT_COL_WIDTH ) ;
getAnnotationDefaultValue: public static Object getAnnotationDefaultValue ( Class < ? extends Annotation > annotation , String name ) { try {
getLocalizedName: No method body
convertAndSave: public ControllerEndpoint convertAndSave ( ControllerEndpointConversionDto dto , String filePath ) { debug ( "[convertAndSave]" ) ; ControllerEndpoint controllerEndpoint = getControllerEndpoint ( dto ) ; controllerEndpoint . setCode ( loadResourceAsString ( dto . getCode ( ) ) ) ; return repositories . unsecure . controllerEndpoint . save ( controllerEndpoint ) ;
getY: public float getY ( ) { return lightData . getY ( ) ;
hasRender: public boolean hasRender ( ) { return false ;
onResponseFail: protected void onResponseFail ( Context context , String errorCode , String errorMsg ) { super . onResponseFail ( context , errorCode , errorMsg ) ; if ( callback != null ) {
getSn: public String getSn ( ) { return sn ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
generateButtonBadges: private void generateButtonBadges ( ) { generateRewardsBadge ( ) ; generateGoalsBadge ( ) ;
getShaderProgram: public ShaderProgram getShaderProgram ( ) { return shaderProgram ;
getComponent: public ClientDeckOfCardsComponentData getComponent ( ComponentObject componentObject ) { return new ClientDeckOfCardsComponentData ( ( ActiveData ) componentObject , this ) ;
setPrivilegesSet: public void setPrivilegesSet ( Set < PrivilegeBase > privilegesSet ) { this . privilegesSet = privilegesSet ; this . privileges = PrivilegeHelper . toJoinedStringInParenthesis ( privilegesSet ) ;
getEntryForIndex: public T getEntryForIndex ( int index ) { return mEntries . get ( index ) ;
init: public PlayState init ( PlayState . InitCallback callback ) { return BrainOutServer . Controller . setPlayState ( callback , PlayState . ID . game ) ;
testDeleteCustomData: public void testDeleteCustomData ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shopCategories ( ) . deleteCustomData ( "acme" , 1 , options ) ;
setPrice: public void setPrice ( BigDecimal price ) { this . price = price ;
apply: public void apply ( PlayerClient playerClient , boolean notify ) { int add = this . amount * multiply ; int have = playerClient . getProfile ( ) . getItems ( ) . get ( id . getID ( ) , 0 ) ; if ( max >= 0 ) { if ( have + add > max ) { add = Math . max ( max - have , 0 ) ; } } playerClient . gotOwnable ( id , "event" , ClientProfile . OnwAction . owned , add , notify ) ; playerClient . sendUserProfile ( ) ;
setTitleCreator: public void setTitleCreator ( BaseTitleCreator titleCreator ) { this . mTitleCreator = titleCreator ; titleCreator . setCallback ( new MyTitleViewCallback ( ) ) ; mTitleLayout . removeAllViews ( ) ; View childView = mTitleCreator . getRootView ( ) ; LayoutParams params = new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ; childView . setLayoutParams ( params ) ; mTitleLayout . addView ( childView ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jFileChooser1ActionPerformed ( evt ) ;
allowZoom: No method body
isDebugEnabled: public boolean isDebugEnabled ( Marker marker ) { return logger . isDebugEnabled ( marker ) ;
loadContent: public Component < ? , ? > loadContent ( ) { return new Vertical ( ) . add ( new Text ( "Currently at " + path ) ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { mFW1OpenActionPerformed ( evt ) ;
setTheme: private void setTheme ( Button btn , AtomicBoolean enabled ) { btn . removeClass ( "btn-success" ) ; btn . removeClass ( "btn-secondary" ) ; if ( enabled . get ( ) ) btn . success ( ) ;
isFlipX: public boolean isFlipX ( ) { return flipX ;
writeToParcel: public void writeToParcel ( Parcel dest , int flags ) { dest . writeString ( mAspectRatioTitle ) ; dest . writeFloat ( mAspectRatioX ) ; dest . writeFloat ( mAspectRatioY ) ;
getFlipX: public boolean getFlipX ( ) { return false ;
getNotifications: public NotificationsResponse getNotifications ( final NotificationRequest request ) throws IOException , NovuNetworkException { Map < String , Object > params = new HashMap < > ( ) ; if ( request . getChannels ( ) != null ) { params . put ( "channels" , request . getChannels ( ) ) ; } if ( request . getTemplates ( ) != null ) { params . put ( "templates" , request . getTemplates ( ) ) ; } if ( request . getEmails ( ) != null ) { params . put ( "emails" , request . getEmails ( ) ) ; } if ( request . getSearch ( ) != null ) { params . put ( "search" , request . getSearch ( ) ) ; } if ( request . getPage ( ) != null ) { params . put ( "page" , request . getPage ( ) ) ; } if ( request . getTransactionId ( ) != null ) { params . put ( "transactionId" , request . getTransactionId ( ) ) ; } return restHandler . extractResponse ( notificationApi . getNotifications ( params ) . execute ( ) ) ;
getAlpha: public int getAlpha ( ) { return mAlpha ;
getUser: public User getUser ( ) { return user ;
isEmpty: public static boolean isEmpty ( String str ) { return str == null || str . isEmpty ( ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
all: public ApiCollection < ShopCountry > all ( String shopKey ) throws ApiErrorException , ConnectionException { Class < ShopCountry > responseModel = ( Class < ShopCountry > ) ( Class < ? > ) ShopCountry . class ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries" , shopKey ) , null , null , responseModel ) ;
getOwnableContent: public OwnableContent getOwnableContent ( ) { return ownableContent ;
onNext: public void onNext ( ByteBuffer byteBuffer ) { if ( this . httpServerResponse . closed ( ) ) { cancelSubscription ( ) ; return ; } this . httpServerResponse . write ( Buffer . buffer ( Unpooled . wrappedBuffer ( byteBuffer ) ) ) ;
getValue: public String getValue ( ) { return value ;
sendEmail: No method body
removeEventListener: public boolean removeEventListener ( long eventListenerId ) { debug ( "[removeEventListener] {}" , eventListenerId ) ; if ( isCluster ( ) ) { getHazelcastInstance ( ) . getTopic ( CLUSTER_EVENT_TOPIC ) . publish ( new ClusterEvent ( EVENT_LISTENER_REMOVE , eventListenerId ) ) ; return true ; } return false ;
getDimension: public String getDimension ( ) { return activeData . getDimension ( ) ;
getNewTableName: public String getNewTableName ( ) { return newTableName ;
getValid: public Boolean getValid ( ) { return valid ;
setting: public Object setting ( @ PathVariable ( name = ID ) Long objectId , @ PathVariable ( name = ORGANIZATIONID , required = false ) Long organizationId , @ PathVariable ( name = "obj" , required = true ) String objKey ) { CRUDControllerConfiguration conf = controllers . htmlCrudControllerConfigurationMap . getIgnoreCase ( objKey ) ; if ( notValidAccess ( conf . getGetSettingsPrivilege ( ) , conf . getOrganizationId ( ) , organizationId ) ) { return ResponseEntity . status ( HttpStatus . UNAUTHORIZED ) . build ( ) ; } return Flow . init ( componentProvider , objectId )
read: public void read ( Json json , JsonValue jsonData ) { name . set ( json . readValue ( "name" , String . class , jsonData ) ) ; description . set ( json . readValue ( "description" , String . class , jsonData ) ) ; if ( jsonData . has ( "tag" ) ) { String tag = jsonData . getString ( "tag" ) ; if ( BrainOut . getInstance ( ) . hasTag ( tag ) ) { this . tag = tag ; } } if ( jsonData . has ( "components" ) )
getId: public Long getId ( ) { return id ;
earn: protected boolean earn ( Client client ) { InstrumentConsumableItem instrument = null ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : itemData . getRecords ( ) . getData ( ) ) { ConsumableRecord record = entry . value ; if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { instrument = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; PlayerOwnerComponent poc = client . getPlayerData ( ) . getComponent ( PlayerOwnerComponent . class ) ; Content content = instrument . getContent ( ) ; if ( content instanceof Instrument ) { Slot slot = ( ( Instrument ) content ) . getSlot ( ) ; if ( poc . getInstrumentForSlot ( slot ) != null ) { return false ; } } } ConsumableRecord r = client . addConsumable ( record . getAmount ( ) , record . getItem ( ) , record . getQuality ( ) ) ; isAlreadyEarned = true ; if ( r != null ) { r . setTag ( record . getTag ( ) ) ; } } if ( instrument != null && itemData . hasProperty ( "killer" ) ) { String killer = itemData . getProperty ( "killer" ) ; try { int killerId = Integer . valueOf ( killer ) ; Client victim = BrainOutServer . Controller . getClients ( ) . get ( itemData . getOwnerId ( ) ) ; if ( itemData . getComponent ( ServerChipItemComponentData . class ) != null ) { return true ; } if ( killerId == client . getId ( ) && victim != null ) { addTrophy ( client , victim , instrument ) ; } } catch ( NumberFormatException ignored ) { } } return true ;
contentProperties: public Collection < String > contentProperties ( ) { return AuditableEntity . super . contentProperties ( ) ;
isControllerUsed: public boolean isControllerUsed ( ) { return controller ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case launchAttachedEffect : { LaunchAttachedEffectEvent e = ( LaunchAttachedEffectEvent ) event ; launchEffect ( e . kind , e . effectAttacher ) ; break ; } case setInstrument : { SetInstrumentEvent e = ( ( SetInstrumentEvent ) event ) ; if ( e . playerData == ( ( InstrumentData ) getComponentObject ( ) ) . getOwner ( ) ) { if ( getComponentObject ( ) != e . selected ) { deactivate ( ) ; } } break ; } case ownerChanged : { OwnerChangedEvent e = ( ( OwnerChangedEvent ) event ) ; if ( e . newOwner == null ) { deactivate ( ) ; } break ; } case simple : { SimpleEvent e = ( ( SimpleEvent ) event ) ; if ( e . getAction ( ) == SimpleEvent . Action . deselected ) { deactivate ( ) ; break ; } break ; } case launchEffect : { LaunchEffectEvent launchEffectEvent = ( LaunchEffectEvent ) event ; if ( launchEffectEvent . kind == null ) return false ; switch ( launchEffectEvent . kind ) { case hit : { effects . launchEffects ( "hit" , launchEffectEvent . launchData ) ; return true ; } case shoot : { extLaunchData = launchEffectEvent . launchData ; extAttacher = null ; activeDimension = extLaunchData . getDimension ( ) ; shootExtTimer = ( ( ExtendedInstrumentEffectsComponent ) getContentComponent ( ) ) . getExtendedShootPeriod ( ) ; update ( 0 ) ; return true ; } case reload : { effects . launchEffects ( "reload" , launchEffectEvent . launchData ) ; return true ; } case fetch : { effects . launchEffects ( "fetch" , launchEffectEvent . launchData ) ; return true ; } case switchMode : { effects . launchEffects ( "switchMode" , launchEffectEvent . launchData ) ; return true ; } case custom : { effects . launchEffects ( launchEffectEvent . custom , launchEffectEvent . launchData ) ; return true ; } } return false ; } } return false ;
deleteCustomData: public void deleteCustomData ( String shopKey ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/custom-data" , shopKey ) , null , null , null ) ;
setIndexString: public void setIndexString ( String indexString ) { this . indexString = indexString ;
getFriction: public float getFriction ( ) { return friction ;
getWaterDensity: public double getWaterDensity ( ) { return waterDensity ;
executeNoActiveLockAction: private void executeNoActiveLockAction ( ) { if ( noActiveLockAction != null ) {
store: public void store ( ) { log ( "Storing user profile!" ) ; storeEvents ( ) ; if ( profile != null && profile . isParticipatingClan ( ) && clanParticipationProfileStats != null && clanParticipationProfileStats . size > 0 && accessToken != null ) { postClanParticipation ( ) ; } if ( profile != null && profile . isLoaded ( ) )
getCategory: public String getCategory ( ) { return category ;
getMissionControlConfig: public Single < routerrpc . RouterOuterClass . GetMissionControlConfigResponse > getMissionControlConfig ( routerrpc . RouterOuterClass . GetMissionControlConfigRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . getMissionControlConfig ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
closeDriver: public synchronized void closeDriver ( ) { if ( camera != null ) {
dragStart: public DragAndDrop . Payload dragStart ( InputEvent event , float x , float y , int pointer ) { if ( menu . getScale ( ) != 1.0f ) { return null ; } int widthPixels = region . getRegionWidth ( ) , heightPixels = region . getRegionHeight ( ) ; int width = MathUtils . ceil ( ( float ) widthPixels / ( float ) Constants . Graphics . BLOCK_SIZE ) , height = MathUtils . ceil ( ( float ) heightPixels / ( float ) Constants . Graphics . BLOCK_SIZE ) ; int fixedWidthPixels = width * Constants . Graphics . BLOCK_SIZE , fixedHeightPixels = height * Constants . Graphics . BLOCK_SIZE ; Group object = new Group ( ) ; object . setTouchable ( Touchable . disabled ) ; Group invalid = new Group ( ) ; invalid . setTouchable ( Touchable . disabled ) ; Group valid = new Group ( ) ; valid . setTouchable ( Touchable . disabled ) ; float offsetX = - fixedWidthPixels * 0.5f + Constants . Graphics . BLOCK_SIZE * 0.5f , offsetY = - fixedHeightPixels * 0.5f + Constants . Graphics . BLOCK_SIZE * 0.5f ; UserSpritePayload payload = new UserSpritePayload ( offsetX , offsetY , width , height , regionName ) ; { Group entry = renderExt ( region ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; object . addActor ( entry ) ; } { Image border = new Image ( BrainOutClient . Skin , "form-drag-good" ) ; border . setBounds ( offsetX - 2 , offsetY - 2 , fixedWidthPixels + 4 , fixedHeightPixels + 4 ) ; valid . addActor ( border ) ; Group entry = renderExt ( region ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; valid . addActor ( entry ) ; payload . addOffsetCallback ( ( x1 , y1 ) -> { border . setPosition ( offsetX - 2 + x1 , offsetY - 2 + y1 ) ; entry . setPosition ( offsetX + x1 , offsetY + y1 ) ; } ) ; } { Image border = new Image ( BrainOutClient . Skin , "form-border-red" ) ; border . setBounds ( offsetX - 2 , offsetY - 2 , fixedWidthPixels + 4 , fixedHeightPixels + 4 ) ; invalid . addActor ( border ) ; Group entry = renderExt ( region ) ; entry . setTouchable ( Touchable . disabled ) ; entry . setPosition ( offsetX , offsetY ) ; invalid . addActor ( entry ) ; payload . addOffsetCallback ( ( x1 , y1 ) -> { border . setPosition ( offsetX - 2 + x1 , offsetY - 2 + y1 ) ; entry . setPosition ( offsetX + x1 , offsetY + y1 ) ; } ) ; } payload . setDragActor ( object ) ; payload . setObject ( us ) ; payload . setValidDragActor ( valid ) ; payload . setInvalidDragActor ( invalid ) ; return payload ;
convertStrings: public static String [ ] convertStrings ( List < String > strings ) { String [ ] ret = new String [ strings . size ( ) ] ; for ( int i = 0 ; i < ret . length ; i ++ ) { ret [ i ] = strings . get ( i ) ; } return ret ;
fetchAllOrganizations: No method body
hasUpdate: public boolean hasUpdate ( ) { return false ;
getRepository: public ScopedSecureRepository < ? > getRepository ( String entityKey ) { return SearchableRepositories . getSearchableRepository ( entityKey , HasSecurityRules . SecurityScope . USER_IN_ORGANIZATION ) ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . gameController , this ) ; subRelease ( ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; tag = jsonData . getString ( "tag" , "" ) ;
getFilterFieldsNames: public static Collection < Object > getFilterFieldsNames ( FrontendMappingDefinition fd ) { return fd . getFieldsNamesByType ( List . of ( FieldType . text , FieldType . checkbox , FieldType . dropdown , FieldType . number , FieldType . date , FieldType . datetime , FieldType . many_to_one ) ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { tgValvesCloseItemStateChanged ( evt ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
checkAnyUserNotificationNotPushedToMsTeams: public void checkAnyUserNotificationNotPushedToMsTeams ( ) { NotificationDto notificationDto = new NotificationDto ( "message" , Notification . NotificationType . SUCCESS , null , 1L ) ; pushNotificationService . createMsTeamsPostMessageRequest ( notificationDto ) ; verify ( integrationService , never ( ) ) . getOrganizationConfiguration ( anyLong ( ) ) ;
trace: public void trace ( Marker marker , String format , Object arg ) { logger . trace ( marker , format , arg ) ;
isMatchNeighbor: protected boolean isMatchNeighbor ( Map map , int currentX , int currentY , int layer , int x , int y ) { BlockData neighbor = BlockData . GetNeighbor ( map , currentX , currentY , layer , x , y ) ; if ( neighbor == null ) return false ; ConnectionComponentData ccd = neighbor . getComponent ( ConnectionComponentData . class ) ; if ( ccd == null ) return false ; ConnectionComponent cc = getContentComponent ( ) ; return cc . getStickTo ( ) != null && cc . getStickTo ( ) . indexOf ( cc . getStickId ( ) , false ) >= 0 ;
getUniqueId: No method body
onClick: public void onClick ( View v ) { holder . getView ( R . id . layout_to_be_paid_delete ) . setVisibility ( View . VISIBLE ) ;
test_getTenantsWithParams: public void test_getTenantsWithParams ( ) throws IOException , NovuNetworkException , InterruptedException { GetTenantRequest getTenantRequest = new GetTenantRequest ( ) ; getTenantRequest . setPage ( 1 ) ; getTenantRequest . setLimit ( 20 ) ; BulkTenantResponse bulkTenantResponse = new BulkTenantResponse ( ) ; bulkTenantResponse . setPage ( 1 ) ; bulkTenantResponse . setData ( List . of ( new Tenant ( ) ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( bulkTenantResponse ) ) ) ; final var response = tenantsHandler . getTenants ( getTenantRequest ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/tenants?limit=20&page=1" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( bulkTenantResponse ) , gson . toJson ( response ) ) ;
keys: public Set < ByteString > keys ( ) { return this . map . keySet ( ) ;
preparePaymentProbe: public RouterOuterClass . SendPaymentRequest preparePaymentProbe ( LightningOuterClass . PayReq paymentRequest ) { return preparePaymentProbe ( paymentRequest . getDestination ( ) , paymentRequest . getAmount ( ) , paymentRequest . getPaymentAddr ( ) , paymentRequest . getRouteHintsList ( ) , paymentRequest . getFeaturesMap ( ) ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case statUpdated : { StatUpdatedEvent e = ( ( StatUpdatedEvent ) event ) ; if ( getGameUser ( ) != null && getGameUser ( ) . getSteamUserStats ( ) != null ) getGameUser ( ) . getSteamUserStats ( ) . setStatI ( e . statId , ( ( int ) e . value ) ) ; return true ; } case achievementCompleted : { AchievementCompletedEvent e = ( ( AchievementCompletedEvent ) event ) ; getGameUser ( ) . getSteamUserStats ( ) . setAchievement ( e . achievementId ) ; getGameUser ( ) . getSteamUserStats ( ) . storeStats ( ) ; return true ; } case controller : { ClientControllerEvent e = ( ( ClientControllerEvent ) event ) ; if ( e . state != null && ( e . state . getID ( ) == ControllerState . ID . endGame || e . state . getID ( ) == ControllerState . ID . onlineInit ) ) { getGameUser ( ) . getSteamUserStats ( ) . storeStats ( ) ; } return false ; } } return false ;
getIndexString: public String getIndexString ( ) { return indexString ;
init: private Event init ( PhysicChunk physicChunk ) { this . physicChunk = physicChunk ; return this ;
calculateDimensions: public void calculateDimensions ( Paint labelpaint , ViewPortHandler viewPortHandler ) { float defaultFormSize = Utils . convertDpToPixel ( mFormSize ) ; float stackSpace = Utils . convertDpToPixel ( mStackSpace ) ; float formToTextSpace = Utils . convertDpToPixel ( mFormToTextSpace ) ; float xEntrySpace = Utils . convertDpToPixel ( mXEntrySpace ) ; float yEntrySpace = Utils . convertDpToPixel ( mYEntrySpace ) ; boolean wordWrapEnabled = mWordWrapEnabled ; LegendEntry [ ] entries = mEntries ; int entryCount = entries . length ; mTextWidthMax = getMaximumEntryWidth ( labelpaint ) ; mTextHeightMax = getMaximumEntryHeight ( labelpaint ) ; switch ( mOrientation ) { case VERTICAL : { float maxWidth = 0f , maxHeight = 0f , width = 0f ; float labelLineHeight = Utils . getLineHeight ( labelpaint ) ; boolean wasStacked = false ; for ( int i = 0 ; i < entryCount ; i ++ ) { LegendEntry e = entries [ i ] ; boolean drawingForm = e . form != LegendForm . NONE ; float formSize = Float . isNaN ( e . formSize ) ? defaultFormSize : Utils . convertDpToPixel ( e . formSize ) ; String label = e . label ; if ( ! wasStacked ) width = 0.f ; if ( drawingForm ) { if ( wasStacked ) width += stackSpace ; width += formSize ; } if ( label != null ) { if ( drawingForm && ! wasStacked ) width += formToTextSpace ; else if ( wasStacked ) { maxWidth = Math . max ( maxWidth , width ) ; maxHeight += labelLineHeight + yEntrySpace ; width = 0.f ; wasStacked = false ; } width += Utils . calcTextWidth ( labelpaint , label ) ; maxHeight += labelLineHeight + yEntrySpace ; } else { wasStacked = true ; width += formSize ; if ( i < entryCount - 1 ) width += stackSpace ; } maxWidth = Math . max ( maxWidth , width ) ; } mNeededWidth = maxWidth ; mNeededHeight = maxHeight ; break ; } case HORIZONTAL : { float labelLineHeight = Utils . getLineHeight ( labelpaint ) ; float labelLineSpacing = Utils . getLineSpacing ( labelpaint ) + yEntrySpace ; float contentWidth = viewPortHandler . contentWidth ( ) * mMaxSizePercent ; float maxLineWidth = 0.f ; float currentLineWidth = 0.f ; float requiredWidth = 0.f ; int stackedStartIndex = - 1 ; mCalculatedLabelBreakPoints . clear ( ) ; mCalculatedLabelSizes . clear ( ) ; mCalculatedLineSizes . clear ( ) ; for ( int i = 0 ; i < entryCount ; i ++ ) { LegendEntry e = entries [ i ] ; boolean drawingForm = e . form != LegendForm . NONE ; float formSize = Float . isNaN ( e . formSize ) ? defaultFormSize : Utils . convertDpToPixel ( e . formSize ) ; String label = e . label ; mCalculatedLabelBreakPoints . add ( false ) ; if ( stackedStartIndex == - 1 ) { requiredWidth = 0.f ; } else { requiredWidth += stackSpace ; } if ( label != null ) { mCalculatedLabelSizes . add ( Utils . calcTextSize ( labelpaint , label ) ) ; requiredWidth += drawingForm ? formToTextSpace + formSize : 0.f ; requiredWidth += mCalculatedLabelSizes . get ( i ) . width ; } else { mCalculatedLabelSizes . add ( FSize . getInstance ( 0.f , 0.f ) ) ; requiredWidth += drawingForm ? formSize : 0.f ; if ( stackedStartIndex == - 1 ) { stackedStartIndex = i ; } } if ( label != null || i == entryCount - 1 ) { float requiredSpacing = currentLineWidth == 0.f ? 0.f : xEntrySpace ; if ( ! wordWrapEnabled || currentLineWidth == 0.f || ( contentWidth - currentLineWidth >= requiredSpacing + requiredWidth ) ) { currentLineWidth += requiredSpacing + requiredWidth ; } else { mCalculatedLineSizes . add ( FSize . getInstance ( currentLineWidth , labelLineHeight ) ) ; maxLineWidth = Math . max ( maxLineWidth , currentLineWidth ) ; mCalculatedLabelBreakPoints . set ( stackedStartIndex > - 1 ? stackedStartIndex : i , true ) ; currentLineWidth = requiredWidth ; } if ( i == entryCount - 1 ) { mCalculatedLineSizes . add ( FSize . getInstance ( currentLineWidth , labelLineHeight ) ) ; maxLineWidth = Math . max ( maxLineWidth , currentLineWidth ) ; } } stackedStartIndex = label != null ? - 1 : stackedStartIndex ; } mNeededWidth = maxLineWidth ; mNeededHeight = labelLineHeight * ( float ) ( mCalculatedLineSizes . size ( ) ) + labelLineSpacing * ( float ) ( mCalculatedLineSizes . size ( ) == 0 ? 0 : ( mCalculatedLineSizes . size ( ) - 1 ) ) ; break ; } } mNeededHeight += mYOffset ; mNeededWidth += mXOffset ;
getId: public String getId ( ) { return id ;
setHookedInstrument: public void setHookedInstrument ( ConsumableRecord record ) { if ( record != null && ! ( record . getItem ( ) instanceof InstrumentConsumableItem ) ) { return ; } if ( hookedInstrument != null ) { unselectHookedInstrument ( ) ; } hookedInstrument = record ; selectHookedInstrument ( ) ; updateHookedInstrument ( ) ;
setShadowColor: public void setShadowColor ( int shadowColor ) { this . mShadowColor = shadowColor ;
getDimension: public String getDimension ( ) { return flagData . getDimension ( ) ;
setD: public void setD ( float d ) { this . d = d ;
reset: public void reset ( ) { Global . reset ( ) ;
setAccountName: public void setAccountName ( String accountName ) { this . accountName = accountName ; this . avatarString = accountName . substring ( 0 , 1 ) ;
drop: public void drop ( DragAndDrop . Source source , DragAndDrop . Payload payload , float x , float y , int i ) { if ( source instanceof CardOnHandSource ) { CardOnHandSource s = ( ( CardOnHandSource ) source ) ; FreePlayCardsGameMenu . this . notify ( new PlaceCardOnTableFromHand ( d ( ) , o ( ) , - 1 , s . card , - 1 , ( int ) x , ( int ) y ) ) ; } if ( source instanceof DeckDragSource ) { FreePlayCardsGameMenu . this . notify ( new TakeCardOffDeckOntoTable ( d ( ) , o ( ) , ( int ) x , ( int ) y ) ) ; } if ( source instanceof CardOnTableSource )
release: public void release ( ) { unRegisterDownLoadSuccessReceiver ( mContext ) ; unRegisterPackAddedReceiver ( mContext ) ;
playSound: public static long playSound ( MenuSound soundKind ) { Sound sound = ( Sound ) BrainOut . ContentMgr . get ( soundKind . toString ( ) ) ; if ( sound == null ) return - 1 ; return sound . play ( ) ;
stuck: protected void stuck ( ) { pop ( ) ;
getID: public ID getID ( ) { return ID . statUpdated ;
onMeasure: protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { measureChildren ( widthMeasureSpec , heightMeasureSpec ) ; int heightMode = MeasureSpec . getMode ( heightMeasureSpec ) ; int heightSize = MeasureSpec . getSize ( heightMeasureSpec ) ; int width = MeasureSpec . getSize ( widthMeasureSpec ) ; int height ; if ( heightMode == MeasureSpec . EXACTLY ) { height = heightSize ; } else { int childCount = getChildCount ( ) ; if ( childCount <= 0 ) { height = 0 ; } else { int row = 1 ; int widthSpace = width ; for ( int i = 0 ; i < childCount ; i ++ ) { View view = getChildAt ( i ) ; int childW = view . getMeasuredWidth ( ) ; if ( widthSpace - mLabelSpace >= childW ) { widthSpace -= childW ; } else { row ++ ; widthSpace = width - childW ; } widthSpace -= mLabelSpace ; } int childH = getChildAt ( 0 ) . getMeasuredHeight ( ) ; height = ( childH * row ) + mLabelRowSpace * ( row - 1 ) ; } } setMeasuredDimension ( width , height ) ;
isWorking: public boolean isWorking ( ) { return working > 0 ;
render: public void render ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ; super . render ( ) ;
getEffect: public EffectData getEffect ( LaunchData launchData ) { return new MusicEffectData ( this , launchData ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionDecrement4ActionPerformed ( evt ) ;
setResearchAndDevelopment: public void setResearchAndDevelopment ( boolean researchAndDevelopment ) { this . researchAndDevelopment = researchAndDevelopment ;
redeliverMap: public void redeliverMap ( ) { BrainOutServer . Controller . playStateChanged ( ) ;
error: public void error ( String reason ) { waitLoadingMenu . pop ( ) ; pop ( ) ;
getProgress: public synchronized int getProgress ( ) { return progress ;
writeShort: protected void writeShort ( int value ) throws IOException { out . write ( value & 0xff ) ; out . write ( ( value > > 8 ) & 0xff ) ;
getFunctions: public List < String > getFunctions ( String code ) { List < String > functions = new ArrayList < > ( ) ; for ( JsPattern jsPattern : JsPattern . values ( ) ) { addFunctions ( jsPattern , code , functions ) ; } return functions ;
renderReward: private void renderReward ( Event . EventReward reward , Table data ) { Reward . Action action = reward . reward . getAction ( ) ; if ( action instanceof ClientReward . ClientAction )
instantiate: protected ObjectPool . Poolable instantiate ( ) { return new AnimatedMoveViewJob ( null , 0 , 0 , null , null , 0 , 0 , 0 ) ;
setHandshaked: public void setHandshaked ( final boolean handshaked ) { this . handshaked = handshaked ;
t8: public Tuple8 t8 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] , list [ 5 ] , list [ 6 ] , list [ 7 ] ) ;
generateHunger: private void generateHunger ( ) { passedDistance = fp . getContentComponent ( ) . getHungerDistance ( ) ; prevPosition . set ( phy . getX ( ) , phy . getY ( ) ) ;
copy: public ObjectContainer copy ( ) { ObjectContainer copy = new ObjectContainer ( ) ; for ( ObjectMap . Entry < String , MarketService . MarketItemEntry > entry : items ) { copy . items . put ( entry . key , new MarketService . MarketItemEntry ( entry . value . name , entry . value . amount , entry . value . payload ) ) ; } return copy ;
addModulePrivilegesToRole: public boolean addModulePrivilegesToRole ( String roleName , Set < PrivilegeBase > privileges ) { debug ( "[addModulePrivilegesToRole] role: {} privilages: {}" , roleName , privileges ) ; services . role . addPrivilegesToRole ( roleName , privileges ) ; return true ;
deleteWorkflowGroup: No method body
byte2HexUpperCase: public static String byte2HexUpperCase ( byte [ ] bytes ) { return byte2Hex ( bytes ) . toUpperCase ( ) ;
copy: public Attachment copy ( ) { if ( parentMesh != null ) return newLinkedMesh ( ) ; MeshAttachment copy = new MeshAttachment ( name ) ; copy . region = region ; copy . path = path ; copy . color . set ( color ) ; copyTo ( copy ) ; copy . regionUVs = new float [ regionUVs . length ] ; arraycopy ( regionUVs , 0 , copy . regionUVs , 0 , regionUVs . length ) ; copy . uvs = new float [ uvs . length ] ; arraycopy ( uvs , 0 , copy . uvs , 0 , uvs . length ) ; copy . triangles = new short [ triangles . length ] ; arraycopy ( triangles , 0 , copy . triangles , 0 , triangles . length ) ; copy . hullLength = hullLength ; if ( edges != null ) { copy . edges = new short [ edges . length ] ; arraycopy ( edges , 0 , copy . edges , 0 , edges . length ) ; } copy . width = width ; copy . height = height ; return copy ;
getMap: public < T extends Map > T getMap ( Class < T > tClass ) { return Map . Get ( this . dimension , tClass ) ;
length: public int length ( ) { return v . length ;
getDimension: public String getDimension ( ) { return getMenu ( ) . getDimension ( ) ;
getCn: public String getCn ( ) { return cn ;
isEnemies: public boolean isEnemies ( RemoteClient a , RemoteClient b ) { if ( a == b || a == null || b == null ) { return false ; } PlayState ps = getPlayState ( ) ; if ( ps instanceof PlayStateGame )
getJavaProjectGenDir: public static List < JavaProjectGenDir > getJavaProjectGenDir ( Database db ) { List < JavaProjectGenDir > dirs = new ArrayList < > ( ) ; for ( File javaProjectDir : db . getJavaProjectDirs ( ) ) { dirs . add ( new JavaProjectGenDir ( javaProjectDir + "/src/main/java/com/osiris/jsqlgen/" + db . name ) ) ; } return dirs ;
getEnabled: public Boolean getEnabled ( ) { return enabled ;
getPages: public int getPages ( ) { return pages ;
deleteFolderFile: public static void deleteFolderFile ( String filePath , boolean deleteThisPath ) { if ( ! TextUtils . isEmpty ( filePath ) ) {
resetSettings: public void resetSettings ( ) { BrainOut . ContentMgr . unloadAllContent ( ) ; applyInitRoomSettings ( ) ; initSettings ( BrainOutServer . Settings ) ;
requiredArgs: public int requiredArgs ( ) { return 1 ;
getClanName: public String getClanName ( ) { return clanName ;
getInputType: public PayloadType getInputType ( ) { return inputType ;
getColor: public Color getColor ( ) { return color ;
flatMap: public static < T , U > Promise < U > flatMap ( @ NotNull Promise < T > promise , @ NotNull PromiseProvider < T , U > provider ) { Promise < U > ret = new Promise < > ( ) ; promise . add ( new PromiseListener < T > ( ) { @ Override public void failed ( Throwable th ) { ret . fail ( th ) ; } @ Override public void succeeded ( T result ) { provider . provide ( result ) . add ( new PromiseListener < U > ( ) { @ Override public void failed ( Throwable th ) { ret . fail ( th ) ; } @ Override public void succeeded ( U result ) { ret . resolve ( result ) ; } } ) ; } } ) ; return ret ;
setUp: void setUp ( ) { rectangle = new Rectangle ( "s01" , "#AA40FF" , new Point ( 0 , 10 ) , new Point ( 10 , 0 ) ) ;
serialize: public byte [ ] serialize ( @ Nullable T value ) { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; try ( JsonGenerator gen = JSON_FACTORY . createGenerator ( outputStream ) ) { serializer . asBiConsumer ( ) . accept ( gen , value ) ; } catch ( IOException e ) { throw new RuntimeException ( "Cannot create JsonGenerator" , e ) ; } return outputStream . toByteArray ( ) ;
visitMethod: public MethodVisitor visitMethod ( int access , String name , String descriptor , String signature , String [ ] exceptions ) { MethodVisitor mv = cv . visitMethod ( access , name , descriptor , signature , exceptions ) ; if ( "<init>" . equals ( name ) && "()V" . equals ( descriptor ) ) { return new MyBatisConfigurationVisitor . ConstructorVisitor ( ASM5 , mv ) ; } return mv ;
setDuration: public void setDuration ( Integer duration ) { this . duration = duration ;
onClick: public void onClick ( View v ) { ToastUtils . showToast ( mContext , "Not yet open, please wait" ) ; shareFailedLayout . setVisibility ( View . GONE ) ;
updateSound: protected void updateSound ( ) { ClientMap map = ( ( ClientMap ) getMap ( ) ) ; if ( map == null ) return ; if ( isPlaying ( ) )
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Person person = ( Person ) o ; return Objects . equals ( name , person . name ) && Objects . equals ( lastname , person . lastname ) && Objects . equals ( phone , person . phone ) ;
reverseStringBuilder: public void reverseStringBuilder ( ) { assertEquals ( "tset gnirtS" , Reverse . reverseStringBuilder ( "String test" ) ) ; assertEquals ( "eoD nhoJ" , Reverse . reverseStringBuilder ( "John Doe" ) ) ; assertEquals ( "!dlroW olleH" , Reverse . reverseStringBuilder ( "Hello World!" ) ) ;
renderAxisLabels: public void renderAxisLabels ( Canvas c ) { if ( ! mYAxis . isEnabled ( ) || ! mYAxis . isDrawLabelsEnabled ( ) ) return ; float [ ] positions = getTransformedPositions ( ) ; mAxisLabelPaint . setTypeface ( mYAxis . getTypeface ( ) ) ; mAxisLabelPaint . setTextSize ( mYAxis . getTextSize ( ) ) ; mAxisLabelPaint . setColor ( mYAxis . getTextColor ( ) ) ; float xoffset = mYAxis . getXOffset ( ) ; float yoffset = Utils . calcTextHeight ( mAxisLabelPaint , "A" ) / 2.5f + mYAxis . getYOffset ( ) ; AxisDependency dependency = mYAxis . getAxisDependency ( ) ; YAxisLabelPosition labelPosition = mYAxis . getLabelPosition ( ) ; float xPos = 0f ; if ( dependency == AxisDependency . LEFT ) { if ( labelPosition == YAxisLabelPosition . OUTSIDE_CHART ) { mAxisLabelPaint . setTextAlign ( Align . RIGHT ) ; xPos = mViewPortHandler . offsetLeft ( ) - xoffset ; } else { mAxisLabelPaint . setTextAlign ( Align . LEFT ) ; xPos = mViewPortHandler . offsetLeft ( ) + xoffset ; } } else { if ( labelPosition == YAxisLabelPosition . OUTSIDE_CHART ) { mAxisLabelPaint . setTextAlign ( Align . LEFT ) ; xPos = mViewPortHandler . contentRight ( ) + xoffset ; } else { mAxisLabelPaint . setTextAlign ( Align . RIGHT ) ; xPos = mViewPortHandler . contentRight ( ) - xoffset ; } } drawYLabels ( c , xPos , positions , yoffset ) ;
getYMax: No method body
onInit: public void onInit ( ) { super . onInit ( ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . simple , this ) ;
getKeys: No method body
hasUpdate: public boolean hasUpdate ( ) { return true ;
getColumnNames: public String getColumnNames ( ) { return columnNames ;
getVersionNumber: No method body
getPerimeter: public double getPerimeter ( ) { return 2 * Math . PI * radius ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; shareLayout . setVisibility ( View . GONE ) ;
getWaterDensity: public double getWaterDensity ( ) { return Loader . tables . getWaterDensityByTemp ( waterTemperature ) ;
init: public void init ( ) { soundDistance = soundEffect . getSoundDistance ( ) ; calculateSound ( ) ; run ( ) ;
close: public void close ( ) throws IOException { this . indexReader . close ( ) ;
getAuthorities: public Collection < ? extends GrantedAuthority > getAuthorities ( ) { return this . authorities ;
listLeases: No method body
showSpawnMenu: public void showSpawnMenu ( ActionPhaseState state , ShopCart shopCart , SpawnMenu . Spawn spawn , Spawnable lastSpawnPoint ) { state . pushMenu ( new Editor2Menu ( ) ) ;
startDownLoad: private void startDownLoad ( String url , String mimeType ) { Uri uri = Uri . parse ( url ) ; fileName = getUrlApkName ( uri ) ; File apkFile = new File ( WebViewConfig . getWebViewDownLoadPath ( mContext ) , fileName ) ; if ( ! apkFile . exists ( ) ) {
getWsByTraceId: public static NanoWSD . WebSocket getWsByTraceId ( String traceId ) { return traceId2Ws . get ( traceId ) ;
getOwnerId: public String getOwnerId ( ) { return ownerId ;
onViewCreated: public void onViewCreated ( View v , Bundle sis ) { super . onViewCreated ( v , sis ) ; if ( v != null && v . getParent ( ) != null ) {
getState: public State getState ( ) { return state ;
givenClass_whenGetsAllConstructors_thenCorrect: public void givenClass_whenGetsAllConstructors_thenCorrect ( ) throws ClassNotFoundException { final Class < ? > birdClass = Class . forName ( "com.nbicocchi.tutorials.reflection.Bird" ) ; final Constructor < ? > [ ] constructors = birdClass . getConstructors ( ) ; assertEquals ( 3 , constructors . length ) ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Table images = new Table ( ) ; Image a = new Image ( BrainOutClient . Skin , "user-image-sizes" ) ; images . add ( a ) . padRight ( 8 ) ; Image b = new Image ( BrainOutClient . Skin , "user-image-sizes-ui" ) ; images . add ( b ) . padLeft ( 8 ) ; data . add ( images ) . pad ( 16 ) . row ( ) ; } { Label description = new Label ( L . get ( "EDITOR2_UPLOAD_USER_IMAGE_DESC" ) , BrainOutClient . Skin , "title-small" ) ; description . setWrap ( true ) ; description . setAlignment ( Align . center ) ; data . add ( description ) . width ( 600 ) . pad ( 32 ) . row ( ) ; } { progress = new Table ( ) ; data . add ( progress ) . pad ( 32 ) . row ( ) ; } if ( updateRegion == null ) { Table buttons = new Table ( ) ; { TextButton check = new TextButton ( L . get ( "EDITOR2_UPLOAD_USER_IMAGE" ) , BrainOutClient . Skin , "button-green" ) ; check . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; check ( ) ; } } ) ; buttons . add ( check ) . size ( 256 , 64 ) . pad ( 8 ) ; } { TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; } } ) ; buttons . add ( cancel ) . size ( 192 , 64 ) . pad ( 8 ) ; } data . add ( buttons ) . row ( ) ; } else { Table buttons = new Table ( ) ; { TextButton check = new TextButton ( L . get ( "EDITOR2_UPDATE_USER_IMAGE" ) , BrainOutClient . Skin , "button-green" ) ; check . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; check ( ) ; } } ) ; buttons . add ( check ) . size ( 192 , 64 ) . pad ( 8 ) ; } { TextButton delete = new TextButton ( L . get ( "MENU_DELETE" ) , BrainOutClient . Skin , "button-danger" ) ; delete . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pushMenu ( new ConfirmationPopup ( L . get ( "EDITOR2_DELETE_USER_IMAGE_WARNING" ) ) { @ Override public void yes ( ) { removeImage ( ) ; } } ) ; } } ) ; buttons . add ( delete ) . size ( 192 , 64 ) . pad ( 8 ) ; } { TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; } } ) ; buttons . add ( cancel ) . size ( 192 , 64 ) . pad ( 8 ) ; } data . add ( buttons ) . row ( ) ; } return data ;
deleteWorkflowGroup: public DeleteWorkflowGroup deleteWorkflowGroup ( final String id ) throws IOException , NovuNetworkException { try {
copyPropertiesExclude: public static void copyPropertiesExclude ( Object from , Object to , String [ ] excludeArray ) throws Exception { List < String > excludesList = null ; if ( excludeArray != null && excludeArray . length > 0 ) { excludesList = Arrays . asList ( excludeArray ) ; } Method [ ] fromMethods = from . getClass ( ) . getDeclaredMethods ( ) ; Method [ ] toMethods = to . getClass ( ) . getDeclaredMethods ( ) ; Method fromMethod = null , toMethod = null ; String fromMethodName = null , toMethodName = null ; for ( int i = 0 ; i < fromMethods . length ; i ++ ) {
setJiraOrganizationName: public void setJiraOrganizationName ( String jiraOrganizationName ) { this . jiraOrganizationName = jiraOrganizationName ;
setXEntrySpace: public void setXEntrySpace ( float space ) { mXEntrySpace = space ;
getLevel: public int getLevel ( ) { return level ;
init: public void init ( ) { super . init ( ) ; BulletData bulletData = ( ( BulletData ) getComponentObject ( ) ) ; attachTo ( new Animable ( )
getLockItem: public ContentLockTree . LockItem getLockItem ( ) { if ( ContentLockTree . getInstance ( ) == null ) { return null ; } return ContentLockTree . getInstance ( ) . getItem ( this ) ;
debugLevel: public Single < lnrpc . LightningOuterClass . DebugLevelResponse > debugLevel ( lnrpc . LightningOuterClass . DebugLevelRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . debugLevel ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
getBool: public boolean getBool ( String key , boolean defaultValue ) { String result = getStr ( key , defaultValue ? Constant . TRUE : Constant . FALSE ) ; return Constant . TRUE . equalsIgnoreCase ( result ) ;
getShareWeight: public String getShareWeight ( ) { return null ;
getIndividualCacheDirectory: public static File getIndividualCacheDirectory ( Context context , String dirName ) { File cacheDir = getCacheDirectory ( context ) ; File individualCacheDir = new File ( cacheDir , dirName ) ; if ( ! individualCacheDir . exists ( ) ) { if ( ! individualCacheDir . mkdir ( ) ) { individualCacheDir = cacheDir ; } } return individualCacheDir ;
initView: protected void initView ( ) { EventBus . getDefault ( ) . register ( this ) ; seedsInputAdapter = new SeedsInputAdapter ( mContext ) ; seedsSelectAdapter = new SeedsSelectAdapter ( mContext ) ; seedsSelectAdapterForPageTwo = new SeedsSelectAdapterForPageTwo ( mContext ) ; for ( int i = 0 ; i < 24 ; i ++ ) { seedsInputList . add ( "" ) ; } initSeedArray ( ) ; initSeedsInputGridView ( ) ; initViewPager ( ) ;
interceptMethod3: private Response interceptMethod3 ( Chain chain ) throws IOException { Request request = chain . request ( ) ; LogUtils . e ( TAG , "请求接口:" + request . toString ( ) ) ; if ( "POST" . equals ( chain . request ( ) . method ( ) ) ) { StringBuilder sb = new StringBuilder ( ) ; if ( request . body ( ) instanceof FormBody ) { FormBody body = ( FormBody ) request . body ( ) ; for ( int i = 0 ; i < body . size ( ) ; i ++ ) { sb . append ( body . encodedName ( i ) + "=" + body . encodedValue ( i ) + "," ) ; } sb . delete ( sb . length ( ) - 1 , sb . length ( ) ) ; LogUtils . e ( TAG , "POST参数:{" + sb . toString ( ) + "}" ) ; } } long t1 = System . nanoTime ( ) ; Response response = chain . proceed ( chain . request ( ) ) ; long t2 = System . nanoTime ( ) ; LogUtils . e ( TAG , String . format ( Locale . getDefault ( ) , "接口返回 %s ，用时： %.1fms%n" , response . request ( ) . url ( ) , ( t2 - t1 ) / 1e6d ) ) ; LogUtils . i ( TAG , "" + response . headers ( ) ) ; ResponseBody responseBody = response . peekBody ( 1024 * 1024 ) ; String content = responseBody . string ( ) ; LogUtils . e ( TAG , "接口返回是:" + content ) ; return response ;
findAllByRoleId: No method body
obtain: public static Event obtain ( PlayerData playerData , PortalData enter , PortalData exit ) { EnterPortalEvent e = obtain ( EnterPortalEvent . class ) ; if ( e == null ) return null ; return e . init ( playerData , enter , exit ) ;
getUpdatePrefs: public static SharedPreferences getUpdatePrefs ( ) { return getByName ( "update" ) ;
pop: public void pop ( ) { focusTables . clear ( ) ; super . pop ( ) ;
onReceive: public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intent . ACTION_CLOSE_SYSTEM_DIALOGS ) ) {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { stop2BActionPerformed ( evt ) ;
loadContent: public void loadContent ( AssetManager assetManager ) { super . loadContent ( assetManager ) ; if ( skin != null )
setId: public void setId ( Long id ) { this . id = id ;
getColor: public Color getColor ( ) { return color ;
success: public void success ( JSONObject response ) { renderItems ( response ) ;
hasRichLocalization: public boolean hasRichLocalization ( ) { return false ;
getYMin: No method body
getWebsiteUrl: public String getWebsiteUrl ( ) { return websiteUrl ;
getWidth: public float getWidth ( ) { return width ;
getAll: public CommonResult < List < ResourceDto > > getAll ( ) { List < ResourceDto > resourceDtoList = resourceService . getAll ( ) ; return CommonResult . success ( resourceDtoList ) ;
getObjectCdnUrl: public String getObjectCdnUrl ( @ NonNull String bucketName , @ NonNull String objectName ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ossProperties . getAliyun ( ) . getCdnEndpoint ( ) ) . append ( "/" ) . append ( ossProperties . getAliyun ( ) . getCdnPrefix ( ) ) . append ( objectName ) ; return sb . toString ( ) ;
received: public boolean received ( final ItemActionMsg msg ) { Gdx . app . postRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; ActiveData activeData = map . getActiveData ( msg . object ) ; if ( activeData != null ) { BrainOutClient . EventMgr . sendDelayedEvent ( activeData , ItemActionEvent . obtain ( msg . action ) ) ; } } ) ; return true ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { return true ;
setState: void setState ( boolean isActive ) { if ( isActive ) {
awardScores: public boolean awardScores ( ) { return false ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fillTop ;
t1: public Object t1 ( ) { return list [ 0 ] ;
setSwamp: public void setSwamp ( boolean swamp ) { this . swamp = swamp ;
create: public ProductVariant create ( Identifier productIdentifier , ProductVariant model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ProductVariant > responseModel = ( Class < ProductVariant > ) ( Class < ? > ) ProductVariant . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/products/%s/variants" , productIdentifier ) , query , null , responseModel , model ) ;
getGenerator: private FreeplayGeneratorData getGenerator ( ) { return ( ( FreeplayGeneratorData ) getComponentObject ( ) ) ;
getRoundWidth: public float getRoundWidth ( ) { return roundWidth ;
getParameter: public float getParameter ( String name ) { return getContentComponent ( ) . getValue ( name , getDurability ( ) ) ;
enableRegionOption: protected boolean enableRegionOption ( ) { return true ;
show: public void show ( final View view ) { if ( mBasePopWindow == null ) {
getReadPrivilege: public String getReadPrivilege ( ) { return readPrivilege ;
getDefaultLabel: public String getDefaultLabel ( String fieldName ) { String result = WordUtils . capitalize ( Arrays . stream ( StringUtils . splitByCharacterTypeCamelCase ( StringUtils . capitalize ( fieldName ) ) ) . filter ( s -> ! s . equals ( "." ) ) . collect ( Collectors . joining ( " " ) ) ) ; return result ;
checkRestrictions: public boolean checkRestrictions ( ) { boolean result = true ; for ( ObjectMap . Entry < Slot , SlotItem . Selection > entry : getItems ( ) ) { SlotItem item = entry . value . getItem ( ) ; if ( item != null && item . getRestriction ( ) != null ) { SlotItem . Restriction r = item . getRestriction ( ) ; SlotItem . Selection selection = getItem ( r . slot ) ; if ( selection == null || selection . getItem ( ) != r . item ) { selectItem ( entry . key , entry . key . getDefaultItem ( ) . getSelection ( ) ) ; result = false ; } } } return result ;
searchByNameAndLastname: void searchByNameAndLastname ( ) { assertArrayEquals ( new Person [ ] { new Person ( "Nicola" , "Bicocchi" , "34567" ) } , pb . searchByNameAndLastname ( "Nicola" , "Bicocchi" ) ) ; pb . addPerson ( new Person ( "Nicola" , "Bicocchi" , "12346" ) ) ; assertArrayEquals ( new Person [ ] { new Person ( "Nicola" , "Bicocchi" , "34567" ) , new Person ( "Nicola" , "Bicocchi" , "12346" ) } , pb . searchByNameAndLastname ( "Nicola" , "Bicocchi" ) ) ; assertArrayEquals ( new Person [ ] { } , pb . searchByNameAndLastname ( "Alessandro" , "Manzoni" ) ) ;
drawIcon: public void drawIcon ( Table renderTo , CardData cardData ) { if ( ! ( cardData instanceof ContentCardData ) ) return ; ContentCardData contentCardData = ( ( ContentCardData ) cardData ) ; OwnableContent content = contentCardData . getCardContent ( ) ; if ( content . hasComponent ( IconComponent . class ) ) { IconComponent iconComponent = content . getComponent ( IconComponent . class ) ; TextureAtlas . AtlasRegion iconSprite = iconComponent . getIcon ( "big-icon" , null ) ; if ( iconSprite != null ) { Image iconImage = new Image ( iconSprite ) ; iconImage . setScaling ( Scaling . none ) ; renderTo . add ( iconImage ) . expand ( ) . fill ( ) . row ( ) ; return ; } } if ( BrainOut . R . instanceOf ( InstrumentSlotItem . class , content ) ) { InstrumentSlotItem isi = ( ( InstrumentSlotItem ) content ) ; renderInstrument ( renderTo , isi . getInstrument ( ) , isi . getDefaultSkin ( ) , cardData ) ; return ; } if ( BrainOut . R . instanceOf ( InstrumentSkin . class , content ) ) { InstrumentSkin skin = ( ( InstrumentSkin ) content ) ; InstrumentSlotItem slotItem = skin . getSlotItem ( ) ; if ( slotItem != null ) { renderInstrument ( renderTo , slotItem . getInstrument ( ) , skin , cardData ) ; } return ; } if ( content . hasComponent ( IconComponent . class ) ) { IconComponent iconComponent = content . getComponent ( IconComponent . class ) ; TextureAtlas . AtlasRegion icon = iconComponent . getIcon ( ) ; if ( icon != null ) { Image iconImage = new Image ( icon ) ; iconImage . setScaling ( Scaling . none ) ; renderTo . add ( iconImage ) . expand ( ) . fill ( ) . row ( ) ; } return ; } if ( content . hasComponent ( AnimatedIconComponent . class ) )
createOrUpdateCustomDataForCountry: public Map < String , Object > createOrUpdateCustomDataForCountry ( String shopKey , Integer shopCategoryId , String countryCode , Map < String , Object > model ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/categories/%s/countries/%s/custom-data" , shopKey , shopCategoryId , countryCode ) , null , null , responseModel , model ) ;
recycleInstance: public static void recycleInstance ( MPPointF instance ) { pool . recycle ( instance ) ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
getKey: public String getKey ( ) { return key ;
awakeable: public void awakeable ( SyscallCallback < Map . Entry < String , Deferred < ByteBuffer > > > callback ) { syscallsExecutor . execute ( ( ) -> syscalls . awakeable ( callback ) ) ;
setAmount: public void setAmount ( int amount ) { this . amount = amount ;
mav: public < O > O mav ( ResultAndModelFunction < O , R > forSuccess , ResultAndModelFunction < O , R > forValidationError ) { return model . get ( BasePageAttributes . isError ) ? forValidationError . getResult ( this ) : forSuccess . getResult ( this ) ;
drawLabels: protected void drawLabels ( Canvas c , float pos , MPPointF anchor ) { final float labelRotationAngleDegrees = mXAxis . getLabelRotationAngle ( ) ; boolean centeringEnabled = mXAxis . isCenterAxisLabelsEnabled ( ) ; float [ ] positions = new float [ mXAxis . mEntryCount * 2 ] ; for ( int i = 0 ; i < positions . length ; i += 2 ) { if ( centeringEnabled ) { positions [ i + 1 ] = mXAxis . mCenteredEntries [ i / 2 ] ; } else { positions [ i + 1 ] = mXAxis . mEntries [ i / 2 ] ; } } mTrans . pointValuesToPixel ( positions ) ; for ( int i = 0 ; i < positions . length ; i += 2 ) {
notificationMessage: public String notificationMessage ( ) { return String . format ( "User: %d was granted with role: %d, within organization %d." , userId , roleId , organizationId ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { stop1AActionPerformed ( evt ) ;
getMaps: public Array < ServerMap > getMaps ( ) { return maps ;
div: public static String div ( String v1 , String v2 , int scale ) { if ( scale < 0 ) { throw new IllegalArgumentException ( "保留的小数位数必须大于零" ) ; } BigDecimal b1 = new BigDecimal ( v1 ) ; BigDecimal b2 = new BigDecimal ( v2 ) ; return b1 . divide ( b2 , scale , BigDecimal . ROUND_HALF_UP ) . toString ( ) ;
dismiss: public void dismiss ( Fragment fragment ) { removeTagFromCache ( fragment ) ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; shareLayout . setVisibility ( View . GONE ) ;
failed: No method body
nextAddr: No method body
subscribeChannelEvents: public Observable < lnrpc . LightningOuterClass . ChannelEventUpdate > subscribeChannelEvents ( lnrpc . LightningOuterClass . ChannelEventSubscription request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . subscribeChannelEvents ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
s: public static String s ( Table t , String tCurrentNameQuoted ) { StringBuilder s = new StringBuilder ( ) ; if ( t . isDebug ) s . append ( "public static volatile boolean hasChanges = false;\n" ) ; s . append ( "static {\n" + "try{\n" + "Connection con = Database.getCon();\n" + "try{\n" + "try (Statement s = con.createStatement()) {\n" + "Database.TableMetaData t = Database.getTableMetaData(" + t . id + ");\n" ) ; s . append ( "for (int i = t.version; i < " + t . changes . size ( ) + "; i++) {\n" ) ; ArrayList < TableChange > changes = t . changes ; for ( int i = 0 ; i < changes . size ( ) ; i ++ ) { s . append ( "if(i == " + i + "){\n" ) ; TableChange change = changes . get ( i ) ; String tNameNewQuoted = JavaCodeGenerator . getSQLTableNameQuoted ( change . newTableName ) ; String tNameOldQuoted = JavaCodeGenerator . getSQLTableNameQuoted ( change . oldTableName ) ; int stepsToComplete = 0 ; stepsToComplete ++ ; s . append ( "if(t.steps < " + stepsToComplete + "){" ) ; if ( i == 0 ) { s . append ( "s.executeUpdate(\"CREATE TABLE IF NOT EXISTS " + tNameNewQuoted + " (" + t . columns . get ( 0 ) . nameQuoted + " " + t . columns . get ( 0 ) . definition + ")\");\n" ) ; } else if ( ! change . oldTableName . equals ( change . newTableName ) ) { s . append ( "try{s.executeUpdate(\"ALTER TABLE " + tNameOldQuoted + " RENAME " + tNameNewQuoted + "\");} catch (Exception e1){\n" + "try{s.executeUpdate(\"ALTER TABLE " + tNameOldQuoted + " RENAME TO " + tNameNewQuoted + "\");} catch (Exception e2){" + "try{s.executeUpdate(\"EXEC sp_rename " + tNameOldQuoted + ", " + tNameNewQuoted + "\");} catch (Exception e3){\n" + "try{s.executeUpdate(\"RENAME  " + tNameOldQuoted + " TO " + tNameNewQuoted + "\");} catch (Exception e4){\n" + "e1.printStackTrace();e2.printStackTrace();e3.printStackTrace();e4.printStackTrace(); throw new Exception(\"Failed to rename this table." + " Your specific SQL database might not be supported, in this case create a PR on Github for jSQL-Gen and rename this table manually for now.\");\n" + "}}}}" ) ; } s . append ( "t.steps++; Database.updateTableMetaData(t);}\n" ) ; int jStart = 0 ; if ( i == 0 ) jStart = 1 ; for ( int j = jStart ; j < change . oldColumnNames . size ( ) ; j ++ ) { stepsToComplete ++ ; s . append ( "if(t.steps < " + stepsToComplete + "){" ) ; String oldColName = change . oldColumnNames . get ( j ) ; String newColName = change . newColumnNames . get ( j ) ; String newColDef = change . newColumnNames_Definitions . get ( j ) ; s . append ( "try{s.executeUpdate(\"ALTER TABLE " + tNameNewQuoted + " RENAME COLUMN `" + oldColName + "` TO `" + newColName + "`\");} catch (Exception e1){\n" + "try{s.executeUpdate(\"ALTER TABLE " + tNameNewQuoted + " CHANGE `" + oldColName + "` `" + newColName + "` " + newColDef + "\");} catch (Exception e2){\n" + "try{s.executeUpdate(\"EXEC sp_rename `" + change . newTableName . toLowerCase ( ) + "." + oldColName + "`, `" + newColName + "`, `COLUMN`\");} catch (Exception e3){" + "e1.printStackTrace();e2.printStackTrace();e3.printStackTrace(); throw new Exception(\"Failed to rename this column." + " Your specific SQL database might not be supported, in this case create a PR on Github for jSQL-Gen and rename this column manually for now.\");\n" + "}}}" ) ; s . append ( "t.steps++; Database.updateTableMetaData(t);}\n" ) ; } for ( int j = jStart ; j < change . oldColumnDefinitions . size ( ) ; j ++ ) { stepsToComplete ++ ; s . append ( "if(t.steps < " + stepsToComplete + "){" ) ; String oldColDef = change . oldColumnDefinitions . get ( j ) ; String newColDef = change . newColumnDefinitions . get ( j ) ; String newColName = change . newColumnDefinitions_Names . get ( j ) ; s . append ( "s.executeUpdate(\"ALTER TABLE " + tNameNewQuoted + " MODIFY COLUMN `" + newColName + "` " + newColDef + "\");\n" ) ; s . append ( "t.steps++; Database.updateTableMetaData(t);}\n" ) ; } for ( int j = jStart ; j < change . deletedColumnNames . size ( ) ; j ++ ) { stepsToComplete ++ ; s . append ( "if(t.steps < " + stepsToComplete + "){" ) ; String colName = change . deletedColumnNames . get ( j ) ; s . append ( "s.executeUpdate(\"ALTER TABLE " + tNameNewQuoted + " DROP COLUMN `" + colName + "`\");\n" ) ; s . append ( "t.steps++; Database.updateTableMetaData(t);}\n" ) ; } for ( int j = jStart ; j < change . addedColumnNames . size ( ) ; j ++ ) { stepsToComplete ++ ; s . append ( "if(t.steps < " + stepsToComplete + "){" ) ; String colName = change . addedColumnNames . get ( j ) ; String colDef = change . addedColumnDefinitions . get ( j ) ; s . append ( "try{s.executeUpdate(\"ALTER TABLE " + tNameNewQuoted + " ADD COLUMN `" + colName + "` " + colDef + "\");}catch(Exception exAdd){if(!exAdd.getMessage().toLowerCase().contains(\"duplicate column\")) throw exAdd;}\n" ) ; s . append ( "t.steps++; Database.updateTableMetaData(t);}\n" ) ; } s . append ( "t.steps = 0; t.version++;\n" + "Database.updateTableMetaData(t);\n" ) ; s . append ( "}\n" ) ; } s . append ( "}\n" ) ; s . append ( "\n" + ( t . isDebug ? "    new Thread(() -> {\n" + "        try{\n" + "            onAdd.add(obj -> {hasChanges = true;});\n" + "            onRemove.add(obj -> {hasChanges = true;});\n" + "            onUpdate.add(obj -> {hasChanges = true;});\n" + "            while(true){\n" + "                Thread.sleep(10000);\n" + "                if(hasChanges){\n" + "                    hasChanges = false;\n" + "                    System.err.println(\"Changes for " + t . name + " detected within the last 10 seconds, printing...\");\n" + "                    Database.printTable(t);\n" + "                }\n" + "            }\n" + "        } catch (Exception e) {\n" + "            throw new RuntimeException(e);\n" + "        }\n" + "    }).start();\n\n" : "" ) + "}\n" + "try (PreparedStatement ps = con.prepareStatement(\"SELECT id FROM " + tCurrentNameQuoted + " ORDER BY id DESC LIMIT 1\")) {\n" + "ResultSet rs = ps.executeQuery();\n" + "if (rs.next()) idCounter.set(rs.getInt(1) + 1);\n" + "}\n" + "}\n" + "catch(Exception e){ throw new RuntimeException(e); }\n" + "finally {Database.freeCon(con);}\n" + "}catch(Exception e){\n" + "e.printStackTrace();\n" + "System.err.println(\"Something went really wrong during table (" + t . name + ") initialisation, thus the program will exit!\");" + "System.exit(1);}\n" + "}\n\n" ) ; return s . toString ( ) ;
createMap: public ServerMap createMap ( int mWidth , int mHeight , String dimension ) { if ( mWidth < 0 || mHeight < 0 || mWidth > 32 || mHeight > 8 ) return null ; try
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { hLevel1ActionPerformed ( evt ) ;
updateOffset: private void updateOffset ( ) { offset . set ( cpc . getMouseOffset ( ) ) ; float h = ( Math . min ( BrainOutClient . getWidth ( ) , BrainOutClient . getHeight ( ) ) / Constants . Graphics . RES_SIZE ) * 0.4f ; if ( h > offset . len ( ) )
log: public void log ( K key , String message ) { String previousValue = put ( key , message ) ; if ( previousValue != null ) {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem10ActionPerformed ( evt ) ;
getEnum: public static < T extends Enum < T > > T getEnum ( @ NotNull Class < T > cls , @ NotNull String key , @ NotNull T defaultVal ) { try {
conversationId: No method body
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
combine: public static < T , U > Promise < Pair < T , U > > combine ( @ NotNull Promise < T > p1 , @ NotNull Promise < U > p2 ) { final Promise < Pair < T , U > > promise = new Promise < > ( ) ; p1 . subscribe ( r1 -> { p2 . subscribe ( r2 -> { promise . resolve ( new Pair < > ( r1 , r2 ) ) ; } , promise :: fail ) ; } , promise :: fail ) ; return promise ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; callback . cancel ( ) ;
error: public void error ( String reason ) { System . out . println ( reason ) ;
valid: public boolean valid ( ) { return block != null ;
getEffect: public EffectData getEffect ( LaunchData launchData ) { return new HitPhysicEffectData ( this , launchData ) ;
init: public void init ( PlayState . InitCallback callback ) { if ( callback != null )
setWorldVerticesLength: public void setWorldVerticesLength ( int worldVerticesLength ) { this . worldVerticesLength = worldVerticesLength ;
clearStateMessage: public static Protocol . ClearStateEntryMessage clearStateMessage ( String key ) { return Protocol . ClearStateEntryMessage . newBuilder ( )
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pop ( ) ; approve . run ( ) ;
keys: public Iterable < String > keys ( Map < String , String > carrier ) { return carrier . keySet ( ) ;
popLastPageUrl: public String popLastPageUrl ( ) { if ( mUrls . size ( ) >= 2 ) { mUrls . pop ( ) ; return mUrls . pop ( ) ; } return null ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pushMenu ( new Editor2CreateMapMenu ( ) ) ;
search: static int search ( float [ ] frames , float time , int step ) { int n = frames . length ; for ( int i = step ; i < n ; i += step ) if ( frames [ i ] > time ) return i - step ; return n - step ;
deselected: private void deselected ( ) { WeaponSlotComponent slot = getCurrentSlot ( ) ; if ( slot == null ) return ; if ( slot . getState ( ) == WeaponSlotComponent . State . cocked ||
received: public boolean received ( final CustomPlayerAnimationMsg msg ) { ClientMap map = Map . Get ( msg . d , ClientMap . class ) ; if ( map == null ) return true ; ActiveData activeData = map . getActiveData ( msg . object ) ; if ( activeData == null ) return true ; Gdx . app . postRunnable ( ( ) -> { if ( msg . animationName != null ) { PlayerComponentData pcd = activeData . getComponent ( PlayerComponentData . class ) ; if ( pcd != null ) { pcd . playCustomHandAnimation ( msg . animationName , false ) ; } } if ( msg . effect != null ) { final Effect effect = ( ( Effect ) BrainOutClient . ContentMgr . get ( msg . effect ) ) ; if ( effect != null ) { effect . getSet ( ) . launchEffects ( new PointLaunchData ( activeData . getX ( ) , activeData . getY ( ) , 0 , map . getDimension ( ) ) ) ; } } } ) ; return true ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { aFWStop1ItemStateChanged ( evt ) ;
getID: public ID getID ( ) { return ID . chat ;
generate: public static String generate ( int length ) { char [ ] chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; Random random = new Random ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = chars [ random . nextInt ( chars . length ) ] ; sb . append ( c ) ; } return sb . toString ( ) ;
length: public long length ( ) { InputStream stream = read ( ) ; if ( stream != null ) { try { return stream . available ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return 0 ; } } return 0 ;
blockCallNotification: public static boolean blockCallNotification ( NotificationData data ) { if ( data != null && "CALL_RING" . equals ( data . getType ( ) ) && shouldHideCalls ( ) ) {
fitSystemWindows: protected final boolean fitSystemWindows ( Rect insets ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . KITKAT ) { mInsets [ 0 ] = insets . left ; mInsets [ 1 ] = insets . top ; mInsets [ 2 ] = insets . right ; insets . left = 0 ; insets . top = 0 ; insets . right = 0 ; } return super . fitSystemWindows ( insets ) ;
getSpawnName: public String getSpawnName ( ) { return spawnName ;
getNodeMetrics: public Single < lnrpc . LightningOuterClass . NodeMetricsResponse > getNodeMetrics ( lnrpc . LightningOuterClass . NodeMetricsRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . getNodeMetrics ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
registerHtmlCrudController: No method body
updatePositionFromState: public static float updatePositionFromState ( int state , int autoState , float position , float speed ) { if ( state != 1 ) { switch ( state ) { case 0 : { if ( position == 0.0 ) { break ; } position -= speed ; if ( position < 0.0 ) { position = 0.0f ; } break ; } case 2 : { if ( position == 1.0 ) { break ; } position += speed ; if ( position > 1.0 ) { position = 1.0f ; } break ; } } } else { switch ( autoState ) { case 0 : { if ( position == 0.0 ) { break ; } position -= speed ; if ( position < 0.0 ) { position = 0.0f ; } break ; } case 2 : { if ( position == 1.0 ) { break ; } position += speed ; if ( position > 1.0 ) { position = 1.0f ; } break ; } } } return position ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; ranks . clear ( ) ; users . clear ( ) ; for ( JsonValue value : jsonData . get ( "ranks" ) )
d: public static void d ( String tag , String msg ) { if ( Constants . isShowLog ) {
drawCorner: private void drawCorner ( Canvas canvas , Rect frame ) { paint . setColor ( cornerColor ) ; canvas . drawRect ( frame . left , frame . top , frame . left + CORNER_RECT_WIDTH , frame . top + CORNER_RECT_HEIGHT , paint ) ; canvas . drawRect ( frame . left , frame . top , frame . left + CORNER_RECT_HEIGHT , frame . top + CORNER_RECT_WIDTH , paint ) ; canvas . drawRect ( frame . right - CORNER_RECT_WIDTH , frame . top , frame . right , frame . top + CORNER_RECT_HEIGHT , paint ) ; canvas . drawRect ( frame . right - CORNER_RECT_HEIGHT , frame . top , frame . right , frame . top + CORNER_RECT_WIDTH , paint ) ; canvas . drawRect ( frame . left , frame . bottom - CORNER_RECT_WIDTH , frame . left + CORNER_RECT_HEIGHT , frame . bottom , paint ) ; canvas . drawRect ( frame . left , frame . bottom - CORNER_RECT_HEIGHT , frame . left + CORNER_RECT_WIDTH , frame . bottom , paint ) ; canvas . drawRect ( frame . right - CORNER_RECT_WIDTH , frame . bottom - CORNER_RECT_HEIGHT , frame . right , frame . bottom , paint ) ; canvas . drawRect ( frame . right - CORNER_RECT_HEIGHT , frame . bottom - CORNER_RECT_WIDTH , frame . right , frame . bottom , paint ) ;
getProgress: public int getProgress ( ) { return progress ;
onClick: public void onClick ( View v ) { mAlertDialog . dismiss ( ) ;
init: private Event init ( ActiveData activeData , int oldId , String oldDimension , String newDimension ) { this . activeData = activeData ; this . oldId = oldId ; this . oldDimension = oldDimension ; this . newDimension = newDimension ; return this ;
isRightsValid: No method body
getChatDateByAP: public static String getChatDateByAP ( Date chatDate ) { String chatTime ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( chatDate ) ; if ( chatDate . getTime ( ) < getYearDateZero ( ) . getTime ( ) ) { SimpleDateFormat lastYearFormat = new SimpleDateFormat ( "yyyy年" ) ; chatTime = lastYearFormat . format ( chatDate ) + ( cal . get ( Calendar . MONTH ) + 1 ) + "月" + cal . get ( Calendar . DAY_OF_MONTH ) + "日" ; } else if ( chatDate . getTime ( ) < getWeekDateZero ( ) . getTime ( ) ) { chatTime = ( cal . get ( Calendar . MONTH ) + 1 ) + "月" + cal . get ( Calendar . DAY_OF_MONTH ) + "日" + get12HoursByAP ( chatDate ) ; } else if ( chatDate . getTime ( ) < getYesterdayDateZero ( ) . getTime ( ) ) { chatTime = getWeekOfDate ( chatDate ) + get12HoursByAP ( chatDate ) ; } else if ( chatDate . getTime ( ) < getTodayDateZero ( ) . getTime ( ) ) { chatTime = "昨天" + get12HoursByAP ( chatDate ) ; } else { chatTime = get12HoursByAP ( chatDate ) ; } return chatTime ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; addMain ( data ) ; addButtons ( data ) ; if ( items . size > 0 ) { for ( ObjectMap . Entry < InventoryContent , Integer > entry : items ) { if ( entry . value > 0 ) { selectItem ( entry . key ) ; break ; } } } return data ;
mouseDrag: public boolean mouseDrag ( Vector2 position , int button ) { if ( button != Input . Buttons . LEFT ) return false ; if ( selectionMode ) { selectionEnd . set ( position ) ; float x1 = Math . min ( selectionStart . x , selectionEnd . x ) , y1 = Math . min ( selectionStart . y , selectionEnd . y ) , x2 = Math . max ( selectionStart . x , selectionEnd . x ) , y2 = Math . max ( selectionStart . y , selectionEnd . y ) ; clearHoveredItems ( ) ; Map map = Map . Get ( getMenu ( ) . getDimension ( ) ) ; for ( ObjectMap . Entry < Integer , ActiveData > entry : map . getActives ( ) ) { ActiveData activeData = entry . value ; SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; if ( x1 <= activeData . getX ( ) && y1 <= activeData . getY ( ) && x2 >= activeData . getX ( ) + sp . getWidth ( ) && y2 >= activeData . getY ( ) + sp . getHeight ( ) ) { hoverItem ( activeData ) ; } } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { if ( x1 <= activeData . getX ( ) && y1 <= activeData . getY ( ) && x2 >= activeData . getX ( ) + us . getWidth ( ) && y2 >= activeData . getY ( ) + us . getHeight ( ) ) { hoverItem ( activeData ) ; } } } } return true ; } else { if ( selected . size > 0 || hoveredItems . size > 0 ) { if ( ! dragMode ) { duplicationMode = isDuplicationMode ( ) ; originalPositions . clear ( ) ; boolean clear = false ; for ( ActiveData hoveredItem : hoveredItems ) { if ( ! isSelected ( hoveredItem ) ) { clear = true ; break ; } } if ( clear ) { if ( ! isMultiSelection ( ) ) { clearSelection ( ) ; } for ( ActiveData hoveredItem : hoveredItems ) { addSelection ( hoveredItem ) ; } } clearHoveredItems ( ) ; if ( duplicationMode ) { originals . clear ( ) ; originals . addAll ( selected ) ; selected . clear ( ) ; Map map = Map . Get ( getMenu ( ) . getDimension ( ) ) ; for ( ActiveData original : originals ) { String d = Data . ComponentSerializer . toJson ( original , Data . ComponentWriter . TRUE , - 1 ) ; ActiveData copy = map . newActiveData ( map . generateClientId ( ) , d , true ) ; selected . add ( copy ) ; } } for ( ActiveData activeData : selected ) { originalPositions . put ( activeData , new Vector2 ( activeData . getX ( ) , activeData . getY ( ) ) ) ; } dragMode = true ; } dragValid = true ; Map map = Map . Get ( getMenu ( ) . getDimension ( ) ) ; tmp . set ( position ) . sub ( dragStart ) ; tmp2 . clear ( ) ; for ( ObjectMap . Entry < ActiveData , Vector2 > entry : originalPositions ) { ActiveData activeData = entry . key ; Vector2 originalPosition = entry . value ; int x_ = ( int ) ( originalPosition . x + ( int ) tmp . x ) , y_ = ( int ) ( originalPosition . y + ( int ) tmp . y ) ; activeData . setPosition ( x_ , y_ ) ; SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; if ( ! sp . validateBlocksForAdding ( map , x_ , y_ , selected ) ) { dragValid = false ; } } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { if ( ! us . validateBlocksForAdding ( map , x_ , y_ , selected ) ) { dragValid = false ; } } } tmp2 . add ( activeData . getLayer ( ) ) ; } for ( Integer layer : tmp2 ) { ClientActiveDataMap . ClientRenderMap renderMap = ( ( ClientActiveDataMap . ClientRenderMap ) map . getActives ( ) . getRenderLayer ( layer ) ) ; renderMap . getCache ( ) . updateCache ( ) ; } } } return false ;
onResponse: public void onResponse ( byte [ ] bytes ) { LogUtils . e ( TAG , "------------------invoicesCancelInvoiceOnResponse------------------" ) ; runOnUiThread ( new Runnable ( ) {
openDriver: public synchronized void openDriver ( SurfaceHolder holder ) throws IOException { OpenCamera theCamera = camera ; if ( theCamera == null ) { theCamera = OpenCameraInterface . open ( requestedCameraId ) ; if ( theCamera == null ) { throw new IOException ( "Camera.open() failed to return object from driver" ) ; } camera = theCamera ; } if ( ! initialized ) { initialized = true ; configManager . initFromCameraParameters ( theCamera ) ; if ( requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0 ) { setManualFramingRect ( requestedFramingRectWidth , requestedFramingRectHeight ) ; requestedFramingRectWidth = 0 ; requestedFramingRectHeight = 0 ; } } Camera cameraObject = theCamera . getCamera ( ) ; Camera . Parameters parameters = cameraObject . getParameters ( ) ; String parametersFlattened = parameters == null ? null : parameters . flatten ( ) ; try { configManager . setDesiredCameraParameters ( theCamera , false ) ; } catch ( RuntimeException re ) { Log . w ( TAG , "Camera rejected parameters. Setting only minimal safe-mode parameters" ) ; Log . i ( TAG , "Resetting to saved camera params: " + parametersFlattened ) ; if ( parametersFlattened != null ) { parameters = cameraObject . getParameters ( ) ; parameters . unflatten ( parametersFlattened ) ; try { cameraObject . setParameters ( parameters ) ; configManager . setDesiredCameraParameters ( theCamera , true ) ; } catch ( RuntimeException re2 ) { Log . w ( TAG , "Camera rejected even safe-mode parameters! No configuration" ) ; } } } cameraObject . setPreviewDisplay ( holder ) ;
setContentTopShadow: private void setContentTopShadow ( D params ) { ViewGroup parent = params . mParent ; ViewGroup contentParent = params . mContentParent ; Context context = params . mContext ; if ( contentParent == null ) { int contentLayoutIndex = parent . getChildCount ( ) - 1 ; if ( contentLayoutIndex >= 0 ) { contentParent = ( ViewGroup ) parent . getChildAt ( contentLayoutIndex ) ; } } if ( contentParent == null ) { return ; } LayoutInflater . from ( context ) . inflate ( R . layout . layout_page_top_shadow_line , contentParent , true ) ;
getYValuePosition: No method body
serialize: public byte [ ] serialize ( T value ) { try {
createUI: public Table createUI ( ) { Table data = new Table ( ) ; Table contents = new Table ( ) ; renderContents ( contents ) ; ScrollPane scrollPane = new ScrollPane ( contents , BrainOutClient . Skin , "scroll-default" ) ; setScrollFocus ( scrollPane ) ; data . add ( scrollPane ) . expand ( ) . fill ( ) . row ( ) ; return data ;
refreshRooms: private void refreshRooms ( ) { renderLoading ( ) ; EnvironmentService env = EnvironmentService . Get ( ) ; ProfileService profileService = ProfileService . Get ( ) ; LoginService loginService = LoginService . Get ( ) ; if ( env == null || profileService == null || loginService == null ) return ; String conflictAccount = ( String ) env . getEnvironmentVariables ( ) . get ( "conflict-account" ) ; if ( conflictAccount == null ) { conflictAccount = defaultConflictAccount ( ) ; } profileService . getAccountProfile ( loginService . getCurrentAccessToken ( ) , conflictAccount ,
getAssignmentId: public Long getAssignmentId ( ) { return assignmentId ;
repairContent: private void repairContent ( Content content ) { DurabilityComponent dc = content . getComponentFrom ( DurabilityComponent . class ) ; if ( dc != null )
updateEventListener: private boolean updateEventListener ( EventListenerEntry eventListenerEntry ) { debug ( "[updateEventListener] {}" , eventListenerEntry ) ; unregisterEventListener ( eventListenerEntry . getId ( ) ) ; boolean r = registerListener ( eventListenerEntry ) ; services . applicationEvent . emitEvent ( EVENT_LISTENER_MODIFIED , eventListenerEntry ) ; return r ;
getModelKeys: public String [ ] getModelKeys ( ) { return modelKeys ;
clicked: public void clicked ( InputEvent event , float x , float y ) { play ( ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
needRolesForBots: public boolean needRolesForBots ( ) { return false ;
getClientRank: private int getClientRank ( Client client ) { ModePayload payload = client . getModePayload ( ) ; if ( ! ( payload instanceof GunGamePayload ) ) return 0 ; return - ( ( GunGamePayload ) payload ) . getRank ( ) ;
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { return ; } new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
getHighlightCircleStrokeAlpha: No method body
getTeams: public Array < Team > getTeams ( ) { return teams ;
write: public void write ( Json json ) { super . write ( json ) ; root . write ( json ) ; json . writeObjectStart ( "game-pads" ) ; for ( ObjectMap . Entry < String , GamePadKeyProperties > entry : gamePadControls ) { json . writeObjectStart ( entry . key ) ; entry . value . write ( json ) ; json . writeObjectEnd ( ) ; } json . writeObjectEnd ( ) ;
setPublicFile: public void setPublicFile ( boolean publicFile ) { this . publicFile = publicFile ;
removeTower: public Single < wtclientrpc . Wtclient . RemoveTowerResponse > removeTower ( wtclientrpc . Wtclient . RemoveTowerRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . removeTower ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
run: public void run ( ) { if ( counter -- < 0 ) { cancel ( ) ; return ; } Menu . playSound ( MenuSound . character ) ;
withdraw: public void withdraw ( int amount ) { balance -= amount ;
getForm: public ReflectionBasedEntityForm getForm ( String formName , Long organizationId , Function < FormFieldDefinitionBuilderStart , FormFieldDefinitionBuilder > builder ) { return new ReflectionBasedEntityForm ( createFrontendMappingDefinition ( formName , builder ) , organizationId , null ) ;
convert: public < F , T > PageModelMap convert ( PageAttr < F > fromKey , PageAttr < T > targetKey , Function < F , T > remappingFunction ) { F from = this . get ( fromKey ) ; if ( from == null ) {
init: public void init ( ) { super . init ( ) ; ClientMap map = Map . Get ( BlockData . CURRENT_DIMENSION , ClientMap . class ) ; if ( map == null ) return ; effectData = map . addEffect ( getContentComponent ( ) . getParticleEffect ( ) ,
getDataIndex: public int getDataIndex ( ) { return mDataIndex ;
setViewVisibility: public PagerViewHolder setViewVisibility ( int viewId , int visibility ) { getView ( viewId ) . setVisibility ( visibility ) ; return this ;
doCheck: public void doCheck ( ) { if ( ! isGameFinished ( ) )
isDetached: public boolean isDetached ( ) { return attachedMagazine == null ;
renderTimeLeft: protected Cell < Table > renderTimeLeft ( Table container ) { Cell < Table > cell = super . renderTimeLeft ( container ) ; if ( cell != null ) { cell . padBottom ( - 16 ) ; } return cell ;
parseNodeUri: public static LightningNodeUri parseNodeUri ( @ NonNull String uri ) { if ( uri . isEmpty ( ) || uri . length ( ) < NODE_URI_MIN_LENGTH ) { return null ; } if ( uri . length ( ) == NODE_URI_MIN_LENGTH ) { if ( UtilFunctions . isHex ( uri ) ) { return new LightningNodeUri . Builder ( ) . setPubKey ( uri ) . build ( ) ; } else { return null ; } } if ( ! ( uri . charAt ( NODE_URI_MIN_LENGTH ) == '@' ) ) { return null ; } String [ ] parts = uri . split ( "@" ) ; if ( parts . length != 2 ) { return null ; } if ( UtilFunctions . isHex ( parts [ 0 ] ) ) {
setSize: public void setSize ( Map map , int blockWidth , int blockHeight , boolean init ) { clear ( ) ; this . blockWidth = blockWidth ; this . blockHeight = blockHeight ; this . width = blockWidth * Constants . Core . CHUNK_SIZE ; this . height = blockHeight * Constants . Core . CHUNK_SIZE ; ensureCapacity ( this . blockWidth * this . blockHeight ) ; for ( int j = 0 ; j < this . blockHeight ; j ++ )
newObject: protected LimitedBulletData newObject ( ) { return new LimitedBulletData ( LimitedBullet . this , this ) ;
reverseAwaitOrder: No method body
init: public void init ( ) { super . init ( ) ; if ( instrumentData != null && instrumentData . getOwner ( ) != null )
getCount: public int getCount ( ) { if ( mAdapter . getPageCount ( ) > 1 ) {
isTime: public boolean isTime ( ) { return this == TIME ;
schedule: public boolean schedule ( Scheduler scheduler ) { if ( scheduler != null ) { debug ( "Scheduling task {} with data {}" , scheduler . getCronExpression ( ) , scheduler . getEventData ( ) ) ; ScheduledSchedulerDto schedulerDto = new ScheduledSchedulerDto ( scheduler . getCronExpression ( ) , scheduler . getEventData ( ) , scheduler . getOrganizationId ( ) , scheduler . isOnMasterOnly ( ) , scheduler . isAsync ( ) , LocalDateTime . now ( ) ) ; currentlyScheduled . put ( scheduler . getId ( ) , taskScheduler . schedule ( new SchedulerTask ( schedulerDto ) , new CronTrigger ( scheduler . getCronExpression ( ) ) ) ) ; return true ; } return false ;
setLength: public void setLength ( float length ) { this . length = length ;
setUser: public void setUser ( User user ) { this . user = user ;
withRequestIdentityVerifier: public Builder withRequestIdentityVerifier ( RequestIdentityVerifier requestIdentityVerifier ) { this . requestIdentityVerifier = requestIdentityVerifier ; return this ;
setPackage: public void setPackage ( ContentPackage contentPackage ) { this . contentPackage = contentPackage ;
hello: public String hello ( String name , String arg2 , String arg3 ) { try { Thread . sleep ( 1000L ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } return "hello " + name + " " + arg2 + " " + arg3 ;
getWinPoints: public int getWinPoints ( ) { return winPoints ;
init: public void init ( ) { SteamEnvironment env = ( ( SteamEnvironment ) BrainOutClient . Env ) ; env . getGameUser ( ) . initSocial ( ) ; switchTo ( new CSPrivacyPolicy ( ) ) ;
onValueSelected: No method body
setScaleY: public void setScaleY ( float scaleY ) { this . scaleY = scaleY ;
success: public static AjaxResult success ( ) { return AjaxResult . success ( "操作成功！" ) ;
getLogStreamName: public String getLogStreamName ( ) { return null ;
getPrefHeight: public float getPrefHeight ( ) { return 64 ;
enlarge: void enlarge ( ) { for ( int i = 0 ; i < 20 ; i ++ ) { l . add ( "Nome " + i ) ; } assertTrue ( l . contains ( "Nome 19" ) ) ; assertEquals ( 20 , l . size ( ) ) ;
fail: private void fail ( ) { Menu . playSound ( Menu . MenuSound . denied ) ;
enter: private void enter ( Client client , PlayerData playerData , String payload ) { if ( ! ( client instanceof PlayerClient ) ) return ; PlayerClient playerClient = ( ( PlayerClient ) client ) ; String tag = portal . tag ; if ( tag . isEmpty ( ) ) return ; ActiveData otherPortal_ = null ; for ( Map map : Map . All ( ) ) { otherPortal_ = map . getActiveForTag ( Constants . ActiveTags . PORTAL , activeData -> { if ( activeData == portal ) return false ; if ( ! ( activeData instanceof PortalData ) ) return false ; PortalData portalData = ( ( PortalData ) activeData ) ; return portalData . tag . equals ( tag ) ; } ) ; if ( otherPortal_ != null ) break ; } final ActiveData otherPortal = otherPortal_ ; if ( otherPortal == null ) { if ( Log . ERROR ) Log . error ( "Portal not found!" ) ; return ; } if ( ! payload . equals ( code ) ) { String denied = getContentComponent ( ) . getDeniedEffect ( ) ; if ( ! denied . isEmpty ( ) ) { BrainOutServer . Controller . getClients ( ) . sendUDP ( new LaunchEffectMsg ( portal . getDimension ( ) , portal . getX ( ) , portal . getY ( ) , denied ) ) ; return ; } } float enterTime = 0.5f ; String effect = getContentComponent ( ) . getActivateEffect ( ) ; if ( ! effect . isEmpty ( ) ) { BrainOutServer . Controller . getClients ( ) . sendUDP ( new LaunchEffectMsg ( portal . getDimension ( ) , portal . getX ( ) , portal . getY ( ) , effect ) ) ; } ServerSafeComponentData otherPortalComponent = otherPortal . getComponent ( ServerSafeComponentData . class ) ; if ( otherPortalComponent != null ) { if ( ! otherPortalComponent . getContentComponent ( ) . getActivateEffect ( ) . isEmpty ( ) ) { BrainOutServer . Controller . getClients ( ) . sendUDPExcept ( new LaunchEffectMsg ( otherPortal . getDimension ( ) , otherPortal . getX ( ) , otherPortal . getY ( ) , otherPortalComponent . getContentComponent ( ) . getActivateEffect ( ) ) , playerClient ) ; } } else { BrainOutServer . Controller . getClients ( ) . sendUDPExcept ( new LaunchEffectMsg ( otherPortal . getDimension ( ) , otherPortal . getX ( ) , otherPortal . getY ( ) , getContentComponent ( ) . getActivateEffect ( ) ) , playerClient ) ; } ActiveProgressComponentData progress = playerData . getComponent ( ActiveProgressComponentData . class ) ; if ( progress == null ) return ; playerClient . setSafesOpenedThisGame ( playerClient . getSafesOpenedThisGame ( ) + 1 ) ; if ( playerClient . getSafesOpenedThisGame ( ) == 1 ) { playerClient . addStat ( "safes-opened" , 1 ) ; } playerClient . enablePlayer ( false ) ; SimplePhysicsComponentData phy = playerData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy != null ) { phy . getSpeed ( ) . set ( 0 , 0 ) ; playerClient . getServerPlayerController ( ) . sendPlayerData ( false , 0 ) ; } Runnable finally_ = ( ) -> { playerClient . enablePlayer ( true ) ; } ; progress . startCancellable ( enterTime , ( ) ->
hasFilters: public boolean hasFilters ( ) { return ( ( Item ) itemData . getContent ( ) ) . getFilters ( ) != null ;
getID: No method body
getViewById: public < T extends View > T getViewById ( int viewId ) { return mViewHelper . getViewById ( viewId ) ;
hasWarmUp: public boolean hasWarmUp ( ) { return false ;
addWhite: void addWhite ( ) throws Exception { assertNotNull ( addWhiteParam , "addWhiteParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/white/add" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( addWhiteParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "新增白名单接口测试成功:{}" , map . get ( "data" ) ) ;
validate: public IntegrationMsTeamsForm validate ( BindingResult br ) { if ( StringUtils . isBlank ( dto . getWebhookUrl ( ) ) ) { br . rejectValue ( "dto.webhookUrl" , "not.empty" ) ; } return null ;
setFocusArea: public static void setFocusArea ( Camera . Parameters parameters ) { if ( parameters . getMaxNumFocusAreas ( ) > 0 ) {
beforeToday: public static boolean beforeToday ( long timeStamp ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTimeInMillis ( timeStamp ) ; Calendar todayCalendar = Calendar . getInstance ( ) ; todayCalendar . setTime ( new Date ( ) ) ; if ( calendar . get ( Calendar . YEAR ) == ( todayCalendar . get ( Calendar . YEAR ) ) ) { int diffDay = calendar . get ( Calendar . DAY_OF_YEAR ) - todayCalendar . get ( Calendar . DAY_OF_YEAR ) ; if ( diffDay < 0 ) { return true ; } } return false ;
getAuthMethod: public LoggedUser . AuthenticationMethods getAuthMethod ( ) { return authMethod ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
convert: public void convert ( ViewHolder holder , final int position , final InvoiceEntity item ) { holder . setText ( R . id . tv_time , DateUtils . MonthDay ( item . getDate ( ) + "" ) ) ; DecimalFormat df = new DecimalFormat ( "0.00######" ) ; if ( item . getAssetId ( ) == 0 ) { holder . setText ( R . id . tv_amount , df . format ( Double . parseDouble ( String . valueOf ( item . getAmount ( ) / 1000 ) ) / 100000000 ) ) ; } else { holder . setText ( R . id . tv_amount , df . format ( Double . parseDouble ( String . valueOf ( item . getAmount ( ) ) ) / 100000000 ) ) ; } if ( item . getInvoice ( ) != null && ! item . getInvoice ( ) . isEmpty ( ) ) { holder . setText ( R . id . tv_receiver , PaymentRequestUtil . getMemo ( item . getInvoice ( ) ) ) ; } else { holder . setText ( R . id . tv_receiver , "unknown" ) ; } final SwipeMenuLayout menuLayout = holder . getView ( R . id . layout_to_be_paid_list_swipe_menu ) ; menuLayout . setSwipeMenuStateListener ( new SwipeMenuStateListener ( ) { @ Override public void menuIsOpen ( boolean isOpen ) { if ( ! isOpen ) { holder . getView ( R . id . layout_to_be_paid_delete ) . setVisibility ( View . GONE ) ; } } } ) ; holder . getView ( R . id . tv_to_be_paid_delete ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { holder . getView ( R . id . layout_to_be_paid_delete ) . setVisibility ( View . VISIBLE ) ; } } ) ; holder . getView ( R . id . tv_to_be_paid_confirm ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { holder . getView ( R . id . layout_to_be_paid_delete ) . setVisibility ( View . GONE ) ; menuLayout . quickClose ( ) ; if ( item . getAssetId ( ) == 0 ) { mToBePaidData . remove ( position ) ; mToBePaidAdapter . notifyRemoveItem ( position ) ; mToBePaidNumTv . setText ( mToBePaidData . size ( ) + "" ) ; if ( mToBePaidData . size ( ) == 0 ) { mToBePaidAdapter . notifyDataSetChanged ( ) ; mToBePaidNumTv . setText ( "0" ) ; } Gson gson = new Gson ( ) ; String jsonStr = gson . toJson ( mToBePaidData ) ; SharedPreferences sp = mContext . getSharedPreferences ( "SP_BTC_INVOICE_LIST" , Activity . MODE_PRIVATE ) ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putString ( "btcInvoiceListKey" , jsonStr ) ; editor . commit ( ) ; } else { mToBePaidData . remove ( position ) ; mToBePaidAdapter . notifyRemoveItem ( position ) ; mToBePaidNumTv . setText ( mToBePaidData . size ( ) + "" ) ; if ( mToBePaidData . size ( ) == 0 ) { mToBePaidAdapter . notifyDataSetChanged ( ) ; mToBePaidNumTv . setText ( "0" ) ; } Gson gson = new Gson ( ) ; String jsonStr = gson . toJson ( mToBePaidData ) ; SharedPreferences sp = mContext . getSharedPreferences ( "SP_INVOICE_LIST" , Activity . MODE_PRIVATE ) ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putString ( "invoiceListKey" , jsonStr ) ; editor . commit ( ) ; } } } ) ; holder . getView ( R . id . tv_to_be_paid_no ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { holder . getView ( R . id . layout_to_be_paid_delete ) . setVisibility ( View . GONE ) ; } } ) ; holder . getView ( R . id . layout_to_be_paid_list ) . setOnClickListener ( new View . OnClickListener ( ) {
hasOrganizations: public boolean hasOrganizations ( ) { return UserProvider . getFromContext ( ) . map ( OrganizationUser :: getOrganizationNames ) . map ( a -> a . size ( ) > 0 ) . orElse ( false ) ;
setId: public void setId ( Long id ) { this . id = id ;
getData: public BulletData getData ( LaunchData launchData , float damageCoefficient , String dimension ) { BulletData bulletData = bulletPool . obtain ( ) ; bulletData . setup ( launchData , damageCoefficient , dimension ) ; return bulletData ;
getRootBone: public Bone getRootBone ( ) { return bones . size == 0 ? null : bones . first ( ) ;
extractClass: public static Class < ? extends Packet > extractClass ( final JsonObject json ) { final String packetCls = json . get ( "packetCls" ) . getAsString ( ) ; try {
show: public void show ( ) { if ( mAlertDialog == null ) { mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme ) . setContentView ( R . layout . layout_popupwindow_create_channel_tip ) . setAnimation ( R . style . popup_anim_style ) . fullWidth ( ) . fullHeight ( ) . create ( ) ; } TextView tipTv = mAlertDialog . findViewById ( R . id . tv_tip ) ; tipTv . setText ( mContext . getString ( R . string . create_channel_tip ) ) ; mAlertDialog . findViewById ( R . id . layout_back ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_create ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; CreateChannelDialog mCreateChannelDialog = new CreateChannelDialog ( mContext ) ; mCreateChannelDialog . show ( User . getInstance ( ) . getBalanceAmount ( mContext ) , User . getInstance ( ) . getWalletAddress ( mContext ) , "" ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_cancel ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; } } ) ; if ( mAlertDialog . isShowing ( ) ) { mAlertDialog . dismiss ( ) ; } mAlertDialog . show ( ) ;
load: public void load ( ) { if ( data . getOwner ( ) == null ) return ; if ( ( source . hasMagazineManagement ( ) && source . getMagazinesCount ( ) > 0 ) ||
isWeChatAvailable: public static boolean isWeChatAvailable ( Context context ) { final PackageManager packageManager = context . getPackageManager ( ) ; List < PackageInfo > pInfo = packageManager . getInstalledPackages ( 0 ) ; if ( pInfo != null ) { for ( int i = 0 ; i < pInfo . size ( ) ; i ++ ) { String pn = pInfo . get ( i ) . packageName ; if ( pn . equals ( "com.tencent.mm" ) ) { return true ; } } } return false ;
info: default void info ( String format , Object ... arguments ) { format = appendRequestId ( format ) ; getLogger ( ) . info ( format , arguments ) ;
getConversationTimeOut: No method body
generateSpringCtxCode: public static String generateSpringCtxCode ( ) { if ( ! isSpring ( ) ) { return "" ; } return String . format ( "%s ctx = (%s) (%s).getSpringBootApplicationContext();\n" ,
getAttribute: public Attribute getAttribute ( Identifier productMasterIdentifier , String attributeGroupName ) throws ApiErrorException , ConnectionException { Class < Attribute > responseModel = ( Class < Attribute > ) ( Class < ? > ) Attribute . class ; return this . request ( "get" , this . resolvePath ( "/product-masters/%s/attributes/%s" , productMasterIdentifier , attributeGroupName ) , null , null , responseModel ) ;
calculateVolumeFlowRate: public static double calculateVolumeFlowRate ( double pressureIn , double pressureOut , double radius , double length , double dynamicViscosity ) { return Math . PI * Math . pow ( radius , 4 ) * ( pressureIn - pressureOut ) * 1000000 / ( 8 * dynamicViscosity * length ) ;
feed: public void feed ( IBarDataSet data ) { float size = data . getEntryCount ( ) * phaseX ; float barWidthHalf = mBarWidth / 2f ; for ( int i = 0 ; i < size ; i ++ ) { BarEntry e = data . getEntryForIndex ( i ) ; if ( e == null ) continue ; float x = e . getX ( ) ; float y = e . getY ( ) ; float [ ] vals = e . getYVals ( ) ; if ( ! mContainsStacks || vals == null ) { float bottom = x - barWidthHalf ; float top = x + barWidthHalf ; float left , right ; if ( mInverted ) { left = y >= 0 ? y : 0 ; right = y <= 0 ? y : 0 ; } else { right = y >= 0 ? y : 0 ; left = y <= 0 ? y : 0 ; } if ( right > 0 ) right *= phaseY ; else left *= phaseY ; addBar ( left , top , right , bottom ) ; } else { float posY = 0f ; float negY = - e . getNegativeSum ( ) ; float yStart = 0f ; for ( int k = 0 ; k < vals . length ; k ++ ) { float value = vals [ k ] ; if ( value >= 0f ) { y = posY ; yStart = posY + value ; posY = yStart ; } else { y = negY ; yStart = negY + Math . abs ( value ) ; negY += Math . abs ( value ) ; } float bottom = x - barWidthHalf ; float top = x + barWidthHalf ; float left , right ; if ( mInverted ) { left = y >= yStart ? y : yStart ; right = y <= yStart ? y : yStart ; } else { right = y >= yStart ? y : yStart ; left = y <= yStart ? y : yStart ; } right *= phaseY ; left *= phaseY ; addBar ( left , top , right , bottom ) ; } } } reset ( ) ;
bindLayoutResId: public int bindLayoutResId ( ) { return R . layout . layout_title ;
save: public static void save ( File file ) { boolean wasPaused = isPaused ( ) ; try {
getColorOf: public Color getColorOf ( RemoteClient remoteClient , boolean includeFriends , boolean allowSpecialColors ) { if ( remoteClient == null ) return ClientConstants . Menu . KillList . ENEMY_COLOR ; if ( allowSpecialColors && BrainOut . OnlineEnabled ( ) ) { if ( remoteClient . isBrainPass ( ) ) { return ClientConstants . Menu . KillList . BRAIN_PASS_COLOR ; } if ( remoteClient . getRights ( ) != null && remoteClient . getRights ( ) != PlayerRights . none ) { return ClientConstants . Menu . KillList . ADMIN_COLOR ; } if ( remoteClient . isSpecial ( ) ) { return ClientConstants . Menu . KillList . SPECIAL_COLOR ; } } if ( getTeam ( ) instanceof SpectatorTeam ) { return getColorOf ( remoteClient . getTeam ( ) ) ; } PlayState ps = getPlayState ( ) ; if ( ps instanceof PlayStateGame ) { PlayStateGame playStateGame = ( ( PlayStateGame ) ps ) ; if ( playStateGame . getMode ( ) . getRealization ( ) instanceof ClientGameRealization ) { ClientGameRealization r = ( ( ClientGameRealization ) ( playStateGame . getMode ( ) . getRealization ( ) ) ) ; Color c = r . getColorOf ( remoteClient ) ; if ( c != null ) return c ; } } if ( remoteClient . getId ( ) == getMyId ( ) ) { return ClientConstants . Menu . KillList . MY_COLOR ; } if ( allowSpecialColors && BrainOut . OnlineEnabled ( ) ) { if ( includeFriends && isMyFriend ( remoteClient ) ) { return ClientConstants . Menu . KillList . CLAN_COLOR ; } } return getColorOf ( remoteClient . getTeam ( ) ) ;
getSkinRequired: public boolean getSkinRequired ( ) { return skinRequired ;
getLocalizedTitle: public String getLocalizedTitle ( ) { return getId ( ) . getTitle ( ) . get ( ) ;
getAddress: public CustomerAddress getAddress ( String shopKey , String countryCode , Identifier customerIdentifier , Identifier addressIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomerAddress > responseModel = ( Class < CustomerAddress > ) ( Class < ? > ) CustomerAddress . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/addresses/%s" , shopKey , countryCode , customerIdentifier , addressIdentifier ) , query , null , responseModel ) ;
setSources: public void setSources ( Pump [ ] sources ) { this . sources = sources ;
getContext: public AnnotationConfigServletWebServerApplicationContext getContext ( ) { return context ;
newUser: public GameUser newUser ( ) { return new GameSteamUser ( ) ;
assertPositive: public static void assertPositive ( byte n , @ NotNull String message ) { if ( n <= 0 ) throw new AssertionError ( message ) ;
updateResource: void updateResource ( ) { Long roleId = 2L ; Set < Long > resourceIds = new HashSet < > ( ) ; resourceIds . add ( 1L ) ; resourceIds . add ( 2L ) ; roleService . updateResource ( roleId , resourceIds ) ; log . info ( "更新角色的资源方法测试成功！" ) ;
getTexture: public TextureAtlas . AtlasRegion getTexture ( ) { return texture ;
getAttributeIfSessionExists: public Object getAttributeIfSessionExists ( String id ) { HttpSession s = getSession ( false ) ; return s != null ? s . getAttribute ( id ) : null ;
canDropConsumable: public boolean canDropConsumable ( ConsumableRecord record ) { return false ;
logException: private void logException ( final String message , final Exception e ) { if ( ! novuConfig . isEnableLogging ( ) ) { return ; } log . error ( message , e ) ;
init: public Event init ( ComponentObject data , float health , float x , float y , float angle , Content content , String damageKind ) { this . data = data ; this . health = health ; this . x = x ; this . y = y ; this . angle = angle ; this . content = content ; this . damageKind = damageKind ; return this ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; spawnName . set ( jsonData . getString ( "sname" , getContent ( ) . getTitle ( ) . getID ( ) ) ) ; state = State . valueOf ( jsonData . getString ( "state" ) ) ; time = jsonData . getFloat ( "time" ) ; spawnRange = jsonData . getFloat ( "spawnRange" , 0 ) ; takeSpeed = jsonData . getFloat ( "speed" , 1.0f ) ; if ( jsonData . has ( "takingteam" ) )
getDistantSound: public Sound getDistantSound ( ) { return distantSound ;
getCode: public String getCode ( ) { return code ;
isEnabled: protected boolean isEnabled ( ) { PlayerData playerData = getPlayerData ( ) ; if ( playerData != null ) { PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { return poc . isEnabled ( ) ; } } return super . isEnabled ( ) ;
onClose: public void onClose ( int code , String message , boolean remote ) { if ( Log . INFO ) Log . info ( "Party session closed: " + code + " " + message ) ; Gdx . app . postRunnable ( ( ) ->
updateResource: void updateResource ( ) throws Exception { assertNotNull ( updateResourceByRoleParam , "updateResourceParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/role/update/resource" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( updateResourceByRoleParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "更改角色资源接口测试成功！" ) ;
sendTG: No method body
resolve: default < T > void resolve ( Serde < T > serde , @ NonNull T payload ) { this . resolve ( serde , payload , RequestOptions . DEFAULT ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case destroy : { destroy ( ( ( DestroyEvent ) event ) ) ; break ; } } return super . onEvent ( event ) ;
getLog: public String getLog ( ) { if ( log instanceof CharArrayWriter ) { CharArrayWriter caw = ( CharArrayWriter ) log ; return caw . toString ( ) ; } return "" ;
hasRender: public boolean hasRender ( ) { return false ;
setMiddleTabText: public Builder setMiddleTabText ( int index , CharSequence text ) { P . mTabTextArray . put ( index , text ) ; return this ;
setSuccess: public void setSuccess ( boolean success ) { this . success = success ;
all: public ApiCollection < ProductImage > all ( Identifier productIdentifier ) throws ApiErrorException , ConnectionException { Class < ProductImage > responseModel = ( Class < ProductImage > ) ( Class < ? > ) ProductImage . class ; return this . requestCollection ( "get" , this . resolvePath ( "/products/%s/images" , productIdentifier ) , null , null , responseModel ) ;
getFlipX: public boolean getFlipX ( ) { return false ;
run: public void run ( ) { mMenuPopWindow . dismiss ( ) ; mLoadingDialog . dismiss ( ) ; UnlockDialog mUnlockDialog = new UnlockDialog ( mContext ) ; mUnlockDialog . show ( ) ;
init: public void init ( PlayState . InitCallback callback ) { BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ; GameState topState = BrainOutClient . getInstance ( ) . topState ( ) ; final CSGame gameController = BrainOutClient . ClientController . getState ( CSGame . class ) ; topState . pushMenu ( new WaitProfileMenu ( ( ) -> { UserProfile userProfile = BrainOutClient . ClientController . getUserProfile ( ) ; if ( userProfile . isDeactivated ( ) ) { topState . pushMenu ( new AccountDeactivatedMenu ( ( ) -> topState . pushMenu ( new LobbyMenu ( gameController . getShopCart ( ) ) ) ) ) ; } else { topState . pushMenu ( new LobbyMenu ( gameController . getShopCart ( ) ) ) ; } topState . pushMenu ( new FadeOutMenu ( 1.0f , Color . BLACK ) ) ; } ) ) ; if ( callback != null )
setSMSTips: public void setSMSTips ( String smsTips ) { this . mSMSTips = smsTips ;
initContextMenu: public void initContextMenu ( RegisterButton callback ) { cutterEnabled = ( Button ) callback . registerButton ( "button-editor-cutter" , ( ) -> { } ) ; Tooltip . RegisterToolTip ( cutterEnabled , L . get ( "EDITOR_BLOCKS_CUTTER" ) , getMenu ( ) ) ; callback . registerSpace ( ) ; RegisterButton subMenuRoot = callback . registerSubMenu ( ) ; this . currentActiveButton = new TextButton ( "" , BrainOutClient . Skin , "button-editor-text" ) ; currentActiveButton . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { SelectContentMenu m = new SelectContentMenu ( currentActive , Active . class , new SelectContentMenu . ContentSelected ( ) { @ Override public void selected ( Content content ) { currentActive = ( ( Active ) content ) ; updateActiveButton ( ) ; } @ Override public void canceled ( ) { } @ Override public boolean filter ( Content content ) { return filterContent ( content ) ; } } ) ; getMenu ( ) . pushMenu ( m ) ; } } ) ; subMenuRoot . registerActor ( currentActiveButton ) ; updateActiveButton ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; canceled ( ) ;
isMatchNeighbor: private boolean isMatchNeighbor ( Map map , int currentX , int currentY , int layer , int x , int y ) { if ( getCreator ( ) . getContactTo ( ) == null ) { return false ; } BlockData neighbor = GetNeighbor ( map , currentX , currentY , layer , x , y ) ; if ( neighbor == null ) { return false ; } Block block = neighbor . getCreator ( ) ; return block . getContactId ( ) != null &&
getContent: public String getContent ( Scheduler entity ) { return null ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVStop1ActionPerformed ( evt ) ;
setScale: public void setScale ( float scaleX , float scaleY ) { this . scaleX = scaleX ; this . scaleY = scaleY ;
initComponents: private void initComponents ( ) { jFileChooser1 = new javax . swing . JFileChooser ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ; setResizable ( false ) ; addWindowListener ( new java . awt . event . WindowAdapter ( ) { public void windowClosed ( java . awt . event . WindowEvent evt ) { formWindowClosed ( evt ) ; } } ) ; jFileChooser1 . setDialogTitle ( "Load IC" ) ; jFileChooser1 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jFileChooser1ActionPerformed ( evt ) ; } } ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( jFileChooser1 , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( jFileChooser1 , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) ) ; pack ( ) ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < Warehouse > responseEntity = this . api . warehouses ( ) . all ( options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/WarehouseAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( Warehouse entity : responseEntity . getEntities ( ) ) {
restart: public Object restart ( ) { App . shutdown ( ) ; return null ;
copy: protected void copy ( CandleDataSet candleDataSet ) { super . copy ( candleDataSet ) ; candleDataSet . mShadowWidth = mShadowWidth ; candleDataSet . mShowCandleBar = mShowCandleBar ; candleDataSet . mBarSpace = mBarSpace ; candleDataSet . mShadowColorSameAsCandle = mShadowColorSameAsCandle ; candleDataSet . mHighLightColor = mHighLightColor ; candleDataSet . mIncreasingPaintStyle = mIncreasingPaintStyle ; candleDataSet . mDecreasingPaintStyle = mDecreasingPaintStyle ; candleDataSet . mNeutralColor = mNeutralColor ; candleDataSet . mIncreasingColor = mIncreasingColor ; candleDataSet . mDecreasingColor = mDecreasingColor ; candleDataSet . mShadowColor = mShadowColor ;
showInSummaryScreen: public boolean showInSummaryScreen ( ) { return true ;
onDetachedFromWindow: protected void onDetachedFromWindow ( ) { if ( mRenderer != null && mRenderer instanceof LineChartRenderer ) { ( ( LineChartRenderer ) mRenderer ) . releaseBitmap ( ) ; } super . onDetachedFromWindow ( ) ;
onSpawned: public void onSpawned ( PlayerData playerData ) { setState ( State . spawned ) ; setPlayerData ( playerData ) ;
updateMenu: public AjaxResult updateMenu ( @ RequestBody @ Valid UpdateMenuByRoleParam param ) { roleService . updateMenu ( param . getRoleId ( ) , param . getMenuIds ( ) ) ; return AjaxResult . success ( "更新成功！" ) ;
warmUpComplete: protected void warmUpComplete ( ) { super . warmUpComplete ( ) ; roundCompleted ( true ) ;
setTitleImage: public Builder setTitleImage ( int imageRes ) { P . mTitleImage = imageRes ; return this ;
copy: public Attachment copy ( ) { SkeletonAttachment copy = new SkeletonAttachment ( name ) ; copy . skeleton = skeleton ; copy . hookTo = hookTo ; return copy ;
globalOrgRole: protected PageModelMap globalOrgRole ( GlobalOrgRoleForm form , Long organizationId ) { return Flow . init ( )
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights ) { case admin : case mod : return true ; } return false ;
setup: public static void setup ( ) { try {
reset: public void reset ( ) { distance = Float . POSITIVE_INFINITY ; shortestPath . clear ( ) ;
remove: void remove ( ) { l . add ( "nicola" ) ; l . add ( "barbara" ) ; l . add ( "marzia" ) ; l . remove ( 2 ) ; l . remove ( "barbara" ) ; assertEquals ( "nicola" , l . get ( 0 ) ) ; assertEquals ( 1 , l . size ( ) ) ;
checkHeaderBinFileExist: public boolean checkHeaderBinFileExist ( ) { String filePath = downloadDictionaryPath + BLOCK_HEADER_FILE_NAME ; File file = new File ( filePath ) ; return file . exists ( ) ;
populateSuppliedValuesFrom: private void populateSuppliedValuesFrom ( ) { for ( FrontendMappingFieldDefinition f : frontendMappingDefinition . getFields ( ) ) {
divide: void divide ( ) { assertEquals ( 2.0 , Divide . divide ( 4 , 2 ) , DELTA ) ; assertEquals ( 2.0 , Divide . divide ( 4.0 , 2.0 ) , DELTA ) ; assertEquals ( 2.0 , Divide . divide ( 4 , 2.0 ) , DELTA ) ; assertEquals ( 2.0 , Divide . divide ( 4.0 , 2 ) , DELTA ) ; assertEquals ( Double . POSITIVE_INFINITY , Divide . divide ( 1.0 , 0.0 ) ) ;
inverted: private boolean inverted ( ) { return ( mClosestDataSetToTouch == null && mChart . isAnyAxisInverted ( ) ) || ( mClosestDataSetToTouch != null
start: public void start ( ) { if ( isRunning ) { return ; } isRunning = true ; Message message = Message . obtain ( ) ; message . obj = System . currentTimeMillis ( ) ; sendMessage ( message ) ;
getSteamDensity: public double getSteamDensity ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
create: public void create ( Shipment model ) throws ApiErrorException , ConnectionException { this . request ( "post" , this . resolvePath ( "/fulfillment/shipments" ) , null , null , null , model ) ;
isValid: private boolean isValid ( ) { if ( nameValue . getText ( ) . equals ( clan . getName ( ) ) && joinMethod . getSelected ( ) . method == clan . getJoinMethod ( ) ) { return false ; } int l = nameValue . getText ( ) . length ( ) ; return l >= 3 && l <= 32 ;
warn: default void warn ( String format , Object ... arguments ) { getLogger ( ) . warn ( format , arguments ) ; logToDebugStack ( null , format , arguments ) ;
setBottomLineVisibility: public Builder setBottomLineVisibility ( int visibility ) { P . mBottomLineVisibility = visibility ; return this ;
renderTabs: private void renderTabs ( Table data ) { {
placeItemIntoObject: public PlaceItemIntoObjectResult placeItemIntoObject ( String rsItemKey , ConsumableRecord record , int amount ) { MarketService . MarketItemEntry marketItem = MarketUtils . ConsumableRecordToMarketEntry ( record ) ; if ( marketItem == null ) { return null ; } marketItem . amount = amount ; RealEstatePayload copy = payload . copy ( ) ; RealEstatePayload . ObjectAtLocation obj = copy . items . get ( rsItemKey ) ; if ( obj == null ) { return null ; } RealEstateItem item = obj . item ; RealEstateItemContainerComponent containerComponent = item . getComponent ( RealEstateItemContainerComponent . class ) ; if ( containerComponent == null ) { return null ; } if ( containerComponent . getWeightLimit ( ) > 0 ) { ItemComponent itemComponent = record . getItem ( ) . getContent ( ) . getComponent ( ItemComponent . class ) ; if ( itemComponent != null ) { if ( obj . getTotalWeight ( ) + itemComponent . getWeight ( ) * amount > containerComponent . getWeightLimit ( ) ) { return null ; } } } if ( containerComponent . getItemLimit ( ) > 0 ) { if ( obj . getContainer ( ) . items . size >= containerComponent . getItemLimit ( ) ) { return null ; } } if ( containerComponent . getTagLimit ( ) != null ) { ItemComponent itemComponent = record . getItem ( ) . getContent ( ) . getComponent ( ItemComponent . class ) ; if ( itemComponent == null || itemComponent . getTags ( record . getItem ( ) . getContent ( ) ) == null ) { return null ; } if ( ! ( itemComponent . getTags ( record . getItem ( ) . getContent ( ) ) . contains ( containerComponent . getTagLimit ( ) , false ) ) ) { return null ; } } int nextId = 0 ; boolean stacked = false ; for ( ObjectMap . Entry < String , MarketService . MarketItemEntry > entry : obj . getContainer ( ) . items ) { ConsumableRecord itm = MarketUtils . MarketObjectToConsumableRecord ( entry . value . name , entry . value . payload , entry . value . amount ) ; if ( itm != null ) { if ( itm . getItem ( ) . stacks ( record . getItem ( ) ) ) { stacked = true ; entry . value . amount += amount ; break ; } } try { int i = Integer . parseInt ( entry . key ) ; if ( nextId < i ) { nextId = i ; } } catch ( NumberFormatException ignore ) { } } if ( ! stacked ) { nextId ++ ; obj . container . items . put ( String . valueOf ( nextId ) , marketItem ) ; } PlaceItemIntoObjectResult r = new PlaceItemIntoObjectResult ( ) ; r . oldPayload = payload ; r . newPayload = copy ; r . marketItem = marketItem ; return r ;
zoomToCenter: public void zoomToCenter ( float scaleX , float scaleY ) { MPPointF center = getCenterOffsets ( ) ; Matrix save = mZoomMatrixBuffer ; mViewPortHandler . zoom ( scaleX , scaleY , center . x , - center . y , save ) ; mViewPortHandler . refresh ( save , this , false ) ;
setMaxPlayers: public void setMaxPlayers ( int maxPlayers ) { this . maxPlayers = maxPlayers ;
checkVisibility: private boolean checkVisibility ( ActiveData target ) { Map map = getMap ( ) ; InstrumentData currentWeapon = getPlayerData ( ) . getCurrentInstrument ( ) ; if ( currentWeapon == null ) return false ; WeaponAnimationComponentData anim = currentWeapon . getComponent ( WeaponAnimationComponentData . class ) ; if ( anim == null ) return false ; SimplePhysicsComponentData phy = target . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy == null ) return false ; BonePointData launch = anim . getLaunchPointData ( ) ; float halfHeight = phy . getHalfSize ( ) . y ; tmp . set ( launch . getX ( ) , launch . getY ( ) ) ; tmp . sub ( target . getX ( ) , target . getY ( ) + halfHeight ) ; if ( ! map . trace ( target . getX ( ) , target . getY ( ) + halfHeight , Constants . Layers . BLOCK_LAYER_FOREGROUND , tmp . angleDeg ( ) , tmp . len ( ) , tmp ) ) { return true ; } tmp . set ( launch . getX ( ) , launch . getY ( ) ) ; tmp . sub ( target . getX ( ) , target . getY ( ) - halfHeight ) ; if ( ! map . trace ( target . getX ( ) , target . getY ( ) - halfHeight , Constants . Layers . BLOCK_LAYER_FOREGROUND , tmp . angleDeg ( ) , tmp . len ( ) , tmp ) ) { return true ; } return false ;
getRewardClients: public Array < Client > getRewardClients ( ) { return rewardClients ;
getWaterMass: No method body
init: public static void init ( final Fragment fragment ) { View settingsView = fragment . getView ( ) ; if ( settingsView != null ) {
serialize: public JsonElement serialize ( T src , Type typeOfSrc , JsonSerializationContext context ) { return context . serialize ( src ) ;
getY: public float getY ( ) { return y ;
isDataState: public boolean isDataState ( ) { return dataState ;
result: No method body
getWaterEnthalpyByTemperature: public double getWaterEnthalpyByTemperature ( double tempC ) { if ( tempC >= 1 && tempC < 373 ) { int lower = ( int ) tempC ; int higher = ( int ) tempC + 1 ; double lowerValue = waterEnthalpyByTempMap . get ( lower ) ; double higherValue = waterEnthalpyByTempMap . get ( higher ) ; double perDegree = higherValue - lowerValue ; return lowerValue + ( ( tempC - lower ) * perDegree ) ; } if ( ! error ) { error = ! error ; NPPSim . endSimulation ( ) ; StackTraceElement [ ] stack = Thread . currentThread ( ) . getStackTrace ( ) ; StringBuilder strBuilder = new StringBuilder ( ) ; for ( StackTraceElement stack1 : stack ) { strBuilder . append ( stack1 . toString ( ) ) ; strBuilder . append ( "\n" ) ; } new ErrorWindow ( "A component has been damaged beyond repair" , strBuilder . toString ( ) , true ) . setVisible ( true ) ; } return 0 ;
openMap: private void openMap ( GameUser . WorkshopItem item ) { WaitLoadingMenu waitLoadingMenu = new WaitLoadingMenu ( "" ) ; pushMenu ( waitLoadingMenu ) ; JSONObject args = new JSONObject ( ) ; args . put ( "workshop_id" , item . getID ( ) ) ; args . put ( "time_updated" , item . getTimeUpdated ( ) ) ; BrainOutClient . SocialController . sendRequest ( "editor2_open_map" , args ,
getUploadId: public Long getUploadId ( ) { return uploadId ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; if ( jsonData . has ( "content" ) )
getUserId: public Long getUserId ( ) { return userId ;
getBlueprintsByCategory: No method body
obtain: public static Event obtain ( String message , float time , boolean doNotForce , int align , String style , String name , boolean isTimer ) { OnScreenMessagesEvent e = obtain ( OnScreenMessagesEvent . class ) ; if ( e == null ) return null ; return e . init ( message , time , doNotForce , align , style , name , isTimer ) ;
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { IkConstraint constraint = skeleton . ikConstraints . get ( ikConstraintIndex ) ; if ( ! constraint . active ) return ; float [ ] frames = this . frames ; if ( time < frames [ 0 ] ) { switch ( blend ) { case setup : constraint . mix = constraint . data . mix ; constraint . softness = constraint . data . softness ; constraint . bendDirection = constraint . data . bendDirection ; constraint . compress = constraint . data . compress ; constraint . stretch = constraint . data . stretch ; return ; case first : constraint . mix += ( constraint . data . mix - constraint . mix ) * alpha ; constraint . softness += ( constraint . data . softness - constraint . softness ) * alpha ; constraint . bendDirection = constraint . data . bendDirection ; constraint . compress = constraint . data . compress ; constraint . stretch = constraint . data . stretch ; } return ; } float mix , softness ; int i = search ( frames , time , ENTRIES ) , curveType = ( int ) curves [ i / ENTRIES ] ; switch ( curveType ) { case LINEAR : float before = frames [ i ] ; mix = frames [ i + MIX ] ; softness = frames [ i + SOFTNESS ] ; float t = ( time - before ) / ( frames [ i + ENTRIES ] - before ) ; mix += ( frames [ i + ENTRIES + MIX ] - mix ) * t ; softness += ( frames [ i + ENTRIES + SOFTNESS ] - softness ) * t ; break ; case STEPPED : mix = frames [ i + MIX ] ; softness = frames [ i + SOFTNESS ] ; break ; default : mix = getBezierValue ( time , i , MIX , curveType - BEZIER ) ; softness = getBezierValue ( time , i , SOFTNESS , curveType + BEZIER_SIZE - BEZIER ) ; } if ( blend == setup ) {
setAnimationState: public void setAnimationState ( AnimationState state ) { this . state = state ;
stayOnTop: public boolean stayOnTop ( ) { return onTop ;
getA: public float getA ( ) { return a ;
setUp: protected void setUp ( ) { mockWebServer = new MockWebServer ( ) ; NovuConfig novuConfig = new NovuConfig ( "1234" ) ; novuConfig . setBaseUrl ( mockWebServer . url ( "" ) . toString ( ) ) ; RestHandler restHandler = new RestHandler ( novuConfig ) ; workflowGroupHandler = new WorkflowGroupHandler ( restHandler ) ;
init: private Event init ( Action action , boolean flag ) { this . action = action ; this . flag = flag ; return this ;
getPrimarySlot: public Slot getPrimarySlot ( ) { return primarySlot ;
getItemCount: public int getItemCount ( ) { return mAdapter . getItemCount ( ) + mHeaderViews . size ( ) + mFooterViews . size ( ) ;
equals: public boolean equals ( Object other ) { if ( other instanceof ReplaceClassTransformer ) { return this . uuid . equals ( ( ( ReplaceClassTransformer ) other ) . getUuid ( ) ) ; } return false ;
filters: public boolean filters ( int owner ) { return filter . filter ( owner ) ;
setAutoLoadEnable: public void setAutoLoadEnable ( boolean enable ) { this . mAutoLoad = enable ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
getJsonResponse: No method body
isEmulator: public static boolean isEmulator ( Context context ) { boolean result = checkPipes ( ) || checkQEmuDriverFile ( ) || CheckEmulatorFiles ( ) || CheckPhoneNumber ( context ) || CheckDeviceIDS ( context ) || CheckImeiIds ( context ) || CheckEmulatorBuild ( context ) || CheckOperatorNameAndroid ( context ) || test ( ) ; LogUtils . e ( TAG , "检测结果：" + result ) ; return result ;
onErrorReturn: public final Promise < T > onErrorReturn ( @ NotNull T value ) { final Promise < T > promise = new Promise < > ( ) ; subscribe ( promise :: resolve , unused -> promise . resolve ( value ) ) ; return promise ;
getControls: public KeyProperties getControls ( ) { return controls ;
get: public Customer get ( String shopKey , String countryCode , Identifier customerIdentifier ) throws ApiErrorException , ConnectionException { Class < Customer > responseModel = ( Class < Customer > ) ( Class < ? > ) Customer . class ; return this . request ( "get" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s" , shopKey , countryCode , customerIdentifier ) , null , null , responseModel ) ;
destroy: private void destroy ( ) { ActiveData . LastHitInfo lastHit = activeData . getLastHitInfo ( ) ; if ( lastHit == null ) return ; Client killer = BrainOutServer . Controller . getClients ( ) . get ( lastHit . hitterId ) ; if ( killer == null ) return ; GameMode mode = BrainOutServer . Controller . getGameMode ( ) ; if ( mode == null ) return ; switch ( mode . getID ( ) ) { case editor : case editor2 : case free : case lobby : { return ; } } killer . addStat ( getContentComponent ( ) . getStat ( ) , 1 ) ;
saveUsdtPriceToLocal: public static void saveUsdtPriceToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_USDT_PRICE , value ) ;
disconnect: public void disconnect ( DisconnectReason reason ) { if ( isConnected ( ) )
onEvent: public boolean onEvent ( Event event ) { return false ;
getTitle: protected String getTitle ( ) { String level = String . valueOf ( getUpgradesLevel ( key , upgrades , info ) + 1 ) ; return upgrade . getTitle ( ) . get ( ) + " (" + L . get ( "MENU_LEVEL_N" , level ) + ")" ;
charIsNum: private static boolean charIsNum ( char c ) { return '0' <= c && '9' >= c ;
findOne: No method body
hasNoDragOffset: public boolean hasNoDragOffset ( ) { return mViewPortHandler . hasNoDragOffset ( ) ;
obtain: public static Event obtain ( Array < ClientEvent > events ) { OnlineEventsUpdatedEvent e = obtain ( OnlineEventsUpdatedEvent . class ) ; if ( e == null ) return null ; return e . init ( events ) ;
generateVotesMaps: public void generateVotesMaps ( int count ) { MapSource mapSource = BrainOutServer . Controller . getMapSource ( ) ; if ( ! ( mapSource instanceof MapSetSource ) ) return ; MapSetSource mapSetSource = ( MapSetSource ) mapSource ; Array < MapSetSource . QueuedItem > maps = mapSetSource . getRandomMaps ( count ) ; votesMaps = new Array < > ( ) ; for ( MapSetSource . QueuedItem map : maps )
run: public void run ( ) { BrainOutServer . PostRunnable ( ( ) -> selectFirstInstrument ( poc ) ) ;
onResponse: public void onResponse ( byte [ ] bytes ) { try {
updateOrCreateProperty: public ShopCategoryProperty updateOrCreateProperty ( String shopKey , String countryCode , Integer shopCategoryId , ShopCategoryProperty model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCategoryProperty > responseModel = ( Class < ShopCategoryProperty > ) ( Class < ? > ) ShopCategoryProperty . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/categories/%s/properties" , shopKey , countryCode , shopCategoryId ) , query , null , responseModel , model ) ;
onDetachedFromWindow: protected void onDetachedFromWindow ( ) { if ( mRenderer != null && mRenderer instanceof PieChartRenderer ) { ( ( PieChartRenderer ) mRenderer ) . releaseBitmap ( ) ; } super . onDetachedFromWindow ( ) ;
launchBottomContact: private void launchBottomContact ( ) { if ( playerData == null ) return ; SimplePhysicsComponentData . ContactData contact = playerData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) . getContact ( SimplePhysicsComponentData . Contact . bottom ) ; if ( contact . valid ( ) )
clipTriangles: public void clipTriangles ( float [ ] vertices , int verticesLength , short [ ] triangles , int trianglesLength , float [ ] uvs , float light , float dark , boolean twoColor ) { FloatArray clipOutput = this . clipOutput , clippedVertices = this . clippedVertices ; ShortArray clippedTriangles = this . clippedTriangles ; Object [ ] polygons = clippingPolygons . items ; int polygonsCount = clippingPolygons . size ; int vertexSize = twoColor ? 6 : 5 ; short index = 0 ; clippedVertices . clear ( ) ; clippedTriangles . clear ( ) ; outer :
isDetached: public boolean isDetached ( ) { return amount == - 1 ;
onClick: public void onClick ( View v ) { mAlertDialog . dismiss ( ) ;
keyDown: public boolean keyDown ( int keyCode ) { switch ( keyCode ) { case Input . Keys . TAB : { if ( escape ( ) ) { return true ; } } } return super . keyDown ( keyCode ) ;
watchTest: public void watchTest ( ) { WatchMessage watchMessage = new WatchMessage ( ) ; watchMessage . setSignature ( "w.core.WatchTarget#voidMethodWithNoParams" ) ; Assertions . assertTrue ( swapper . swap ( watchMessage ) ) ; target . voidMethodWithNoParams ( ) ;
getFlow: public double getFlow ( ) { return flow ;
getUniqueId: public String getUniqueId ( ) { return "steam" ;
checkClientTrusted: public void checkClientTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { LogUtils . e ( TAG , "========X509TrustManager====checkClientTrusted()============>" ) ;
anonymizeAddressByIdentifier: public void anonymizeAddressByIdentifier ( String shopKey , String countryCode , Identifier addressIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/customers/addresses/%s/anonymize" , shopKey , countryCode , addressIdentifier ) , null , null , null ) ;
getComponent: public ClientFreeplayExitDoorComponentData getComponent ( ComponentObject componentObject ) { return new ClientFreeplayExitDoorComponentData ( ( FreeplayExitDoorData ) componentObject , this ) ;
showWithButtonDelay: public void showWithButtonDelay ( long time , TimeUnit unit ) { ThreadUtils . runOnUiThread ( ( ) -> {
getAngle: public float getAngle ( ) { return activeData . getAngle ( ) ;
cancel: public static void cancel ( @ NotNull String notificationId ) { cancel ( notificationId . hashCode ( ) ) ;
getMaxSizePercent: public float getMaxSizePercent ( ) { return mMaxSizePercent ;
onFocusOut: public void onFocusOut ( Menu toMenu ) { super . onFocusOut ( toMenu ) ; BrainOutClient . Env . getGameController ( ) . setControllerMode ( GameController . ControllerMode . disabled ) ; enablePlayerAimMarker ( true ) ; if ( ClientConstants . Client . MOUSE_LOCK )
setPasswordHash: public void setPasswordHash ( String shopKey , String countryCode , Identifier customerIdentifier , CustomerPasswordHash model ) throws ApiErrorException , ConnectionException { this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/password-hash" , shopKey , countryCode , customerIdentifier ) , null , null , null , model ) ;
getOrganizationIdsWithPrivilege: public Set < Long > getOrganizationIdsWithPrivilege ( String privilegeName ) { debug ( "[getOrganizationIdsWithPrivilege] {}" , privilegeName ) ; Set < Long > result = organizationPrivileges . entrySet ( ) . stream ( ) . filter ( a -> a . getValue ( ) . contains ( privilegeName ) ) . map ( a -> a . getKey ( ) ) . collect ( Collectors . toSet ( ) ) ; return result . isEmpty ( ) ? nonExistingOrganizationIds : result ;
getSteamIdCredential: public static String getSteamIdCredential ( SteamID id ) { return String . valueOf ( SteamID . getNativeHandle ( id ) ) ;
all: static DeferredInternal < Void > all ( List < DeferredInternal < ? > > all ) { return new AllDeferred ( all ) ;
makeQuery: public Observable < ModelSearchResponse > makeQuery ( StoreSearch . SearchTarget target , Long id , SearchQuery searchQuery ) { return null ;
owned: public void owned ( PlayerClient client , OwnableContent content ) { client . getProfile ( ) . addStat ( Constants . User . SKILLPOINTS , getAmount ( ) , true ) ; client . notify ( NotifyAward . skillpoints , getAmount ( ) , NotifyReason . skillPointsEarned ,
reset: public void reset ( ) { sender = null ; block = null ; damage = 0 ;
changed: public void changed ( ChangeEvent event , Actor actor ) { setItem ( selectBox . getSelected ( ) ) ;
touchUp: public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { if ( menus . empty ( ) ) return false ; for ( int i = menus . size ( ) - 1 ; i >= 0 ; i -- ) { Menu menu = menus . get ( i ) ; if ( menu . touchUp ( screenX , screenY , pointer , button ) ) return true ; if ( menu . lockInput ( ) ) return true ; } return false ;
filterLayouts: No method body
lookupInvoiceV2: public Single < lnrpc . LightningOuterClass . Invoice > lookupInvoiceV2 ( invoicesrpc . InvoicesOuterClass . LookupInvoiceMsg request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . lookupInvoiceV2 ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
onCaseResult: private void onCaseResult ( CaseOpenResultMsg . Result result , CaseData caseData ) { switch ( result )
setResourceType: public void setResourceType ( String resourceType ) { this . resourceType = resourceType ;
renderShape: public void renderShape ( Canvas c , IScatterDataSet dataSet , ViewPortHandler viewPortHandler , float posX , float posY , Paint renderPaint ) { final float shapeHalf = dataSet . getScatterShapeSize ( ) / 2f ; renderPaint . setStyle ( Paint . Style . STROKE ) ; renderPaint . setStrokeWidth ( Utils . convertDpToPixel ( 1f ) ) ; c . drawLine ( posX , posY - ( 2 * shapeHalf ) , posX + ( 2 * shapeHalf ) , posY , renderPaint ) ; c . drawLine (
getIconId: public String getIconId ( ) { return icon ;
getRMBStr: private static String getRMBStr ( Context context ) { return context . getResources ( ) . getString ( R . string . base_rmb ) ;
run: public void run ( ) { int i = 0 ; while ( ! isInterrupted ( ) ) {
getState: public String getState ( ) { return state ;
setSecond: public void setSecond ( T second ) { this . second = second ;
renderShape: public void renderShape ( Canvas c , IScatterDataSet dataSet , ViewPortHandler viewPortHandler , float posX , float posY , Paint renderPaint ) { final float shapeSize = dataSet . getScatterShapeSize ( ) ; final float shapeHalf = shapeSize / 2f ; final float shapeHoleSizeHalf = Utils . convertDpToPixel ( dataSet . getScatterShapeHoleRadius ( ) ) ; final float shapeHoleSize = shapeHoleSizeHalf * 2.f ; final float shapeStrokeSize = ( shapeSize - shapeHoleSize ) / 2.f ; final float shapeStrokeSizeHalf = shapeStrokeSize / 2.f ; final int shapeHoleColor = dataSet . getScatterShapeHoleColor ( ) ; if ( shapeSize > 0.0 ) {
validate: private boolean validate ( ) { String name = mapName . getText ( ) ; if ( ! Constants . Editor . NAME_PATTERN . matcher ( name ) . matches ( ) ) return false ; if ( mapDescription . getText ( ) . length ( ) > 300 ) return false ; return true ;
findOne: No method body
setContentLength: public void setContentLength ( long contentLength ) { this . contentLength = contentLength ;
getAngle: public float getAngle ( ) { return FlippedAngle . getAngle ( launchData . getAngle ( ) , launchData . getFlipX ( ) ) ;
detect: private void detect ( ) { if ( detected ) return ; detected = true ; BrainOutServer . EventMgr . sendDelayedEvent ( activeData ,
isHighlightEnabled: No method body
get: protected TestInvocationBuilder get ( ) { return testDefinitionForVirtualObject (
hasUpdate: public boolean hasUpdate ( ) { return true ;
getRegion: public TextureRegion getRegion ( ) { if ( region == null ) throw new IllegalStateException ( "Region has not been set: " + this ) ; return region ;
getPlayersCount: public int getPlayersCount ( ) { int result = 0 ; for ( Entry < Integer , Client > entry : this ) { if ( entry . value instanceof PlayerClient ) { result ++ ; } } return result ;
getGuildChannelInternal$app_productionGoogleRelease: public final Channel getGuildChannelInternal$app_productionGoogleRelease ( long guildId , long parentGuildId ) { return null ; }
callAsync: No method body
getComponent: public ServerHealthComponentData getComponent ( ComponentObject componentObject ) { return new ServerHealthComponentData ( componentObject , this ) ;
getHighlightCircleStrokeColor: No method body
test_deleteSubscriberCredentialsFailure: public void test_deleteSubscriberCredentialsFailure ( ) throws IOException , InterruptedException , NovuNetworkException { mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 400 ) . setBody ( "{}" ) ) ; assertThrows ( NovuNetworkException . class , ( ) -> subscribersHandler . deleteSubscriberCredentials ( "sId" , "pId" ) ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/subscribers/sId/credentials/pId" , request . getPath ( ) ) ; assertEquals ( "DELETE" , request . getMethod ( ) ) ;
autoRefresh: public void autoRefresh ( ) { autoRefresh ( 200 ) ;
buttonNo: public String buttonNo ( ) { return L . get ( "MENU_CLOSE" ) ;
generatePreview: private void generatePreview ( ) throws IOException { byte [ ] data = Files . readAllBytes ( previewFile . toPath ( ) ) ; previewTexture = new Texture ( new Pixmap ( data , 0 , data . length ) , true ) ; previewTexture . setFilter ( Texture . TextureFilter . MipMapLinearLinear , Texture . TextureFilter . MipMapLinearLinear ) ; hasPreview = true ;
init: public static void init ( Kryo registerTo ) { initClasses ( registerTo , new Class [ ]
fitScreen: public void fitScreen ( Matrix outputMatrix ) { mMinScaleX = 1f ; mMinScaleY = 1f ; outputMatrix . set ( mMatrixTouch ) ; float [ ] vals = valsBufferForFitScreen ; for ( int i = 0 ; i < 9 ; i ++ ) { vals [ i ] = 0 ; } outputMatrix . getValues ( vals ) ; vals [ Matrix . MTRANS_X ] = 0f ; vals [ Matrix . MTRANS_Y ] = 0f ; vals [ Matrix . MSCALE_X ] = 1f ; vals [ Matrix . MSCALE_Y ] = 1f ; outputMatrix . setValues ( vals ) ;
onProxyInitialization: public void onProxyInitialization ( final ProxyInitializeEvent event ) { logger . info ( "Starting server..." ) ; this . proxyServer = new ProxyServerWrapper ( dataDirectory . toString ( ) ) ; proxyServer . start ( ) ; logger . info ( "Successfully initialized server bootstrap." ) ;
getFloat: protected static float getFloat ( String name , Context context , String key , float defaultValue ) { SharedPreferences settings = context . getSharedPreferences ( name , Context . MODE_PRIVATE ) ; return settings . getFloat ( key , defaultValue ) ;
createSubscriber: No method body
search: No method body
clearToOriginalArrachments: private void clearToOriginalArrachments ( ) { if ( dynamic )
getSteamPressureByDensity: public double getSteamPressureByDensity ( double density ) { if ( density >= 0.0032 && density < 77.875 ) { int lower = ( int ) ( density * 10000.0 ) ; int higher = ( int ) ( density * 10000.0 + 1 ) ; double lowerValue = steamPressureByDensityMap . get ( lower ) ; double higherValue = steamPressureByDensityMap . get ( higher ) ; double perDensity = higherValue - lowerValue ; return lowerValue + ( ( density * 10000.0 - lower ) * perDensity ) ; } if ( ! error ) { error = ! error ; NPPSim . endSimulation ( ) ; StackTraceElement [ ] stack = Thread . currentThread ( ) . getStackTrace ( ) ; StringBuilder strBuilder = new StringBuilder ( ) ; for ( StackTraceElement stack1 : stack ) { strBuilder . append ( stack1 . toString ( ) ) ; strBuilder . append ( "\n" ) ; } new ErrorWindow ( "A component has been damaged beyond repair" , strBuilder . toString ( ) , true ) . setVisible ( true ) ; } return 0 ;
getGridClippingRect: public RectF getGridClippingRect ( ) { mGridClippingRect . set ( mViewPortHandler . getContentRect ( ) ) ; mGridClippingRect . inset ( 0.f , - mAxis . getGridLineWidth ( ) ) ; return mGridClippingRect ;
fileExists: private boolean fileExists ( String stringPath ) { return Files . exists ( Paths . get ( stringPath ) ) ;
getBarBorderWidth: No method body
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "parts" , parts ) ;
moan: private void moan ( ) { effect ( zombieComponent . getMoanEffect ( ) ) ;
sendPlayerData: protected void sendPlayerData ( boolean spectatorsOnly , int priority ) { PlayerData playerData = getPlayerData ( ) ; PlayerComponentData pcd = playerData . getComponent ( ClientPlayerComponent . class ) ; BrainOutClient . ClientController . sendUDP ( new PlayerMoveMsg (
getRounds: No method body
removeDraft: public Object removeDraft ( @ PathVariable ( name = ID ) Long objectId , @ PathVariable ( name = ORGANIZATIONID , required = false ) Long organizationId ) { CRUDControllerConfiguration conf = controllers . htmlCrudControllerConfigurationMap . get ( FRONTENDRESOURCE ) ; PrivilegeBase privilege = conf . getPostRemovePrivilege ( ) ; if ( not ( hasGlobalOrOrgPrivilege ( privilege , organizationId ) ) ) { return ResponseEntity . status ( HttpStatus . UNAUTHORIZED ) . build ( ) ; } return Flow . init ( componentProvider , objectId )
onReceive: public void onReceive ( Context context , Intent intent ) { ConnectivityManager connectivityManager = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo networkInfo = connectivityManager . getActiveNetworkInfo ( ) ; if ( networkInfo == null ) { callBackNetWork . callBack ( - 1 ) ; Log . e ( TAG , "当前无网络连接" ) ; return ; } callBackNetWork . callBack ( networkInfo . getType ( ) ) ;
getViewWidth: public static int getViewWidth ( View view ) { if ( view == null ) { return 0 ; } view . measure ( View . MeasureSpec . makeMeasureSpec ( 0 , View . MeasureSpec . UNSPECIFIED ) , View . MeasureSpec . makeMeasureSpec ( 0 , View . MeasureSpec . UNSPECIFIED ) ) ; return view . getMeasuredWidth ( ) ;
onCloseUselessActivityEvent: public void onCloseUselessActivityEvent ( CloseUselessActivityEvent event ) { finish ( ) ;
setTableColumns: public void setTableColumns ( String tableColumns ) { this . tableColumns = tableColumns ;
wrap: static < T , U > BiConsumer < T , U > wrap ( ThrowingBiConsumer < T , U > fn ) { return fn . asBiConsumer ( ) ;
setAccessToken: public void setAccessToken ( String accessToken ) { this . accessToken = accessToken ;
onClick: public void onClick ( View v ) { if ( null != mCallback ) { mCallback . onItemClick ( v , item ) ; } mBasePopWindow . dismiss ( ) ;
getColorOf: public Color getColorOf ( Team team ) { if ( getTeam ( ) instanceof SpectatorTeam && team != null ) { return team . getColor ( ) ; } return isEnemies ( team , getTeam ( ) ) ?
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case launchEffect : { LaunchEffectEvent launchEffectEvent = ( LaunchEffectEvent ) event ; EffectSetGroup effects = getContentComponent ( ) . getEffects ( ) ; switch ( launchEffectEvent . kind ) { case hit : { effects . launchEffects ( "hit" , launchEffectEvent . launchData ) ; break ; } case bleeding : { effects . launchEffects ( "bleeding" , launchEffectEvent . launchData ) ; break ; } case custom : { effects . launchEffects ( launchEffectEvent . custom , launchEffectEvent . launchData ) ; break ; } } break ; } } return false ;
resetVelocity: private void resetVelocity ( ) { _velocitySamples . clear ( ) ;
isGoodQuality: public boolean isGoodQuality ( ) { return quality >= 80 ;
search: No method body
additionalPrivileges: public FormFieldDefinitionBuilder < V > additionalPrivileges ( PrivilegeBase readPrivilege , PrivilegeBase writePrivilege ) { fields . set ( fields . size ( ) - 1 , lastField = createFormFieldDefinition ( formName , lastField , readPrivilege , writePrivilege ) ) ; return this ;
load: private boolean load ( boolean full , boolean loadTime ) { PlayerOwnerComponent poc = weaponData . getOwner ( ) . getComponent ( PlayerOwnerComponent . class ) ; return poc != null && load ( poc , full , loadTime ) ;
getRPM: public float getRPM ( ) { return rpm ;
setItemType: public void setItemType ( int itemType ) { this . itemType = itemType ;
getReverse: public boolean getReverse ( ) { return reverse ;
getReward: public ClientReward getReward ( ) { return ( ( ClientReward ) reward ) ;
renderMarketItems: private void renderMarketItems ( Array < MarketService . MarketItemEntry > items ) { if ( items . size == 0 ) { Label noItems = new Label ( L . get ( "MENU_REAL_ESTATE_NO_ITEMS" ) , BrainOutClient . Skin , "title-gray" ) ; noItems . setWrap ( true ) ; noItems . setAlignment ( Align . center | Align . top ) ; objectsTable . add ( noItems ) . expand ( ) . fill ( ) ; return ; } for ( MarketService . MarketItemEntry entry : items )
isAwardPartner: public boolean isAwardPartner ( ) { return awardPartner ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
addFooterView: public void addFooterView ( View view ) { int position = mFooterViews . indexOfValue ( view ) ; if ( position < 0 ) { mFooterViews . put ( BASE_ITEM_TYPE_FOOTER ++ , view ) ; } notifyDataSetChanged ( ) ;
isEnemiesActive: public boolean isEnemiesActive ( ActiveData a , ActiveData b ) { return true ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
setFormLineDashEffect: public void setFormLineDashEffect ( DashPathEffect dashPathEffect ) { mFormLineDashEffect = dashPathEffect ;
status: public Single < autopilotrpc . AutopilotOuterClass . StatusResponse > status ( autopilotrpc . AutopilotOuterClass . StatusRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . status ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
compileMethod: public static byte [ ] compileMethod ( String className , String methodContent ) throws CompileException { String packageName = className . substring ( 0 , className . lastIndexOf ( "." ) ) ; String simpleClassName = className . substring ( className . lastIndexOf ( "." ) + 1 ) ; return compileWholeClass ( "package " + packageName + ";\n import java.util.*;\n public class " + simpleClassName + " {" + methodContent + "}" ) ;
getColliders: public ObjectMap < String , Collider > getColliders ( ) { return colliders ;
rejectAwakeable: No method body
accepted: private void accepted ( ) { switchTo ( new CSOnlineInit ( ) ) ;
lockInput: public boolean lockInput ( ) { return true ;
givenClass_whenGetsFieldsByName_thenCorrect: public void givenClass_whenGetsFieldsByName_thenCorrect ( ) throws Exception { final Class < ? > birdClass = Class . forName ( "com.nbicocchi.tutorials.reflection.Bird" ) ; final Field field = birdClass . getDeclaredField ( "walks" ) ; assertEquals ( "walks" , field . getName ( ) ) ;
getNumberOfStaticParams: public int getNumberOfStaticParams ( ) { return numberOfStaticParams ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionIncrement1ActionPerformed ( evt ) ;
getId: public long getId ( ) { return 0 ;
genYesLabel: public Span genYesLabel ( ) { Span txt = genLabel ( ) ; txt . setText ( "Yes" ) ; txt . getStyle ( ) . set ( "background-color" , "var(--lumo-success-color)" ) ; return txt ;
findOrganizationByName: public Organization findOrganizationByName ( String name ) { return repositories . unsecure . organization . findByName ( name ) ;
getTableName: public String getTableName ( ) { return tableName ;
validate: public boolean validate ( ) { if ( zip == null ) return false ; if ( BrainOutClient . getInstance ( ) . unsafe ) return true ; ZipEntry hashesEntry = zip . getEntry ( "__H" ) ; ZipEntry signatureEntry = zip . getEntry ( "__S" ) ; if ( hashesEntry == null || signatureEntry == null ) return false ; InputStream hashesStream ; InputStream signatureStream ; try { hashesStream = zip . getInputStream ( hashesEntry ) ; signatureStream = zip . getInputStream ( signatureEntry ) ; } catch ( Exception e ) { return false ; } KeyFactory kf ; try { kf = KeyFactory . getInstance ( "RSA" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; return false ; } PublicKey publicKey ; try { publicKey = kf . generatePublic ( new X509EncodedKeySpec ( Base64 . decode ( ClientConstants . Security . PUBLIC_KEY . getBytes ( ) ) ) ) ; } catch ( InvalidKeySpecException e ) { e . printStackTrace ( ) ; return false ; } String hashes = StringFunctions . StringFromInputStream ( hashesStream ) ; String b64Signature = StringFunctions . StringFromInputStream ( signatureStream ) ; Signature signature ; try { signature = Signature . getInstance ( "SHA256withRSA" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; return false ; } try { signature . initVerify ( publicKey ) ; } catch ( InvalidKeyException e ) { e . printStackTrace ( ) ; return false ; } try { signature . update ( hashes . getBytes ( ) ) ; } catch ( SignatureException e ) { e . printStackTrace ( ) ; return false ; } boolean result ; byte [ ] b64sign = Base64 . decode ( b64Signature . getBytes ( ) ) ; if ( b64sign == null ) return false ; try { result = signature . verify ( b64sign ) ; } catch ( SignatureException e ) { e . printStackTrace ( ) ; return false ; } if ( ! result ) return false ; JsonReader jsonReader = new JsonReader ( ) ; JsonValue hashesValue ; try { hashesValue = jsonReader . parse ( hashes ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } if ( ! hashesValue . isObject ( ) ) return false ; for ( JsonValue file : hashesValue ) { String fileName = file . name ( ) ; long fileHash = file . asLong ( ) ; ZipEntry entry = zip . getEntry ( fileName ) ; if ( entry == null ) return false ; if ( entry . getCrc ( ) != fileHash ) return false ; } return super . validate ( ) ;
getNeighborCoordinates: private short [ ] getNeighborCoordinates ( short x , short y , short c ) { short neighborX = x ; short neighborY = y ; switch ( c ) { case 0 : neighborX -- ; neighborY -- ; break ; case 1 : neighborX -- ; break ; case 2 : neighborX -- ; neighborY ++ ; break ; case 3 : neighborY -- ; break ; case 4 : neighborY ++ ; break ; case 5 : neighborX ++ ; neighborY -- ; break ; case 6 : neighborX ++ ; break ; case 7 : neighborX ++ ; neighborY ++ ; break ; } return new short [ ] { neighborX , neighborY } ;
getEnvironments: public BulkEnvironmentResponse getEnvironments ( ) throws IOException , NovuNetworkException { try {
get: public V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { return wrapped . get ( timeout , unit ) ;
isLoop: public boolean isLoop ( ) { return loop ;
setVolume: public void setVolume ( float volume ) { this . volume = volume ;
update: public void update ( ) { sdv_c . forEach ( valve -> { valve . setLocked ( valve . drain . getPressure ( ) > 0.023 || valve . drain . getSteamTemperature ( ) > 100.0 ) ; } ) ; if ( sdv_cControl . get ( 0 ) . isEnabled ( ) ) { Runnable controller = mcc . drum1 . getPressure ( ) > mcc . drum2 . getPressure ( ) ? sdv_cControl . get ( 0 ) :: update : sdv_cControl . get ( 1 ) :: update ; controller . run ( ) ; } if ( tgValveControl . get ( 0 ) . isEnabled ( ) ) { Runnable controller = mcc . drum1 . getPressure ( ) > mcc . drum2 . getPressure ( ) ? tgValveControl . get ( 0 ) :: update : tgValveControl . get ( 1 ) :: update ; controller . run ( ) ; } if ( tgValveControl . get ( 2 ) . isEnabled ( ) ) { Runnable controller = mcc . drum1 . getPressure ( ) > mcc . drum2 . getPressure ( ) ? tgValveControl . get ( 2 ) :: update : tgValveControl . get ( 3 ) :: update ; controller . run ( ) ; } condenserWaterLevelControl . forEach ( controller -> { if ( controller . isEnabled ( ) ) { controller . update ( ) ; } } ) ; for ( short i = 0 ; i < 4 ; i ++ ) { if ( dearatorWaterAndMakeupControl . get ( i ) . isEnabled ( ) ) { dearatorWaterAndMakeupControl . get ( i ) . update ( ) ; } else if ( dearatorWaterControl . get ( i ) . isEnabled ( ) ) { dearatorWaterControl . get ( i ) . update ( ) ; } else if ( dearatorMakeupControl . get ( i ) . isEnabled ( ) ) { dearatorMakeupControl . get ( i ) . update ( ) ; } } dearatorPressureControl . forEach ( controller -> { if ( controller . isEnabled ( ) ) { controller . update ( ) ; } } ) ; auxFeederControl . forEach ( controller -> { if ( controller . isEnabled ( ) ) { controller . update ( ) ; } } ) ; mainFeederControl . forEach ( controller -> { if ( controller . isEnabled ( ) ) { controller . update ( ) ; } } ) ; sdv_aControl . forEach ( controller -> { if ( controller . isEnabled ( ) ) { controller . update ( ) ; } } ) ; msv1Control . forEach ( controller -> { if ( controller . isEnabled ( ) ) { controller . update ( ) ; } } ) ; msv2Control . forEach ( controller -> { if ( controller . isEnabled ( ) ) { controller . update ( ) ; } } ) ; if ( az1Control . isEnabled ( ) ) { az1Control . update ( ) ; } fasrControl . update ( ) ; automaticRodController . update ( ) ;
validateBitcoinAddress: public static boolean validateBitcoinAddress ( String addr ) { if ( addr . length ( ) < 26 || addr . length ( ) > 34 ) return false ; byte [ ] decoded = decodeBase58To25Bytes ( addr ) ; if ( decoded == null ) return false ; byte [ ] hash1 = sha256 ( Arrays . copyOfRange ( decoded , 0 , 21 ) ) ; byte [ ] hash2 = sha256 ( hash1 ) ; return Arrays . equals ( Arrays . copyOfRange ( hash2 , 0 , 4 ) , Arrays . copyOfRange ( decoded , 21 , 25 ) ) ;
onReceivedError: public void onReceivedError ( WebView view , int errorCode , String description , String failingUrl ) { receivedError ( mContext , view , errorCode ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { scale = button . isChecked ( ) ? 2.0f : 1.0f ; value . setText ( button . isChecked ( ) ? "50%" : "100%" ) ; moveCursor ( 0 , 0 ) ;
readSkeletonData: public SkeletonData readSkeletonData ( InputStream input ) { if ( input == null ) throw new IllegalArgumentException ( "dataInput cannot be null." ) ; return readSkeletonData ( new JsonReader ( ) . parse ( input ) ) ;
spawnBotAt: private void spawnBotAt ( ActiveData spawnAt_ , SpawnEntry entry ) { Player player = BrainOutServer . ContentMgr . get ( entry . player , Player . class ) ; Team team = BrainOutServer . ContentMgr . get ( "team-freeplay" , Team . class ) ; Map map = Map . Get ( entry . spawnAtDimension ) ; if ( map == null ) return ; PlayerData playerData = ( PlayerData ) player . getData ( map . getDimension ( ) ) ; playerData . setTeam ( team ) ; BotControllerComponentData botController = new BotControllerComponentData ( playerData ) ; PlayerOwnerComponent ownerComponent = new PlayerOwnerComponent ( playerData ) ; PlayerRemoteComponent remoteComponent = new PlayerRemoteComponent ( playerData ) ; Task newTask = ( Task ) BrainOut . R . newInstance ( entry . botTask , new Class [ ] { TaskStack . class } , new Object [ ] { botController . getTasksStack ( ) } ) ; botController . getTasksStack ( ) . pushTask ( newTask ) ; playerData . addComponent ( new ServerFreePartnerBotComponent ( entry . groupId ) ) ; playerData . addComponent ( botController ) ; playerData . addComponent ( ownerComponent ) ; playerData . addComponent ( remoteComponent ) ; float spawnX = spawnAt_ . getX ( ) , spawnY = spawnAt_ . getY ( ) ; playerData . setPosition ( spawnX , spawnY ) ; playerData . setAngle ( 180 ) ; PlayerAnimationComponentData pac = playerData . getComponent ( PlayerAnimationComponentData . class ) ; pac . setSkin ( entry . botSkin ) ; entry . give . generate ( ownerComponent . getConsumableContainer ( ) , entry . spawnAtDimension , playerData ) ; botController . selectFirstInstrument ( ownerComponent ) ; remoteComponent . setCurrentInstrument ( ownerComponent . getCurrentInstrument ( ) ) ; map . addActive ( map . generateServerId ( ) , playerData , true , true , ActiveData . ComponentWriter . TRUE ) ;
setSkeleton: public void setSkeleton ( @ Null Skeleton skeleton ) { this . skeleton = skeleton ;
calculateContact: public LaunchData calculateContact ( LaunchData launchFrom , LaunchData launchTo , boolean in , Map map , int blockX , int blockY ) { return contactShape . calculateContact (
test_createWorkflow: public void test_createWorkflow ( ) throws IOException , NovuNetworkException , InterruptedException { WorkflowRequest workflowRequest = new WorkflowRequest ( ) ; workflowRequest . setDescription ( "Desc" ) ; workflowRequest . setActive ( false ) ; workflowRequest . setName ( "name" ) ; workflowRequest . setDraft ( false ) ; PreferenceSettings preferenceSettings = new PreferenceSettings ( ) ; preferenceSettings . setEmail ( true ) ; preferenceSettings . setSms ( true ) ; preferenceSettings . setInApp ( true ) ; preferenceSettings . setPush ( true ) ; preferenceSettings . setChat ( true ) ; workflowRequest . setPreferenceSettings ( preferenceSettings ) ; workflowRequest . setCritical ( false ) ; workflowRequest . setTags ( List . of ( ) ) ; workflowRequest . setSteps ( List . of ( ) ) ; workflowRequest . setNotificationGroupId ( "notificationId" ) ; NotificationGroup notificationGroup1 = new NotificationGroup ( ) ; notificationGroup1 . setId ( "id" ) ; notificationGroup1 . setName ( "name" ) ; notificationGroup1 . setEnvironmentId ( "environmentId" ) ; notificationGroup1 . setOrganizationId ( "organizationId" ) ; notificationGroup1 . setParentId ( "parentId" ) ; SingleWorkflowResponse singleWorkflowResponse = new SingleWorkflowResponse ( ) ; WorkflowResponse data = new WorkflowResponse ( ) ; data . setId ( "id" ) ; data . setDescription ( "Desc" ) ; data . setActive ( false ) ; data . setName ( "name" ) ; data . setDraft ( false ) ; PreferenceSettings preferenceSettings1 = new PreferenceSettings ( ) ; preferenceSettings1 . setEmail ( true ) ; preferenceSettings1 . setSms ( true ) ; preferenceSettings1 . setInApp ( true ) ; preferenceSettings1 . setPush ( true ) ; preferenceSettings1 . setChat ( true ) ; data . setPreferenceSettings ( preferenceSettings1 ) ; data . setCritical ( false ) ; data . setTags ( List . of ( ) ) ; data . setSteps ( List . of ( ) ) ; data . setOrganizationId ( "organizationId" ) ; data . setCreatorId ( "creatorId" ) ; data . setEnvironmentId ( "environmentId" ) ; data . setTriggers ( Collections . singletonList ( new Trigger ( ) ) ) ; data . setNotificationGroupId ( "notificationId" ) ; data . setDeleted ( false ) ; data . setDeletedAt ( "deletedAt" ) ; data . setDeletedBy ( "deletedBy" ) ; NotificationGroup notificationGroup2 = new NotificationGroup ( ) ; notificationGroup2 . setId ( "id" ) ; notificationGroup2 . setName ( "name" ) ; notificationGroup2 . setEnvironmentId ( "environmentId" ) ; notificationGroup2 . setOrganizationId ( "organizationId" ) ; notificationGroup2 . setParentId ( "parentId" ) ; data . setNotificationGroup ( notificationGroup2 ) ; data . setIsBlueprint ( false ) ; singleWorkflowResponse . setData ( data ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( singleWorkflowResponse ) ) ) ; SingleWorkflowResponse response = workflowHandler . createWorkflow ( workflowRequest ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/workflows" , request . getPath ( ) ) ; assertEquals ( "POST" , request . getMethod ( ) ) ; assertNotNull ( response ) ; assertEquals ( singleWorkflowResponse , response ) ;
getLoggingLevel: No method body
get: public MasterCategory get ( Integer masterCategoryId ) throws ApiErrorException , ConnectionException { Class < MasterCategory > responseModel = ( Class < MasterCategory > ) ( Class < ? > ) MasterCategory . class ; return this . request ( "get" , this . resolvePath ( "/master-categories/%s" , masterCategoryId ) , null , null , responseModel ) ;
update: public void update ( ) { clear ( ) ; for ( Char characteristic : chars )
execute: public String execute ( String [ ] args , Client client ) { PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( playState . getID ( ) != PlayState . ID . game ) return "Not in game" ; GameMode mode = ( ( ServerPSGame ) playState ) . getMode ( ) ; if ( mode . getID ( ) != GameMode . ID . free ) return "Not in freeplay" ; ServerFreeRealization free = ( ( ServerFreeRealization ) mode . getRealization ( ) ) ; int offset ; try { offset = args . length > 1 ? Integer . parseInt ( args [ 1 ] ) : 1 ; } catch ( NumberFormatException ignored ) { offset = 1 ; } free . setTimeOfDayOffset ( offset ) ; return "Done" ;
complete: No method body
updated: protected void updated ( ) { super . updated ( ) ; updateStats ( ) ;
setActive: public void setActive ( boolean active ) { this . active = active ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem12ActionPerformed ( evt ) ;
setzIndex: public void setzIndex ( int zIndex ) { if ( this . zIndex != zIndex )
generate: public void generate ( Array < ConsumableRecord > records , String dimension ) { for ( ItemsCollection . Item item : items )
getTags: public int getTags ( ) { return WithTag . TAG ( Constants . ActiveTags . CHIP_RECEIVER ) ;
isMenuShow: public boolean isMenuShow ( ) { return mMenuView != null && mMenuView . isShowing ( ) ;
init: public void init ( ) { super . init ( ) ;
doFullBackup_badParam: public void doFullBackup_badParam ( ) { ScheduledSchedulerDto consumerParam = new ScheduledSchedulerDto ( "" , "badParamWhichIsNotEqualBackup" , - 1L , false , LocalDateTime . now ( ) ) ; boolean result = backupService . doFullBackup ( consumerParam ) ; assertFalse ( result ) ;
checkEnemy: private boolean checkEnemy ( ) { GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; float maxDistance = 64f ; Array < ActiveData > a = getMap ( ) . getActivesForTag ( Constants . ActiveTags . PLAYERS , activeData -> { if ( activeData == getPlayerData ( ) ) return false ; if ( ! ( activeData instanceof PlayerData ) ) return false ; if ( activeData . getOwnerId ( ) >= 0 && getPlayerData ( ) . getOwnerId ( ) >= 0 ) { if ( ! gameMode . isEnemies ( activeData . getOwnerId ( ) , getPlayerData ( ) . getOwnerId ( ) ) ) return false ; } else { if ( ! gameMode . isEnemies ( activeData . getTeam ( ) , getPlayerData ( ) . getTeam ( ) ) ) return false ; } return getController ( ) . checkVisibility ( activeData , maxDistance , null ) ; } ) ; if ( a . size > 0 ) { pushTask ( new TaskShootTarget ( getStack ( ) , a . random ( ) , new RandomValue ( 0.5f , 1.0f ) , new RandomValue ( 0.1f , 0.5f ) ) ) ; return true ; } return false ;
onRefreshing: No method body
verifyRequest: No method body
setSingleChoiceItems: public SafeDialogBuilder setSingleChoiceItems ( CharSequence [ ] items , int checkedItem , DialogInterface . OnClickListener listener ) { super . setSingleChoiceItems ( items , checkedItem , listener ) ; return this ;
execute: public String execute ( String [ ] args , Client client ) { if ( ! client . isAlive ( ) ) return "Player is dead" ; PlayerData playerData = client . getPlayerData ( ) ; Map map = playerData . getMap ( ) ; ActiveData bot = map . getClosestActiveForTag ( 32 , playerData . getX ( ) , playerData . getY ( ) , PlayerData . class , Constants . ActiveTags . PLAYERS , activeData -> activeData . getComponent ( BotControllerComponentData . class ) != null ) ; if ( bot == null ) return "No bot nearby" ; BotControllerComponentData ctl = bot . getComponent ( BotControllerComponentData . class ) ; ctl . getTasksStack ( ) . pushTask ( new TaskFollowTarget ( ctl . getTasksStack ( ) , playerData , ( stack , enemy ) -> false , false ) ) ; return "Done" ;
prepareIntegrationModuleOrganizationConfiguration: private IntegrationModuleOrganizationConfiguration prepareIntegrationModuleOrganizationConfiguration ( long organizationId ) { IntegrationModuleOrganizationConfiguration result = new IntegrationModuleOrganizationConfiguration ( organizationId ) ; result . trelloApiToken = result . trelloApiKey = result . trelloBoardName = result . trelloListName = result . gitHubToken = result . gitHubRepoName = result . gitHubRepoOwner = result . jiraToken = result . jiraRefreshToken = result . jiraOrganizationName = result . jiraProjectName = result . slackWebhookUrl = result . msTeamsWebhookUrl = result . email = "foo" ; return result ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < AttributeGroup > responseEntity = this . api . attributeGroups ( ) . all ( options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/AttributeGroupAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( AttributeGroup entity : responseEntity . getEntities ( ) ) {
allAttributes: public ApiCollection < Attribute > allAttributes ( Identifier productIdentifier , Identifier imageIdentifier ) throws ApiErrorException , ConnectionException { Class < Attribute > responseModel = ( Class < Attribute > ) ( Class < ? > ) Attribute . class ; return this . requestCollection ( "get" , this . resolvePath ( "/products/%s/images/%s/attributes" , productIdentifier , imageIdentifier ) , null , null , responseModel ) ;
renderItem: private void renderItem ( ) { content . clear ( ) ; Pair < String , String > item = items . get ( currentItem ) ; { final Label text = new Label ( L . get ( item . first ) , BrainOutClient . Skin , "title-yellow" ) ; text . setAlignment ( Align . center ) ; content . add ( text ) . pad ( 16 ) . center ( ) . expandX ( ) . fill ( ) . row ( ) ; } {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterInVStop4ActionPerformed ( evt ) ;
playMusic: public void playMusic ( ) { if ( musicList != null )
getOriginalFilename: public String getOriginalFilename ( ) { return this . originalFilename ;
getSimOperatorName: public static String getSimOperatorName ( Context context ) { TelephonyManager telephonyManager = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; String operator = OPERATOR_NONE ; try { if ( telephonyManager != null && telephonyManager . getSimState ( ) == TelephonyManager . SIM_STATE_READY ) { String name = telephonyManager . getSimOperatorName ( ) ; if ( PermissionChecker . checkReadPhoneStatePermission ( context ) ) { String IMSI = telephonyManager . getSubscriberId ( ) ; if ( IMSI == null || IMSI . equals ( "" ) ) { return operator ; } if ( IMSI . startsWith ( "46000" ) || IMSI . startsWith ( "46002" ) ) { operator = OPERATOR_CMCC ; } else if ( IMSI . startsWith ( "46001" ) ) { operator = OPERATOR_CUCC ; } else if ( IMSI . startsWith ( "46003" ) ) { operator = OPERATOR_CTCC ; } } else { return name ; } } } catch ( Exception e ) { LogUtils . e ( TAG , "获取手机运营商信息异常:" + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } return operator ;
newNetworkClient: public NetworkClient newNetworkClient ( Kryo kryo , NetworkConnectionListener listener ) { return new KryoNetworkClient ( kryo , listener ) ;
sum: public static int sum ( int [ ] v , int begin , int end ) { int sum = 0 ; for ( int i = begin ; i < end ; i ++ ) { sum += v [ i ] ; } return sum ;
setInfo: public void setInfo ( JSONObject info ) { this . info = info ;
setButtons: public void setButtons ( ArrayMap < String , PopupButtonStyle > buttons ) { this . buttons = buttons ;
getItemsClass: public String getItemsClass ( ) { return itemsClass ;
removeLimitLine: public void removeLimitLine ( LimitLine l ) { mLimitLines . remove ( l ) ;
isJustComplete: public boolean isJustComplete ( float scoreAdded ) { return score - scoreAdded < targetScore && isComplete ( ) ;
onInit: public void onInit ( ) { super . onInit ( ) ; setKeyboardFocus ( sendTextField ) ; for ( String s : BrainOutClient . ClientController . getTerminal ( ) ) { addTerminalMessage ( s ) ; } scrollToBottom ( ) ; BrainOut . EventMgr . subscribe ( Event . ID . chat , this ) ;
toString: public String toString ( ) { switch ( method )
populateFrom: public FrontendResourceForm populateFrom ( FrontendResource entity ) { debug ( "[populateFrom] {}" , entity ) ; dto . name = entity . getName ( ) ; dto . organizationId = entity . getOrganizationId ( ) ; dto . content = entity . isDraft ( ) ? entity . getDraftContent ( ) : entity . getContent ( ) ; dto . contentEditable = FrontendResourceService . CONTENT_EDITABLE_BEGIN + StringUtils . substringBetween ( dto . content , FrontendResourceService . CONTENT_EDITABLE_BEGIN , FrontendResourceService . CONTENT_EDITABLE_END ) + FrontendResourceService . CONTENT_EDITABLE_END ; dto . requiredPrivilege = entity . getRequiredPrivilege ( ) ; dto . includeInSitemap = entity . getIncludeInSitemap ( ) ; dto . type = entity . getType ( ) ; dto . embeddable = entity . isEmbeddable ( ) ; dto . accessLevel = entity . getAccessLevel ( ) ; return this ;
createOrUpdateCustomDataForKey: public Map < String , Object > createOrUpdateCustomDataForKey ( Identifier campaignId , String key , Map < String , Object > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/campaigns/%s/custom-data/%s" , campaignId , key ) , query , null , responseModel , model ) ;
getValueFormatter: public IValueFormatter getValueFormatter ( ) { if ( needsFormatter ( ) ) return Utils . getDefaultValueFormatter ( ) ; return mValueFormatter ;
resize: public void resize ( double scale ) { radius *= scale ;
listLeases: public Single < walletrpc . Walletkit . ListLeasesResponse > listLeases ( walletrpc . Walletkit . ListLeasesRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . listLeases ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
