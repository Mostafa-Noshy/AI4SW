service: public static Target service ( String name , String handler ) { return new Target ( name , handler , null ) ;
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { super . write ( json , componentWriter , owner ) ; json . writeValue ( "result" , gameResult ) ; json . writeValue ( "restartIn" , restartIn ) ; if ( votesMaps != null ) { json . writeArrayStart ( "votesMaps" ) ; for ( VoteMap voteMap : votesMaps ) { json . writeValue ( voteMap ) ; } json . writeArrayEnd ( ) ; } if ( votedPlayers != null ) { json . writeArrayStart ( "votedPlayers" ) ; for ( Integer votedPlayer : votedPlayers ) { json . writeValue ( votedPlayer ) ; } json . writeArrayEnd ( ) ; } if ( winningMapIndex >= 0 )
put: public PlayerClient put ( Connection key , PlayerClient value ) { value . setConnection ( key ) ; return super . put ( key , value ) ;
setEnabled: public void setEnabled ( boolean enabled ) { this . enabled = enabled ;
toString: public String toString ( ) { return "MutableUserInOrganization{" +
removeAttachment: public void removeAttachment ( int slotIndex , String name ) { lookup . set ( slotIndex , name ) ; attachments . remove ( lookup ) ;
reset: public void reset ( ) { blockData = null ;
getSkin: public PlayerSkin getSkin ( ) { return skin ;
update: public Shop update ( String shopKey , Shop model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Shop > responseModel = ( Class < Shop > ) ( Class < ? > ) Shop . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/shops/%s" , shopKey ) , query , null , responseModel , model ) ;
show: public void show ( final View view , LightningOuterClass . Invoice item ) { if ( mBasePopWindow == null ) {
setPaths: public void setPaths ( boolean paths ) { this . drawPaths = paths ;
getSteamDensity: public double getSteamDensity ( ) { return steamDensity ;
getLoadViewCreator: public LoadViewCreator getLoadViewCreator ( ) { return this . mLoadCreator ;
initRect: private void initRect ( ) { mTextBounds = new Rect ( ) ; mTextBoundsFlag = new Rect ( ) ;
run: public void run ( ) { System . out . println ( getName ( ) + " started" ) ; while ( ! interrupted ( ) ) { LocalDate lastCheck = LocalDate . now ( ) ; try { Thread . sleep ( TimeUnit . MINUTES . toMillis ( 15 ) ) ; } catch ( InterruptedException ignored ) { } LocalDate now = LocalDate . now ( ) ; if ( now . getDayOfMonth ( ) != lastCheck . getDayOfMonth ( ) ) { System . out . println ( getName ( ) + " the day of month changed" ) ; } } System . out . println ( getName ( ) + " terminated" ) ;
getPartyId: public String getPartyId ( ) { return getInfoString ( "party" , null ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ;
getFailedConditionLocalizedText: public String getFailedConditionLocalizedText ( ) { if ( getGenerator ( ) . isEmpty ( ) ) { return L . get ( "MENU_EMPTY" ) ; } if ( ! getGenerator ( ) . isRequiredItemFulfilled ( ) ) { return L . get ( "MENU_BROKEN" ) ; } return "" ;
toAuditString: No method body
prepareImmutableSetsMap: private Map < Long , Set < String > > prepareImmutableSetsMap ( Map < Long , Set < String > > map , String additionalValue ) { debug ( "[prepareImmutableSetsMap]" ) ; Map < Long , Set < String > > result = new HashMap < > ( map . size ( ) ) ; for ( Map . Entry < Long , Set < String > > e : map . entrySet ( ) ) { result . put ( e . getKey ( ) , prepareImmutableSet ( e . getValue ( ) , additionalValue ) ) ; } return new UnmodifiableMapWithRemove ( result ) ;
init: public void init ( ) { for ( BlocksLayer layer : layers ) { if ( layer == null ) continue ; layer . init ( ) ; } super . init ( ) ;
insertUserRole: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { pauseActionPerformed ( evt ) ;
getBtcPrice: public String getBtcPrice ( Context context ) { btcPrice = PreferencesUtils . getBtcPriceFromLocal ( context ) ; return btcPrice ;
executeTest: No method body
updateFreezing: private void updateFreezing ( ) { TemperatureComponentData tmp = playerData . getComponent ( TemperatureComponentData . class ) ; if ( tmp != null )
setGridLineWidth: public void setGridLineWidth ( float width ) { mGridLineWidth = Utils . convertDpToPixel ( width ) ;
switch_: No method body
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamInVStop3ItemStateChanged ( evt ) ;
delete: public void delete ( String shopKey , String countryCode , Identifier orderIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/orders/%s" , shopKey , countryCode , orderIdentifier ) , null , null , null ) ;
init: private Event init ( RemoteClient remoteClient ) { this . remoteClient = remoteClient ; return this ;
getCustomDataForKey: public Map < String , Object > getCustomDataForKey ( String shopKey , Integer shopCategoryId , String key , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/categories/%s/custom-data/%s" , shopKey , shopCategoryId , key ) , query , null , responseModel ) ;
getCircleBox: public RectF getCircleBox ( ) { return mCircleBox ;
createRow: private javax . swing . JPanel createRow ( ) { javax . swing . JPanel row = new javax . swing . JPanel ( ) ; row . setBackground ( UI . BACKGROUND . darker ( ) ) ; row . setMaximumSize ( new java . awt . Dimension ( 1000 , 7 ) ) ; row . setMinimumSize ( new java . awt . Dimension ( 8 , 7 ) ) ; row . setPreferredSize ( new java . awt . Dimension ( 8 , 7 ) ) ; row . setRequestFocusEnabled ( false ) ; row . setLayout ( new java . awt . FlowLayout ( java . awt . FlowLayout . CENTER , 0 , 0 ) ) ; for ( short i = 50 ; i > 0 ; i -- ) { Channel currentChannel = NPPSim . core . coreArray . get ( 50 - rowNumber + 2 ) . get ( i + 2 ) ; if ( currentChannel instanceof FuelChannel || currentChannel instanceof CPSChannel ) { javax . swing . JTextField button = new javax . swing . JTextField ( ) ; channelMtkBinding . put ( currentChannel , button ) ; button . setBorder ( javax . swing . BorderFactory . createLineBorder ( CHANNELOFFCOLOR . darker ( ) , 1 ) ) ; button . setMaximumSize ( new java . awt . Dimension ( 8 , 7 ) ) ; button . setMinimumSize ( new java . awt . Dimension ( 8 , 7 ) ) ; button . setPreferredSize ( new java . awt . Dimension ( 8 , 7 ) ) ; if ( currentChannel instanceof FuelChannel ) { button . setBackground ( currentChannel . uiData . UIBackgroundColor ) ; } else { button . setBackground ( CPSOFFCOLOR ) ; } button . setEditable ( false ) ; row . add ( button ) ; } else { javax . swing . JPanel button = new javax . swing . JPanel ( ) ; button . setBackground ( UI . BACKGROUND . darker ( ) ) ; button . setMaximumSize ( new java . awt . Dimension ( 8 , 7 ) ) ; button . setMinimumSize ( new java . awt . Dimension ( 8 , 7 ) ) ; button . setPreferredSize ( new java . awt . Dimension ( 8 , 7 ) ) ; row . add ( button ) ; } } this . add ( row ) ; rowNumber ++ ; return row ;
main: public static void main ( String [ ] args ) { try {
addDict: No method body
getLogger: public LambdaLogger getLogger ( ) { return null ;
getWindowBackground: protected Drawable getWindowBackground ( ) { return ContextCompat . getDrawable ( mContext , R . color . color_f9f9f9 ) ;
setPosition: public void setPosition ( int x , int y ) { this . x = x ; this . y = y ;
draw: public String draw ( Curve curve ) { return "i'm a pencil drawing " + curve . draw ( ) ;
getLimit: public int getLimit ( ) { return limit ;
init: private Event init ( BulletData bulletData , float x , float y , ColliderComponentData . Collider collider , String colliderName ) { this . bulletData = bulletData ; this . x = x ; this . y = y ; this . collider = collider ; this . colliderName = colliderName ; return this ;
getLoggingLevel: public Level getLoggingLevel ( ) { return Level . parse ( logLevel ) ; }
getMaxDistance: public float getMaxDistance ( ) { return maxDistance ;
reload: public void reload ( ) { mWebView . reload ( ) ;
getComponentWithSubclass: public < T extends Component > T getComponentWithSubclass ( Class < T > classOf ) { if ( fistComponent == null ) return null ; if ( componentsCount <= 4 ) { return findComponentWithSubclass ( classOf ) ; } if ( componentsIndex == null )
getComponent: public ServerPhysicsSyncComponentData getComponent ( ComponentObject componentObject ) { return new ServerPhysicsSyncComponentData ( componentObject , this ) ;
reset: public void reset ( ) { setEnabled ( true ) ; setText ( mReGetText ) ;
getAcceptedIssuers: public X509Certificate [ ] getAcceptedIssuers ( ) { return new X509Certificate [ 0 ] ;
setPhaseX: public void setPhaseX ( float phase ) { if ( phase > 1f ) { phase = 1f ; } else if ( phase < 0f ) { phase = 0f ; } mPhaseX = phase ;
processMessageNotification: private static void processMessageNotification ( int eventAmount , String notice , NotifyReason eventReason , NotifyAward notifyAward , NotifyData eventData , String title , boolean finalPositive , Actor defaultAdditional ) { int amount = eventAmount ; if ( notice != null ) { switch ( eventReason ) { case duelLost : { Menu . playSound ( Menu . MenuSound . chipFail ) ; break ; } case duelWon : { Menu . playSound ( Menu . MenuSound . chipSuccess ) ; break ; } } switch ( notifyAward ) { case trophy : { Menu . playSound ( Menu . MenuSound . trophy ) ; break ; } case candies : { Menu . playSound ( Menu . MenuSound . trophy ) ; break ; } case ch : { TextureAtlas . AtlasRegion chRegion = BrainOutClient . getRegion ( "icon-big-gold" ) ; if ( chRegion == null ) return ; Image image = new Image ( chRegion ) ; image . setScaling ( Scaling . none ) ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; additional . add ( image ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; addLabelNotice ( notice , additional ) ; Menu . playSound ( Menu . MenuSound . skillpointsEarned ) ; break ; } case skillpoints : { TextureAtlas . AtlasRegion skillptsRegion = BrainOutClient . getRegion ( "skillpoints-big" ) ; if ( skillptsRegion == null ) return ; Image image = new Image ( skillptsRegion ) ; image . setScaling ( Scaling . none ) ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; additional . add ( image ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; addLabelNotice ( notice , additional ) ; Menu . playSound ( Menu . MenuSound . skillpointsEarned ) ; break ; } case ru : { Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; { Table image = new Table ( ) ; if ( eventData instanceof ConsumableND ) { ConsumableRecord record = ( ( ConsumableND ) eventData ) . item ; if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; if ( ici . getInstrumentData ( ) . getInstrument ( ) . getComponent ( IconComponent . class ) != null ) { ContentImage . RenderImage ( ici . getInstrumentData ( ) . getInstrument ( ) , image , 1 ) ; } else { ContentImage . RenderInstrument ( image , ici . getInstrumentData ( ) . getInfo ( ) ) ; } } else { ContentImage . RenderImage ( record . getItem ( ) . getContent ( ) , image , eventAmount ) ; } } else { ContentImage . RenderImage ( BrainOutClient . ContentMgr . get ( "freeplay-ru" ) , image , eventAmount ) ; } additional . add ( image ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; } addLabelNotice ( notice , additional ) ; switch ( eventReason ) { case marketOrderFulfilled : { Menu . playSound ( Menu . MenuSound . itemSold ) ; break ; } default : { Menu . playSound ( Menu . MenuSound . skillpointsEarned ) ; break ; } } break ; } case clanScore : { TextureAtlas . AtlasRegion dogTags = BrainOutClient . getRegion ( "dog-tags" ) ; if ( dogTags == null ) return ; Image image = new Image ( dogTags ) ; image . setScaling ( Scaling . none ) ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; additional . add ( image ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; addLabelNotice ( notice , additional ) ; break ; } case gears : { TextureAtlas . AtlasRegion gearsRegion = BrainOutClient . getRegion ( "icon-gears-big" ) ; if ( gearsRegion == null ) return ; Image image = new Image ( gearsRegion ) ; image . setScaling ( Scaling . none ) ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; additional . add ( image ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; addLabelNotice ( notice , additional ) ; Menu . playSound ( Menu . MenuSound . repair ) ; break ; } case nuclearMaterial : { TextureAtlas . AtlasRegion gearsRegion = BrainOutClient . getRegion ( "icon-nuclear-material-big-3" ) ; if ( gearsRegion == null ) return ; Image image = new Image ( gearsRegion ) ; image . setScaling ( Scaling . none ) ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; additional . add ( image ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; addLabelNotice ( notice , additional ) ; Menu . playSound ( Menu . MenuSound . geigerCard ) ; break ; } case ownable : { String ownedId = ( ( ContentND ) eventData ) . id ; OwnableContent ownableContent = ( ( OwnableContent ) BrainOutClient . ContentMgr . get ( ownedId ) ) ; Actor ac = null ; if ( ownableContent != null ) { if ( ownableContent . hasComponent ( AnimationComponent . class ) ) { AnimationComponent anim = ownableContent . getComponent ( AnimationComponent . class ) ; ac = new ProfileBadgeAnimation ( anim . getAnimation ( ) ) ; } else if ( ownableContent . hasComponent ( IconComponent . class ) ) { ac = new Image ( ownableContent . getComponent ( IconComponent . class ) . getIcon ( "big-icon" ) ) ; ( ( Image ) ac ) . setScaling ( Scaling . none ) ; } else if ( ownableContent . hasComponent ( AnimatedIconComponent . class ) ) { ac = new Image ( ) ; ownableContent . getComponent ( AnimatedIconComponent . class ) . setupImage ( ( ( Image ) ac ) ) ; ( ( Image ) ac ) . setScaling ( Scaling . none ) ; } else if ( ownableContent instanceof InstrumentSlotItem ) { InstrumentSlotItem item = ( ( InstrumentSlotItem ) ownableContent ) ; InstrumentInfo info = new InstrumentInfo ( ) ; info . instrument = item . getInstrument ( ) ; info . skin = item . getDefaultSkin ( ) ; InstrumentIcon icon = new InstrumentIcon ( info , 1.0f , false ) ; icon . init ( ) ; icon . setSize ( 192 , 64 ) ; ac = icon ; } Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; if ( ac != null ) { additional . add ( ac ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; } if ( ownableContent . getTitle ( ) . isValid ( ) ) { final Label contentTitle = new Label ( ownableContent . getTitle ( ) . get ( ) , BrainOutClient . Skin , "title-messages-white" ) ; contentTitle . setAlignment ( Align . center ) ; contentTitle . setWrap ( true ) ; additional . add ( contentTitle ) . expandX ( ) . fillX ( ) . row ( ) ; } addLabelNotice ( notice , additional ) ; amount = 0 ; if ( ownableContent . hasComponent ( UnlockSoundComponent . class ) ) { Sound sound = ownableContent . getComponent ( UnlockSoundComponent . class ) . getSound ( ) ; sound . play ( ) ; } else { Menu . playSound ( Menu . MenuSound . contentOwned ) ; } } break ; } case consumable : { ConsumableRecord record = ( ( ConsumableND ) eventData ) . item ; Actor image = null ; String contentTitle ; if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; InstrumentIcon icon = new InstrumentIcon ( ici . getInstrumentData ( ) . getInfo ( ) , 1.0f , false ) ; contentTitle = ici . getInstrumentData ( ) . getInfo ( ) . skin != null ? ici . getInstrumentData ( ) . getInfo ( ) . skin . getTitle ( ) . get ( ) : ici . getInstrumentData ( ) . getInfo ( ) . instrument . getTitle ( ) . get ( ) ; icon . init ( ) ; icon . setSize ( 192 , 64 ) ; image = icon ; } else { Content content = record . getItem ( ) . getContent ( ) ; contentTitle = content . getTitle ( ) . get ( ) ; if ( content . hasComponent ( IconComponent . class ) ) { image = new Image ( content . getComponent ( IconComponent . class ) . getIcon ( "big-icon" ) ) ; ( ( Image ) image ) . setScaling ( Scaling . none ) ; } else if ( content . hasComponent ( AnimatedIconComponent . class ) ) { image = new Image ( ) ; content . getComponent ( AnimatedIconComponent . class ) . setupImage ( ( ( Image ) image ) ) ; ( ( Image ) image ) . setScaling ( Scaling . none ) ; } } Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; if ( image != null ) { additional . add ( image ) . padTop ( 48 ) . expandX ( ) . fillX ( ) . row ( ) ; } { final Label contentTitle_ = new Label ( contentTitle , BrainOutClient . Skin , "title-messages-white" ) ; contentTitle_ . setAlignment ( Align . center ) ; contentTitle_ . setWrap ( true ) ; additional . add ( contentTitle_ ) . expandX ( ) . fillX ( ) . row ( ) ; } addLabelNotice ( notice , additional ) ; amount = 0 ; switch ( eventReason ) { case marketItemPurchased : { Menu . playSound ( Menu . MenuSound . itemSold ) ; break ; } case marketOrderPosted : case marketOrderCancelled : { Menu . playSound ( Menu . MenuSound . chipFail ) ; break ; } default : { Menu . playSound ( Menu . MenuSound . contentOwned ) ; break ; } } break ; } case weaponSkills : { Skin weapon = ( ( Skin ) BrainOut . ContentMgr . get ( ( ( SkillsND ) eventData ) . weaponSkin ) ) ; if ( weapon == null ) return ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; String levelIcon = "weapon-skill-" + eventAmount + "-big" ; TextureRegion levelIconRegion = BrainOutClient . getRegion ( levelIcon ) ; if ( levelIconRegion != null ) { Image image = new Image ( levelIconRegion ) ; image . setScaling ( Scaling . none ) ; additional . add ( image ) . padTop ( 22 ) . expandX ( ) . fillX ( ) . row ( ) ; } final Label contentTitle = new Label ( weapon . getTitle ( ) . get ( ) , BrainOutClient . Skin , "title-messages-white" ) ; contentTitle . setAlignment ( Align . center ) ; contentTitle . setWrap ( true ) ; additional . add ( contentTitle ) . padTop ( 10 ) . expandX ( ) . fillX ( ) . row ( ) ; addLabelNotice ( notice , additional ) ; amount = 0 ; Menu . playSound ( Menu . MenuSound . newWeaponSkill ) ; break ; } case level : { String kind = ( ( LevelND ) eventData ) . kind ; Levels levels = BrainOutClient . ClientController . getLevels ( kind ) ; Levels . Level newLevel = levels . getLevel ( eventAmount ) ; final Label newLevelTitle = new Label ( newLevel . toString ( ) , BrainOutClient . Skin , "title-messages-white" ) ; newLevelTitle . setAlignment ( Align . center ) ; newLevelTitle . setWrap ( true ) ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; additional . add ( newLevelTitle ) . padTop ( 10 ) . expandX ( ) . fillX ( ) . row ( ) ; String levelIcon = newLevel . icon ; TextureRegion levelIconRegion = BrainOutClient . getRegion ( levelIcon ) ; if ( levelIconRegion != null ) { Image image = new Image ( levelIconRegion ) ; image . setScaling ( Scaling . none ) ; additional . add ( image ) . padTop ( 22 ) . expandX ( ) . fillX ( ) . row ( ) ; } final Label contentTitle = new Label ( newLevel . name . get ( ) , BrainOutClient . Skin , "title-messages-white" ) ; contentTitle . setAlignment ( Align . bottom , Align . center ) ; contentTitle . setWrap ( true ) ; additional . add ( contentTitle ) . expand ( ) . fill ( ) . padBottom ( 48 ) . row ( ) ; addLabelNotice ( notice , additional ) ; amount = 0 ; if ( kind . equals ( Constants . User . LEVEL ) ) { Menu . playSound ( Menu . MenuSound . levelUp ) ; } else { Menu . playSound ( Menu . MenuSound . techLevelUp ) ; } break ; } case rankUp : { Menu . playSound ( Menu . MenuSound . rankUp ) ; Table additional = new Table ( ) ; additional . setFillParent ( true ) ; additional . align ( Align . top ) ; final Label contentTitle = new Label ( L . get ( "MENU_GUNGAME_RANK_UP" ) , BrainOutClient . Skin , "title-messages-white" ) ; contentTitle . setAlignment ( Align . bottom , Align . center ) ; contentTitle . setWrap ( true ) ; additional . add ( contentTitle ) . expand ( ) . fill ( ) . padBottom ( 48 ) . row ( ) ; addLabelNotice ( notice , additional ) ; break ; } default : { addLabelNotice ( notice , defaultAdditional ) ; } } } final Table r = new Table ( ) ; r . setFillParent ( true ) ; r . align ( Align . center | Align . top ) ; String postFix ; switch ( notifyAward ) { case ru : { postFix = " RU" ; break ; } default : { postFix = "" ; break ; } } Table d = new Notify ( title , finalPositive , amount , postFix ) ; r . add ( d ) . pad ( 100 ) . maxSize ( 400 ) . row ( ) ; if ( ! BrainOutClient . getInstance ( ) . topState ( ) . hasTopMenu ( ) ) return ; Menu menu = BrainOutClient . getInstance ( ) . topState ( ) . topMenu ( ) ; menu . addActor ( r ) ; r . addAction ( Actions . sequence (
bg: public boolean bg ( ) { return false ;
getRealOwner: private Owner getRealOwner ( ) { long a = lastA >= conflictStart ? lastA : 0 ; long b = lastB >= conflictStart ? lastB : 0 ; if ( a == 0 && b == 0 ) { return defaultOwner ; } if ( a > b )
shouldParseNegativeCodedoseCords_withPositiveLng: public void shouldParseNegativeCodedoseCords_withPositiveLng ( ) { String point = "POINT (-51.1083 17.0352)" ; Geometry geometry = MapService . parsePoint ( point ) ; assertEquals ( "Point" , geometry . getGeometryType ( ) ) ; assertEquals ( geometry . toText ( ) , point ) ;
clientInitialized: public void clientInitialized ( Client client , boolean reconnected ) { super . clientInitialized ( client , reconnected ) ; if ( client instanceof PlayerClient ) { PlayerClient playerClient = ( ( PlayerClient ) client ) ; String account = playerClient . getAccount ( ) ; if ( account != null && owner != null && account . equals ( owner ) ) { playerClient . setRights ( PlayerRights . owner ) ; playerClient . log ( "Player is a server owner now." ) ; } playerClient . sendRightsUpdated ( ) ; playerClient . sendUserProfile ( ) ; } client . setState ( Client . State . readyToSpawn ) ;
getDayOfWeek: public Integer getDayOfWeek ( ) { return dayOfWeek ;
setCode: public void setCode ( String code ) { this . code = code ;
payOnAverage: void payOnAverage ( ) { Map < String , Double > fees = new HashMap < > ( Map . of ( "3474565432" , 11.75 , "3336534965" , 9.95 , "3315467927" , 9.75 , "3316393736" , 8.75 ) ) ; assertEquals ( Map . of (
setHighlight: public void setHighlight ( ActiveData highlight ) { this . highlight = highlight ;
searchByLastname: public Person [ ] searchByLastname ( String lastname ) { int k = 0 ; Person [ ] tmp = new Person [ MAX_PERSONS ] ; for ( int i = 0 ; i < MAX_PERSONS ; i ++ ) { if ( phoneBook [ i ] != null && phoneBook [ i ] . getLastname ( ) . equals ( lastname ) ) { tmp [ k ++ ] = phoneBook [ i ] ; } } return Arrays . copyOf ( tmp , k ) ;
get: public WebhookSubscription get ( Integer subscriptionId ) throws ApiErrorException , ConnectionException { Class < WebhookSubscription > responseModel = ( Class < WebhookSubscription > ) ( Class < ? > ) WebhookSubscription . class ; return this . request ( "get" , this . resolvePath ( "/webhooks/subscriptions/%s" , subscriptionId ) , null , null , responseModel ) ;
calculateLegendOffsets: protected void calculateLegendOffsets ( RectF offsets ) { offsets . left = 0.f ; offsets . right = 0.f ; offsets . top = 0.f ; offsets . bottom = 0.f ; if ( mLegend == null || ! mLegend . isEnabled ( ) || mLegend . isDrawInsideEnabled ( ) ) return ; switch ( mLegend . getOrientation ( ) ) {
search: No method body
update: public void update ( float dt ) { super . update ( dt ) ; if ( maps != null ) { for ( ServerMap map : maps ) { map . update ( dt ) ; } } if ( isGameFinished ( ) )
onCompleted: public void onCompleted ( ) { mEmitter . onComplete ( ) ;
getRequiredWritePrivilege: public String getRequiredWritePrivilege ( ) { return requiredWritePrivilege ;
getContentView: protected int getContentView ( ) { return R . layout . activity_web_view_common ;
disconnected: public void disconnected ( Connection connection ) { KryoNetworkConnection conn = connections . get ( connection ) ; if ( conn != null )
received: public boolean received ( final CopyObjectsMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; ObjectSet < ActiveData > items = new ObjectSet < > ( ) ; for ( int objectId : msg . o ) { ActiveData activeData = map . getActives ( ) . get ( objectId ) ; if ( activeData == null ) return ; if ( activeData . getComponent ( SpriteWithBlocksComponentData . class ) == null && activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) == null ) return ; items . add ( activeData ) ; } for ( ActiveData activeData : items ) { SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; int x = ( int ) ( activeData . getX ( ) + msg . x ) , y = ( int ) ( activeData . getY ( ) + msg . y ) ; if ( ! sp . validateBlocksForAdding ( map , x , y , null ) ) return ; } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { UserSpriteWithBlocksComponent sp = us . getContentComponent ( ) ; int x = ( int ) ( activeData . getX ( ) + msg . x ) , y = ( int ) ( activeData . getY ( ) + msg . y ) ; if ( ! us . validateBlocksForAdding ( map , x , y , null ) ) return ; } else { return ; } } } JsonReader reader = new JsonReader ( ) ; for ( ActiveData original : items ) { String d = Data . ComponentSerializer . toJson ( original , Data . ComponentWriter . TRUE , - 1 ) ; ActiveData activeData = map . newActiveData ( map . getJson ( ) , reader . parse ( d ) ) ; int x_ = ( int ) ( original . getX ( ) + msg . x ) , y_ = ( int ) ( original . getY ( ) + msg . y ) ; activeData . setPosition ( x_ , y_ ) ; map . addActive ( map . generateServerId ( ) , activeData , true , true , false ) ; SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; int layer = sp . getBlocksLayer ( ) ; for ( int j = 0 ; j < sp . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < sp . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; BlockData b ; if ( sp . hasOnlyOneUnderlyingBlock ( ) ) { Block underlyingBlock = sp . getUnderlyingBlock ( ) ; b = underlyingBlock . getBlock ( ) ; } else { Block underlyingBlock = sp . getUnderlyingBlockAt ( i , j ) ; b = underlyingBlock . getBlock ( ) ; } SpriteBlockComponentData sbc = b . getComponent ( SpriteBlockComponentData . class ) ; if ( sbc != null ) { sbc . setSprite ( activeData ) ; } map . setBlock ( x , y , b , sp . getBlocksLayer ( ) , false , false ) ; } } } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { UserSpriteWithBlocksComponent sp = us . getContentComponent ( ) ; Block underlyingBlock = sp . getUnderlyingBlock ( ) ; int layer = sp . getBlocksLayer ( ) ; for ( int j = 0 ; j < us . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < us . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; BlockData b = underlyingBlock . getBlock ( ) ; SpriteBlockComponentData sbc = b . getComponent ( SpriteBlockComponentData . class ) ; if ( sbc != null ) { sbc . setSprite ( activeData ) ; } map . setBlock ( x , y , b , sp . getBlocksLayer ( ) , false , false ) ; } } } else { return ; } } } } ) ; return true ;
onSingleTapConfirmed: public boolean onSingleTapConfirmed ( MotionEvent e ) { return false ;
setCode: public void setCode ( String code ) { this . code = code ;
updateWaterInflow: public void updateWaterInflow ( double flow , double tempC ) { if ( flow < 0 || waterInflow < 0 ) {
get: No method body
isLieutenant: public boolean isLieutenant ( ) { return isOwner ( ) ||
addAction: public void addAction ( String title , ActionCallback callback , String style ) { Action action = new Action ( ) ; action . title = title ; action . style = style ; action . callback = callback ; this . actions . add ( action ) ;
test: No method body
execute: public String execute ( String [ ] args , Client client ) { PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( ! ( playState instanceof ServerPSGame ) ) { return "Not in game" ; } ServerPSGame game = ( ( ServerPSGame ) playState ) ; try { final Integer time = Integer . parseInt ( args [ 1 ] ) ; BrainOutServer . PostRunnable ( ( ) -> { game . getMode ( ) . setEndTime ( time ) ; ( ( ServerRealization ) game . getMode ( ) . getRealization ( ) ) . updated ( ) ; } ) ; } catch ( NumberFormatException e ) { return "Bad time." ; } return "Done." ;
getPaymentType: public PaymentType getPaymentType ( ) { return paymentType ;
showTutorial: private void showTutorial ( ) { if ( ! Tutorials . IsFinished ( "daily" ) )
search: public List < T > search ( String fieldName , Object value ) { return wrapped . search ( scope , fieldName , value ) ;
setFirstName: public void setFirstName ( String firstName ) { this . firstName = firstName ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { sdvcClose1ActionPerformed ( evt ) ;
afterPropertiesSet: public void afterPropertiesSet ( ) throws Exception { if ( ! initialized ) {
merchants: public MerchantService merchants ( ) { MerchantService service = this . getService ( "com.scayle.adminapi.service.MerchantService" ) ; return service ;
getResourceName: public String getResourceName ( ) { return "health" ;
getPlayerData: public PlayerData getPlayerData ( ) { return stack . getController ( ) . getPlayerData ( ) ;
run: public void run ( ) { int i = 0 ; while ( ! isInterrupted ( ) ) {
readTask: protected void readTask ( JsonValue jsonData ) { category = Category . valueOf ( jsonData . getString ( "category" , Category . other . toString ( ) ) ) ; hash = jsonData . getString ( "hash" , "" ) ; share = jsonData . getInt ( "share" , 0 ) ;
isFooterViewType: private boolean isFooterViewType ( int viewType ) { int position = mFooterViews . indexOfKey ( viewType ) ; return position >= 0 ;
onException: public boolean onException ( Exception e , Object model , Target < GlideDrawable > target , boolean isFirstResource ) { if ( callback != null ) { callback . onLoadException ( e ) ; } return false ;
update: public ShopCategory update ( String shopKey , Integer shopCategoryId , ShopCategory model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCategory > responseModel = ( Class < ShopCategory > ) ( Class < ? > ) ShopCategory . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "patch" , this . resolvePath ( "/shops/%s/categories/%s" , shopKey , shopCategoryId ) , query , null , responseModel , model ) ;
getSliceSpace: No method body
acquireShortestPath: Queue < WayPoint > acquireShortestPath ( WayPoint wayPoint ) { WayPointDistanceEntry entry = get ( wayPoint , null ) ; if ( entry == null ) { synchronized ( distanceEntryPool ) { entry = distanceEntryPool . obtain ( ) ; } put ( wayPoint , entry ) ; } return entry . shortestPath ;
withOptions: public RestateHttpEndpointBuilder withOptions ( HttpServerOptions options ) { this . options = Objects . requireNonNull ( options ) ; return this ;
init: public void init ( ) { updatePublishers ( ) ;
getOrganizationWithPrivilegePairs: public List < String > getOrganizationWithPrivilegePairs ( ) { debug ( "[getOrganizationWithPrivilegePairs]" ) ; List < String > result = new ArrayList < > ( ) ; if ( organizationPrivileges . entrySet ( ) . isEmpty ( ) ) { result . add ( "" ) ; } for ( Map . Entry < Long , Set < String > > e : organizationPrivileges . entrySet ( ) ) { for ( String s : e . getValue ( ) ) { result . add ( e . getKey ( ) + s ) ; } } return result ;
cutAndLogMsg: private static void cutAndLogMsg ( int type , String tag , String msg , Throwable exception ) { int segmentSize = 4 * 1024 ; long length = msg . length ( ) ; if ( length <= segmentSize ) { logMsgByType ( type , tag , msg , exception ) ;
showLayoutRoundBg: public static void showLayoutRoundBg ( final Context context , Object imagePath , final View layout , int roundDP ) { showLayoutRoundBg ( context , imagePath , layout , R . color . color_f7f7f7 , roundDP ) ;
preparePaymentProbe: public RouterOuterClass . SendPaymentRequest preparePaymentProbe ( String destination , long amountSat , @ Nullable ByteString paymentAddress , @ Nullable List < LightningOuterClass . RouteHint > routeHints , @ Nullable Map < Integer , LightningOuterClass . Feature > destFeatures ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ PAYMENT_HASH_BYTE_LENGTH ] ; random . nextBytes ( bytes ) ; long feeLimit = calculateAbsoluteFeeLimit ( amountSat ) ; RouterOuterClass . SendPaymentRequest . Builder sprb = RouterOuterClass . SendPaymentRequest . newBuilder ( ) . setAssetId ( ( int ) mAssetId ) . setDest ( byteStringFromHex ( destination ) ) . setAssetAmt ( amountSat ) . setFeeLimitMsat ( feeLimit ) . setPaymentHash ( ByteString . copyFrom ( bytes ) ) . setNoInflightUpdates ( true ) . setTimeoutSeconds ( RefConstants . TIMEOUT_MEDIUM * RefConstants . TOR_TIMEOUT_MULTIPLIER ) . setMaxParts ( 1 ) ; if ( paymentAddress != null ) { sprb . setPaymentAddr ( paymentAddress ) ; } if ( destFeatures != null && ! destFeatures . isEmpty ( ) ) { for ( Map . Entry < Integer , LightningOuterClass . Feature > entry : destFeatures . entrySet ( ) ) { sprb . addDestFeaturesValue ( entry . getKey ( ) ) ; } } if ( routeHints != null && ! routeHints . isEmpty ( ) ) { sprb . addAllRouteHints ( routeHints ) ; } return sprb . build ( ) ;
writeOutput: public void writeOutput ( ByteBuffer value , SyscallCallback < Void > callback ) { wrapAndPropagateExceptions (
deleteWorkflowOverride: public DeleteWorkflowOverrideResponse deleteWorkflowOverride ( final String overrideId ) throws IOException , NovuNetworkException { try {
acquireMap: public ServerSettings . MapConditions acquireMap ( ) { return map ;
lerpAngle: public boolean lerpAngle ( float x , float y ) { PlayerData playerData = getPlayerData ( ) ; if ( playerData == null ) return false ; InstrumentData currentWeapon = playerData . getCurrentInstrument ( ) ; if ( currentWeapon == null ) return false ; WeaponAnimationComponentData anim = currentWeapon . getComponent ( WeaponAnimationComponentData . class ) ; if ( anim == null ) return false ; BonePointData launch = anim . getLaunchPointData ( ) ; tmp . set ( x , y ) . sub ( launch . getX ( ) , launch . getY ( ) ) ; float angleRequired = tmp . angleDeg ( ) ; float angleHave = playerData . getAngle ( ) ; float result = MathUtils . lerpAngleDeg ( angleHave , angleRequired , 0.6f ) ; playerData . setAngle ( result ) ; float diff = Math . abs ( angleHave - angleRequired ) ; return diff < 5.0f || diff >= 355.0f ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights )
run: public void run ( ) { mShowImage . setImageResource ( R . drawable . bg_dialog_verify_image_iv ) ;
deletedHandle: No method body
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamInVopen2ItemStateChanged ( evt ) ;
isDrawTopTitle: protected boolean isDrawTopTitle ( int position ) { return true ;
d: private static String d ( String s ) { return new String ( Base64 . decode ( s , Base64 . NO_PADDING ) , StandardCharsets . UTF_8 ) ;
getData: public BulletData getData ( LaunchData launchData , float damageCoefficient , String dimension ) { BulletData bulletData = bulletPool . obtain ( ) ; bulletData . setup ( launchData , damageCoefficient , dimension ) ; return bulletData ;
setPos: private void setPos ( ) { int w = getMeasuredWidth ( ) ; LogUtils . e ( TAG , "ProgressBar的宽度是：" + w ) ; MarginLayoutParams params = ( MarginLayoutParams ) mValueTv . getLayoutParams ( ) ; int pro = mProgressBar . getProgress ( ) ; int tW = mValueTv . getWidth ( ) ; if ( w * pro / 100 + tW * 0.3 > w ) { params . leftMargin = ( int ) ( w - tW * 1.1 ) ; } else if ( w * pro / 100 < tW * 0.7 ) { params . leftMargin = 0 ; } else { params . leftMargin = ( int ) ( w * pro / 100 - tW * 0.7 ) ; } mValueTv . setLayoutParams ( params ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
c: public float c ( ) { return 0.0f ;
clicked: public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; if ( Gdx . input . isKeyPressed ( Input . Keys . ALT_LEFT ) )
setTitle: public void setTitle ( String title ) { this . title = title ;
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/AssetCreateRequest.json" ) ; Asset requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Asset . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; AssetUrl responseEntity = this . api . assets ( ) . create ( requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/AssetCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
testGetMemberships: public void testGetMemberships ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < CustomerMembership > responseEntity = this . api . customers ( ) . getMemberships ( "acme" , "acme" , Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CustomerGetMembershipsResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( CustomerMembership entity : responseEntity . getEntities ( ) ) {
setPassword: public void setPassword ( String password ) { this . password = password ;
onResponse: public void onResponse ( byte [ ] bytes ) { try {
getSubject: public String getSubject ( ) { return subject ;
copy: public final State copy ( Set < Integer > set , Map < Integer , Set < String > > map ) { return new State ( set , map ) ;
initContent: protected void initContent ( Table data ) { final RichLabel text = new RichLabel ( this . text , BrainOutClient . Skin , "title-medium" ) ; data . add ( text ) . pad ( 16 ) . center ( ) . expand ( ) . fill ( ) . row ( ) ;
getId: public Long getId ( ) { return id ;
initChannel: protected void initChannel ( final @ NotNull SocketChannel channel ) { try { channel . config ( ) . setOption ( ChannelOption . TCP_NODELAY , true ) ; } catch ( ChannelException exception ) { logger . fatal ( "Encountered error whilst settings options to channel: {}" , ExceptionUtils . getStackTrace ( exception ) ) ; } channel . pipeline ( ) . addLast ( "frame_decoder" , new LengthFieldBasedFrameDecoder ( Message . MAX_PACKET_LENGTH , 0 , 4 , 0 , 4 ) ) ; channel . pipeline ( ) . addLast ( "message_decoder" , new JRPCMessageDecoder < > ( JRPCClient . this ) ) ; channel . pipeline ( ) . addLast ( "handshake_handler" , new JRPCClientHandshakeHandler ( JRPCClient . this ) ) ; channel . pipeline ( ) . addLast ( "message_handler" , handler ) ; channel . pipeline ( ) . addLast ( "message_encoder" , new JRPCClientMessageEncoder ( JRPCClient . PROTOCOL_VERSION . getVersionNumber ( ) ) ) ; channel . pipeline ( ) . addLast ( "handshake_encoder" , new JRPCClientHandshakeEncoder ( JRPCClient . PROTOCOL_VERSION . getVersionNumber ( ) ) ) ;
render: public void render ( Batch batch , RenderContext context ) { super . render ( batch , context ) ; if ( hitTimer > 0 && hitSprite != null )
test_getWorkflow: public void test_getWorkflow ( ) throws IOException , NovuNetworkException , InterruptedException { SingleWorkflowResponse singleWorkflowResponse = new SingleWorkflowResponse ( ) ; WorkflowResponse data = new WorkflowResponse ( ) ; data . setId ( "id" ) ; data . setDescription ( "Desc" ) ; data . setActive ( false ) ; data . setName ( "name" ) ; data . setDraft ( false ) ; PreferenceSettings preferenceSettings1 = new PreferenceSettings ( ) ; preferenceSettings1 . setEmail ( true ) ; preferenceSettings1 . setSms ( true ) ; preferenceSettings1 . setInApp ( true ) ; preferenceSettings1 . setPush ( true ) ; preferenceSettings1 . setChat ( true ) ; data . setPreferenceSettings ( preferenceSettings1 ) ; data . setCritical ( false ) ; data . setTags ( List . of ( ) ) ; data . setSteps ( List . of ( ) ) ; data . setOrganizationId ( "organizationId" ) ; data . setCreatorId ( "creatorId" ) ; data . setEnvironmentId ( "environmentId" ) ; data . setTriggers ( Collections . singletonList ( new Trigger ( ) ) ) ; data . setNotificationGroupId ( "notificationId" ) ; data . setDeleted ( false ) ; data . setDeletedAt ( "deletedAt" ) ; data . setDeletedBy ( "deletedBy" ) ; NotificationGroup notificationGroup2 = new NotificationGroup ( ) ; notificationGroup2 . setId ( "id" ) ; notificationGroup2 . setName ( "name" ) ; notificationGroup2 . setEnvironmentId ( "environmentId" ) ; notificationGroup2 . setOrganizationId ( "organizationId" ) ; notificationGroup2 . setParentId ( "parentId" ) ; data . setNotificationGroup ( notificationGroup2 ) ; data . setIsBlueprint ( false ) ; singleWorkflowResponse . setData ( data ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( singleWorkflowResponse ) ) ) ; SingleWorkflowResponse response = workflowHandler . getWorkflow ( "workflowId" ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/workflows/workflowId" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertNotNull ( response ) ; assertEquals ( singleWorkflowResponse , response ) ;
execute: public String execute ( String [ ] args , Client client ) { int amount ; try { amount = args . length > 1 ? Integer . parseInt ( args [ 1 ] ) : 1 ; } catch ( NumberFormatException ignored ) { amount = 1 ; } int added = 0 ; for ( int i = 0 ; i < amount ; i ++ ) { BotClient botClient = BrainOutServer . Controller . getClients ( ) . newBotClient ( client . getTeam ( ) ) ; if ( botClient != null ) { added ++ ; botClient . init ( ) ; } } return "Added bots: " + added ;
setRequiredPrivilege: public void setRequiredPrivilege ( String requiredPrivilege ) { this . requiredPrivilege = requiredPrivilege ;
onResponse: public void onResponse ( byte [ ] bytes ) { new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
calcSum: private static float calcSum ( float [ ] vals ) { if ( vals == null ) return 0f ; float sum = 0f ; for ( float f : vals ) sum += f ; return sum ;
create: public Shop create ( Shop model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Shop > responseModel = ( Class < Shop > ) ( Class < ? > ) Shop . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shops" ) , query , null , responseModel , model ) ;
sneakyThrow: public static < E extends Throwable > void sneakyThrow ( ) throws E { throw ( E ) AbortedExecutionException . INSTANCE ;
findAllUserRolesInOrganizationWithRoles: No method body
getId: public String getId ( ) { return id ;
init: private void init ( ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setTextSize ( sp2px ( 11 ) ) ; mPaint . setColor ( ContextCompat . getColor ( mContext , R . color . color_1977da ) ) ; setBackgroundColor ( ContextCompat . getColor ( mContext , R . color . color_f7f7f7 ) ) ; setOnClickListener ( this ) ;
idOffset: default int idOffset ( ) { return 0 ; } ;
isWarnEnabled: public boolean isWarnEnabled ( Marker marker ) { return logger . isWarnEnabled ( marker ) ;
endLaunching: private void endLaunching ( ) { launching = false ;
notifyTableToAll: private void notifyTableToAll ( ) { IntSet . IntSetIterator lit = listeners . iterator ( ) ; while ( lit . hasNext )
FlymeSetStatusBarLightMode: public static boolean FlymeSetStatusBarLightMode ( Window window , boolean dark ) { boolean result = false ; if ( window != null ) { try { WindowManager . LayoutParams lp = window . getAttributes ( ) ; Field darkFlag = WindowManager . LayoutParams . class . getDeclaredField ( "MEIZU_FLAG_DARK_STATUS_BAR_ICON" ) ; Field meizuFlags = WindowManager . LayoutParams . class . getDeclaredField ( "meizuFlags" ) ; darkFlag . setAccessible ( true ) ; meizuFlags . setAccessible ( true ) ; int bit = darkFlag . getInt ( null ) ; int value = meizuFlags . getInt ( lp ) ; if ( dark ) { value |= bit ; } else { value &= ~ bit ; } meizuFlags . setInt ( lp , value ) ; window . setAttributes ( lp ) ; result = true ; } catch ( Exception e ) { } } return result ;
getWorkflow: public SingleWorkflowResponse getWorkflow ( final String workflowId ) throws IOException , NovuNetworkException { Response < SingleWorkflowResponse > response = workflowApi . getWorkflow ( workflowId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
getStyleEven: protected String getStyleEven ( ) { return "button-row-dark-blue" ;
findByIdAndPublicFileTrue: No method body
all: public ApiCollection < ShopCategory > all ( String shopKey ) throws ApiErrorException , ConnectionException { Class < ShopCategory > responseModel = ( Class < ShopCategory > ) ( Class < ? > ) ShopCategory . class ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/categories" , shopKey ) , null , null , responseModel ) ;
itemUnlocked: public void itemUnlocked ( OwnableContent content ) { if ( Shop . getInstance ( ) . isFree ( content ) ) { content . addItem ( this , 1 ) ; onOwn . owned ( content , "lock-tree" , OnwAction . owned , 1 ) ; } else { onOwn . owned ( content , "lock-tree" , OnwAction . unlocked , 1 ) ; } setDirty ( ) ;
lastAction: public long lastAction ( ) { long a = lastA >= conflictStart ? lastA : 0 ; long b = lastB >= conflictStart ? lastB : 0 ; return Math . max ( a , b ) ;
checkRecord: private boolean checkRecord ( ConsumableRecord record ) { if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; InstrumentData instrumentData = ici . getInstrumentData ( ) ; if ( instrumentData instanceof ChipData ) { ChipData chipData = ( ( ChipData ) instrumentData ) ; ServerChipComponentData s = chipData . getComponent ( ServerChipComponentData . class ) ; if ( s != null && s . getSpawner ( ) == this ) { return true ; } } } return false ;
sendConsumable: public void sendConsumable ( ) { if ( playerData != null )
calculateAccuracyMin: public float calculateAccuracyMin ( ) { return MathUtils . lerp ( Constants . Weapon . ACCURACY_MIN_MIN ,
updateMenu: public void updateMenu ( @ NonNull Long roleId , @ NonNull Set < Long > menuIds ) { this . baseMapper . deleteMenuByRoleId ( roleId ) ; this . baseMapper . insertMenuByRoleId ( roleId , menuIds ) ; eventPublisher . publishEvent ( new ClearCacheEvent ( SystemDictConstants . ROLE ) ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; enabled = jsonData . getBoolean ( "enabled" , true ) ;
getInstance: public static Swapper getInstance ( ) { return INSTANCE ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
of: public static MessageType of ( final int id ) { return Arrays . stream ( values ( ) ) . filter ( messageType -> messageType . getId ( ) == id ) . findFirst ( ) . orElse ( null ) ;
getX: No method body
getMenuList: public List < MenuDto > getMenuList ( String queryKey ) { List < MenuDto > menuDtos = new ArrayList < > ( ) ; List < Menu > menuList = this . baseMapper . selectAllByQueryKey ( queryKey ) ; if ( ! CollectionUtils . isEmpty ( menuList ) ) { menuDtos = MenuConverterMapper . INSTANCE . MenuToMenuDtoList ( menuList ) ; menuDtos = getMenuDtos ( menuDtos ) ; } return menuDtos ;
addBar: protected void addBar ( float left , float top , float right , float bottom ) { buffer [ index ++ ] = left ; buffer [ index ++ ] = top ; buffer [ index ++ ] = right ; buffer [ index ++ ] = bottom ;
getCurrentWeaponRecord: public ConsumableRecord getCurrentWeaponRecord ( ) { PlayerData playerData = getPlayerData ( ) ; if ( playerData == null ) return null ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return null ; return poc . getCurrentInstrumentRecord ( ) ;
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Carrier responseEntity = this . api . carriers ( ) . get ( Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CarrierGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
resetZoom: public void resetZoom ( ) { mViewPortHandler . resetZoom ( mZoomMatrixBuffer ) ; mViewPortHandler . refresh ( mZoomMatrixBuffer , this , false ) ; calculateOffsets ( ) ; postInvalidate ( ) ;
resetAxisMaximum: public void resetAxisMaximum ( ) { mCustomAxisMax = false ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem3ActionPerformed ( evt ) ;
deposit: void deposit ( ) { bankAccount . deposit ( 1000 ) ; assertEquals ( 2000 , bankAccount . getBalance ( ) ) ;
catTrackStatsWithBots: public boolean catTrackStatsWithBots ( ) { return getLevel ( Constants . User . LEVEL , 0 ) < 10 ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
forValue: public static ErrorCode forValue ( String value ) { return errorsMap . get ( value . toLowerCase ( ) ) ;
post: public HttpUtils post ( ) { mType = TYPE_POST ; return this ;
eval: public static Object eval ( String script ) throws Exception { if ( cl != null ) { Thread . currentThread ( ) . setContextClassLoader ( cl ) ; Class < ? > bundle = cl . loadClass ( GroovyBundle . class . getName ( ) ) ; return bundle . getDeclaredMethod ( "eval" , String . class ) . invoke ( null , script ) ; } if ( script . startsWith ( "!" ) ) {
getInstance: public static ExceptionCrashHandler getInstance ( ) { return instance ;
run: default void run ( String name , ThrowingRunnable runnable ) throws TerminalException { run (
render: public void render ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ; super . render ( ) ;
act: public void act ( Inspectable inspectable ) { inspectable . inspect ( this ) ; doInspect ( inspectable ) ;
ready: public void ready ( Spawnable spawnAt ) { gameController . spawnAt ( spawnAt ) ;
toString: public String toString ( ) { return name ;
onProgressChanged: public void onProgressChanged ( SeekBar bar , int progress , boolean fromUser ) { setTv ( tv , progress ) ; if ( fromUser ) {
getOrganization: public Organization getOrganization ( ) { return organization ;
bindPendingClosingChannelItem: void bindPendingClosingChannelItem ( PendingClosingChannelItem pendingClosingChannelItem ) { bindPendingChannelItem ( pendingClosingChannelItem . getChannel ( ) . getChannel ( ) ) ; setOnRootViewClickListener ( pendingClosingChannelItem , ChannelListItem . TYPE_PENDING_CLOSING_CHANNEL ) ;
initUnitXY: private void initUnitXY ( ) { mUnitRandomX = ( int ) ( Math . random ( ) * ( mBitmap . getWidth ( ) - mUnitWidth ) ) ; mUnitRandomY = ( int ) ( Math . random ( ) * ( mBitmap . getHeight ( ) - mUnitHeight ) ) ; if ( mUnitRandomX <= mBitmap . getWidth ( ) / 2 ) { mUnitRandomX = mUnitRandomX + mBitmap . getWidth ( ) / 4 ; } if ( mUnitRandomX + mUnitWidth > getWidth ( ) ) {
methodArgumentTypeMismatchExceptionHandler: public CommonResult < ? > methodArgumentTypeMismatchExceptionHandler ( MethodArgumentTypeMismatchException ex ) { log . warn ( "SpringMVC 请求参数类型错误.[异常原因={}]" , ex . getMessage ( ) , ex ) ; return CommonResult . failed ( HttpStatus . BAD_REQUEST ,
updated: private void updated ( ) { pop ( ) ; received . run ( ) ;
reset: public void reset ( ) { this . playerData = null ;
assets: public AssetService assets ( ) { AssetService service = this . getService ( "com.scayle.adminapi.service.AssetService" ) ; return service ;
escape: public boolean escape ( ) { pushMenu ( new ExitMenu ( false ) ) ; return true ;
markSubscriberMessageFeedAs: public SubscriberNotificationResponse markSubscriberMessageFeedAs ( final MarkSubscriberFeedAsRequest request , final String subscriberId ) throws IOException , NovuNetworkException { Response < SubscriberNotificationResponse > response = subscribersApi . markSubscriberMessageFeedAs ( request , subscriberId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
init: private Event init ( String statId , float value ) { this . statId = statId ; this . value = value ; return this ;
updateStats: private void updateStats ( ) { if ( stats == null ) return ; stats . clear ( ) ; int goldPieces = BrainOutClient . ClientController . getUserProfile ( ) . getInt ( "ch" , 0 ) ; addStat ( String . valueOf ( goldPieces ) , "icon-big-gold" , - 8 , 68 ) ;
dropWeapon: private void dropWeapon ( ConsumableRecord weaponRecord ) { ItemData itemData = getController ( ) . dropConsumable ( weaponRecord . getId ( ) , getPlayerData ( ) . getAngle ( ) , 1 ) ; if ( itemData != null )
getEventObjectType: public String getEventObjectType ( ) { return eventObjectType ;
backupChannelToFile: public void backupChannelToFile ( Context context ) { Obdmobile . subscribeChannelBackups ( null , new RecvStream ( ) {
drawGridLine: protected void drawGridLine ( Canvas c , float x , float y , Path gridLinePath ) { gridLinePath . moveTo ( x , mViewPortHandler . contentBottom ( ) ) ; gridLinePath . lineTo ( x , mViewPortHandler . contentTop ( ) ) ; c . drawPath ( gridLinePath , mGridPaint ) ; gridLinePath . reset ( ) ;
setState: public void setState ( int state ) { this . state = state ;
createOrganizationRole: public Role createOrganizationRole ( String name , Set < PrivilegeBase > privileges , boolean removable ) { OrganizationRole role = new OrganizationRole ( name ) ; role . setPrivilegesSet ( privileges ) ; role . setRemovable ( removable ) ; repositories . unsecure . role . save ( role ) ; return repositories . unsecure . role . findByName ( name ) ;
refreshMenuData: public void refreshMenuData ( ) { mMenuDataHelper . requestFilterData ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; callback . cancelled ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { sdvcStop1ActionPerformed ( evt ) ;
leaveGroupDM: public static void leaveGroupDM ( long channelId ) { appSubscribe ( RestAPI . Companion . getApi ( ) . deleteChannel ( channelId ) ) ;
write: public void write ( Json json ) { json . writeValue ( "width" , blockWidth ) ; json . writeValue ( "height" , blockHeight ) ;
initData: private void initData ( final Context context ) { mWebView . setVerticalScrollBarEnabled ( false ) ; mWebView . setHorizontalScrollBarEnabled ( false ) ; mWebSettings = mWebView . getSettings ( ) ; if ( Build . VERSION . SDK_INT >= 19 ) { mWebSettings . setLoadsImagesAutomatically ( true ) ; } else { mWebSettings . setLoadsImagesAutomatically ( false ) ; } mWebSettings . setJavaScriptEnabled ( true ) ; mWebSettings . setRenderPriority ( RenderPriority . HIGH ) ; mWebSettings . setBlockNetworkImage ( false ) ; mWebSettings . setDatabaseEnabled ( true ) ; mWebSettings . setDatabasePath ( context . getCacheDir ( ) . getAbsolutePath ( ) ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { mWebSettings . setMixedContentMode ( WebSettings . MIXED_CONTENT_ALWAYS_ALLOW ) ; } mWebSettings . setDomStorageEnabled ( true ) ; mWebSettings . setAppCacheEnabled ( true ) ; mWebSettings . setAppCacheMaxSize ( 1024 * 1024 * 10 ) ; mWebSettings . setAppCachePath ( context . getCacheDir ( ) . getAbsolutePath ( ) ) ; mWebSettings . setAllowFileAccess ( true ) ; mWebSettings . setCacheMode ( WebSettings . LOAD_DEFAULT ) ; mWebSettings . setSupportZoom ( true ) ; mWebSettings . setNeedInitialFocus ( true ) ; mWebSettings . setLayoutAlgorithm ( WebSettings . LayoutAlgorithm . SINGLE_COLUMN ) ; mWebSettings . setLoadWithOverviewMode ( true ) ; mWebSettings . setUseWideViewPort ( true ) ; mWebSettings . setUserAgentString ( "" ) ; mWebSettings . setTextZoom ( 100 ) ; mWebView . setWebChromeClient ( new MyWebChromeClient ( context , mProgressBar ) ) ; mWebView . setWebViewClient ( new MyWebViewClient ( ) ) ; mWebViewLoadUtils = new WebViewLoadUtil ( mContext , mWebView ) ; mWebView . setDownloadListener ( mWebViewLoadUtils ) ; mWebSettings . setMediaPlaybackRequiresUserGesture ( false ) ;
initContent: protected void initContent ( Table data ) { super . initContent ( data ) ; valueEdit . setAlignment ( Align . center ) ;
jMenuItem1ActionPerformed: private void jMenuItem1ActionPerformed ( java . awt . event . ActionEvent evt ) { UI . createOrContinue ( TGUI . class , true , false ) ;
onBind: public IBinder onBind ( Intent intent ) { return null ;
getEffects: public EffectSetGroup getEffects ( ) { return effects ;
applyRelativeWorld: private void applyRelativeWorld ( ) { float mixRotate = this . mixRotate , mixX = this . mixX , mixY = this . mixY , mixScaleX = this . mixScaleX , mixScaleY = this . mixScaleY , mixShearY = this . mixShearY ; boolean translate = mixX != 0 || mixY != 0 ; Bone target = this . target ; float ta = target . a , tb = target . b , tc = target . c , td = target . d ; float degRadReflect = ta * td - tb * tc > 0 ? degRad : - degRad ; float offsetRotation = data . offsetRotation * degRadReflect , offsetShearY = data . offsetShearY * degRadReflect ; Object [ ] bones = this . bones . items ; for ( int i = 0 , n = this . bones . size ; i < n ; i ++ ) {
getNameTo: public String getNameTo ( ) { return nameTo ;
asmTest2: public void asmTest2 ( ) throws IOException , InterruptedException { ChangeResultMessage msg = new ChangeResultMessage ( ) ; msg . setClassName ( "w.core.ChangeTarget" ) ; msg . setMethod ( "hello" ) ; msg . setMode ( Codes . changeResultModeUseASM ) ; msg . setParamTypes ( Arrays . asList ( ) ) ; msg . setInnerMethod ( "getName" ) ; msg . setInnerClassName ( "*" ) ; msg . setBody ( "{$_= \"10086\";}" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; System . out . println ( target . hello ( ) ) ;
findActiveOrganizationIdsAsList: No method body
release: public void release ( ) { BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
valid: public boolean valid ( ) { return modesList . size > 0 ;
newObject: protected ShortArray newObject ( ) { return new ShortArray ( 16 ) ;
failed: No method body
removeBlock: public boolean removeBlock ( ConsumableRecord record , int layer , int x , int y ) { if ( ! isEnabled ( ) ) return false ; Map map = getMap ( ) ; if ( map == null ) return false ; { ChunkData chunk = map . getChunkAt ( ( int ) playerData . getX ( ) , ( int ) playerData . getY ( ) ) ; if ( chunk != null && chunk . hasFlag ( ChunkData . ChunkFlag . shootingDisabled ) ) return false ; } GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode != null && ! gameMode . isGameActive ( ) ) { return false ; } PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc . getInstrument ( record . getId ( ) ) != poc . getCurrentInstrument ( ) ) { if ( changeInstrument ( record . getId ( ) ) == null ) { return false ; } } InstrumentData currentInstrument = poc . getCurrentInstrument ( ) ; if ( ! ( currentInstrument instanceof PlaceBlockData ) ) return false ; PlaceBlockData placeBlockData = ( ( PlaceBlockData ) currentInstrument ) ; float maxDist = placeBlockData . getPlaceBlock ( ) . getMaxDistance ( ) + 1 ; if ( Vector2 . dst ( playerData . getX ( ) , playerData . getY ( ) , x , y ) <= maxDist ) { BlockData blockAt = map . getBlock ( x , y , layer ) ; if ( blockAt == null ) return false ; PlaceBlock placeBlock = placeBlockData . getPlaceBlock ( ) ; DropComponentData dcd = blockAt . getComponent ( DropComponentData . class ) ; if ( dcd != null ) { if ( ! dcd . getContentComponent ( ) . hasChance ( placeBlock . getID ( ) ) ) return false ; } BrainOut . EventMgr . sendEvent ( blockAt , DamageEvent . obtain ( placeBlock . getDamage ( ) , playerData . getId ( ) , currentInstrument . getInfo ( ) , null , x + 0.5f , y + 0.5f , 0 , Constants . Damage . DAMAGE_HIT ) ) ; sendUDPExceptDistance ( new OtherPlayerInstrumentLaunch ( playerData , currentInstrument ) ) ; return true ; } return false ;
load: public void load ( InputStream stream ) { try {
getUses: public int getUses ( ) { return uses ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
findListenersFlow: protected PageModelMap findListenersFlow ( String eventListenerSearchTerm , Specification < EventListenerEntry > eventListenerSpecification , Pageable eventListenerPageable ) { debug ( "[findListenersFlow]" ) ; return Flow . init ( )
dictionary: public < T extends SearchableEntity > Map dictionary ( Class < T > entityClass , String label , Function < Tuple , ? extends Stream < Tuple > > postQueryTupleMapper ) { CriteriaQuery < Tuple > q = getTupleCriteriaQuery ( entityClass , ID , label , label ) . distinct ( true ) ; List < Tuple > result = em . createQuery ( q ) . getResultList ( ) ; if ( postQueryTupleMapper != null ) { result = result . stream ( ) . flatMap ( postQueryTupleMapper ) . distinct ( ) . collect ( Collectors . toList ( ) ) ; } return toLinkedMap ( result ) ;
exitSideEffectBlock: public void exitSideEffectBlock ( ByteBuffer toWrite , ExitSideEffectSyscallCallback callback ) { syscallsExecutor . execute ( ( ) -> syscalls . exitSideEffectBlock ( toWrite , callback ) ) ;
getFirstName: No method body
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case activeActivateData : { ActivateActiveEvent ev = ( ( ActivateActiveEvent ) event ) ; call ( ev . client , ev . playerData ) ; return true ; } } return false ;
updateAnimation: private void updateAnimation ( ) { skeleton . setPosition ( getX ( ) + getWidth ( ) / 2.0f , getY ( ) + getHeight ( ) / 2.0f ) ;
copy: public Attachment copy ( ) { BoundingBoxAttachment copy = new BoundingBoxAttachment ( name ) ; copyTo ( copy ) ; copy . color . set ( color ) ; return copy ;
add: public final void add ( Vector3 other ) { x += other . x ; y += other . y ; z += other . z ;
hasRender: public boolean hasRender ( ) { return true ;
remove: private void remove ( JsonValue parent , JsonValue child ) { if ( child . prev == null ) { parent . child = child . next ; if ( parent . child != null ) { parent . child . prev = null ; } } else { child . prev . next = child . next ; if ( child . next != null ) { child . next . prev = child . prev ; } } -- parent . size ;
getComponent: public CollisionDetectorComponentData getComponent ( ComponentObject componentObject ) { return new CollisionDetectorComponentData ( ( ActiveData ) componentObject , this ) ;
checkEnemy: private boolean checkEnemy ( ) { GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; float maxDistance = 96f ; Array < ActiveData > a = getMap ( ) . getActivesForTag ( Constants . ActiveTags . PLAYERS , activeData -> { if ( activeData == getPlayerData ( ) ) return false ; if ( ! ( activeData instanceof PlayerData ) ) return false ; if ( activeData . getOwnerId ( ) >= 0 && getPlayerData ( ) . getOwnerId ( ) >= 0 ) { if ( ! gameMode . isEnemies ( activeData . getOwnerId ( ) , getPlayerData ( ) . getOwnerId ( ) ) ) return false ; } else { if ( ! gameMode . isEnemiesActive ( activeData , getPlayerData ( ) ) ) return false ; } return getController ( ) . checkVisibility ( activeData , maxDistance , null ) ; } ) ; if ( a . size > 0 ) { attack ( a . random ( ) ) ; return true ; } return false ;
notifyDataSetChanged: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesOpen6ActionPerformed ( evt ) ;
getCredential: public String getCredential ( ) { return credential ;
getSelection: public InstrumentSelection getSelection ( ) { return new InstrumentSelection ( ) ;
run: public Stream < T > run ( final T input ) { return Stream . of ( input ) ;
colorMap: public byte [ ] colorMap ( ) { byte [ ] map = new byte [ 3 * netsize ] ; int [ ] index = new int [ netsize ] ; for ( int i = 0 ; i < netsize ; i ++ ) index [ network [ i ] [ 3 ] ] = i ; int k = 0 ; for ( int i = 0 ; i < netsize ; i ++ ) { int j = index [ i ] ; map [ k ++ ] = ( byte ) ( network [ j ] [ 0 ] ) ; map [ k ++ ] = ( byte ) ( network [ j ] [ 1 ] ) ; map [ k ++ ] = ( byte ) ( network [ j ] [ 2 ] ) ; } return map ;
getRoleNamesToAdd: private Set < String > getRoleNamesToAdd ( Map < String , Boolean > roles ) { debug ( "[getRoleNamesToAdd]" ) ; return roles . entrySet ( ) . stream ( ) . filter ( Map . Entry :: getValue ) . map ( Map . Entry :: getKey ) . collect ( Collectors . toSet ( ) ) ;
updateChannelPolicy: public Single < lnrpc . LightningOuterClass . PolicyUpdateResponse > updateChannelPolicy ( lnrpc . LightningOuterClass . PolicyUpdateRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . updateChannelPolicy ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
getAxisDependency: No method body
getFormTableNames: private Map < String , String > getFormTableNames ( Map < String , Object > configsFromZip ) { return configsFromZip . values ( ) . stream ( )
setLabels: public void setLabels ( List < String > labels ) { this . mLabels = labels ;
getNewValue: public Long getNewValue ( ) { return newValue ;
isInitializationProfile: public static boolean isInitializationProfile ( ) { return isActiveProfile ( INITIALIZATION_PROFILE ) ;
getRefreshView: No method body
listInvoices: public Single < lnrpc . LightningOuterClass . ListInvoiceResponse > listInvoices ( lnrpc . LightningOuterClass . ListInvoiceRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . oBListInvoices ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
update: public void update ( ) { condenserPump . update ( ) ; double condensedWaterMass = 0 , deltaCondensedSteamMass , deltaSteamMass , potentialPressure ; feedwaterTemperature -= ( 0.5 * feedwaterTemperature - 10 ) * 0.000005 ; double [ ] waterInflowData = NPPMath . mixWater ( waterMass , waterTemperature , condenserPump . flow * 25 , condenserPump . source . getWaterTemperature ( ) ) ; waterMass = waterInflowData [ 0 ] ; waterTemperature = waterInflowData [ 1 ] ; if ( initialSteamMass <= 0 ) { steamMass += initialSteamMass ; initialSteamMass = 0 ; steamMass -= steamOutflow ; } else { initialSteamMass -= steamOutflow ; } if ( pressure > 0.10142 ) { steamMass -= ( pressure - 0.10142 ) * 6000 ; } if ( steamMass <= 0 ) { steamMass = 0 ; } Double steamInFlowData [ ] = NPPMath . mixSteam ( steamMass , feedwaterTemperature , steamInflow , steamInflowTemperature ) ; steamMass = steamInFlowData [ 0 ] ; steamTemperature = steamInFlowData [ 1 ] ; initialSteamMass += ( steamInflow / 60 * 0.06 + ( 0.10142 - pressure ) ) / 20 ; feedwaterMass -= feedwaterOutflow ; double condensedSteamEnergy = Loader . tables . getSteamEnthalpyByTemperature ( steamTemperature ) * steamMass ; steamTemperature = waterTemperature * ( 1 + steamTemperature / waterTemperature / 30 * ( 1 - waterTemperature / steamTemperature ) * 1.084337735 ) ; condensedSteamEnergy -= Loader . tables . getSteamEnthalpyByTemperature ( steamTemperature ) * steamMass ; double steamEnergy = 0 - deltaSteamEnergy / 3 ; deltaSteamEnergy -= deltaSteamEnergy / 3 ; waterTemperature += ( ( condensedSteamEnergy + steamEnergy ) / ( NPPMath . calculateSpecificHeatWater ( waterTemperature ) * waterMass ) ) ; potentialPressure = Loader . tables . getSteamPressureByTemp ( steamTemperature ) ; specificDensityFeedwater = Loader . tables . getWaterDensityByTemp ( feedwaterTemperature ) ; feedwaterVolume = feedwaterMass * specificDensityFeedwater ; steamVolume = volume - feedwaterVolume ; deltaCondensedSteamMass = steamVolume / Loader . tables . getSteamDensityByPressure ( potentialPressure ) - ( steamMass + initialSteamMass ) ; if ( steamMass + deltaCondensedSteamMass < 0 ) { deltaCondensedSteamMass = 0 - steamMass ; } deltaSteamEnergy += deltaCondensedSteamMass * Loader . tables . getSpecificVaporEnthalpyByTemperature ( steamTemperature ) ; condensedWaterMass -= deltaCondensedSteamMass ; steamMass += deltaCondensedSteamMass ; double oldFeedwaterMass = feedwaterMass ; double [ ] feedwaterInflowData = NPPMath . mixWater ( feedwaterMass , feedwaterTemperature , condensedWaterMass , steamTemperature ) ; feedwaterMass = feedwaterInflowData [ 0 ] ; feedwaterTemperature = feedwaterInflowData [ 1 ] ; condensationRate = oldFeedwaterMass < feedwaterMass ? feedwaterMass - oldFeedwaterMass : 0 ; double energy = 0 - deltaEnergy / 3 ; deltaEnergy -= deltaEnergy / 3 ; feedwaterTemperature += energy / ( NPPMath . calculateSpecificHeatWater ( feedwaterTemperature ) * feedwaterMass ) ; potentialPressure = Loader . tables . getSteamPressureByTemp ( feedwaterTemperature ) ; if ( potentialPressure > pressure ) { specificDensityFeedwater = Loader . tables . getWaterDensityByTemp ( feedwaterTemperature ) ; feedwaterVolume = feedwaterMass * specificDensityFeedwater ; steamVolume = volume - feedwaterVolume ; deltaSteamMass = steamVolume / Loader . tables . getSteamDensityByPressure ( potentialPressure ) - ( steamMass + initialSteamMass ) ; if ( steamMass + deltaSteamMass < 0 ) { deltaSteamMass = 0 - steamMass ; } deltaEnergy += deltaSteamMass * Loader . tables . getSpecificVaporEnthalpyByTemperature ( feedwaterTemperature ) ; feedwaterMass -= deltaSteamMass ; steamMass += deltaSteamMass ; } waterOutflow = waterMass * Loader . tables . getWaterDensityByTemp ( waterTemperature ) - volumeWaterSide ; waterMass -= waterOutflow ; specificDensityFeedwater = Loader . tables . getWaterDensityByTemp ( feedwaterTemperature ) ; feedwaterVolume = feedwaterMass * specificDensityFeedwater ; feedwaterLevel = ( feedwaterVolume / nominalFeedwaterVolume - 1 ) * 100 ; steamVolume = volume - feedwaterVolume ; steamDensity = steamVolume / ( steamMass + initialSteamMass ) ; pressure = Loader . tables . getSteamPressureByDensity ( steamDensity ) ; feedwaterOutflowRate = feedwaterOutflow ; feedwaterOutflow = 0 ; resetFlows ( ) ; waterLevel = feedwaterLevel ;
getChambered: public int getChambered ( ) { return chambered ;
awaitAny: No method body
deleteCustomDataForKey: public void deleteCustomDataForKey ( Identifier campaignId , String key , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/campaigns/%s/custom-data/%s" , campaignId , key ) , query , null , null ) ;
getBuyerCompanyCountry: public String getBuyerCompanyCountry ( ) { return buyerCompanyCountry ;
keyTyped: public boolean keyTyped ( char character ) { return ui . keyTyped ( character ) || super . keyTyped ( character ) ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , String datalistId , FieldType type , String additionalCss , BiFunction < DtoAndEntity , SecureEntityDictionaryRepository , Object > datalistSupplier , PrivilegeBase requiredReadPrivilege , PrivilegeBase requiredWritePrivilege ) { return new FrontendMappingFieldDefinition ( formName , name , type , null , null , requiredReadPrivilege ,
calculateHash: public static long calculateHash ( String name ) { InputStream packageStream ; try { File packageFile = packageFile ( name ) ; packageStream = new BufferedInputStream ( new FileInputStream ( packageFile ) ) ; } catch ( Exception e ) { return - 1 ; } CRC32 crc = new CRC32 ( ) ; crc . reset ( ) ; try { byte buff [ ] = new byte [ 65535 ] ; int read ; while ( ( read = packageStream . read ( buff ) ) != - 1 ) { crc . update ( buff , 0 , read ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; return - 1 ; } return crc . getValue ( ) ;
onInterceptTouchEvent: public boolean onInterceptTouchEvent ( MotionEvent event ) { if ( isCanScroll ) { return super . onInterceptTouchEvent ( event ) ; } return false ;
source: No method body
drawValues: public void drawValues ( Canvas c ) { if ( isDrawingValuesAllowed ( mChart ) ) {
update: public void update ( float dt ) { super . update ( dt ) ; zombieState . update ( dt ) ; updateFollow ( dt ) ;
hasRender: public boolean hasRender ( ) { return false ;
getFlags: public int getFlags ( ) { return 0 ;
getFirstLogin: public String getFirstLogin ( ) { return firstLogin ;
setDimension: public void setDimension ( String dimension ) { this . dimension = dimension ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; postEffects . dispose ( ) ; BrainOutClient . MusicMng . stopMusic ( ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . csGame , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . killedBy , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . modeWillFinish , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . popup , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . screenSizeUpdated , this ) ; this . actionPhaseMenu = null ;
getDistantChangeTo: public float getDistantChangeTo ( ) { return distantChangeTo ;
updateCache: public void updateCache ( ) { cacheList . orderedKeys ( ) . sort ( this ) ; if ( cache == null ) return ; Map map = getMap ( ) ; if ( map == null ) return ; cache . clear ( ) ; cache . beginCache ( ) ; for ( Cacheble entry : cacheList . values ( ) ) { entry . cache ( map , cache ) ; } cacheId = cache . endCache ( ) ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "Exception while deleting payment probe." ) ; LogUtils . e ( TAG , e . getMessage ( ) ) ;
toAuditString: public String toAuditString ( ) { return name ;
formMapToForm: public static < T > T formMapToForm ( Map < String , Object > map , Class < T > formClass ) { return om . convertValue ( map , formClass ) ;
getType: public MessageType getType ( ) { return type ;
setText: public ViewHolder setText ( int viewId , CharSequence text ) { TextView tv = getView ( viewId ) ; if ( tv != null ) { tv . setText ( text ) ; } return this ;
onDraw: public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { super . onDraw ( c , parent , state ) ; if ( mOrientation == VERTICAL_LINE ) {
isAppBarLayoutOpen: public static boolean isAppBarLayoutOpen ( int verticalOffset ) { return verticalOffset >= 0 ;
supplyContextData: public Map < String , String > supplyContextData ( ) { SyscallsInternal syscalls = ( SyscallsInternal ) HandlerRunner . SYSCALLS_THREAD_LOCAL . get ( ) ; if ( syscalls == null ) { return Collections . emptyMap ( ) ; } HashMap < String , String > m = new HashMap < > ( 3 ) ; m . put ( RestateEndpoint . LoggingContextSetter . INVOCATION_ID_KEY , syscalls . request ( ) . invocationId ( ) . toString ( ) ) ; m . put ( RestateEndpoint . LoggingContextSetter . INVOCATION_TARGET_KEY , syscalls . getFullyQualifiedMethodName ( ) ) ; m . put ( RestateEndpoint . LoggingContextSetter . INVOCATION_STATUS_KEY , syscalls . getInvocationState ( ) . toString ( ) ) ; return m ;
packagePath: public static String packagePath ( Context context ) { return StorageUtils . SDCardPath ( ) + File . separator + context . getPackageName ( ) ;
onRefreshing: No method body
update: public void update ( ) { checkAlarms ( ) ; if ( this . isVisible ( ) ) {
getTransY: public float getTransY ( ) { return mTransY ;
getT1: public Object getT1 ( ) { return list [ 0 ] ;
sendChanges: public void sendChanges ( ) { angle = playerData . getAngle ( ) ; sendPlayerData ( false , 1 ) ;
readTask: protected void readTask ( JsonValue jsonData ) { super . readTask ( jsonData ) ; give = new ItemsCollection ( jsonData . get ( "give" ) ) ; botTask = jsonData . getString ( "bot-task" ) ; goTo = jsonData . getString ( "go-to" ) ; skin = BrainOutServer . ContentMgr . get ( jsonData . getString ( "skin" ) , PlayerSkin . class ) ; spawnAt = jsonData . getString ( "spawn-at" ) ; placeNearbyAt = jsonData . getString ( "place-nearby-at" , null ) ; if ( placeNearbyAt != null ) { placeNearby = new ItemsCollection ( jsonData . get ( "place-nearby" ) ) ; } spawnAtDimension = jsonData . getString ( "spawn-at-dimension" ) ;
dictionary: public < T extends SearchableEntity > Map dictionary ( Class < T > entityClass , String keyField , String labelField ) { return dictionary ( entityClass , keyField , labelField , labelField ) ;
send: default < Req > SendResponse send ( Target target , Serde < Req > reqSerde , Req req , @ Nullable Duration delay ) throws IngressException { return send ( target , reqSerde , req , delay , RequestOptions . DEFAULT ) ;
getPathToContentFile: public String getPathToContentFile ( Form entity ) { String orgPath = entity . getOrganizationId ( ) == null ? "" : SUBDIR_ORGANIZATION_PREFIX + entity . getOrganizationId ( ) + "/" ; String entityExportPath = FORM_ + orgPath ; return EXPORT_CODE_PATH_ + entityExportPath + String . format ( "%s.js" , entity . getName ( ) ) ;
isCompleted: No method body
run: public void run ( WorkflowContext context , String myInput ) { var client = MyWorkflowClient . fromContext ( context , context . key ( ) ) ; client . send ( ) . sharedHandler ( myInput ) ;
set: public void set ( T value ) { if ( container == null ) return ; container . set ( key , value ) ;
getID: public ID getID ( ) { return ID . modeWillFinish ;
update: public void update ( float dt ) { Map map = getMap ( ) ; if ( map == null ) return ; super . update ( dt ) ; float stepDt = dt / ( float ) Constants . Core . BULLET_UPDATE_STEPS ; float speedLength = speed . len ( ) ; tmpStart . set ( position ) . scl ( Constants . Physics . SCALE ) ; tmpEnd . set ( tmpStart ) . add ( speed . x * dt * 1.05f * Constants . Physics . SCALE , speed . y * dt * 1.05f * Constants . Physics . SCALE ) ; if ( ! tmpStart . equals ( tmpEnd ) ) { World world = map . getPhysicWorld ( ) ; if ( world == null ) return ; world . rayCast ( this :: collision , tmpStart , tmpEnd ) ; if ( done ) return ; } for ( int i = 0 ; i < Constants . Core . BULLET_UPDATE_STEPS ; i ++ ) { float oldX = position . x , oldY = position . y ; position . add ( speed . x * stepDt , speed . y * stepDt ) ; float r = ( float ) Math . atan2 ( speed . y , speed . x ) ; angle = ( float ) Math . toDegrees ( r ) ; speed . y -= mass * 12.0f * stepDt ; power -= powerResponse * speedLength * stepDt ; int blockX = ( int ) position . x , blockY = ( int ) position . y ; BlockData blockData = map . getBlockAt ( blockX , blockY , Constants . Layers . BLOCK_LAYER_FOREGROUND ) ; if ( blockData != null && ! blockData . isContact ( this , position . x - ( int ) position . x , position . y - ( int ) position . y , null , speed , TMP , 0 , map , blockX , blockY ) ) { blockData = null ; } if ( blockIn != blockData ) { LaunchData hitLaunchData = null ; if ( ( blockIn == null ) != ( blockData == null ) ) { if ( blockData != null ) { if ( bullet . isHitEffectNormal ( ) ) { hitLaunchData = blockData . calculateContact ( getLaunchData ( ) , new PointLaunchData ( oldX , oldY , getAngle ( ) , getDimension ( ) ) , true , map , blockX , blockY ) ; } else { hitLaunchData = new PointLaunchData ( oldX , oldY , getAngle ( ) , getDimension ( ) ) ; } BrainOut . EventMgr . sendEvent ( this , LaunchEffectEvent . obtain ( LaunchEffectEvent . Kind . hit , hitLaunchData ) ) ; if ( bullet . isBlockEffectEnabled ( ) ) { BrainOut . EventMgr . sendEvent ( blockData , LaunchEffectEvent . obtain ( LaunchEffectEvent . Kind . hit , hitLaunchData ) ) ; } if ( blockData . getCreator ( ) . hasComponent ( BlockHitConfirmationComponent . class ) ) { BrainOut . EventMgr . sendEvent ( BlockHitConfirmationEvent . obtain ( playerData , blockData , blockX , blockY , map . getDimensionId ( ) , ( int ) calculateDamage ( ) ) ) ; } } else { if ( bullet . isHitEffectNormal ( ) ) { hitLaunchData = blockIn . calculateContact ( new PointLaunchData ( oldX , oldY , getAngle ( ) , getDimension ( ) ) , getLaunchData ( ) , false , map , blockX , blockY ) ; } else { hitLaunchData = new PointLaunchData ( oldX , oldY , getAngle ( ) , getDimension ( ) ) ; } BrainOut . EventMgr . sendEvent ( this , LaunchEffectEvent . obtain ( LaunchEffectEvent . Kind . hit , hitLaunchData ) ) ; if ( bullet . isBlockEffectEnabled ( ) ) { BrainOut . EventMgr . sendEvent ( blockIn , LaunchEffectEvent . obtain ( LaunchEffectEvent . Kind . hit , hitLaunchData ) ) ; } } } if ( blockData != null ) { float damage = bullet . calculateDamage ( blockData . limitPower ( power ) , getDamage ( ) ) ; BrainOut . EventMgr . sendEvent ( blockData , DamageBlockEvent . obtain ( map , damage , blockX , blockY , Constants . Layers . BLOCK_LAYER_FOREGROUND , instrumentInfo , this ) ) ; } } blockIn = blockData ; if ( blockIn != null ) { power -= blockIn . getCreator ( ) . getResist ( ) * stepDt ; if ( power <= 0 ) { done = true ; return ; } } if ( power > 0 ) { collide ( position . x , position . y ) ; } } time -= dt ; distance += speed . len ( ) * dt ;
addRemoteClient: public void addRemoteClient ( int id , String name , String avatar , String clanAvatar , String clanId , String teamId , PlayerRights rights , JSONObject info ) { Team team = ( ( Team ) BrainOut . ContentMgr . get ( teamId ) ) ; RemoteClient remoteClient = getRemoteClients ( ) . get ( id ) ; if ( remoteClient == null )
newReward: protected Reward newReward ( ) { return new Reward ( ) ;
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { json . writeObjectStart ( "score" ) ; for ( ObjectMap . Entry < Team , Integer > point : score ) { json . writeValue ( point . key . getID ( ) , point . value ) ; } json . writeObjectEnd ( ) ; json . writeObjectStart ( "alive" ) ; for ( ObjectMap . Entry < Team , TeamState > alive : this . alive ) { json . writeValue ( alive . key . getID ( ) , alive . value ) ; } json . writeObjectEnd ( ) ; json . writeValue ( "target" , targetScore ) ; json . writeValue ( "round" , round ) ; json . writeValue ( "roundState" , state . toString ( ) ) ; super . write ( json , componentWriter , owner ) ;
isPinned: public static boolean isPinned ( Object o ) { if ( PINNED_IDS . size ( ) == 0 ) return false ; long id = StoreUtils . getId ( o ) ; return id > 0 && PINNED_IDS . contains ( id ) ;
deleteMenu: public void deleteMenu ( @ NonNull Long menuId ) { eventPublisher . publishEvent ( new ClearCacheEvent ( "system" ) ) ; Assert . isTrue ( this . baseMapper . deleteById ( menuId ) > 0 , "删除菜单失败！" ) ;
load: public void load ( ) { this . data = BrainOutServer . Controller . loadMaps ( this . map , ServerConstants . Maps . MAP_KEY ) ;
canSpawn: public SpawnMode canSpawn ( Team team ) { return SpawnMode . allowed ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
getEntryForHighlight: public Entry getEntryForHighlight ( Highlight highlight ) { return getDataSetByIndex ( highlight . getDataSetIndex ( ) ) . getEntryForIndex ( ( int ) highlight . getX ( ) ) ;
updateOffset: public void updateOffset ( float x , float y ) { for ( UpdateOffsetCallback callback : offsetCallbacks )
init: public void init ( PlayState . InitCallback callback ) { BrainOutClient . MusicMng . stopMusic ( ) ; UserProfile profile = BrainOutClient . ClientController . getUserProfile ( ) ; geiger = BrainOutClient . ContentMgr . get ( "consumable-item-geiger" , ConsumableContent . class ) ; BrainOut . ContentMgr . queryContentGen ( Tree . class , tree -> { if ( ! tree . isActive ( profile , BrainOutClient . ClientController . getMyAccount ( ) ) ) return ; Quest current = tree . getCurrentQuest ( profile , BrainOutClient . ClientController . getMyAccount ( ) ) ; if ( current == null ) return ; if ( current . isCoop ( ) && ! hasParty ( ) ) { return ; } activeQuests . add ( current ) ; } ) ; super . init ( callback ) ;
genLabel: public Span genLabel ( ) { Span txt = new Span ( "" ) ; txt . getStyle ( ) . set ( "color" , "var(--lumo-base-color)" ) ; txt . getStyle ( ) . set ( "text-align" , "center" ) ; txt . getStyle ( ) . set ( "padding-left" , "10px" ) ; txt . getStyle ( ) . set ( "padding-right" , "10px" ) ; txt . getStyle ( ) . set ( "border-radius" , "10px" ) ; return txt ;
convertAndSave: public Scheduler convertAndSave ( SchedulerConversionDto dto , String filePath , Map < String , String > resources ) { Scheduler scheduler = convertAndSave ( dto , filePath ) ; services . scheduler . schedule ( scheduler ) ; return scheduler ;
getThenStatements: public Map < Long , Map < StatementKey , Object > > getThenStatements ( ) { return thenStatements ;
shouldOverrideUrlLoading: public boolean shouldOverrideUrlLoading ( WebView view , String url ) { return false ;
tryGet: public < T > T tryGet ( Class < T > clazz , Supplier < T > producer ) { if ( ! requestSessionCacheEnabled ) { return producer . get ( ) ; } @ SuppressWarnings ( "unchecked" ) CacheObject < T > cache = objectCache . get ( clazz ) ; if ( cache == null ) { objectCache . put ( clazz , cache = new CacheObject < T > ( ) ) ; } Lock writeLock = cache . cacheLock . writeLock ( ) ; writeLock . lock ( ) ; T object = null ; try { RequestSessionContextMetadata < T > requestSessionMeta = getRequestSessionMetadata ( ) ; if ( requestSessionMeta == null ) { debug ( ">>> [preHandle] no request context, getting object" ) ; object = producer . get ( ) ; return object ; } RequestSessionContextMetadata < T > cachedRequestSessionMeta = cache . cacheMap . get ( requestSessionMeta . getSessionId ( ) ) ; if ( cachedRequestSessionMeta != null && cachedRequestSessionMeta . getTimestamp ( ) == requestSessionMeta . getTimestamp ( ) ) { debug ( "=== [preHandle] using cached object {}" , clazz ) ; object = cachedRequestSessionMeta . getCached ( ) ; } else { debug ( ">>> [preHandle] getting object {}" , clazz ) ; object = producer . get ( ) ; debug ( "<<<[preHandle] got object {}" , clazz ) ; requestSessionMeta . setCached ( object ) ; cache . cacheMap . put ( requestSessionMeta . getSessionId ( ) , requestSessionMeta ) ; } } finally { try { writeLock . unlock ( ) ; } catch ( Throwable th ) { error ( "Could not unlock {}" , th . getMessage ( ) ) ; } } return object ;
deleteByModule: No method body
addComponent: private void addComponent ( ContentComponent component ) { components . add ( component ) ; componentsIndex . put ( component . getContentClass ( ) , component ) ;
init: protected void init ( ) { super . init ( ) ; mAxisLeft = new YAxis ( AxisDependency . LEFT ) ; mAxisRight = new YAxis ( AxisDependency . RIGHT ) ; mLeftAxisTransformer = new Transformer ( mViewPortHandler ) ; mRightAxisTransformer = new Transformer ( mViewPortHandler ) ; mAxisRendererLeft = new YAxisRenderer ( mViewPortHandler , mAxisLeft , mLeftAxisTransformer ) ; mAxisRendererRight = new YAxisRenderer ( mViewPortHandler , mAxisRight , mRightAxisTransformer ) ; mXAxisRenderer = new XAxisRenderer ( mViewPortHandler , mXAxis , mLeftAxisTransformer ) ; setHighlighter ( new ChartHighlighter ( this ) ) ; mChartTouchListener = new BarLineChartTouchListener ( this , mViewPortHandler . getMatrixTouch ( ) , 3f ) ; mGridBackgroundPaint = new Paint ( ) ; mGridBackgroundPaint . setStyle ( Style . FILL ) ; mGridBackgroundPaint . setColor ( Color . rgb ( 240 , 240 , 240 ) ) ; mBorderPaint = new Paint ( ) ; mBorderPaint . setStyle ( Style . STROKE ) ; mBorderPaint . setColor ( Color . BLACK ) ; mBorderPaint . setStrokeWidth ( Utils . convertDpToPixel ( 1f ) ) ;
annotationType: public Class < ? extends Annotation > annotationType ( ) { return DynamicGreeter . class ;
setBones: public void setBones ( @ Null int [ ] bones ) { this . bones = bones ;
getType: public final String getType ( ) { return null ;
getXMax: public float getXMax ( ) { return mXMax ;
getPowerUsage: public float getPowerUsage ( ) { return powerUsage ;
attributeTranslations: public AttributeTranslationService attributeTranslations ( ) { AttributeTranslationService service = this . getService ( "com.scayle.adminapi.service.AttributeTranslationService" ) ; return service ;
getTokenFromLocal: public static String getTokenFromLocal ( Context context ) { return getString ( SETTINGS , context , KEY_TOKEN , "" ) ;
setStaticData4: public void setStaticData4 ( String staticData4 ) { this . staticData4 = staticData4 ;
saveBtcPriceToLocal: public static void saveBtcPriceToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_BTC_PRICE , value ) ;
init: public void init ( ) { soundDistance = soundEffect . getSoundDistance ( ) ;
setWorldY: public void setWorldY ( float worldY ) { this . worldY = worldY ;
getPlanName: public String getPlanName ( ) { return planName ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case componentUpdated : { ComponentUpdatedEvent ev = ( ( ComponentUpdatedEvent ) event ) ; if ( ev . component instanceof PlayerBoostersComponentData ) { BrainOutClient . EventMgr . sendDelayedEvent ( SimpleEvent . obtain ( SimpleEvent . Action . playerInfoUpdated ) ) ; } break ; } case consumable : { PlayerOwnerComponent poc = getPlayerData ( ) . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return false ; ConsumableEvent consumableEvent = ( ( ConsumableEvent ) event ) ; ConsumableRecord record = consumableEvent . record ; switch ( consumableEvent . action ) { case added : { initRecord ( record ) ; if ( poc . getCurrentInstrument ( ) == null && record . getItem ( ) instanceof InstrumentConsumableItem ) { switchInstrument ( record , null ) ; } break ; } case removed : { if ( record == poc . getCurrentInstrumentRecord ( ) ) { switchInstrument ( null , null ) ; } break ; } } break ; } case selectPreviousSlot : { if ( currentSlot >= 0 && previousSlot >= 0 ) { if ( selectSlot ( previousSlot , previousMode ) ) { int tmp = previousSlot ; previousSlot = currentSlot ; currentSlot = tmp ; String tmp2 = previousMode ; previousMode = currentMode ; currentMode = tmp2 ; } } break ; } case selectSlot : { SelectSlotEvent e = ( ( SelectSlotEvent ) event ) ; if ( selectSlot ( e . slot , e . mode ) ) { previousSlot = currentSlot ; currentSlot = e . slot ; previousMode = currentMode ; currentMode = e . mode ; return true ; } break ; } case gameController : { GameControllerEvent gcEvent = ( GameControllerEvent ) event ; switch ( gcEvent . action ) { case switchWeapon : { switchInstrument ( ) ; updatePlayerData ( ) ; break ; } case move : { setMoveDirection ( gcEvent . data ) ; break ; } case aim : { controller = gcEvent . flag ; setAimDirection ( gcEvent . data , false ) ; break ; } case absoluteAim : { setAimDirection ( gcEvent . data , true ) ; break ; } case dropInstrument : { dropInstrument ( ) ; break ; } case dropAmmo : { dropAmmo ( ) ; break ; } case beginSit : { squatFlag = false ; if ( state == Player . State . run && runFlag ) { setPositionMode ( PositionMode . crouch ) ; } else { setPositionMode ( PositionMode . sit ) ; } sitFlag = true ; return true ; } case squat : { if ( BrainOutClient . ClientController . isFreePlay ( ) ) { if ( state == Player . State . squat ) { setPositionMode ( PositionMode . normal ) ; squatFlag = false ; } else { setPositionMode ( PositionMode . squat ) ; squatFlag = true ; } } return true ; } case endSit : { squatFlag = false ; setPositionMode ( PositionMode . normal ) ; sitFlag = false ; return true ; } case beginRun : { squatFlag = false ; if ( state == Player . State . sit ) { setPositionMode ( PositionMode . crouch ) ; } else { setRun ( true ) ; } runFlag = true ; return true ; } case endRun : { squatFlag = false ; if ( state == Player . State . crawl && sitFlag ) { setPositionMode ( PositionMode . sit ) ; } else { setRun ( false ) ; } runFlag = false ; return true ; } case switchZoom : { switchZoom ( ) ; return true ; } case activate : { if ( activate ( ) ) { return true ; } InstrumentData currentInstrument = getPlayerData ( ) . getCurrentInstrument ( ) ; if ( currentInstrument != null ) { if ( currentInstrument . onEvent ( event ) ) { return true ; } } } } break ; } case hitConfirmed : { HitConfirmEvent e = ( ( HitConfirmEvent ) event ) ; showHitMarker ( e . collider , e . x , e . y , e . dmg , e . d ) ; break ; } case damaged : { DamagedEvent damaged = ( DamagedEvent ) event ; if ( damaged . data == getPlayerData ( ) ) { showDamageMarker ( damaged . x , damaged . y , damaged . angle ) ; if ( damaged . content instanceof Bullet ) { Bullet bullet = ( ( Bullet ) damaged . content ) ; ClientMap map = ( ( ClientMap ) getMap ( ) ) ; if ( map != null ) map . shake ( bullet . getHitShake ( ) ) ; } updatePlayerData ( ) ; } break ; } case ammoLoaded : { PlayerOwnerComponent poc = getPlayerData ( ) . getComponent ( PlayerOwnerComponent . class ) ; ConsumableContainer container = poc . getConsumableContainer ( ) ; AmmoLoadedEvent ale = ( ( AmmoLoadedEvent ) event ) ; ConsumableRecord bullets = container . get ( ale . bulletsId ) ; if ( bullets != null && bullets . getItem ( ) . getContent ( ) instanceof Bullet ) { if ( bullets . getAmount ( ) - ale . ammoCount > 0 ) { bullets . setAmount ( bullets . getAmount ( ) - ale . ammoCount ) ; } else if ( bullets . getAmount ( ) - ale . ammoCount <= 0 ) { container . removeRecord ( bullets ) ; } container . updateWeight ( ) ; BrainOut . EventMgr . sendDelayedEvent ( SimpleEvent . obtain ( SimpleEvent . Action . consumablesUpdated ) ) ; } break ; } } return false ;
updateTenant: No method body
getAdditionalSettings: public ServerSettings . BaseConditions getAdditionalSettings ( ) { return null ;
acquireMode: public ServerSettings . GameModeConditions acquireMode ( ) { return mode ;
getContentView: protected int getContentView ( ) { return R . layout . activity_backup_channel ;
test_updateLayout: public void test_updateLayout ( ) throws IOException , NovuNetworkException , InterruptedException { LayoutRequest layoutRequest = new LayoutRequest ( ) ; layoutRequest . setName ( "name" ) ; layoutRequest . setContent ( "content" ) ; layoutRequest . setDescription ( "desc" ) ; layoutRequest . setIsDefault ( false ) ; GetLayoutResponse getLayoutResponse = new GetLayoutResponse ( ) ; LayoutResponse layoutResponse = new LayoutResponse ( ) ; layoutResponse . setName ( "name" ) ; layoutResponse . setContent ( "content" ) ; getLayoutResponse . setData ( layoutResponse ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( getLayoutResponse ) ) ) ; GetLayoutResponse response = layoutHandler . updateLayout ( "bat-123" , layoutRequest ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/layouts/bat-123" , request . getPath ( ) ) ; assertEquals ( "PATCH" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( getLayoutResponse ) , gson . toJson ( response ) ) ;
changeStatus: No method body
cancelTriggeredEvent: public CancelEventResponse cancelTriggeredEvent ( final String transactionId ) throws IOException , NovuNetworkException { try {
testGetEntryForXValue: public void testGetEntryForXValue ( ) { List < Entry > entries = new ArrayList < Entry > ( ) ; entries . add ( new Entry ( 10 , 10 ) ) ; entries . add ( new Entry ( 15 , 5 ) ) ; entries . add ( new Entry ( 21 , 5 ) ) ; ScatterDataSet set = new ScatterDataSet ( entries , "" ) ; Entry closest = set . getEntryForXValue ( 17 , Float . NaN , DataSet . Rounding . CLOSEST ) ; assertEquals ( 15 , closest . getX ( ) , 0.01f ) ; assertEquals ( 5 , closest . getY ( ) , 0.01f ) ; closest = set . getEntryForXValue ( 17 , Float . NaN , DataSet . Rounding . DOWN ) ; assertEquals ( 15 , closest . getX ( ) , 0.01f ) ; assertEquals ( 5 , closest . getY ( ) , 0.01f ) ; closest = set . getEntryForXValue ( 15 , Float . NaN , DataSet . Rounding . DOWN ) ; assertEquals ( 15 , closest . getX ( ) , 0.01f ) ; assertEquals ( 5 , closest . getY ( ) , 0.01f ) ; closest = set . getEntryForXValue ( 14 , Float . NaN , DataSet . Rounding . DOWN ) ; assertEquals ( 10 , closest . getX ( ) , 0.01f ) ; assertEquals ( 10 , closest . getY ( ) , 0.01f ) ; closest = set . getEntryForXValue ( 17 , Float . NaN , DataSet . Rounding . UP ) ; assertEquals ( 21 , closest . getX ( ) , 0.01f ) ; assertEquals ( 5 , closest . getY ( ) , 0.01f ) ; closest = set . getEntryForXValue ( 21 , Float . NaN , DataSet . Rounding . UP ) ; assertEquals ( 21 , closest . getX ( ) , 0.01f ) ; assertEquals ( 5 , closest . getY ( ) , 0.01f ) ; closest = set . getEntryForXValue ( 21 , Float . NaN , DataSet . Rounding . CLOSEST ) ; assertEquals ( 21 , closest . getX ( ) , 0.01f ) ; assertEquals ( 5 , closest . getY ( ) , 0.01f ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
resetAnimator: protected void resetAnimator ( ) { animator . removeAllListeners ( ) ; animator . removeAllUpdateListeners ( ) ; animator . reverse ( ) ; animator . addUpdateListener ( this ) ; animator . addListener ( this ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; nextPage ( ) ;
sin: public static float sin ( float radians ) { return ( float ) Math . sin ( radians ) ;
replacePackageGroupForWarehouses: public void replacePackageGroupForWarehouses ( String shopKey , String countryCode , Integer packageGroupId , List < PackageGroupWarehouse > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/package-groups/%s" , shopKey , countryCode , packageGroupId ) , query , null , null , model ) ;
isValid: public boolean isValid ( ) { return cnt != null ;
doSave: public void doSave ( ) throws org . json . JSONException { if ( ! dirty ) return ; PlayerClient client = getClient ( ) ; if ( client == null ) return ; client . log ( "Flushing user profile" ) ; dirty = false ; locked = true ; JSONObject ext = new JSONObject ( ) ; JSONObject items = new JSONObject ( ) ; for ( ObjectMap . Entry < String , Integer > entry : getItems ( ) ) { items . put ( entry . key , entry . value ) ; } final JSONObject stats = new JSONObject ( ) ; for ( ObjectMap . Entry < String , Float > entry : getStats ( ) ) { stats . put ( entry . key , entry . value ) ; } final JSONObject slots = new JSONObject ( ) ; for ( ObjectMap . Entry < String , String > entry : selectedSlots ) { slots . put ( entry . key , entry . value ) ; } final JSONObject cnt = new JSONObject ( ) ; for ( ObjectMap . Entry < String , FreePlayContainer > entry : containers ) { JSONArray out = new JSONArray ( ) ; if ( ! entry . value . isSaveEmpty ( ) ) { entry . value . write ( out ) ; } cnt . put ( entry . key , out ) ; } JSONArray badges = new JSONArray ( ) ; for ( String badge : this . badges ) { badges . put ( badge ) ; } JSONArray favorites = new JSONArray ( ) ; for ( String favorite : this . favorites ) { favorites . put ( favorite ) ; } JSONObject trophies = new JSONObject ( ) ; for ( int i = 0 ; i < MAX_TROPHIES ; i ++ ) { Trophy trophy = this . trophies . get ( i ) ; if ( trophy != null ) { try { if ( trophy . isValid ( ) ) { trophies . put ( String . valueOf ( i ) , trophy . write ( ) ) ; } } catch ( Exception ignored ) { trophies . put ( String . valueOf ( i ) , "" ) ; } } else { trophies . put ( String . valueOf ( i ) , "" ) ; } } ext . put ( "items" , items ) ; ext . put ( "stats" , stats ) ; ext . put ( "slots" , slots ) ; ext . put ( "cont" , cnt ) ; ext . put ( "badges" , badges ) ; ext . put ( "favorites" , favorites ) ; ext . put ( "trophies" , trophies ) ; ext . put ( "name" , getName ( ) ) ; ext . put ( "clan-avatar" , getClanAvatar ( ) ) ; ext . put ( "clan-avatar" , getClanAvatar ( ) ) ; ext . put ( "clan-id" , getClanId ( ) ) ; ext . put ( "layout" , layout ) ; ext . put ( "level" , getStats ( ) . get ( "level" , 1.0f ) ) ; ext . put ( "last-daily-claim" , getLastDailyClaim ( ) ) ; ext . put ( "deactivated" , getDeactivated ( ) ) ; JSONObject limits = new JSONObject ( ) ; ext . put ( "limits" , limits ) ; for ( ObjectMap . Entry < String , Limits > entry : this . limits ) { long now = System . currentTimeMillis ( ) / 1000L ; if ( now > entry . value . time ) continue ; JSONObject limit = new JSONObject ( ) ; limit . put ( "time" , entry . value . time ) ; limit . put ( "amount" , entry . value . amount ) ; limits . put ( entry . key , limit ) ; } dumpProfile ( ext ) ; BrainOutServer . EventMgr . sendDelayedEvent ( PlayerSavedEvent . obtain ( client ) ) ;
release: public void release ( ) { ActiveData playerData = weaponData . getOwner ( ) ; if ( playerData != null && magazines == null ) { PlayerOwnerComponent pog = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( pog != null ) { unload ( pog , false ) ; } } originalOwner = null ;
isSuitable: public boolean isSuitable ( ) { return enabled == necessaryClasses . size ( ) ;
setInfoInt: public void setInfoInt ( String key , int v ) { if ( this . info == null ) return ; this . info . put ( key , v ) ;
isNoPlayer: public boolean isNoPlayer ( ) { return noPlayer ;
getHeight: public static int getHeight ( ) { return Gdx . graphics . getHeight ( ) ;
onSharedPreferenceChanged: public void onSharedPreferenceChanged ( SharedPreferences sp , String s ) { needsActivityRefresh = true ; needsFragmentRefresh = true ; if ( StoragePermissionUtils . needsPermissionForKey ( s ) && ! StoragePermissionUtils . hasStoragePermission ( this ) ) {
waitFor: public Conversation < TRequest , TResponse > waitFor ( final long duration , final TimeUnit timeUnit , final boolean keepCachedUntilTimeout ) { this . timeout = timeUnit . toMillis ( duration ) ; this . concurrentResponseProcessing = keepCachedUntilTimeout ; return this ;
setAttachmentThreshold: public void setAttachmentThreshold ( float attachmentThreshold ) { this . attachmentThreshold = attachmentThreshold ;
init: public void init ( ) { super . init ( ) ; otherPortal = findOtherPortal ( ) ;
lockInput: public boolean lockInput ( ) { return true ;
runTest: public void runTest ( ) { WatchMessage msg = new WatchMessage ( ) ; msg . setSignature ( "w.core.WatchTarget#run" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; target . run ( ) ;
getLogLevel: No method body
playBackground: private void playBackground ( ) { if ( getContentComponent ( ) . getBackground ( ) != null )
getProperty: public ShopCategoryProperty getProperty ( String shopKey , String countryCode , Integer shopCategoryId , String shopCategoryPropertyKey , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCategoryProperty > responseModel = ( Class < ShopCategoryProperty > ) ( Class < ? > ) ShopCategoryProperty . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/countries/%s/categories/%s/properties/%s" , shopKey , countryCode , shopCategoryId , shopCategoryPropertyKey ) , query , null , responseModel ) ;
purchaseContent: private void purchaseContent ( Content content ) { if ( content instanceof StoreSlotItem ) { StoreSlotItem storeSlotItem = ( ( StoreSlotItem ) content ) ; Shop . ShopItem shopItem = storeSlotItem . getShopItem ( ) ; if ( ! profile . checkLimit ( storeSlotItem . getID ( ) ) ) { return ; } if ( shopItem != null ) { int need = shopItem . getAmount ( ) ; float amount = profile . getStats ( ) . get ( shopItem . getCurrency ( ) , 0.0f ) ; if ( amount >= need ) { float update = amount - need ; resourceEvent ( - need , shopItem . getCurrency ( ) , "purchase" , storeSlotItem . getID ( ) ) ; profile . getStats ( ) . put ( shopItem . getCurrency ( ) , update ) ; ServerStoreItemComponent ssi = storeSlotItem . getComponentFrom ( ServerStoreItemComponent . class ) ; if ( ssi != null ) { if ( ssi . purchased ( this ) ) { profile . acquireLimit ( storeSlotItem . getID ( ) , storeSlotItem . getLimit ( ) ) ; profile . setDirty ( ) ; sendUserProfile ( ) ; } } } } return ; } if ( content instanceof OwnableContent )
createUI: public Table createUI ( ) { Table data = super . createUI ( ) ; this . content = new Table ( ) ; Table buttons = new Table ( ) ; this . items = new ButtonGroup < > ( ) ; ScrollPane scrollPane = new ScrollPane ( content , BrainOutClient . Skin , "scroll-default" ) ; scrollPane . setFadeScrollBars ( false ) ; getRootActor ( ) . getStage ( ) . setScrollFocus ( scrollPane ) ; updateContent ( ) ; TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { SelectContentMenu . this . cancel ( ) ; } } ) ; buttons . add ( cancel ) . size ( 196 , 64 ) ; Table filterTable = new Table ( ) ; final TextField filerField = new TextField ( "" , BrainOutClient . Skin , "edit-default" ) ; filerField . setTextFieldListener ( ( textField , c ) -> { filter = filerField . getText ( ) . toLowerCase ( ) ; updateContent ( ) ; } ) ; data . add ( filerField ) . pad ( 8 ) . expandX ( ) . fillX ( ) . row ( ) ; data . add ( scrollPane ) . height ( 500 ) . width ( 820 ) . pad ( 8 ) . padTop ( 0 ) . expand ( ) . fill ( ) . row ( ) ; data . add ( buttons ) . padBottom ( 8 ) . expandX ( ) . row ( ) ; setKeyboardFocus ( filerField ) ; setScrollFocus ( scrollPane ) ; return data ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
getReplyTo: public String getReplyTo ( ) { return replyTo ;
setBufferSize: public void setBufferSize ( int bufferSize ) { this . bufferSizeField = String . valueOf ( bufferSize ) ;
onWebViewShouldOverrideUrl: No method body
serializeToByteBuffer: public ByteBuffer serializeToByteBuffer ( @ Nullable T value ) { return Objects . requireNonNull ( value ) . toByteString ( ) . asReadOnlyByteBuffer ( ) ;
init: public void init ( ) { if ( Map . GetWatcherMap ( Map . class ) != getMap ( ) ) return ; sound . play ( BrainOutClient . ClientSett . getSoundVolume ( ) . getFloatValue ( ) ) ;
getTimeScale: public float getTimeScale ( ) { return timeScale ;
success: No method body
getSelectIndex: public int getSelectIndex ( ) { return selectIndex ;
onEvent: public boolean onEvent ( Event event ) { return false ;
hasNext: public boolean hasNext ( ) { return position < list . size ( ) ;
getComponent: public PhysicsCollisionDetectorComponentData getComponent ( ComponentObject componentObject ) { return new PhysicsCollisionDetectorComponentData ( ( ActiveData ) componentObject , this ) ;
onItemClick: No method body
getLineColor: public int getLineColor ( ) { return mLineColor ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem5ActionPerformed ( evt ) ;
getTags: public int getTags ( ) { return 0 ;
map: public final < U > Awaitable < U > map ( ThrowingFunction < T , U > mapper ) { return new MappedAwaitable < > (
parseCode: public static String parseCode ( String bitmapPath ) { Map < DecodeHintType , Object > hints = new HashMap < > ( ) ; Vector < BarcodeFormat > decodeFormats = new Vector < > ( ) ; decodeFormats . addAll ( DecodeFormatManager . ONE_D_FORMATS ) ; decodeFormats . addAll ( DecodeFormatManager . QR_CODE_FORMATS ) ; decodeFormats . addAll ( DecodeFormatManager . DATA_MATRIX_FORMATS ) ; decodeFormats . addAll ( DecodeFormatManager . AZTEC_FORMATS ) ; decodeFormats . addAll ( DecodeFormatManager . PDF417_FORMATS ) ; hints . put ( DecodeHintType . TRY_HARDER , Boolean . TRUE ) ; hints . put ( DecodeHintType . POSSIBLE_FORMATS , decodeFormats ) ; return parseCode ( bitmapPath , hints ) ;
clear: public void clear ( ) { values . clear ( ) ;
toStringTest: public void toStringTest ( ) { WatchMessage msg = new WatchMessage ( ) ; msg . setSignature ( "w.core.WatchTarget#toString" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; System . out . println ( new WatchTarget ( ) . toString ( ) ) ;
createSearch: public static String createSearch ( HttpServletRequest request , String qualifier ) { String result = request . getParameter ( qualifier + "_search" ) ; if ( result == null ) { Optional < Map . Entry < String , String [ ] > > searches = request . getParameterMap ( ) . entrySet ( ) . stream ( ) . filter ( e -> StringUtils . equalsAnyIgnoreCase ( qualifier + "_search" , e . getKey ( ) ) ) . findFirst ( ) ; if ( searches != null && searches . isPresent ( ) && searches . get ( ) . getValue ( ) . length > 0 ) { return searches . get ( ) . getValue ( ) [ searches . get ( ) . getValue ( ) . length - 1 ] ; } } else { return result ; } return "" ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; String group = jsonData . getString ( "group" ) ; this . group = ( ( CardGroup ) BrainOut . ContentMgr . get ( group ) ) ; this . weight = jsonData . getFloat ( "weight" ) ; this . shareWeight = jsonData . getString ( "weight" , null ) ;
setTrigger: public void setTrigger ( boolean condition , javax . swing . JTextField element ) { if ( condition ) {
getLogin: public String getLogin ( ) { return login ;
enemyNoticed: private boolean enemyNoticed ( TaskStack taskStack , ActiveData activeData ) { popMeAndPushTask ( new TaskFollowAndShootTarget ( taskStack , activeData , new RandomValue ( 0.1f , 0.6f ) , new RandomValue ( 0.4f , 0.9f ) ) { @ Override protected void stuck ( ) { pop ( ) ; } } ) ; return true ;
setContent: public void setContent ( Map < String , Object > content ) { this . content = content ;
release: public void release ( ) { this . callback . destroyed ( getComponentObject ( ) ) ; super . release ( ) ;
sendOutputs: No method body
getBuilder: public static CRUDControllerConfiguration getBuilder ( String key , FrontendMappingDefinition frontendMappingDefinition , ScopedSecureRepository secureRepository , Class formClass , PrivilegeBase readPrivilege , PrivilegeBase writePrivilege ) { return new CRUDControllerConfiguration ( key , frontendMappingDefinition ,
getPathToContentFile: public String getPathToContentFile ( ServerJs entity ) { String orgPath = entity . getOrganizationId ( ) == null ? "" : SUBDIR_ORGANIZATION_PREFIX + entity . getOrganizationId ( ) + "/" ; String entityExportPath = SERVER_SIDE_ + orgPath ; return EXPORT_CODE_PATH_ + entityExportPath + String . format ( "%s.js" , entity . getName ( ) ) ;
getInstancesCount: public int getInstancesCount ( ) { return instancesCount ;
close: private void close ( ) { pop ( ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
renderWait: private void renderWait ( ) { clanList . clear ( ) ; Label wait = new Label ( L . get ( "MENU_PLEASE_WAIT" ) , BrainOutClient . Skin , "title-gray" ) ; wait . setAlignment ( Align . center ) ; clanList . add ( wait ) . pad ( 32 ) . expandX ( ) . fillX ( ) . center ( ) . row ( ) ;
getResourceAsStringOrEmpty: public static String getResourceAsStringOrEmpty ( String path ) { try {
isResponseContext: public boolean isResponseContext ( ) { return responseContext ;
updateOrCreateProperty: public ShopCategoryProperty updateOrCreateProperty ( String shopKey , String countryCode , Integer shopCategoryId , ShopCategoryProperty model ) throws ApiErrorException , ConnectionException { Class < ShopCategoryProperty > responseModel = ( Class < ShopCategoryProperty > ) ( Class < ? > ) ShopCategoryProperty . class ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/categories/%s/properties" , shopKey , countryCode , shopCategoryId ) , null , null , responseModel , model ) ;
getFormLineDashEffect: public DashPathEffect getFormLineDashEffect ( ) { return mFormLineDashEffect ;
getID: public ID getID ( ) { return ID . blockHitConfirmation ;
getController: public BotControllerComponentData getController ( ) { return stack . getController ( ) ;
detachWarehouse: public void detachWarehouse ( Identifier merchantIdentifier , Identifier warehouseIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/merchants/%s/warehouses/%s" , merchantIdentifier , warehouseIdentifier ) , null , null , null ) ;
isPlaying: public boolean isPlaying ( ) { return soundId != - 1 ;
getEndSlot: public @ Null SlotData getEndSlot ( ) { return endSlot ;
getStyleOdd: protected String getStyleOdd ( ) { return "button-row-default" ;
renderPanels: public void renderPanels ( Table toolbar ) { { Table panel = new Table ( BrainOutClient . Skin ) ; panel . setBackground ( "buttons-group" ) ; renderShapesPanel ( panel ) ; toolbar . add ( panel ) . padRight ( 8 ) ; } {
formattedDurationShort: public static String formattedDurationShort ( long duration , Context context ) { String formattedString = "" ; int seconds = ( int ) duration ; String secondsString = context . getResources ( ) . getQuantityString ( R . plurals . duration_second , seconds , seconds ) ; int minutes = ( int ) ( duration % 3600 ) / 60 ; String minutesString = context . getResources ( ) . getQuantityString ( R . plurals . duration_minute , minutes , minutes ) ; int hours = ( int ) duration / 3600 ; String hoursString = context . getResources ( ) . getQuantityString ( R . plurals . duration_hour , hours , hours ) ; int days = ( int ) duration / 86400 ; String daysString = context . getResources ( ) . getQuantityString ( R . plurals . duration_day , days , days ) ; int years = ( int ) duration / ( 86400 * 365 ) ; String yearsString = context . getResources ( ) . getQuantityString ( R . plurals . duration_year , years , years ) ; if ( duration < 60 ) { formattedString = secondsString ; } else if ( duration < 3600 ) { formattedString = minutesString ; } else if ( duration < 86400 ) { formattedString = hoursString ; } else if ( duration < 86400 * 365 ) { formattedString = daysString ; } else { formattedString = yearsString ; } return formattedString ;
getButtonHeight: protected float getButtonHeight ( ) { return 64 ;
getUser: public User getUser ( String firstName , String lastName , String email , boolean userEnabled , String [ ] globalRoles , String orgRoles ) { User user = repositories . unsecure . user . findByLogin ( email ) ; if ( user != null ) { return user ; } Organization org = findOrganizationByName ( "Test Org" ) ; return createUser ( firstName , lastName , email , userEnabled , globalRoles , new Tuple2 [ ] { Tuples . of ( orgRoles , org . getId ( ) ) } ) ;
antiGroupAdd: private static void antiGroupAdd ( @ NonNull Message message ) { Integer type = message . F ( ) ; if ( type != null && type == TYPE_RECIPIENT_ADD && Prefs . getBoolean ( PreferenceKeys . DO_NOT_ADD , false ) ) {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesClose17ActionPerformed ( evt ) ;
getAllServers: public void getAllServers ( final Callback < ClusterInformationConversation . Response > responseCallback ) { requestClusterInformation ( Message . TargetType . ALL , "" , responseCallback ) ;
isItemTaskRelated: public boolean isItemTaskRelated ( ConsumableItem item ) { return false ;
onMenuClose: No method body
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; JsonValue instrument = jsonData . get ( "instrument" ) ; if ( instrument != null )
flipCard: public String flipCard ( int owner , int card ) { if ( ! validateParticipant ( owner ) ) return null ; TableCard tableCard = findCard ( card ) ; if ( tableCard == null ) return null ; if ( tableCard . flipped ) return null ; tableCard . flipped = true ; notifyAll ( new FlipCard ( d ( ) , o ( ) , card , tableCard . card ) ) ; return tableCard . card ;
getStarttls: public Boolean getStarttls ( ) { return starttls ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; flowX = jsonData . getFloat ( "flowX" , 0 ) ;
selectInstrument: public boolean selectInstrument ( InstrumentData instrumentData ) { PlayerData playerData = getPlayerData ( ) ; PlayerOwnerComponent ownerComponent = playerData . getComponent ( PlayerOwnerComponent . class ) ; PlayerRemoteComponent remoteComponent = playerData . getComponent ( PlayerRemoteComponent . class ) ; ServerPlayerControllerComponentData ctl = playerData . getComponentWithSubclass ( ServerPlayerControllerComponentData . class ) ; if ( ctl != null ) { ConsumableRecord r = ownerComponent . findRecord ( instrumentData ) ; if ( r != null ) { ctl . instrumentSelected ( r ) ; ctl . changeInstrument ( r . getId ( ) ) ; remoteComponent . setCurrentInstrument ( instrumentData ) ; playerData . setCurrentInstrument ( instrumentData ) ; return true ; } } return false ;
setToken_name: public void setToken_name ( String token_name ) { this . token_name = token_name ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; doCreate ( ) ;
getTitle: No method body
updateOrCreateCountry: public ShopCategoryCountry updateOrCreateCountry ( String shopKey , String countryCode , Integer shopCategoryId , ShopCategoryCountry model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCategoryCountry > responseModel = ( Class < ShopCategoryCountry > ) ( Class < ? > ) ShopCategoryCountry . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/categories/%s" , shopKey , countryCode , shopCategoryId ) , query , null , responseModel , model ) ;
getAY: public float getAY ( ) { return ay ;
setCircleSize: public void setCircleSize ( float size ) { setCircleRadius ( size ) ;
copyFileFromAssets: public static void copyFileFromAssets ( Context c , File f ) { try {
unprocessedLeafs: public Stream < SingleDeferredInternal < ? > > unprocessedLeafs ( ) { return Stream . concat (
d: public String d ( ) { return null ;
update: public void update ( float dt ) { super . update ( dt ) ; for ( Slot slot : slots . values ( ) )
isImmersive: public Builder isImmersive ( boolean isImmersive ) { P . mIsImmersive = isImmersive ; return this ;
getThemedFont: public Typeface getThemedFont ( Context context , int i2 ) { return null ;
getID: public ID getID ( ) { return ID . hitConfirmed ;
toString: public String toString ( ) { return "Car{" + "brand='" + brand + '\'' + '}' ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
refresh: No method body
reset: public void reset ( ) { this . success = false ;
apply: public void apply ( OkHttpClient . Builder builder ) { builder . addNetworkInterceptor ( new FlipperOkhttpInterceptor ( networkFlipperPlugin ) ) ;
failed: public static < T > CommonResult < T > failed ( int code , String message ) { return new CommonResult < T > ( HttpStatus . ERROR , message , null ) ;
getInstrumentData: public InstrumentData getInstrumentData ( ) { return instrumentData ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
onClick: public void onClick ( View v ) { ToastUtils . showToast ( mContext , "Not yet open, please wait" ) ; shareLayout . setVisibility ( View . GONE ) ;
show: public void show ( final View view , LightningOuterClass . AssetTx item ) { if ( mBasePopWindow == null ) {
getRandom: public Music getRandom ( ) { return musicArray . random ( ) ;
warn: default void warn ( String message , Throwable throwable ) { getLogger ( ) . warn ( message , throwable ) ; logToDebugStack ( throwable , message ) ;
updateReferenceKey: public Order updateReferenceKey ( String shopKey , String countryCode , Integer orderId , OrderReferenceKey model ) throws ApiErrorException , ConnectionException { Class < Order > responseModel = ( Class < Order > ) ( Class < ? > ) Order . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/orders/%s/reference-key" , shopKey , countryCode , orderId ) , null , null , responseModel , model ) ;
getTags: public int getTags ( ) { return WithTag . TAG ( Constants . ActiveTags . SPAWNABLE ) ;
getEditorComponent: private EditorComponent getEditorComponent ( ) { return map . getComponents ( ) . getComponent ( EditorComponent . class ) ;
drawFade: protected void drawFade ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_TRIPLE , getBatch ( ) ) ;
start: public void start ( long startTime , long endTime , boolean cancellable ) { this . active = true ; this . startTime = startTime ; this . endTime = endTime ; this . cancellable = cancellable ; updated ( ( ( ActiveData ) getComponentObject ( ) ) , this ) ;
getGameModes: protected GameMode . ID [ ] getGameModes ( ) { return Constants . Matchmaking . APPROVED_COMPETITIVE_MODES ;
onError: public void onError ( Exception e ) { new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) { @ Override public void run ( ) { mLoadingDialog . dismiss ( ) ; } } ) ; LogUtils . e ( TAG , "------------------decodePaymentOnError------------------" + e . getMessage ( ) ) ;
getBannerColor: public String getBannerColor ( ) { return null ;
removeDataSet: public boolean removeDataSet ( T d ) { if ( d == null ) return false ; boolean removed = mDataSets . remove ( d ) ; if ( removed ) { notifyDataChanged ( ) ; } return removed ;
drawResultBitmap: private Bitmap drawResultBitmap ( Bitmap bitmap ) { Bitmap shadeBitmap ; if ( null != mShadeBitmap ) { shadeBitmap = handleBitmap ( mShadeBitmap , mUnitWidth , mUnitHeight ) ; } else { shadeBitmap = handleBitmap ( BitmapFactory . decodeResource ( getResources ( ) , R . drawable . shape_verify_image_shade ) , mUnitWidth , mUnitHeight ) ; } if ( mNeedRotate ) { shadeBitmap = handleBitmap ( rotateBitmap ( mRotate , shadeBitmap ) , mUnitWidth , mUnitHeight ) ; } Bitmap resultBmp = Bitmap . createBitmap ( mUnitWidth , mUnitHeight , Bitmap . Config . ARGB_8888 ) ; Paint paint = new Paint ( ) ; paint . setAntiAlias ( true ) ; Canvas canvas = new Canvas ( resultBmp ) ; canvas . drawBitmap ( shadeBitmap , new Rect ( 0 , 0 , mUnitWidth , mUnitHeight ) , new Rect ( 0 , 0 , mUnitWidth , mUnitHeight ) , paint ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . MULTIPLY ) ) ; canvas . drawBitmap ( bitmap , new Rect ( 0 , 0 , mUnitWidth , mUnitHeight ) , new Rect ( 0 , 0 , mUnitWidth , mUnitHeight ) , paint ) ; return resultBmp ;
onLoadUrl: No method body
draw: public void draw ( Batch batch , float parentAlpha ) { icon . resetAnimation ( ) ; super . draw ( batch , parentAlpha ) ; icon . animateTo ( animationName , parts , of ) ; _draw ( batch , parentAlpha ) ;
findBySalesforceId: No method body
isEmpty: boolean isEmpty ( ) { return this . unprocessedMessages . isEmpty ( ) ;
getNameAndTableName: No method body
getContent: public PlayerSkin getContent ( ) { return playerSkin ;
setLinkedinId: public void setLinkedinId ( String linkedinId ) { this . linkedinId = linkedinId ;
isHttpRequest: private boolean isHttpRequest ( ) { return request != null && RequestContextHolder . getRequestAttributes ( ) != null ;
prepareEvent: protected PageModelMap prepareEvent ( SendEventForm eventForm , BindingResult br ) { debug ( "[prepareEvent]" ) ; return Flow . init ( sendEventForm , eventForm )
getWeapons: public ObjectMap < String , WeaponPreset > getWeapons ( ) { return weapons ;
getY: public float getY ( ) { return y ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new ServerGrenadeComponentData ( componentObject , this ) ;
updateEffect: public EffectData updateEffect ( Effect effect ) { releaseEffect ( ) ; setEffect ( effect ) ; initEffect ( ) ; return effectData ;
deleteTopic: public DeleteTopicResponse deleteTopic ( final String topicKey ) throws IOException , NovuNetworkException { Response < Void > response = topicApi . deleteTopic ( topicKey ) . execute ( ) ; return restHandler . extractResponse ( response , new DeleteTopicResponse ( ) ) ;
getEndTime: public long getEndTime ( ) { return endTime ;
buildSearchQuery: private static SearchQuery buildSearchQuery ( long authorId ) { Map < String , List < String > > map = new HashMap < > ( ) ; map . put ( "author_id" , Collections . singletonList ( Long . toString ( authorId ) ) ) ; map . put ( "sort_by" , Collections . singletonList ( "timestamp" ) ) ; map . put ( "sort_order" , Collections . singletonList ( "desc" ) ) ; return new SearchQuery ( map , true ) ;
search: default Page < T > search ( Long organizationId , Specification < T > specification , int page , int size , String sortField , String sortDirection ) { return SearchableFunctionalRepositoryWithLongId . super . search ( DEFAULT_SCOPE , organizationId , specification , page , size , sortField , sortDirection ) ;
onClick: public void onClick ( View v ) { mAlertDialog . dismiss ( ) ;
getKey: public String getKey ( ) { return key ;
getTakingPoints: public int getTakingPoints ( Team team ) { return takingPoints . get ( team , 0 ) ;
release: public void release ( ) { super . release ( ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
followDirectly: public void followDirectly ( ActiveData target , Runnable targetReached ) { PlayerData playerData = getPlayerData ( ) ; if ( playerData == null ) return ; this . recentPosition . set ( playerData . getX ( ) , playerData . getY ( ) ) ; this . recentTimer = 0 ; this . followTarget = target ; this . targetDistance = 2.0f ; this . needPathFinding = false ; this . targetReached = targetReached ; this . stuckCallback = null ; this . blocksInWayCallback = null ;
emitErrorLogNotificationEvent: default void emitErrorLogNotificationEvent ( Throwable throwable , String format , Object ... arguments ) { ApplicationEventService applicationEventService = ApplicationEventService . getApplicationEventService ( ) ; if ( applicationEventService != null ) {
lockInput: public boolean lockInput ( ) { return true ;
onInit: public void onInit ( ) { super . onInit ( ) ; UserProfile userProfile = BrainOutClient . ClientController . getUserProfile ( ) ; if ( BrainOutClient . ClientController . isLobby ( ) ) { Table leftButtons = MenuHelper . AddLeftButtonsContainers ( this ) ; if ( BrainOut . OnlineEnabled ( ) && userProfile != null && ! userProfile . isParticipatingClan ( ) ) { Button btn = new Button ( BrainOutClient . Skin , "button-green" ) ; btn . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; GameState gs = getGameState ( ) ; if ( gs == null ) return ; close ( ) ; gs . pushMenu ( new CreateClanMenu ( ) ) ; } } ) ; Image image = new Image ( BrainOutClient . getRegion ( "skillpoints-big" ) ) ; image . setScaling ( Scaling . none ) ; btn . add ( image ) . expand ( ) . fill ( ) ; Label title = new Label ( L . get ( "MENU_CREATE_CLAN" ) , BrainOutClient . Skin , "title-small" ) ; title . setAlignment ( Align . center ) ; leftButtons . add ( btn ) . size ( 64 , 64 ) . padRight ( 10 ) ; leftButtons . add ( title ) . left ( ) . row ( ) ; } } MenuHelper . AddCloseButton ( this , this :: close ) ; this . searchItemClicked = new ClickOverListener ( )
setUsdtPrice: public void setUsdtPrice ( Context context , String usdtPrice ) { PreferencesUtils . saveUsdtPriceToLocal ( context , usdtPrice ) ; this . usdtPrice = usdtPrice ;
setSellableWithoutStock: public SellableWithoutStock setSellableWithoutStock ( Identifier variantIdentifier , SellableWithoutStock model ) throws ApiErrorException , ConnectionException { Class < SellableWithoutStock > responseModel = ( Class < SellableWithoutStock > ) ( Class < ? > ) SellableWithoutStock . class ; return this . request ( "put" , this . resolvePath ( "/variants/%s/stocks/sellableWithoutStock" , variantIdentifier ) , null , null , responseModel , model ) ;
run: public void run ( ) { slide . clear ( ) ; slide . getColor ( ) . a = 0 ; slide . setPosition ( 128 , 0 ) ; page . render ( slide ) ; buttons . setVisible ( true ) ; slide . addAction ( Actions . sequence (
reservations: public ReservationService reservations ( ) { ReservationService service = this . getService ( "com.scayle.adminapi.service.ReservationService" ) ; return service ;
UpdateParamToDict: No method body
getStats: public ObjectMap < String , Float > getStats ( ) { return stats ;
cancel: public boolean cancel ( boolean mayInterruptIfRunning ) { return wrapped . cancel ( mayInterruptIfRunning ) ;
isHaveToLeave: public boolean isHaveToLeave ( ) { return hasToLeave ;
updateSteamInflow: public void updateSteamInflow ( double flow , double tempC ) { throw new UnsupportedOperationException ( "Unimplemented method 'updateSteamInFlow'" ) ;
getRefillAmount: public float getRefillAmount ( ) { return refillAmount ;
setProtocol: public void setProtocol ( String protocol ) { this . protocol = protocol ;
playMusic: public com . badlogic . gdx . audio . Music playMusic ( String id , boolean repeat ) { stopMusic ( ) ; musicList = null ; Music music = ( ( Music ) BrainOut . ContentMgr . get ( id ) ) ; if ( music != null ) { currentMusic = music . getMusic ( ) ; try { currentMusic . play ( ) ; currentMusic . setLooping ( repeat ) ; } catch ( GdxRuntimeException ignored ) { } updateVolume ( ) ; return currentMusic ; } return null ;
isRatingEnabled: public boolean isRatingEnabled ( boolean shouldBeActive ) { GameMode gameMode = getGameMode ( ) ; if ( gameMode != null ) { if ( shouldBeActive && ! gameMode . isGameActive ( ) ) { return false ; } } return BrainOutServer . Settings . isRatingEnabled ( ) ;
getFileDtos: public final Map < Long , FileDto > getFileDtos ( EntityWithFiles entity ) { if ( entity == null || entity . getFiles ( ) == null ) { return Collections . emptyMap ( ) ; } Map < Long , FileDto > result = new LinkedHashMap < > ( ) ; Long i = 0l ; for ( File a : entity . getFiles ( ) ) { if ( a != null ) { result . put ( i , toFileDto ( a ) ) ; i ++ ; } } return result ;
updated: protected void updated ( ) { super . updated ( ) ; updateStats ( ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case simple : { SimpleEvent e = ( SimpleEvent ) event ; switch ( e . getAction ( ) ) { case disconnect : { Gdx . app . postRunnable ( ( ) -> { DisconnectReason reason = BrainOutClient . ClientController . getDisconnectReason ( ) ; switch ( reason ) { case leave : case disconnect : case reconnect : { break ; } case shutdown : { BrainOutClient . Env . gameCompleted ( ) ; BrainOutClient . getInstance ( ) . popState ( ) ; BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ; break ; } case connectionError : { Gdx . app . postRunnable ( ( ) -> { BrainOutClient . getInstance ( ) . switchState ( new LoadingState ( L . get ( "MENU_RECONNECTING" ) ) ) ; BrainOutClient . ClientController . setState ( new CSReconnect ( ) ) ; } ) ; break ; } default : { pushMenu ( new AlertPopup ( L . get ( "MENU_DISCONNECTED" , reason . toString ( ) ) ) { @ Override public void ok ( ) { BrainOutClient . Env . gameCompleted ( ) ; BrainOutClient . getInstance ( ) . popState ( ) ; BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ; } } ) ; break ; } } } ) ; return true ; } case teamSelected : { if ( topMenu ( ) instanceof SelectTeamMenu ) { popTopMenu ( ) ; } return true ; } } break ; } case popup : { final PopupEvent popupEvent = ( ( PopupEvent ) event ) ; final String title = popupEvent . title ; final String text = popupEvent . data ; addAction ( new MenuAction ( ) { @ Override public void run ( ) { pushMenu ( new FadeInMenu ( 0.25f , ( ) -> pushMenu ( new RichAlertPopup ( title , text ) { @ Override public void ok ( ) { done ( ) ; } } ) ) ) ; } } ) ; break ; } } return false ;
enableLogging: public static void enableLogging ( ) { ToastUtil . toast ( "StrictMode is enabled. Remove before release!" ) ; StrictMode . setVmPolicy ( new StrictMode . VmPolicy . Builder ( )
getUDID: public static String getUDID ( ) { String serial ; String m_szDevIDShort = "35" + Build . BOARD . length ( ) % 10 + Build . BRAND . length ( ) % 10 + Build . CPU_ABI . length ( ) % 10 + Build . DEVICE . length ( ) % 10 + Build . DISPLAY . length ( ) % 10 + Build . HOST . length ( ) % 10 + Build . ID . length ( ) % 10 + Build . MANUFACTURER . length ( ) % 10 + Build . MODEL . length ( ) % 10 + Build . PRODUCT . length ( ) % 10 + Build . TAGS . length ( ) % 10 + Build . TYPE . length ( ) % 10 + Build . USER . length ( ) % 10 ; try { serial = Build . class . getField ( "SERIAL" ) . get ( null ) . toString ( ) ; return new UUID ( m_szDevIDShort . hashCode ( ) , serial . hashCode ( ) ) . toString ( ) ; } catch ( Exception exception ) { serial = "serial" ; } return new UUID ( m_szDevIDShort . hashCode ( ) , serial . hashCode ( ) ) . toString ( ) ;
read: public File read ( JsonReader in ) throws IOException { if ( in . peek ( ) == JsonToken . NULL ) { in . nextNull ( ) ; return null ; } String s = in . nextString ( ) ; return new File ( s ) ;
request: public Response request ( String httpMethod , String relativeUrl , Map < String , Object > query , Map < String , Object > headers , String body ) throws IOException { httpMethod = httpMethod . toUpperCase ( ) ; HttpUrl . Builder urlBuilder = HttpUrl . parse ( this . apiConfiguration . getUrl ( ) + relativeUrl ) . newBuilder ( ) ; if ( query != null ) { for ( String key : query . keySet ( ) ) { urlBuilder . addQueryParameter ( key , String . valueOf ( query . get ( key ) ) ) ; } } Builder builder = new Request . Builder ( ) . header ( "X-Access-Token" , this . apiConfiguration . getAccessToken ( ) ) . url ( urlBuilder . build ( ) . toString ( ) ) ; if ( headers != null ) { for ( String key : headers . keySet ( ) ) { Object value = headers . get ( key ) ; if ( value != null ) { builder . header ( key , String . valueOf ( value ) ) ; } } } RequestBody requestBody = null ; if ( body != null ) { builder . header ( "Content-Type" , "application/json" ) ; MediaType mediaType = MediaType . parse ( "application/json; charset=utf-8" ) ; requestBody = RequestBody . create ( body , mediaType ) ; } if ( body == null && httpMethod . equals ( "POST" ) ) { requestBody = RequestBody . create ( null , new byte [ 0 ] ) ; } Request request = builder . method ( httpMethod , requestBody ) . build ( ) ; return httpClient . newCall ( request ) . execute ( ) ;
toString: public String toString ( ) { return data . name ;
getGitHubRepoName: public String getGitHubRepoName ( ) { return gitHubRepoName ;
init: public void init ( ) { super . init ( ) ; tm = getComponentObject ( ) . getComponent ( ServerTeamVisibilityComponentData . class ) ; ;
getNewFeature: public String getNewFeature ( ) { return newFeature ;
removeFile: protected PageModelMap removeFile ( long fileId ) { debug ( "[removeFile] fileId: {}" , fileId ) ; return Flow . init ( transactional )
setUp: public static void setUp ( ) throws Exception { Instrumentation instrumentation = ByteBuddyAgent . install ( ) ; Global . instrumentation = instrumentation ; Global . fillLoadedClasses ( ) ; System . setProperty ( "maxHit" , "10" ) ;
getPrompt: public String getPrompt ( ) { return prompt ;
run: public void run ( ) { getWalletState ( ) ; handler . postDelayed ( this , 500 ) ;
setRepositoryName: public void setRepositoryName ( String repositoryName ) { this . repositoryName = repositoryName ;
getHost: public String getHost ( ) { if ( connection == null ) return null ; InetSocketAddress tcp = connection . getRemoteAddressTCP ( ) ; if ( tcp == null ) return null ; InetAddress address = tcp . getAddress ( ) ; if ( address == null ) return null ; return address . getHostAddress ( ) ;
setFilterBottomMenu: public void setFilterBottomMenu ( MenuView menuView ) { this . mMenuView = menuView ;
renderLegend: public void renderLegend ( Canvas c ) { if ( ! mLegend . isEnabled ( ) ) return ; Typeface tf = mLegend . getTypeface ( ) ; if ( tf != null ) mLegendLabelPaint . setTypeface ( tf ) ; mLegendLabelPaint . setTextSize ( mLegend . getTextSize ( ) ) ; mLegendLabelPaint . setColor ( mLegend . getTextColor ( ) ) ; float labelLineHeight = Utils . getLineHeight ( mLegendLabelPaint , legendFontMetrics ) ; float labelLineSpacing = Utils . getLineSpacing ( mLegendLabelPaint , legendFontMetrics ) + Utils . convertDpToPixel ( mLegend . getYEntrySpace ( ) ) ; float formYOffset = labelLineHeight - Utils . calcTextHeight ( mLegendLabelPaint , "ABC" ) / 2.f ; LegendEntry [ ] entries = mLegend . getEntries ( ) ; float formToTextSpace = Utils . convertDpToPixel ( mLegend . getFormToTextSpace ( ) ) ; float xEntrySpace = Utils . convertDpToPixel ( mLegend . getXEntrySpace ( ) ) ; Legend . LegendOrientation orientation = mLegend . getOrientation ( ) ; Legend . LegendHorizontalAlignment horizontalAlignment = mLegend . getHorizontalAlignment ( ) ; Legend . LegendVerticalAlignment verticalAlignment = mLegend . getVerticalAlignment ( ) ; Legend . LegendDirection direction = mLegend . getDirection ( ) ; float defaultFormSize = Utils . convertDpToPixel ( mLegend . getFormSize ( ) ) ; float stackSpace = Utils . convertDpToPixel ( mLegend . getStackSpace ( ) ) ; float yoffset = mLegend . getYOffset ( ) ; float xoffset = mLegend . getXOffset ( ) ; float originPosX = 0.f ; switch ( horizontalAlignment ) { case LEFT : if ( orientation == Legend . LegendOrientation . VERTICAL ) originPosX = xoffset ; else originPosX = mViewPortHandler . contentLeft ( ) + xoffset ; if ( direction == Legend . LegendDirection . RIGHT_TO_LEFT ) originPosX += mLegend . mNeededWidth ; break ; case RIGHT : if ( orientation == Legend . LegendOrientation . VERTICAL ) originPosX = mViewPortHandler . getChartWidth ( ) - xoffset ; else originPosX = mViewPortHandler . contentRight ( ) - xoffset ; if ( direction == Legend . LegendDirection . LEFT_TO_RIGHT ) originPosX -= mLegend . mNeededWidth ; break ; case CENTER : if ( orientation == Legend . LegendOrientation . VERTICAL ) originPosX = mViewPortHandler . getChartWidth ( ) / 2.f ; else originPosX = mViewPortHandler . contentLeft ( ) + mViewPortHandler . contentWidth ( ) / 2.f ; originPosX += ( direction == Legend . LegendDirection . LEFT_TO_RIGHT ? + xoffset : - xoffset ) ; if ( orientation == Legend . LegendOrientation . VERTICAL ) { originPosX = ( float ) ( originPosX + ( direction == Legend . LegendDirection . LEFT_TO_RIGHT ? - mLegend . mNeededWidth / 2.0 + xoffset : mLegend . mNeededWidth / 2.0 - xoffset ) ) ; } break ; } switch ( orientation ) {
trigger: public void trigger ( boolean close ) { SimplePhysicsComponentData phy = activeData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy == null ) return ; Vector2 speed = phy . getSpeed ( ) ; ServerActiveMoveMsg msg = new ServerActiveMoveMsg ( activeData . getId ( ) , activeData . getX ( ) , activeData . getY ( ) , speed . x , speed . y , activeData . getAngle ( ) , activeData . getDimension ( ) ) ; for ( ObjectMap . Entry < Integer , Client > entry : BrainOutServer . Controller . getClients ( ) )
getFormatDateString: public static String getFormatDateString ( float timeZoneOffset , String format ) { if ( timeZoneOffset > 13 || timeZoneOffset < - 12 ) { timeZoneOffset = 0 ; } int newTime = ( int ) ( timeZoneOffset * 60 * 60 * 1000 ) ; TimeZone timeZone ; String [ ] ids = TimeZone . getAvailableIDs ( newTime ) ; if ( ids . length == 0 ) { timeZone = TimeZone . getDefault ( ) ; } else { timeZone = new SimpleTimeZone ( newTime , ids [ 0 ] ) ; } if ( StringUtils . isEmpty ( format ) ) { format = "yyyy-MM-dd HH:mm:ss" ; } SimpleDateFormat sdf = new SimpleDateFormat ( format , Locale . CHINA ) ; sdf . setTimeZone ( timeZone ) ; return sdf . format ( new Date ( ) ) ;
enableAxisLineDashedLine: public void enableAxisLineDashedLine ( float lineLength , float spaceLength , float phase ) { mAxisLineDashPathEffect = new DashPathEffect ( new float [ ] {
release: public void release ( ) { super . release ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . setMyPlayer , this ) ;
getCredential: No method body
getTeam: public Team getTeam ( ) { return team ;
deleteComposite: public void deleteComposite ( Identifier productIdentifier , Identifier variantIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/products/composite/%s/variants/%s" , productIdentifier , variantIdentifier ) , query , null , null ) ;
newCallback: public static < T > Callback < T > newCallback ( final Consumer < T > onComplete , final Consumer < Throwable > onExcept ) { return new Callback < > ( onComplete , onExcept ) ;
getID: public ID getID ( ) { return ID . caseOpenResult ;
getNameAndTableNameAsMap: default Map < String , String > getNameAndTableNameAsMap ( ) { return getNameAndTableName ( ) . stream ( ) . collect ( toMap ( o -> ( String ) o [ 0 ] , o -> ( String ) o [ 1 ] ) ) ;
toSnowflakeId: public static long toSnowflakeId ( long timestamp ) { return ( timestamp - EPOCH ) << 22 ;
setSoftness: public void setSoftness ( float softness ) { this . softness = softness ;
getMicrophoneVolume: public IntegerRangeProperty getMicrophoneVolume ( ) { return microphoneVolume ;
sendReliableUDP: public int sendReliableUDP ( ReliableBody object ) { getServerController ( ) . getReliableManager ( ) . deliver ( object , this ) ; return 0 ;
init: private Event init ( EntityReceived entity , int amount ) { this . entity = entity ; this . amount = amount ; return this ;
degree: public int degree ( ) { return coefficients . size ( ) - 1 ;
fill: public void fill ( int value ) { Arrays . fill ( v , value ) ;
run: public Void run ( final Stream < Map < String , String > > input ) { try ( final RestClient restClient = restClientBuilder . build ( ) ) { if ( this . indexCreator != null ) { createIndexIfNotExists ( restClient ) ; } input . forEach ( document -> { final String documentJson = documentJsonCreator . apply ( document ) ; final Request indexRequest = createIndexRequest ( document ) ; indexRequest . setJsonEntity ( documentJson ) ; try { restClient . performRequest ( indexRequest ) ; } catch ( final IOException innerIoException ) { throw new IllegalStateException ( "error writing document " + documentJson , innerIoException ) ; } } ) ; } catch ( final IOException ioException ) { throw new IllegalStateException ( "error writing documents to elasticsearch index" , ioException ) ; } return null ;
intersectionRetainAll: public static Set < Integer > intersectionRetainAll ( Set < Integer > first , Set < Integer > second ) { Set < Integer > intersection = new HashSet < > ( first ) ; intersection . retainAll ( second ) ; return intersection ;
lockInput: public boolean lockInput ( ) { return true ;
run: public void run ( ) { long startTime = System . nanoTime ( ) ; System . out . println ( getName ( ) + " started" ) ; while ( ! interrupted ( ) ) { System . out . printf ( "%s running since %d ms\n" , getName ( ) , TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - startTime ) ) ; } System . out . println ( getName ( ) + " terminated" ) ;
getTitleView: public View getTitleView ( ) { return getView ( R . id . layout_title_parent ) ;
getPressure: public double getPressure ( ) { return pressure ;
error: public void error ( String reason ) { waitLoadingMenu . pop ( ) ; pushMenu ( new AlertPopup ( L . get ( reason ) ) ) ;
testUpdateFrontendName: public void testUpdateFrontendName ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/AttributeGroupUpdateFrontendNameRequest.json" ) ; Map < String , String > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . attributeGroups ( ) . updateFrontendName ( "acme" , requestEntity , options ) ;
getPageTitle: public CharSequence getPageTitle ( int position ) { if ( mIndicators != null ) { return mIndicators [ position % mIndicators . length ] ; } if ( mIndicatorsList != null ) { return mIndicatorsList . get ( position % mIndicatorsList . size ( ) ) ; } return "" ;
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof SendResponse ) ) return false ; SendResponse that = ( SendResponse ) o ; return status == that . status && Objects . equals ( invocationId , that . invocationId ) ;
applyProperties: private void applyProperties ( MailProperties properties , JavaMailSenderImpl sender ) { sender . setHost ( properties . getHost ( ) ) ; if ( properties . getPort ( ) != null ) { sender . setPort ( properties . getPort ( ) ) ; } sender . setUsername ( properties . getUsername ( ) ) ; sender . setPassword ( properties . getPassword ( ) ) ; sender . setProtocol ( properties . getProtocol ( ) ) ; if ( properties . getDefaultEncoding ( ) != null ) { sender . setDefaultEncoding ( properties . getDefaultEncoding ( ) . name ( ) ) ; } if ( ! properties . getProperties ( ) . isEmpty ( ) ) {
onChanged: protected void onChanged ( int newValue ) { SendResourcesToClanMenu . this . amount = newValue ;
onError: public void onError ( Exception e ) { if ( e . getMessage ( ) . equals ( "EOF" ) ) { return ; } LogUtils . e ( TAG , "------------------oBSafeBoxCloseChannelOnError------------------" + e . getMessage ( ) ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
setStackSpace: public void setStackSpace ( float space ) { mStackSpace = space ;
onChartDoubleTapped: No method body
getPhase: public Phase getPhase ( ) { return phase ;
reset: public void reset ( ) { this . visible = false ;
startApp: protected static void startApp ( Class appClass , String [ ] args , boolean forced ) { mainClass = appClass ; if ( ! forced ) { boolean isForce = args != null && Arrays . stream ( args ) . anyMatch ( a -> "--force" . equals ( a ) ) ; initializationSafetyCheck ( isForce ) ; } System . setProperty ( "jakarta.xml.bind.JAXBContextFactory" , "com.sun.xml.bind.v2.ContextFactory" ) ; context = SpringApplication . run ( appClass , args ) ; BasicCustomisationService customisationService = context . getBean ( BasicCustomisationService . class ) ;
getCode: public String getCode ( ) { return code ;
getCroppedRoundBitmap: public Bitmap getCroppedRoundBitmap ( Bitmap bmp , int radius ) { Bitmap scaledSrcBmp ; int diameter = radius * 2 ; int bmpWidth = bmp . getWidth ( ) ; int bmpHeight = bmp . getHeight ( ) ; int squareWidth = 0 , squareHeight = 0 ; int x = 0 , y = 0 ; Bitmap squareBitmap ; if ( bmpHeight > bmpWidth ) { squareWidth = squareHeight = bmpWidth ; x = 0 ; y = ( bmpHeight - bmpWidth ) / 2 ; squareBitmap = Bitmap . createBitmap ( bmp , x , y , squareWidth , squareHeight ) ; } else if ( bmpHeight < bmpWidth ) { squareWidth = squareHeight = bmpHeight ; x = ( bmpWidth - bmpHeight ) / 2 ; y = 0 ; squareBitmap = Bitmap . createBitmap ( bmp , x , y , squareWidth , squareHeight ) ; } else { squareBitmap = bmp ; } if ( squareBitmap . getWidth ( ) != diameter || squareBitmap . getHeight ( ) != diameter ) { scaledSrcBmp = Bitmap . createScaledBitmap ( squareBitmap , diameter , diameter , true ) ; } else { scaledSrcBmp = squareBitmap ; } Bitmap output = Bitmap . createBitmap ( scaledSrcBmp . getWidth ( ) , scaledSrcBmp . getHeight ( ) , Bitmap . Config . ARGB_8888 ) ; Canvas canvas = new Canvas ( output ) ; Paint paint = new Paint ( ) ; Rect rect = new Rect ( 0 , 0 , scaledSrcBmp . getWidth ( ) , scaledSrcBmp . getHeight ( ) ) ; paint . setAntiAlias ( true ) ; paint . setFilterBitmap ( true ) ; paint . setDither ( true ) ; canvas . drawARGB ( 0 , 0 , 0 , 0 ) ; canvas . drawCircle ( scaledSrcBmp . getWidth ( ) / 2 , scaledSrcBmp . getHeight ( ) / 2 , scaledSrcBmp . getWidth ( ) / 2 , paint ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . SRC_IN ) ) ; canvas . drawBitmap ( scaledSrcBmp , rect , rect , paint ) ; bmp = null ; squareBitmap = null ; scaledSrcBmp = null ; return output ;
initOrUpdateDataStartApp: private static void initOrUpdateDataStartApp ( Context context ) { AssetsValueDataDao assetsValueDataDao = new AssetsValueDataDao ( context ) ; assetsValueDataDao . completeAssetData ( ) ; getBtcBalanceAction ( context ) ;
getDistance: float getDistance ( MapDimensionGraphPoint map ) { MapDistanceEntry entry = get ( map , null ) ; if ( entry == null ) return Float . POSITIVE_INFINITY ; return entry . distance ;
rejectAsync: default CompletableFuture < Void > rejectAsync ( String reason ) { return rejectAsync ( reason , RequestOptions . DEFAULT ) ;
setContent: public void setContent ( String content ) { this . content = content ;
deleteConfigurationsForOrganization: public boolean deleteConfigurationsForOrganization ( OrganizationDto organization ) { return true ;
run: public void run ( ) { setText ( text ) ;
inviteNewOrExistingUserNullOrgTest: public void inviteNewOrExistingUserNullOrgTest ( ) { User user = mockAndAuthenticateUser ( 1l , "test@openkoda.com" , "TEST" , "" ) ; InviteUserForm userForm = new InviteUserForm ( ) ; try { Tuple3 < Email , User , InviteUserForm > result = userService . inviteNewOrExistingUser ( userForm , user , null ) ; } catch ( Exception e ) { return ; } fail ( "Organization must not be null" ) ;
updateStatusById: No method body
saveSettings: protected PageModelMap saveSettings ( LoggerForm loggerFormData , BindingResult br ) { debug ( "[saveSettings]" ) ; return Flow . init ( loggerForm , loggerFormData )
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductCreateRequest.json" ) ; Product requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Product . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Product responseEntity = this . api . products ( ) . create ( requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
getFrom: public String getFrom ( ) { return from ;
setSMSTips: public void setSMSTips ( int smsTipsId ) { this . mSMSTips = getContext ( ) . getResources ( ) . getString ( smsTipsId ) ;
start: public void start ( ) { if ( isPlaying ) { return ; } isPlaying = true ; play ( mCurrentFrame ) ;
logitBias: public OpenAiChatCompletionsParameters logitBias ( final Map < Integer , Integer > logitBias ) { setLogitBias ( logitBias ) ; return this ;
copy: public DataSet < Entry > copy ( ) { List < Entry > entries = new ArrayList < Entry > ( ) ; for ( int i = 0 ; i < mEntries . size ( ) ; i ++ ) { entries . add ( mEntries . get ( i ) . copy ( ) ) ; } ScatterDataSet copied = new ScatterDataSet ( entries , getLabel ( ) ) ; copy ( copied ) ; return copied ;
canDropConsumable: public boolean canDropConsumable ( Client playerClient , ConsumableItem item ) { return false ;
extendedSectionWidth: public float extendedSectionWidth ( ) { return 192 ;
getX: public float getX ( ) { return activeData . getX ( ) ;
getEntryCount: public int getEntryCount ( ) { return mEntries . size ( ) ;
isLocked: public boolean isLocked ( ) { return locked ;
onCancel: public void onCancel ( @ Nullable Throwable t ) { exitFut . cancel ( true ) ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
createChange: public String createChange ( AuditableEntity auditedObject , AuditedObjectState aos , String entityClassName ) { debug ( "[createChange] {} {} {}" , auditedObject , aos , entityClassName ) ; StringBuilder change = new StringBuilder ( ) ; change . append ( entityClassName ) ; switch ( aos . getOperation ( ) ) {
subtractMultiple: public final void subtractMultiple ( Vector3 other , float multiplicator ) { x -= other . x * multiplicator ; y -= other . y * multiplicator ; z -= other . z * multiplicator ;
test_createTenant: public void test_createTenant ( ) throws IOException , NovuNetworkException , InterruptedException { TenantRequest tenantRequest = new TenantRequest ( ) ; tenantRequest . setName ( "name" ) ; tenantRequest . setIdentifier ( "id" ) ; TenantResponse tenantResponse = new TenantResponse ( ) ; tenantResponse . setData ( new Tenant ( ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( tenantResponse ) ) ) ; TenantResponse response = tenantsHandler . createTenant ( tenantRequest ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/tenants" , request . getPath ( ) ) ; assertEquals ( "POST" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( tenantResponse ) , gson . toJson ( response ) ) ;
destroyItem: protected boolean destroyItem ( ) { return true ;
clicked: public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . back ) ; pop ( ) ;
error: public void error ( String reason ) { waitLoadingMenu . popMeAndPushMenu ( new AlertPopup ( L . get ( reason ) ) ) ;
getStartupSound: public SoundEffect getStartupSound ( ) { return startupSound ;
registerEntryToAck: void registerEntryToAck ( int entryIndex ) { this . lastEntryToAck = Math . max ( entryIndex , this . lastEntryToAck ) ;
refillHunger: public void refillHunger ( float hunger ) { this . hunger = Math . min ( this . hunger + hunger , getContentComponent ( ) . getHungerMax ( ) ) ;
getXEntrySpace: public float getXEntrySpace ( ) { return mXEntrySpace ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case settingsUpdated : { updateVolume ( ) ; break ; } case simple : { if ( ( ( SimpleEvent ) event ) . getAction ( ) == SimpleEvent . Action . audioUpdated ) { updateVolume ( ) ; } break ; } case gameController : { GameControllerEvent gcEvent = ( ( GameControllerEvent ) event ) ; switch ( gcEvent . action ) { case voiceChatBegin : { startStreaming ( ) ; break ; } case voiceChatEnd : { stopStreaming ( ) ; break ; } } } } return false ;
getParticle: public com . badlogic . gdx . graphics . g2d . ParticleEffect getParticle ( ) { return particle ;
getLayoutId: protected int getLayoutId ( ) { return R . layout . view_refresh_header_main_page ;
onTouchEvent: public boolean onTouchEvent ( MotionEvent event ) { super . onTouchEvent ( event ) ; if ( mChartTouchListener == null || mData == null ) return false ; if ( ! mTouchEnabled )
getEmail: public String getEmail ( ) { return email ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ;
preferableShootMode: No method body
loadBoth: public boolean loadBoth ( PlayerOwnerComponent playerOwnerComponent , boolean full , boolean loadTime ) { if ( loadTime ) { state = State . reloading ; reloadTimer = getReloadBothTime ( ) . asFloat ( ) ; } else { state = State . normal ; } fixStuck ( ) ; if ( weaponProperties . isPerBulletReload ( ) && ! full ) { if ( this . getRounds ( ) >= clipSize . asInt ( ) ) { return false ; } ConsumableContainer . AcquiredConsumables add = playerOwnerComponent . getAmmo ( 1 , getBullet ( ) ) ; setRounds ( getRounds ( ) + add . amount , ( getRoundsQuality ( ) * getRounds ( ) + add . amount * add . quality ) / ( getRounds ( ) + add . amount ) ) ; } else { if ( getRounds ( ) > 0 ) { unload ( playerOwnerComponent , false ) ; } ConsumableContainer . AcquiredConsumables g = playerOwnerComponent . getAmmo ( clipSize . asInt ( ) , getBullet ( ) ) ; setRounds ( g . amount , g . quality ) ; } updateWeapon ( true ) ; return true ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
setContentLoaded: public void setContentLoaded ( boolean contentLoaded ) { this . contentLoaded = contentLoaded ;
registerEventClass: public < T > boolean registerEventClass ( Class < T > eventClass ) { debug ( "[registerEventClass]" ) ; return eventClasses . add ( eventClass ) ;
verifyChecksum: private static boolean verifyChecksum ( byte [ ] hrp , byte [ ] data ) { byte [ ] exp = hrpExpand ( hrp ) ; byte [ ] values = new byte [ exp . length + data . length ] ; System . arraycopy ( exp , 0 , values , 0 , exp . length ) ; System . arraycopy ( data , 0 , values , exp . length , data . length ) ; return ( 1 == polymod ( values ) ) ;
getComponent: public BulletExplosiveComponentData getComponent ( ComponentObject componentObject ) { return new BulletExplosiveComponentData ( componentObject , this ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionIncrement2ActionPerformed ( evt ) ;
onDraw: protected void onDraw ( Canvas canvas ) { if ( mDrawable != null ) {
getY: public float getY ( ) { return phy . getY ( ) ;
getY: public float getY ( ) { return y ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { aFWOpen2ActionPerformed ( evt ) ;
setUserId: public void setUserId ( Long userId ) { this . userId = userId ;
isBlob: public boolean isBlob ( ) { return this == BLOB ;
readResolve: private Object readResolve ( ) { return INSTANCE ;
clickPwdEye: public void clickPwdEye ( ) { if ( mCanClick ) {
hasRender: public boolean hasRender ( ) { return true ;
updatePassword: public void updatePassword ( String oldPassword , String newPassword ) { User currentAdmin = securityUtils . getCurrentAdmin ( ) ; Assert . notNull ( currentAdmin , "用户登录已失效！" ) ; User user = this . baseMapper . selectById ( currentAdmin . getId ( ) ) ; Assert . notNull ( user , "未查询到该用户信息！" ) ; String encodeOldPassword = passwordEncoder . encode ( oldPassword ) ; if ( Objects . equals ( encodeOldPassword , user . getPassword ( ) ) ) { throw new PiscesException ( "密码不一致，请重新输入！" ) ; } String encodeNewPassword = passwordEncoder . encode ( newPassword ) ; Assert . isTrue ( this . baseMapper . updatePasswordById ( user . getId ( ) , encodeNewPassword ) > 0 , "更新密码失败！" ) ;
setScatterShapeHoleColor: public void setScatterShapeHoleColor ( int holeColor ) { mScatterShapeHoleColor = holeColor ;
getMagazines: public IntMap . Keys getMagazines ( ) { return magazines . keys ( ) ;
reverse: public String reverse ( String s ) { return new StringBuilder ( s ) . reverse ( ) . toString ( ) ;
createAttribute: public AttributeGroupAttribute createAttribute ( String attributeGroupName , AttributeGroupAttribute model ) throws ApiErrorException , ConnectionException { Class < AttributeGroupAttribute > responseModel = ( Class < AttributeGroupAttribute > ) ( Class < ? > ) AttributeGroupAttribute . class ; return this . request ( "post" , this . resolvePath ( "/attribute-groups/%s/attributes" , attributeGroupName ) , null , null , responseModel , model ) ;
deposit: No method body
pageFinished: private void pageFinished ( WebView view ) { mProgressBar . setProgress ( 100 ) ; postDelayed ( new Runnable ( ) { @ Override public void run ( ) { mProgressBar . setVisibility ( View . GONE ) ; } } , 100 ) ; if ( ! mWebSettings . getLoadsImagesAutomatically ( ) ) { mWebSettings . setLoadsImagesAutomatically ( true ) ; } if ( mCallBack != null ) {
abandonChannel: public Single < lnrpc . LightningOuterClass . AbandonChannelResponse > abandonChannel ( lnrpc . LightningOuterClass . AbandonChannelRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . abandonChannel ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
SortRecords: public static int SortRecords ( ConsumableRecord record ) { ConsumableItem item = record . getItem ( ) ; if ( item instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) item ) ; Instrument instrument = ( ( Instrument ) ici . getContent ( ) ) ; Slot slot = instrument . getSlot ( ) ; if ( slot != null ) { int index = Constants . Inventory . SLOTS . indexOf ( slot . getID ( ) , false ) ; if ( index < 0 ) { return 5000 ; } return index * 100 ; } } return 5000 ;
switchZoom: private void switchZoom ( ) { ClientPlayerComponent cpc = getPlayerData ( ) . getComponent ( ClientPlayerComponent . class ) ; if ( cpc . getScale ( ) == 1.0f )
sideEffectGuard: protected TestInvocationBuilder sideEffectGuard ( ) { return testDefinitionForService (
registerUserOrReturnExisting: public User registerUserOrReturnExisting ( String email , String firstName , String lastName ) { RegisterUserForm form = new RegisterUserForm ( ) ; form . setLogin ( email ) ; form . setFirstName ( firstName ) ; form . setLastName ( lastName ) ; return userService . registerUserOrReturnExisting ( form , false ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { con2StopActionPerformed ( evt ) ;
getAudiences: public ApiCollection < Audience > getAudiences ( ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Audience > responseModel = ( Class < Audience > ) ( Class < ? > ) Audience . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/promotions/audiences" ) , query , null , responseModel ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoSteamPressure2OffItemStateChanged ( evt ) ;
decode: private static void decode ( String s , OutputStream os ) throws IOException { int i = 0 ; int len = s . length ( ) ; while ( true ) {
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . customDataConfigs ( ) . delete ( "acme" , options ) ;
update: public void update ( float dt ) { effect . setPosition ( getX ( ) , getY ( ) ) ; float angle = getAngle ( ) ; for ( ParticleEmitter emitter : effect . getEmitters ( ) ) { emitter . getAngle ( ) . setHigh ( angleMin + angle , angleMax + angle ) ; emitter . getRotation ( ) . setHigh ( rotationMin + angle , rotationMax + angle ) ; } effect . update ( dt ) ;
toAuditString: public String toAuditString ( ) { return this . getClass ( ) . getSimpleName ( ) ;
testDeleteCustomData: public void testDeleteCustomData ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . products ( ) . deleteCustomData ( Identifier . fromId ( 1 ) , options ) ;
registerAtlas: public void registerAtlas ( String atlasName , String fileName , AssetManager assetManager ) { dataNames . add ( atlasName ) ; TextureAtlas txt ; try { txt = assetManager . get ( fileName , TextureAtlas . class ) ; } catch ( GdxRuntimeException ignored ) { return ; } if ( atlasName . equals ( "GAME" ) ) { game = txt ; } data . put ( atlasName , txt ) ; BrainOutClient . Skin . addRegions ( txt ) ;
promoResult: private void promoResult ( PromoCodeResultMsg . Result result ) { pop ( ) ; switch ( result )
write: public void write ( Json json ) { json . writeArrayStart ( "index" ) ; for ( String content : contentToIndex ) { json . writeValue ( content ) ; } json . writeArrayEnd ( ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
onError: public void onError ( ) { spinner . hide ( ) ; DiscordTools . basicAlert (
onClick: public void onClick ( DialogInterface dialog , int which ) { positiveButtonOnClick ( dialog , onClickListener ) ;
hasRender: public boolean hasRender ( ) { return false ;
beforeDictControllerTest: static void beforeDictControllerTest ( ) { dictPageListParam = new DictPageListParam ( ) ; dictPageListParam . setPageNum ( 1 ) ; dictPageListParam . setPageSize ( 10 ) ; dictPageListParam . setQueryKey ( "" ) ; addDictParam = new AddDictParam ( ) ; addDictParam . setGroupName ( "TEST_ADD" ) ; addDictParam . setKey ( "TEST_KEY" ) ; addDictParam . setKey ( "TEST_VALUE" ) ; addDictParam . setRemark ( "这是一条接口测试生成的数据" ) ; updateDictParam = new UpdateDictParam ( ) ; updateDictParam . setId ( 100L ) ; updateDictParam . setGroupName ( "TEST_POST" ) ; updateDictParam . setKey ( "TEST_KEY" ) ; updateDictParam . setValue ( "TEST_VALUE" ) ; updateDictParam . setRemark ( "这是一条接口测试更新的数据" ) ;
delete: public void delete ( Integer brandId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/brands/%s" , brandId ) , null , null , null ) ;
isTraceEnabled: public boolean isTraceEnabled ( ) { return logger . isTraceEnabled ( ) ;
getOffsetScaleX: public float getOffsetScaleX ( ) { return offsetScaleX ;
registerUserTest: public void registerUserTest ( ) { reset ( userRepository ) ; User user = mock ( User . class ) ; Organization organization = mock ( Organization . class ) ; RegisterUserForm userForm = new RegisterUserForm ( ) ; userForm . setLogin ( USER_EMAIL ) ; userForm . setFirstName ( USER_FIRST_NAME ) ; userForm . setLastName ( USER_LAST_NAME ) ; userForm . setPassword ( StringUtils . EMPTY ) ; when ( userRepository . findByLogin ( anyString ( ) ) ) . thenReturn ( null ) ; when ( organizationRepository . save ( any ( Organization . class ) ) ) . thenReturn ( organization ) ; when ( userRepository . save ( any ( User . class ) ) ) . thenReturn ( user ) ; when ( organizationRepository . findOne ( anyLong ( ) ) ) . thenReturn ( organization ) ; when ( user . getId ( ) ) . thenReturn ( 1L ) ; when ( user . getName ( ) ) . thenReturn ( USER_FIRST_NAME + USER_LAST_NAME ) ; when ( user . getEmail ( ) ) . thenReturn ( USER_EMAIL ) ; when ( userRepository . findOne ( anyLong ( ) ) ) . thenReturn ( user ) ; when ( organization . getId ( ) ) . thenReturn ( 1L ) ; when ( tokenService . createTokenForUser ( user , Privilege . canVerifyAccount ) ) . thenReturn ( new Token ( ) ) ; User result = userService . registerUserOrReturnExisting ( userForm ) ; verify ( userRepository , times ( 2 ) ) . save ( any ( User . class ) ) ; assertNotNull ( result ) ; assertEquals ( USER_EMAIL , result . getEmail ( ) ) ;
onEnable: public void onEnable ( ) { registerService ( ) ;
get: public Shop get ( String shopKey , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Shop > responseModel = ( Class < Shop > ) ( Class < ? > ) Shop . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s" , shopKey ) , query , null , responseModel ) ;
createFileFromStream: No method body
getMonthFirstdayDateZero: public static long getMonthFirstdayDateZero ( ) { Calendar c = Calendar . getInstance ( ) ; c . add ( Calendar . MONTH , 0 ) ; c . set ( Calendar . DAY_OF_MONTH , 1 ) ; c . set ( Calendar . HOUR_OF_DAY , 0 ) ; c . set ( Calendar . MINUTE , 0 ) ; c . set ( Calendar . SECOND , 0 ) ; c . set ( Calendar . MILLISECOND , 0 ) ; return c . getTimeInMillis ( ) ;
isFriend: public boolean isFriend ( int id ) { return friends . contains ( id ) ;
getOrganizationId: public Long getOrganizationId ( ) { return organizationId ;
getContent: public OwnableContent getContent ( ) { return ( ( OwnableContent ) BrainOut . ContentMgr . get ( rewardContent ) ) ;
clientInitialized: public void clientInitialized ( Client client , boolean reconnected ) { super . clientInitialized ( client , reconnected ) ; if ( ! client . isAlive ( ) )
getAngle: public float getAngle ( ) { return angle ;
update: public void update ( float dt ) { super . update ( dt ) ; timeOfDay += timeOfDayUpdateSpeed * dt ; if ( timeOfDay > 1 )
isViewFromObject: public boolean isViewFromObject ( View view , Object object ) { return view == object ;
init: private Event init ( String effect ) { this . effect = effect ; return this ;
setSubscriptionStatus: public void setSubscriptionStatus ( String subscriptionStatus ) { this . subscriptionStatus = subscriptionStatus ;
sendOutputs: public Single < walletrpc . Walletkit . SendOutputsResponse > sendOutputs ( walletrpc . Walletkit . SendOutputsRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . sendOutputs ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
showInFileManager: public static void showInFileManager ( File file ) throws IOException { if ( SystemUtils . IS_OS_WINDOWS )
itemStateChanged: public void itemStateChanged ( ItemEvent e ) { if ( e . getStateChange ( ) == 1 ) {
getCamera: public OrthographicCamera getCamera ( ) { return camera ;
getVisibleXRange: public float getVisibleXRange ( ) { return Math . abs ( getHighestVisibleX ( ) - getLowestVisibleX ( ) ) ;
release: public void release ( ) { if ( mBasePopWindow != null ) { mBasePopWindow . dismiss ( ) ; mBasePopWindow = null ; } if ( mCreateChannelStepOnePopupWindow != null ) { mCreateChannelStepOnePopupWindow . release ( ) ; } if ( mCreateChannelDialog != null ) {
onPull: public void onPull ( int currentDragHeight , int refreshViewHeight , int currentRefreshStatus ) { float rotate = ( ( float ) currentDragHeight ) / refreshViewHeight ; mRefreshIcon . setRotation ( rotate * 360 ) ; if ( currentDragHeight >= refreshViewHeight ) {
getDr: public int getDr ( ) { return dr ;
onDoubleClick: No method body
sendTCP: public void sendTCP ( Object object ) { if ( serverConnection != null )
getStageInstances: public static StoreStageInstances getStageInstances ( ) { return new StoreStageInstances ( ) ;
isConnected: public boolean isConnected ( final @ NonNull JRPCClientInstance instance ) { return connected . stream ( ) . anyMatch ( other -> other . getUniqueId ( ) . equalsIgnoreCase ( instance . getUniqueId ( ) ) ) ;
getMailgunApiKey: public String getMailgunApiKey ( ) { return mailgunApiKey ;
show: public void show ( final View view ) { if ( mBasePopWindow == null ) {
escape: public boolean escape ( ) { pop ( ) ; return true ;
setUserJob: public void setUserJob ( Context context , String userJob ) { PreferencesUtils . saveUserJobToLocal ( context , userJob ) ; this . userJob = userJob ;
getAcceptedIssuers: public X509Certificate [ ] getAcceptedIssuers ( ) { return new X509Certificate [ ] { } ;
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { return ; } try {
getUrl: public String getUrl ( ) { return url ;
create: public Voucher create ( String shopKey , String countryCode , Voucher model ) throws ApiErrorException , ConnectionException { Class < Voucher > responseModel = ( Class < Voucher > ) ( Class < ? > ) Voucher . class ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/vouchers" , shopKey , countryCode ) , null , null , responseModel , model ) ;
getAngle: public float getAngle ( ) { return 0 ;
sortIkConstraint: private void sortIkConstraint ( IkConstraint constraint ) { constraint . active = constraint . target . active && ( ! constraint . data . skinRequired || ( skin != null && skin . constraints . contains ( constraint . data , true ) ) ) ; if ( ! constraint . active ) return ; Bone target = constraint . target ; sortBone ( target ) ; Array < Bone > constrained = constraint . bones ; Bone parent = constrained . first ( ) ; sortBone ( parent ) ; if ( constrained . size == 1 ) {
setColor: public void setColor ( Color tint ) { light . set ( tint ) ; lightPacked = tint . toFloatBits ( ) ;
loadJSONFromAsset: public String loadJSONFromAsset ( Context context ) { String json = null ; try { InputStream is = context . getAssets ( ) . open ( "asset_list.json" ) ; int size = is . available ( ) ; byte [ ] buffer = new byte [ size ] ; is . read ( buffer ) ; is . close ( ) ; json = new String ( buffer , "UTF-8" ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; return null ; } LogUtils . e ( LOG_TAG , "Error reading country_list JSON: " + json . toString ( ) ) ; return json ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { trip1ActionPerformed ( evt ) ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , FieldType type ) { return new FrontendMappingFieldDefinition ( formName , name , type , null , null , null , null , null , null , false , null , null , null , false , null , null , null , null , null , null , null , null , null , null , false , false ) ;
setMixY: public void setMixY ( float mixY ) { this . mixY = mixY ;
getFormattedValue: public String getFormattedValue ( float value , AxisBase axis ) { int index = ( int ) value ; if ( index < 0 || index >= result . size ( ) ) { return "" ; } return result . get ( index ) . getTime ( ) ;
init: public void init ( ) { super . init ( ) ; this . effect = getContentComponent ( ) . getEffect ( ) ; setTimer ( ) ;
changePassword: public Single < lnrpc . Walletunlocker . ChangePasswordResponse > changePassword ( lnrpc . Walletunlocker . ChangePasswordRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . changePassword ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
onCreate: public void onCreate ( Bundle bundle ) { super . onCreate ( bundle ) ; int overrideXml = this . getArguments ( ) == null ? 0 : this . getArguments ( ) . getInt ( "pref" , 0 ) ; addPreferencesFromResource ( overrideXml == 0 ? Constants . PREFS_BASE : overrideXml ) ; handleBackgroundState ( ) ;
populateTo: protected File populateTo ( File entity ) { entity . setFilename ( getSafeValue ( entity . getFilename ( ) , FileFrontendMappingDefinitions . FILENAME_ ) ) ; entity . setPublicFile ( getSafeValue ( entity . isPublicFile ( ) , FileFrontendMappingDefinitions . PUBLIC_FILE_ ) ) ; entity . setContentType ( getSafeValue ( entity . getContentType ( ) , FileFrontendMappingDefinitions . CONTENT_TYPE_ ) ) ; return entity ;
initMode: public void initMode ( InitCallback callback ) { mode . init ( callback ) ;
buttonStyleYes: public String buttonStyleYes ( ) { return "button-green" ;
doLaunch: private void doLaunch ( ) { component . activate ( consumableRecord ) ; setState ( State . launched ) ;
computeWorldPositions: float [ ] computeWorldPositions ( PathAttachment path , int spacesCount , boolean tangents ) { Slot target = this . target ; float position = this . position ; float [ ] spaces = this . spaces . items , out = this . positions . setSize ( spacesCount * 3 + 2 ) , world ; boolean closed = path . getClosed ( ) ; int verticesLength = path . getWorldVerticesLength ( ) , curveCount = verticesLength / 6 , prevCurve = NONE ; if ( ! path . getConstantSpeed ( ) ) { float [ ] lengths = path . getLengths ( ) ; curveCount -= closed ? 1 : 2 ; float pathLength = lengths [ curveCount ] ; if ( data . positionMode == PositionMode . percent ) position *= pathLength ; float multiplier ; switch ( data . spacingMode ) { case percent : multiplier = pathLength ; break ; case proportional : multiplier = pathLength / spacesCount ; break ; default : multiplier = 1 ; } world = this . world . setSize ( 8 ) ; for ( int i = 0 , o = 0 , curve = 0 ; i < spacesCount ; i ++ , o += 3 ) { float space = spaces [ i ] * multiplier ; position += space ; float p = position ; if ( closed ) { p %= pathLength ; if ( p < 0 ) p += pathLength ; curve = 0 ; } else if ( p < 0 ) { if ( prevCurve != BEFORE ) { prevCurve = BEFORE ; path . computeWorldVertices ( target , 2 , 4 , world , 0 , 2 ) ; } addBeforePosition ( p , world , 0 , out , o ) ; continue ; } else if ( p > pathLength ) { if ( prevCurve != AFTER ) { prevCurve = AFTER ; path . computeWorldVertices ( target , verticesLength - 6 , 4 , world , 0 , 2 ) ; } addAfterPosition ( p - pathLength , world , 0 , out , o ) ; continue ; } for ( ; ; curve ++ ) { float length = lengths [ curve ] ; if ( p > length ) continue ; if ( curve == 0 ) p /= length ; else { float prev = lengths [ curve - 1 ] ; p = ( p - prev ) / ( length - prev ) ; } break ; } if ( curve != prevCurve ) { prevCurve = curve ; if ( closed && curve == curveCount ) { path . computeWorldVertices ( target , verticesLength - 4 , 4 , world , 0 , 2 ) ; path . computeWorldVertices ( target , 0 , 4 , world , 4 , 2 ) ; } else path . computeWorldVertices ( target , curve * 6 + 2 , 8 , world , 0 , 2 ) ; } addCurvePosition ( p , world [ 0 ] , world [ 1 ] , world [ 2 ] , world [ 3 ] , world [ 4 ] , world [ 5 ] , world [ 6 ] , world [ 7 ] , out , o , tangents || ( i > 0 && space < epsilon ) ) ; } return out ; } if ( closed ) { verticesLength += 2 ; world = this . world . setSize ( verticesLength ) ; path . computeWorldVertices ( target , 2 , verticesLength - 4 , world , 0 , 2 ) ; path . computeWorldVertices ( target , 0 , 2 , world , verticesLength - 4 , 2 ) ; world [ verticesLength - 2 ] = world [ 0 ] ; world [ verticesLength - 1 ] = world [ 1 ] ; } else { curveCount -- ; verticesLength -= 4 ; world = this . world . setSize ( verticesLength ) ; path . computeWorldVertices ( target , 2 , verticesLength , world , 0 , 2 ) ; } float [ ] curves = this . curves . setSize ( curveCount ) ; float pathLength = 0 ; float x1 = world [ 0 ] , y1 = world [ 1 ] , cx1 = 0 , cy1 = 0 , cx2 = 0 , cy2 = 0 , x2 = 0 , y2 = 0 ; float tmpx , tmpy , dddfx , dddfy , ddfx , ddfy , dfx , dfy ; for ( int i = 0 , w = 2 ; i < curveCount ; i ++ , w += 6 ) { cx1 = world [ w ] ; cy1 = world [ w + 1 ] ; cx2 = world [ w + 2 ] ; cy2 = world [ w + 3 ] ; x2 = world [ w + 4 ] ; y2 = world [ w + 5 ] ; tmpx = ( x1 - cx1 * 2 + cx2 ) * 0.1875f ; tmpy = ( y1 - cy1 * 2 + cy2 ) * 0.1875f ; dddfx = ( ( cx1 - cx2 ) * 3 - x1 + x2 ) * 0.09375f ; dddfy = ( ( cy1 - cy2 ) * 3 - y1 + y2 ) * 0.09375f ; ddfx = tmpx * 2 + dddfx ; ddfy = tmpy * 2 + dddfy ; dfx = ( cx1 - x1 ) * 0.75f + tmpx + dddfx * 0.16666667f ; dfy = ( cy1 - y1 ) * 0.75f + tmpy + dddfy * 0.16666667f ; pathLength += ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; dfx += ddfx ; dfy += ddfy ; ddfx += dddfx ; ddfy += dddfy ; pathLength += ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; dfx += ddfx ; dfy += ddfy ; pathLength += ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; dfx += ddfx + dddfx ; dfy += ddfy + dddfy ; pathLength += ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; curves [ i ] = pathLength ; x1 = x2 ; y1 = y2 ; } if ( data . positionMode == PositionMode . percent ) position *= pathLength ; float multiplier ; switch ( data . spacingMode ) { case percent : multiplier = pathLength ; break ; case proportional : multiplier = pathLength / spacesCount ; break ; default : multiplier = 1 ; } float [ ] segments = this . segments ; float curveLength = 0 ; for ( int i = 0 , o = 0 , curve = 0 , segment = 0 ; i < spacesCount ; i ++ , o += 3 ) { float space = spaces [ i ] * multiplier ; position += space ; float p = position ; if ( closed ) { p %= pathLength ; if ( p < 0 ) p += pathLength ; curve = 0 ; } else if ( p < 0 ) { addBeforePosition ( p , world , 0 , out , o ) ; continue ; } else if ( p > pathLength ) { addAfterPosition ( p - pathLength , world , verticesLength - 4 , out , o ) ; continue ; } for ( ; ; curve ++ ) { float length = curves [ curve ] ; if ( p > length ) continue ; if ( curve == 0 ) p /= length ; else { float prev = curves [ curve - 1 ] ; p = ( p - prev ) / ( length - prev ) ; } break ; } if ( curve != prevCurve ) { prevCurve = curve ; int ii = curve * 6 ; x1 = world [ ii ] ; y1 = world [ ii + 1 ] ; cx1 = world [ ii + 2 ] ; cy1 = world [ ii + 3 ] ; cx2 = world [ ii + 4 ] ; cy2 = world [ ii + 5 ] ; x2 = world [ ii + 6 ] ; y2 = world [ ii + 7 ] ; tmpx = ( x1 - cx1 * 2 + cx2 ) * 0.03f ; tmpy = ( y1 - cy1 * 2 + cy2 ) * 0.03f ; dddfx = ( ( cx1 - cx2 ) * 3 - x1 + x2 ) * 0.006f ; dddfy = ( ( cy1 - cy2 ) * 3 - y1 + y2 ) * 0.006f ; ddfx = tmpx * 2 + dddfx ; ddfy = tmpy * 2 + dddfy ; dfx = ( cx1 - x1 ) * 0.3f + tmpx + dddfx * 0.16666667f ; dfy = ( cy1 - y1 ) * 0.3f + tmpy + dddfy * 0.16666667f ; curveLength = ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; segments [ 0 ] = curveLength ; for ( ii = 1 ; ii < 8 ; ii ++ ) { dfx += ddfx ; dfy += ddfy ; ddfx += dddfx ; ddfy += dddfy ; curveLength += ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; segments [ ii ] = curveLength ; } dfx += ddfx ; dfy += ddfy ; curveLength += ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; segments [ 8 ] = curveLength ; dfx += ddfx + dddfx ; dfy += ddfy + dddfy ; curveLength += ( float ) Math . sqrt ( dfx * dfx + dfy * dfy ) ; segments [ 9 ] = curveLength ; segment = 0 ; } p *= curveLength ; for ( ; ; segment ++ ) { float length = segments [ segment ] ; if ( p > length ) continue ; if ( segment == 0 ) p /= length ; else { float prev = segments [ segment - 1 ] ; p = segment + ( p - prev ) / ( length - prev ) ; } break ; } addCurvePosition ( p * 0.1f , x1 , y1 , cx1 , cy1 , cx2 , cy2 , x2 , y2 , out , o , tangents || ( i > 0 && space < epsilon ) ) ; } return out ;
renderSprite: private Group renderSprite ( SpriteWithBlocksComponent sprite ) { Group entry = new Group ( ) ; for ( SpriteWithBlocksComponent . SpriteImage spriteImage : sprite . getImages ( ) ) { Image image = new Image ( BrainOutClient . Skin , spriteImage . getImage ( ) ) ; image . setTouchable ( Touchable . disabled ) ; image . setBounds ( spriteImage . getX ( ) * Constants . Graphics . BLOCK_SIZE , spriteImage . getY ( ) * Constants . Graphics . BLOCK_SIZE , spriteImage . getW ( ) * Constants . Graphics . BLOCK_SIZE , spriteImage . getH ( ) * Constants . Graphics . BLOCK_SIZE ) ; entry . addActor ( image ) ; } return entry ;
decodePayReq: No method body
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Order responseEntity = this . api . orders ( ) . get ( "acme" , "acme" , Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/OrderGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
createAddress: public CustomerAddress createAddress ( String shopKey , String countryCode , Identifier customerIdentifier , CustomerAddress model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomerAddress > responseModel = ( Class < CustomerAddress > ) ( Class < ? > ) CustomerAddress . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/addresses" , shopKey , countryCode , customerIdentifier ) , query , null , responseModel , model ) ;
test_getTenant: public void test_getTenant ( ) throws IOException , NovuNetworkException , InterruptedException { TenantResponse tenantResponse = new TenantResponse ( ) ; tenantResponse . setData ( new Tenant ( ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( tenantResponse ) ) ) ; TenantResponse response = tenantsHandler . getTenant ( "id" ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/tenants/id" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( tenantResponse ) , gson . toJson ( response ) ) ;
onMeasure: protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; int widthMode = MeasureSpec . getMode ( widthMeasureSpec ) ; int width = 0 ; if ( widthMode == MeasureSpec . UNSPECIFIED ) width = widthMeasureSpec ; else if ( widthMode == MeasureSpec . AT_MOST ) width = MeasureSpec . getSize ( widthMeasureSpec ) ; else if ( widthMode == MeasureSpec . EXACTLY ) width = MeasureSpec . getSize ( widthMeasureSpec ) ; int heightMode = MeasureSpec . getMode ( heightMeasureSpec ) ; int height = 0 ; if ( heightMode == MeasureSpec . UNSPECIFIED ) height = heightMeasureSpec ; else if ( heightMode == MeasureSpec . AT_MOST ) height = MeasureSpec . getSize ( heightMeasureSpec ) ; else if ( heightMode == MeasureSpec . EXACTLY ) height = MeasureSpec . getSize ( heightMeasureSpec ) ; setMeasuredDimension ( width , height ) ;
isFullyZoomedOutY: public boolean isFullyZoomedOutY ( ) { return ! ( mScaleY > mMinScaleY || mMinScaleY > 1f ) ;
cancelTail: private void cancelTail ( ) { done = true ;
getFiles: No method body
received: public boolean received ( StepMsg msg ) { Gdx . app . postRunnable ( ( ) -> { Block contact = BrainOutClient . ClientController . getContentFromIndex ( msg . i , Block . class ) ; if ( contact == null ) return ; BlockEffectsComponent e = contact . getComponent ( BlockEffectsComponent . class ) ; if ( e == null ) return ; e . getEffects ( ) . launchEffects ( "step" , new StepPointData ( msg . v , msg . p , msg . d ) ) ; } ) ; return true ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
warn: public void warn ( String msg , Throwable t ) { if ( isReleaseVersion ) {
subscribeTransactions: No method body
done: public boolean done ( ) { return super . done ( ) || distance >= bullet . getMaxDistance ( ) ;
func: public float func ( float x , float y ) { ActiveData it = ( ( ActiveData ) getComponentObject ( ) ) ; float dist = Math . abs ( it . getX ( ) - x ) ; float max = getContentComponent ( ) . getDistance ( ) ; if ( dist > max ) return 0 ; return ( 1.0f - dist / max ) ;
getServerJsThreads: public static Map < ServerJsThreadDto , LoggingEntriesStack < String > > getServerJsThreads ( ) { Map < ServerJsThreadDto , LoggingEntriesStack < String > > map = new HashMap < > ( ) ; for ( Map . Entry < Thread , LoggingEntriesStack < String > > item : serverJsThreads . entrySet ( ) ) { map . put ( new ServerJsThreadDto ( item . getKey ( ) ) , item . getValue ( ) ) ; } return map ;
generateNecessaryMagazines: public void generateNecessaryMagazines ( ) { if ( magazines == null ) return ; magazinesCount = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . NUMBER_OF_MAGAZINES ) , getWeaponData ( ) . getUpgrades ( ) . values ( ) ) ; int have = ( attachedMagazine != null ? 1 : 0 ) + magazines . size ; int need = 1 + magazinesCount . asInt ( ) ; for ( int i = have ; i < need ; i ++ ) { magazines . put ( getNextMagazineId ( ) , new Magazine ( ) ) ; } updateWeapon ( true ) ;
init: public PlayState init ( PlayState . InitCallback callback ) { return BrainOutServer . Controller . setPlayState ( callback , playState ) ;
switchSource: boolean switchSource ( PlayerOwnerComponent poc ) { unload ( poc , false ) ; return load ( poc , false , false ) ;
jMenuItem8ActionPerformed: private void jMenuItem8ActionPerformed ( java . awt . event . ActionEvent evt ) { createOrContinue ( FeedwaterUI . class , true , false ) ;
getComponent: public ChemicalExposureComponentData getComponent ( ComponentObject componentObject ) { return new ChemicalExposureComponentData ( ( ActiveData ) componentObject , this ) ;
getStatusColor: int getStatusColor ( ) { return R . drawable . bg_btn_round_ff0000_25 ;
changesMade: public boolean changesMade ( ) { return prevMousePosition . dst2 ( pcd . getMousePosition ( ) ) > 4 * 4 ;
haveUnreadMessages: public boolean haveUnreadMessages ( String recipientClass , String recipientKey ) { LastReadMessage lastRead = lastReadMessages . get ( recipientClass + "." + recipientKey ) ; for ( ObjectMap . Entry < String , ClientMessage > entry : messages ) { ClientMessage message = entry . value ; if ( ! message . recipientClass . equals ( recipientClass ) ) continue ; if ( ! message . recipientKey . equals ( recipientKey ) ) continue ; if ( lastRead == null ) return true ; if ( Objects . equals ( lastRead . messageId , message . messageId ) ) return false ; if ( lastRead . time . after ( message . time ) ) return false ; if ( ! message . isRead ( ) ) return true ; } return false ;
read: public void read ( Json json , JsonValue jsonData ) { speed . x = jsonData . getFloat ( "sx" ) ; speed . y = jsonData . getFloat ( "sy" ) ; enabled = jsonData . getBoolean ( "en" , true ) ;
createWorkflow: No method body
onError: public void onError ( Throwable throwable ) { this . input . onError ( throwable ) ;
saveGitHubConfig: public Object saveGitHubConfig ( @ PathVariable ( ORGANIZATIONID ) Long orgId , @ Valid IntegrationGitHubForm form , BindingResult br ) { debug ( "[saveGitHubConfig] OrgId: {}" , orgId ) ; return Flow . init ( integrationGitHubForm , form )
draw: public String draw ( Curve curve ) { return "i'm a pencil drawing " + curve . draw ( ) ;
getStartTime: public float getStartTime ( ) { return startTime ;
removeWidget: public void removeWidget ( Widget widget ) { widget . setStage ( null ) ; widget . release ( ) ; widget . remove ( ) ; widgets . removeValue ( widget , true ) ;
hasGlobalOrOrgPrivilege: default boolean hasGlobalOrOrgPrivilege ( String p , Long orgId ) { return hasGlobalPrivilege ( p ) || hasOrgPrivilege ( p , orgId ) ;
getId: public Long getId ( ) { return id ;
getMenuDict: public List < MenuDictDto > getMenuDict ( ) { List < MenuDictDto > menuDictDtoList = ( List < MenuDictDto > ) redisTemplate . opsForValue ( ) . get ( SystemDictConstants . MENU ) ; if ( CollectionUtils . isEmpty ( menuDictDtoList ) ) { synchronized ( this ) { menuDictDtoList = ( List < MenuDictDto > ) redisTemplate . opsForValue ( ) . get ( SystemDictConstants . MENU ) ; if ( CollectionUtils . isEmpty ( menuDictDtoList ) ) { List < MenuDto > menuDtoList = getAll ( ) ; if ( ! CollectionUtils . isEmpty ( menuDtoList ) ) { menuDictDtoList = getMenuDictHandler ( menuDtoList ) ; redisTemplate . opsForValue ( ) . set ( SystemDictConstants . MENU , menuDictDtoList ) ; } } } } return menuDictDtoList ;
shutdown: void shutdown ( ) { cancel ( ) ;
setPositionMode: public void setPositionMode ( PositionMode positionMode ) { if ( positionMode == null ) throw new IllegalArgumentException ( "positionMode cannot be null." ) ; this . positionMode = positionMode ;
filterTopics: public FilterTopicsResponse filterTopics ( final FilterTopicsRequest request ) throws IOException , NovuNetworkException { Map < String , Object > params = new HashMap < > ( ) ; if ( request . getPage ( ) != null ) { params . put ( "page" , request . getPage ( ) ) ; } if ( request . getPageSize ( ) != null ) { params . put ( "pageSize" , request . getPageSize ( ) ) ; } if ( request . getKey ( ) != null ) { params . put ( "key" , request . getKey ( ) ) ; } Response < FilterTopicsResponse > response = topicApi . filterTopics ( params ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
createOrUpdateCustomData: public Map < String , Object > createOrUpdateCustomData ( Identifier variantIdentifier , Map < String , Object > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/variants/%s/custom-data" , variantIdentifier ) , query , null , responseModel , model ) ;
releaseClient: public void releaseClient ( Client client ) { releaseClient ( client , true ) ;
received: public boolean received ( final EditorSetActivePropertiesMsg msg ) { if ( ! validateEditor ( ) ) return true ; BrainOutServer . PostRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; ActiveData activeData = map . getActiveData ( msg . activeId ) ; if ( activeData != null ) { setProperties ( activeData , new Array < > ( msg . properties ) ) ; activeData . updated ( ) ; } } ) ; return true ;
PointToLineDistance: public static float PointToLineDistance ( float x , float y , float x1 , float y1 , float x2 , float y2 ) { float A = x - x1 ; float B = y - y1 ; float C = x2 - x1 ; float D = y2 - y1 ; float E = - D ; float dot = A * E + B * C ; float len_sq = E * E + C * C ; return ( float ) Math . abs ( dot / Math . sqrt ( len_sq ) ) ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------walletBalanceByAddressOnError------------------" + e . getMessage ( ) ) ;
findAll: public List < T > findAll ( ) { return wrapped . findAll ( scope ) ;
setSellerCompanyCountry: public void setSellerCompanyCountry ( String sellerCompanyCountry ) { this . sellerCompanyCountry = sellerCompanyCountry ;
withInputType: public Builder withInputType ( PayloadType inputType ) { this . inputType = inputType ; return this ;
isInBoundsRight: public boolean isInBoundsRight ( float x ) { x = ( float ) ( ( int ) ( x * 100.f ) ) / 100.f ; return mContentRect . right >= x - 1 ;
setMinMaxScaleX: public void setMinMaxScaleX ( float minScaleX , float maxScaleX ) { if ( minScaleX < 1f ) minScaleX = 1f ; if ( maxScaleX == 0.f ) maxScaleX = Float . MAX_VALUE ; mMinScaleX = minScaleX ; mMaxScaleX = maxScaleX ; limitTransAndScale ( mMatrixTouch , mContentRect ) ;
getBoneWatcher: public Watcher getBoneWatcher ( String boneName ) { BonePointData b = getBone ( boneName ) ; AnimationData animationData = ( ( AnimationData ) getComponentObject ( ) ) ; return new Watcher ( )
contains: void contains ( ) { assertTrue ( m . contains ( 2 ) ) ; assertFalse ( m . contains ( 12 ) ) ;
getOrganizationId: public Long getOrganizationId ( ) { return organizationId ;
unregisterHtmlCrudController: No method body
stopRoll: public void stopRoll ( ) { if ( mHandler != null ) {
received: public boolean received ( final ActivateOwnerComponentMsg msg ) { try { CSGame game = getState ( CSGame . class ) ; if ( game != null ) { PlayerData playerData = game . getPlayerData ( ) ; if ( playerData != null ) { PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { poc . setEnabled ( msg . enable ) ; } } } } catch ( Exception ignored ) { } return true ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { super . enter ( event , x , y , pointer , fromActor ) ; chars . setHoverUpgrade ( key , upgrade ) ; updateChars ( ) ;
getFormAttribute: public PageAttr < F > getFormAttribute ( ) { return ( PageAttr < F > ) formAttribute ;
testCreateOrUpdateCustomData: public void testCreateOrUpdateCustomData ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCategoryCreateOrUpdateCustomDataRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . shopCategories ( ) . createOrUpdateCustomData ( "acme" , 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCategoryCreateOrUpdateCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
getStages: public Array < Stage > getStages ( ) { return stages ;
getMixDuration: public float getMixDuration ( ) { return mixDuration ;
cancel: public void cancel ( ) { byteBufferSubscription . cancel ( ) ;
run: public void run ( ) { Looper . prepare ( ) ; handler = new DecodeHandler ( context , cameraManager , captureHandler , hints ) ; handlerInitLatch . countDown ( ) ; Looper . loop ( ) ;
getEvent: public Event getEvent ( ) { return this ;
renderLimitLineLabel: public void renderLimitLineLabel ( Canvas c , LimitLine limitLine , float [ ] position , float yOffset ) { String label = limitLine . getLabel ( ) ; if ( label != null && ! label . equals ( "" ) ) {
setOrganizationId: public void setOrganizationId ( Long organizationId ) { this . organizationId = organizationId ;
size: public int size ( ) { return queue . size ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamInVOpen1ActionPerformed ( evt ) ;
setClearDrawable: public void setClearDrawable ( Drawable drawable ) { this . mClearDrawable = drawable ;
queryScores: No method body
update: public void update ( float dt ) { super . update ( dt ) ; if ( activated )
reset: public void reset ( ) { this . action = null ;
getElevator: public ServerElevatorComponentData getElevator ( ) { ActiveData activeData = findActiveData ( elevator ) ; if ( activeData == null ) return null ; return activeData . getComponent ( ServerElevatorComponentData . class ) ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . notify , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . simple , this ) ; BrainOutClient . EventMgr . unsubscribeAll ( Event . ID . badgeRead ) ; instrumentIcon . dispose ( ) ;
init: public void init ( ) { super . init ( ) ; LaunchData launch = new LaunchData ( ) { @ Override public float getX ( ) { return activeData . getX ( ) ; } @ Override public float getY ( ) { return activeData . getY ( ) + 0.25f * ( float ) Math . cos ( ( double ) counter * 8f ) ; } @ Override public float getAngle ( ) { return 0 ; } @ Override public String getDimension ( ) { return activeData . getDimension ( ) ; } @ Override public boolean getFlipX ( ) { return false ; } } ; this . progressBar = new ActiveProgressBar ( launch ) ; this . iconSprite = new CenterSprite ( getContentComponent ( ) . getIcon ( ) , launch ) ; BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ;
read: public void read ( Json json , JsonValue jsonData ) { elevator = jsonData . getString ( "elevator" , "" ) ;
getMass: public float getMass ( ) { return mass . getValue ( ) ;
error: public void error ( String reason ) { waitLoadingMenu . pop ( ) ;
hasRender: public boolean hasRender ( ) { return false ;
received: public boolean received ( final ClaimOnlineEventResultMsg msg ) { Gdx . app . postRunnable ( ( ) -> { BrainOutClient . EventMgr . sendDelayedEvent ( ClaimOnlineEventResultEvent . obtain ( msg . eventId , msg . rewardIndex , msg . success ) ) ; } ) ; return true ;
getLocalUniqueId: public String getLocalUniqueId ( ) { return client . getConfig ( ) . getUniqueId ( ) ;
createOrUpdateCustomDataForKey: public Map < String , Object > createOrUpdateCustomDataForKey ( String shopKey , String countryCode , String key , Map < String , Object > model ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/custom-data/%s" , shopKey , countryCode , key ) , null , null , responseModel , model ) ;
UpdateParamToResource: No method body
deleteGroup: public void deleteGroup ( String shopKey , String countryCode , Identifier customerIdentifier , String customerGroup ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/customer-groups/%s" , shopKey , countryCode , customerIdentifier , customerGroup ) , null , null , null ) ;
setDirty: public void setDirty ( ) { this . dirty = true ;
sendRemotePlayers: public void sendRemotePlayers ( ) { BrainOutServer . PostRunnable ( ( ) ->
getBuffer: public ByteBuffer getBuffer ( ) { return buffer ;
isSuitable: public boolean isSuitable ( ) { return super . isSuitable ( ) && config . getBool ( RELOADER_MYBATIS_ENABLE ) ;
addAnimation: public TrackEntry addAnimation ( int trackIndex , Animation animation , boolean loop , float delay ) { if ( trackIndex < 0 ) throw new IllegalArgumentException ( "trackIndex must be >= 0." ) ; if ( animation == null ) throw new IllegalArgumentException ( "animation cannot be null." ) ; TrackEntry last = expandToIndex ( trackIndex ) ; if ( last != null ) { while ( last . next != null ) last = last . next ; } TrackEntry entry = trackEntry ( trackIndex , animation , loop , last ) ; if ( last == null ) { setCurrent ( trackIndex , entry , true ) ; queue . drain ( ) ; } else { last . next = entry ; entry . previous = last ; if ( delay <= 0 ) delay += last . getTrackComplete ( ) - entry . mixDuration ; } entry . delay = delay ; return entry ;
findAll: public Page < DynamicPrivilege > findAll ( Pageable pageable ) { return dynamicPrivilegeRepository . findAll ( pageable ) ;
getOrgIdFromPath: private Long getOrgIdFromPath ( String filePath ) { String orgIdString = StringUtils . substringBetween ( filePath , SUBDIR_ORGANIZATION_PREFIX , "/" ) ; return StringUtils . isNotEmpty ( orgIdString ) ? Long . parseLong ( orgIdString ) : null ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
onInit: public void onInit ( ) { super . onInit ( ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . gameController , this ) ; addAction ( Actions . sequence (
setFloat: public void setFloat ( float floatValue ) { this . floatValue = floatValue ;
getX: public float getX ( ) { return pointPos . x ;
setValueSum: public void setValueSum ( double valueSum ) { this . valueSum = valueSum ;
removeDclPromiseStackFrames: public static StackTraceElement [ ] removeDclPromiseStackFrames ( StackTraceElement [ ] elements ) { final List < StackTraceElement > frames = new ArrayList < > ( ) ; StackTraceElement lastElementRemoved = null ; int consecutiveElementsRemoved = 0 ; for ( int i = 1 ; i < elements . length - 1 ; i ++ ) { final StackTraceElement frame = elements [ i ] ; if ( frame . getClassName ( ) . startsWith ( promiseClassName ) ) { lastElementRemoved = frame ; consecutiveElementsRemoved ++ ; } else if ( lastElementRemoved != null ) { frames . add ( new StackTraceElement ( lastElementRemoved . getClassName ( ) , lastElementRemoved . getMethodName ( ) , null , - 1 ) ) ; frames . add ( new StackTraceElement ( "[Removed " + consecutiveElementsRemoved + " elements]" , "" , null , - 1 ) ) ; lastElementRemoved = null ; consecutiveElementsRemoved = 0 ; } else { frames . add ( frame ) ; } } return frames . toArray ( new StackTraceElement [ 0 ] ) ;
wrapPlayState: public void wrapPlayState ( PlayState . ID playState ) { this . playState = playState ;
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Product responseEntity = this . api . products ( ) . get ( Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
printStatistics: public void printStatistics ( String prefix ) { System . out . printf ( "%sNode: %s%n" , prefix , name ) ; System . out . printf ( "%sExecuted %d times%n" , prefix , executionCount ) ; System . out . printf ( "%sTotal time: %d ns%n" , prefix , totalRuntime ) ; System . out . println ( ) ; for ( final ProfilingNode child : childNodes . values ( ) ) {
getAmount: public int getAmount ( ) { return amount ;
setColor: public void setColor ( Color color ) { if ( color == null ) throw new IllegalArgumentException ( "color cannot be null." ) ; this . color . set ( color ) ;
getWorkflow: public SingleWorkflowResponse getWorkflow ( final String workflowId ) throws IOException , NovuNetworkException { try {
isConnected: public boolean isConnected ( ) { if ( connection == null ) return false ; return getConnection ( ) . isConnected ( ) ;
next: protected int next ( int bits ) { if ( this . syscalls . isInsideSideEffect ( ) ) { throw new IllegalStateException ( "You can't use RestateRandom inside ctx.run!" ) ; } return super . next ( bits ) ;
onEditorAction: public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( actionId == EditorInfo . IME_ACTION_DONE ) { clickForward ( ) ; } return true ;
started: public void started ( ) { for ( Plugin plugin : plugins )
decode: protected void decode ( final ChannelHandlerContext context , final ByteBuf in , final List < Object > out ) { final int length = in . readableBytes ( ) ; if ( ! ( length > 0 ) ) { provider . getLogger ( ) . fatal ( "Malformed packet received from {}. Closing connection." , context . channel ( ) . remoteAddress ( ) ) ; context . close ( ) ; return ; } final byte [ ] data = new byte [ length ] ; in . readBytes ( data ) ; final HeaderData header = PacketDataSerializer . deserialize ( data , HeaderData . class ) ; if ( header == null ) { provider . getLogger ( ) . warn ( "Error whilst deserializing header. Closing connection to {}." , context . channel ( ) . remoteAddress ( ) ) ; return ; } final int versionNumber = header . getProtocolVersion ( ) ; final ProtocolVersion version = ProtocolVersion . getByVersionNumber ( versionNumber ) ; if ( version != provider . getProtocolVersion ( ) ) { final String message = "Message Protocol version mismatch! Received: {} Current Version: {}" ; if ( ! provider . isAllowVersionMismatch ( ) ) { provider . getLogger ( ) . warn ( message , version , provider . getProtocolVersion ( ) ) ; in . resetReaderIndex ( ) ; return ; } else { provider . getLogger ( ) . debugFine ( message , version , provider . getProtocolVersion ( ) ) ; } } final JRPCMessage message ; if ( header . getMessageType ( ) == MessageType . HANDSHAKE . getId ( ) ) { message = PacketDataSerializer . deserialize ( data , JRPCClientHandshakeMessage . class ) ; } else if ( header . getMessageType ( ) == MessageType . MESSAGE . getId ( ) ) { message = PacketDataSerializer . deserialize ( data , JRPCMessage . class ) ; } else { provider . getLogger ( ) . warn ( "Invalid message format. Closing connection to {}" , context . channel ( ) . remoteAddress ( ) ) ; context . close ( ) ; return ; } out . add ( message ) ;
getSelectedStrLabels: public List < String > getSelectedStrLabels ( ) { List < String > resultList = new ArrayList < > ( ) ; for ( SelectEntity entity : mLabelsList ) { if ( entity . isSelected ( ) ) { resultList . add ( entity . getTitle ( ) ) ; } } return resultList ;
getDebugLoggers: default Set < Class > getDebugLoggers ( ) { return debugLoggers ;
markSubscriberMessageFeedAs: public SubscriberNotificationResponse markSubscriberMessageFeedAs ( final MarkSubscriberFeedAsRequest request , final String subscriberId ) throws IOException , NovuNetworkException { try {
setMaximumScaleX: public void setMaximumScaleX ( float xScale ) { if ( xScale == 0.f ) xScale = Float . MAX_VALUE ; mMaxScaleX = xScale ; limitTransAndScale ( mMatrixTouch , mContentRect ) ;
downloadBlockHeader: public void downloadBlockHeader ( View view , DownloadCallback downloadCallback ) { String fileName = BLOCK_HEADER_FILE_NAME ; String downloadFileName = downloadVersion + fileName ; String downloadUrl = ConstantWithNetwork . getInstance ( ConstantInOB . networkType ) . getDownloadBaseUrl ( ) + downloadFileName ; String filePath = downloadDictionaryPath ; OnDownloadListener onDownloadListener = new OnDownloadListener ( ) { @ Override public void onDownloadComplete ( ) { downloadCallback . callback ( ) ; } @ Override public void onError ( Error error ) { view . findViewById ( R . id . refresh_btn ) . setVisibility ( View . VISIBLE ) ; if ( error . isServerError ( ) ) { ToastUtils . showToast ( mContext , fileName + "server occur error!" ) ; } else if ( error . isConnectionError ( ) ) { ToastUtils . showToast ( mContext , fileName + "connection occur error!" ) ; } else { ToastUtils . showToast ( mContext , fileName + "download occur error:" + error . toString ( ) ) ; } } } ; downloadFile ( view , fileName , filePath , downloadUrl , onDownloadListener ) ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; FileHandle fileHandle = BrainOut . PackageMgr . getFile ( fileName ) ; if ( fileHandle . exists ( ) )
getFilterColumnsList: public String [ ] getFilterColumnsList ( ) { return filterColumns != null ? filterColumns . split ( "," ) : ArrayUtils . EMPTY_STRING_ARRAY ;
setHighlightColor: public void setHighlightColor ( @ Nullable Integer color ) { this . mHighlightColor = color ;
isBitcoin: public boolean isBitcoin ( ) { return mIsBitcoin ;
setValue: public boolean setValue ( Boolean value ) { super . setValue ( value ) ; return true ;
getOldAddress: public void getOldAddress ( ) { Log . d ( TAG , "getOldAddress: " ) ; LightningOuterClass . ListAddressesRequest listAddressesRequest = LightningOuterClass . ListAddressesRequest . newBuilder ( ) . build ( ) ; Obdmobile . oB_ListAddresses ( listAddressesRequest . toByteArray ( ) , new Callback ( ) {
hasUpdate: public boolean hasUpdate ( ) { return false ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fill ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionIncrement2ActionPerformed ( evt ) ;
setValue: public void setValue ( float value ) { this . value = value ;
showInSummaryScreen: public boolean showInSummaryScreen ( ) { return true ;
setItemsLoadedHook: public void setItemsLoadedHook ( ItemsLoadedHook itemsLoadedHook ) { this . itemsLoadedHook = itemsLoadedHook ;
getChunkData: public ChunkData getChunkData ( BlockMatrixData matrixData , int x , int y ) { return new ClientChunkData ( matrixData , x , y ) ;
setLogin: public void setLogin ( String login ) { this . login = login ;
reject: No method body
getDimension: public String getDimension ( ) { return dimension ;
setProfiles: private static void setProfiles ( String [ ] args ) { if ( System . getProperty ( SPRING_PROFILES_ACTIVE_PROP ) == null && args != null && args . length > 0 ) {
getTeams: public Array < Team > getTeams ( ) { return teams ;
hasRender: public boolean hasRender ( ) { return true ;
timedOut: public boolean timedOut ( PlayStateEndGame . GameResult gameResult ) { OrderedMap < Team , Integer > points = new OrderedMap < > ( ) ; for ( Team team : BrainOutServer . Controller . getTeams ( ) ) { points . put ( team , getGameMode ( ) . getPoints ( team ) ) ; } if ( points . size == 2 && Objects . equals ( points . get ( points . orderedKeys ( ) . get ( 0 ) , 0 ) , points . get ( points . orderedKeys ( ) . get ( 1 ) , 0 ) ) ) { return timedOutDraw ( gameResult ) ; } points . orderedKeys ( ) . sort ( ( o1 , o2 ) -> points . get ( o2 , 0 ) - points . get ( o1 , 0 ) ) ; gameResult . setTeamWon ( points . orderedKeys ( ) . get ( 0 ) ) ; return true ;
reset: public void reset ( ) { this . result = null ;
setMailgunApiKey: public void setMailgunApiKey ( String mailgunApiKey ) { this . mailgunApiKey = mailgunApiKey ;
test: public static boolean test ( ) { boolean result ; Process process = null ; DataOutputStream os = null ; try { process = Runtime . getRuntime ( ) . exec ( "getprop ro.kernel.qemu" ) ; os = new DataOutputStream ( process . getOutputStream ( ) ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) , "gbk" ) ) ; os . writeBytes ( "exit\n" ) ; os . flush ( ) ; process . waitFor ( ) ; result = ( Integer . valueOf ( in . readLine ( ) ) == 1 ) ; } catch ( Exception e ) { result = false ; e . printStackTrace ( ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( process != null ) { process . destroy ( ) ; } } LogUtils . e ( TAG , result ? "是模拟器" : "不是模拟器" ) ; return result ;
getFileCRC32: public static String getFileCRC32 ( String filePath ) { String fileCRC32Str = "" ; File file = new File ( filePath ) ; fileCRC32Str = getFileCRC32 ( file ) ; return fileCRC32Str ;
init: public void init ( ) { initComponents ( ) ;
getTimeScale: public float getTimeScale ( ) { return timeScale ;
jMenuItem6ActionPerformed: private void jMenuItem6ActionPerformed ( java . awt . event . ActionEvent evt ) { createOrContinue ( CondensateUI . class , true , false ) ;
resolveAwakeable: public void resolveAwakeable ( String id , ByteBuffer payload , SyscallCallback < Void > requestCallback ) { syscallsExecutor . execute ( ( ) -> syscalls . resolveAwakeable ( id , payload , requestCallback ) ) ;
setPassword: public void setPassword ( String password ) { this . password = password ;
getDayOfMonthInWeek: public static int getDayOfMonthInWeek ( Date date ) { Calendar cld = Calendar . getInstance ( ) ; cld . setTime ( date ) ; cld . set ( Calendar . DAY_OF_MONTH , 1 ) ; return cld . get ( Calendar . DAY_OF_WEEK ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; doCreate ( ) ;
queryRoutes: public Single < lnrpc . LightningOuterClass . QueryRoutesResponse > queryRoutes ( lnrpc . LightningOuterClass . QueryRoutesRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . queryRoutes ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
isSuccess: public boolean isSuccess ( ) { return true ;
setChambered: No method body
sendVoiceData: No method body
toString: public String toString ( ) { return "Column{" +
onApplyWindowInsets: public final WindowInsets onApplyWindowInsets ( WindowInsets insets ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . KITKAT_WATCH ) {
getItem: public Object getItem ( int position ) { return mDatas . get ( position ) ;
getNeighbors: public Array < ZoneData > getNeighbors ( ) { return neighbors ;
run: No method body
copyToClipboard: public static void copyToClipboard ( String text ) { if ( text != null ) {
getDeclaringType: public TypeDescription getDeclaringType ( ) { return null ;
updateResource: public void updateResource ( @ NonNull Long roleId , @ NonNull Set < Long > resourceIds ) { this . baseMapper . deleteResourceByRoleId ( roleId ) ; this . baseMapper . insertResourceByRoleId ( roleId , resourceIds ) ; eventPublisher . publishEvent ( new ClearCacheEvent ( SystemDictConstants . ROLE ) ) ; eventPublisher . publishEvent ( new ClearCacheEvent ( AuthConstants . PERMISSION_RULES_KEY ) ) ;
update: public void update ( float delta ) { delta *= timeScale ; Object [ ] tracks = this . tracks . items ; for ( int i = 0 , n = this . tracks . size ; i < n ; i ++ ) { TrackEntry current = ( TrackEntry ) tracks [ i ] ; if ( current == null ) continue ; current . animationLast = current . nextAnimationLast ; current . trackLast = current . nextTrackLast ; float currentDelta = delta * current . timeScale ; if ( current . delay > 0 ) { current . delay -= currentDelta ; if ( current . delay > 0 ) continue ; currentDelta = - current . delay ; current . delay = 0 ; } TrackEntry next = current . next ; if ( next != null ) { float nextTime = current . trackLast - next . delay ; if ( nextTime >= 0 ) { next . delay = 0 ; next . trackTime += current . timeScale == 0 ? 0 : ( nextTime / current . timeScale + delta ) * next . timeScale ; current . trackTime += currentDelta ; setCurrent ( i , next , true ) ; while ( next . mixingFrom != null ) { next . mixTime += delta ; next = next . mixingFrom ; } continue ; } } else if ( current . trackLast >= current . trackEnd && current . mixingFrom == null ) { tracks [ i ] = null ; queue . end ( current ) ; clearNext ( current ) ; continue ; } if ( current . mixingFrom != null && updateMixingFrom ( current , delta ) ) { TrackEntry from = current . mixingFrom ; current . mixingFrom = null ; if ( from != null ) from . mixingTo = null ; while ( from != null ) { queue . end ( from ) ; from = from . mixingFrom ; } } current . trackTime += currentDelta ; } queue . drain ( ) ;
init: public void init ( InitCallback done ) { CSGame csGame = BrainOutClient . ClientController . getState ( CSGame . class ) ; BrainOutClient . ClientController . setState ( new CSEndGame ( this , csGame ) ) ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { super . enter ( event , x , y , pointer , fromActor ) ; chars . setHoverUpgrade ( key , upgrade ) ; updateChars ( ) ;
statUpdated: public void statUpdated ( String stat , float newValue , float added ) { if ( subscription == null ) return ; if ( subscription . getPublisher ( stat ) == null ) { subscription . addPublisher ( stat , new UnlockSubscription . Publisher ( ) { @ Override public float getProperty ( ) { return profile . getStats ( ) . get ( getName ( ) , 0.0f ) ; } } ) ; } subscription . update ( stat ) ; if ( added > 0 )
awaitResolvePromise: protected TestDefinitions . TestInvocationBuilder awaitResolvePromise ( String promiseKey , String completionValue ) { return testDefinitionForWorkflow (
setCurrentWeapon: public void setCurrentWeapon ( String currentWeapon ) { this . currentWeapon = currentWeapon ;
setValueAsMap: public void setValueAsMap ( OrganizationRelatedMap valueMap ) { value = JsonHelper . to ( valueMap ) ;
buttonNo: public String buttonNo ( ) { return L . get ( "MENU_NO" ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
onPageFinished: public void onPageFinished ( WebView view , String url ) { isPageLoaded . set ( true ) ;
getRequestQueryString: String getRequestQueryString ( HttpServletRequest request ) { return request . getQueryString ( ) ;
isDeathDropEnabled: public boolean isDeathDropEnabled ( PlayerData playerData ) { return false ;
succeeded: public void succeeded ( T result ) { onSuccess . call ( result ) ;
filterStudentsByGrade: public static List < Student > filterStudentsByGrade ( List < Student > students , double average ) { List < Student > result = new ArrayList < > ( ) ; for ( Student s : students ) { if ( s . getAverage ( ) == average ) { String str = String . format ( "%s_%s_%f" , s . getLastname ( ) , s . getName ( ) , s . getAverage ( ) ) ; System . out . println ( str ) ; result . add ( s ) ; } } return result ;
onEvent: public boolean onEvent ( Event event ) { iter . clear ( ) ; tasks . values ( ) . toArray ( iter ) ; for ( Task task : iter ) { if ( task instanceof EventReceiver ) { EventReceiver ev = ( ( EventReceiver ) task ) ; if ( ev . onEvent ( event ) ) { return true ; } } } return false ;
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { Bone bone = skeleton . bones . get ( boneIndex ) ; if ( ! bone . active ) return ; float [ ] frames = this . frames ; if ( time < frames [ 0 ] ) { switch ( blend ) { case setup : bone . x = bone . data . x ; bone . y = bone . data . y ; return ; case first : bone . x += ( bone . data . x - bone . x ) * alpha ; bone . y += ( bone . data . y - bone . y ) * alpha ; } return ; } float x , y ; int i = search ( frames , time , ENTRIES ) , curveType = ( int ) curves [ i / ENTRIES ] ; switch ( curveType ) { case LINEAR : float before = frames [ i ] ; x = frames [ i + VALUE1 ] ; y = frames [ i + VALUE2 ] ; float t = ( time - before ) / ( frames [ i + ENTRIES ] - before ) ; x += ( frames [ i + ENTRIES + VALUE1 ] - x ) * t ; y += ( frames [ i + ENTRIES + VALUE2 ] - y ) * t ; break ; case STEPPED : x = frames [ i + VALUE1 ] ; y = frames [ i + VALUE2 ] ; break ; default : x = getBezierValue ( time , i , VALUE1 , curveType - BEZIER ) ; y = getBezierValue ( time , i , VALUE2 , curveType + BEZIER_SIZE - BEZIER ) ; } switch ( blend ) {
isFixture: public boolean isFixture ( ) { return fixture ;
jFileChooser1ActionPerformed: private void jFileChooser1ActionPerformed ( java . awt . event . ActionEvent evt ) { String command = evt . getActionCommand ( ) ; if ( command . equals ( "ApproveSelection" ) ) {
clearCacheFolder: public static int clearCacheFolder ( File dir , long numDays ) { int deletedFiles = 0 ; if ( dir != null && dir . isDirectory ( ) ) { try { for ( File child : dir . listFiles ( ) ) { if ( child . isDirectory ( ) ) { deletedFiles += clearCacheFolder ( child , numDays ) ; } if ( child . lastModified ( ) < numDays ) { if ( child . delete ( ) ) { deletedFiles ++ ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return deletedFiles ;
getTransformConstraints: public Array < TransformConstraintData > getTransformConstraints ( ) { return transformConstraints ;
getBarData: No method body
getRadius: public float getRadius ( ) { if ( mCircleBox == null )
setOrganizationId: public void setOrganizationId ( Long organizationId ) { this . organizationId = organizationId ;
addAction: public ActionList addAction ( MenuAction menuAction ) { actions . add ( menuAction ) ; return this ;
channelBalance: No method body
getNodeVersionFromLocal: public static String getNodeVersionFromLocal ( Context context ) { return getString ( SETTINGS , context , KEY_NODE_VERSION ) ;
validateBlocksForAdding: public boolean validateBlocksForAdding ( Map map , int atX , int atY , ObjectSet < ActiveData > ignore ) { if ( atX < 0 || atY < 0 || atX > map . getWidth ( ) - getWidth ( ) || atY > map . getHeight ( ) - getHeight ( ) ) return false ; for ( int j = 0 ; j < getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < getWidth ( ) ; i ++ ) { int x = atX + i , y = atY + j ; BlockData b = map . getBlock ( x , y , getContentComponent ( ) . getBlocksLayer ( ) ) ; if ( b != null ) { SpriteBlockComponentData sbc = b . getComponent ( SpriteBlockComponentData . class ) ; if ( sbc != null ) { ActiveData sp = sbc . getSprite ( map ) ; if ( sp == null ) return false ; if ( ignore != null && ignore . contains ( sp ) ) { continue ; } return false ; } else { return false ; } } } } return true ;
of: public static < T > Serde < T > of ( ObjectMapper mapper , Class < T > clazz ) { return new Serde < > ( ) {
setEnabled: public void setEnabled ( boolean enabled ) { this . enabled = enabled ;
dateTimeNow: public LocalDateTime dateTimeNow ( ) { return LocalDateTime . now ( ) ;
getSpaceBottom: public float getSpaceBottom ( ) { return mSpacePercentBottom ;
isPlaying: public boolean isPlaying ( ) { Music music = musicEffect . getMusic ( ) ; if ( music == null ) return false ; return music . isPlaying ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesClose18ActionPerformed ( evt ) ;
renderPanel: private void renderPanel ( Table panel , Menu menu ) { {
delivered: public void delivered ( int id ) { synchronized ( messages )
getOrganizationId: public long getOrganizationId ( ) { return organizationId ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
showPing: protected boolean showPing ( ) { return false ;
calcEntryCountIncludingStacks: private void calcEntryCountIncludingStacks ( List < BarEntry > yVals ) { mEntryCountStacks = 0 ; for ( int i = 0 ; i < yVals . size ( ) ; i ++ ) {
getFacing: public CameraFacing getFacing ( ) { return facing ;
getDuration: public Integer getDuration ( ) { return duration ;
setTitleViewShow: public void setTitleViewShow ( ) { getTitleView ( ) . setVisibility ( View . VISIBLE ) ;
toString: public String toString ( ) { return "Circle{" + "center=" + center + ", radius=" + radius + '}' ;
exportEventListenerToZippedYaml: public byte [ ] exportEventListenerToZippedYaml ( @ PathVariable ( ID ) long eventListenerId ) { debug ( "[exportEventListenerToZippedYaml]" ) ; return services . componentExport . exportToZip ( Arrays . asList ( repositories . secure . eventListener . findOne ( eventListenerId ) ) ) . toByteArray ( ) ;
updateWhite: No method body
count: No method body
valid: private void valid ( String promoCode ) { BrainOutClient . ClientController . sendTCP ( new PromoCodeMsg ( promoCode ) ) ;
bulkTriggerEvent: public BulkTriggerEventResponse bulkTriggerEvent ( final BulkTriggerEventRequest request ) throws IOException , NovuNetworkException { try {
readAssetsText: public static String readAssetsText ( Context context , String fileName ) { try { InputStream is = context . getAssets ( ) . open ( fileName ) ; int size = is . available ( ) ; byte [ ] buffer = new byte [ size ] ; is . read ( buffer ) ; is . close ( ) ; String text = new String ( buffer , "utf-8" ) ; return text ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return "" ;
showLoading: public static void showLoading ( LoginLoadingDialog loadingDialog ) { if ( ! loadingDialog . isShowing ( ) ) {
isDrawIconsEnabled: No method body
testStringFlowExecute: public void testStringFlowExecute ( ) { PageModelMap result = testFlow . execute ( ) ; Assert . assertEquals ( "The result is 25" , result . get ( someMessageString ) ) ; Assert . assertEquals ( "Agreed. The result is 25" , result . get ( "otherMessageString" ) ) ;
getID: public ID getID ( ) { return ID . empty ;
linePath: protected Path linePath ( Path p , int i , float [ ] positions ) { p . moveTo ( positions [ i ] , mViewPortHandler . contentTop ( ) ) ; p . lineTo ( positions [ i ] , mViewPortHandler . contentBottom ( ) ) ; return p ;
setZoom: public Matrix setZoom ( float scaleX , float scaleY ) { Matrix save = new Matrix ( ) ; setZoom ( scaleX , scaleY , save ) ; return save ;
getComponent: public ActiveEffectComponentData getComponent ( ComponentObject componentObject ) { return null ;
createErrorAuditForException: public static boolean createErrorAuditForException ( Throwable exception , String message ) { Audit a = new Audit ( ) ; String reqId = RequestIdHolder . getId ( ) ; a . setSeverity ( Audit . Severity . ERROR ) ; a . setUserId ( UserProvider . getUserIdOrNotExistingId ( ) ) ; a . setOperation ( Audit . AuditOperation . BROWSE ) ; a . setRequestId ( reqId ) ; a . setIpAddress ( getIpService ( ) . getCurrentUserIpAddress ( ) ) ; a . setChange ( message ) ; if ( exception != null ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; exception . printStackTrace ( pw ) ; a . setContent ( sw . toString ( ) ) ; } if ( instance != null ) { instance . auditRepository . saveAudit ( a ) ; } return true ;
getChannel: No method body
setRotation: public void setRotation ( float rotation ) { this . rotation = rotation ;
getUpdatedOn: public LocalDateTime getUpdatedOn ( ) { return updatedOn ;
decode: public static byte [ ] decode ( byte [ ] in ) { return decode ( in , in . length ) ;
run: public void run ( ) { BrainOutServer . PostRunnable ( ( ) -> respawn ( ( ( PlayerClient ) client ) ) ) ;
getSkin: public PlayerSkin getSkin ( ) { return skin ;
getSecond: public V getSecond ( ) { return second ;
createFileFromByteArray: public File createFileFromByteArray ( byte [ ] input , String fileName ) { File f = null ; try {
getLabel: public String getLabel ( ) { return "" ;
getAngle: public float getAngle ( ) { return 0 ;
createBulkSubscriber: No method body
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; for ( JsonValue music : jsonData . get ( "music" ) ) { fileNames . add ( music . asString ( ) ) ; } soundDistance = jsonData . getFloat ( "distance" , 1.0f ) ;
getRealName: public String getRealName ( ) { return realName ;
hashCode: public int hashCode ( ) { return ( int ) ( uid ^ ( uid > > > 32 ) ) ;
renameTopic: public TopicResponse renameTopic ( final RenameTopicRequest request , final String topicKey ) throws IOException , NovuNetworkException { try {
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new FlagChunkComponentData ( ( ActiveData ) componentObject , this ) ;
getSubscriber: public SingleSubscriberResponse getSubscriber ( final String subscriberId ) throws IOException , NovuNetworkException { return restHandler . extractResponse ( subscribersApi . getSubscriber ( subscriberId ) . execute ( ) ) ;
write: public void write ( GameService . RoomSettings filer , String key ) { if ( isDefined ( ) )
hideSystemBarAndFullScreen: public static void hideSystemBarAndFullScreen ( Activity activity ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . KITKAT ) { View v = activity . getWindow ( ) . getDecorView ( ) ;
preparePaymentProbe: public RouterOuterClass . SendPaymentRequest preparePaymentProbe ( String destination , long amountSat , @ Nullable ByteString paymentAddress , @ Nullable List < LightningOuterClass . RouteHint > routeHints , @ Nullable Map < Integer , LightningOuterClass . Feature > destFeatures ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ PAYMENT_HASH_BYTE_LENGTH ] ; random . nextBytes ( bytes ) ; long feeLimit = calculateAbsoluteFeeLimit ( amountSat ) ; RouterOuterClass . SendPaymentRequest . Builder sprb = RouterOuterClass . SendPaymentRequest . newBuilder ( ) . setAssetId ( ( int ) mAssetId ) . setDest ( byteStringFromHex ( destination ) ) . setAssetAmt ( amountSat ) . setFeeLimitMsat ( feeLimit ) . setPaymentHash ( ByteString . copyFrom ( bytes ) ) . setNoInflightUpdates ( true ) . setTimeoutSeconds ( RefConstants . TIMEOUT_MEDIUM * RefConstants . TOR_TIMEOUT_MULTIPLIER ) . setMaxParts ( 1 ) ; if ( paymentAddress != null ) { sprb . setPaymentAddr ( paymentAddress ) ; } if ( destFeatures != null && ! destFeatures . isEmpty ( ) ) { for ( Map . Entry < Integer , LightningOuterClass . Feature > entry : destFeatures . entrySet ( ) ) { sprb . addDestFeaturesValue ( entry . getKey ( ) ) ; } } if ( routeHints != null && ! routeHints . isEmpty ( ) ) { sprb . addAllRouteHints ( routeHints ) ; } return sprb . build ( ) ;
setVisibleXRangeMinimum: public void setVisibleXRangeMinimum ( float minXRange ) { float xScale = mXAxis . mAxisRange / ( minXRange ) ; mViewPortHandler . setMaximumScaleY ( xScale ) ;
disposeOnRelease: public boolean disposeOnRelease ( ) { return false ;
setName: public void setName ( String name ) { this . name = name ;
findByFrontendResourceId: No method body
updateWaterInflow: No method body
generateServerId: public int generateServerId ( ) { return actives . generateServerId ( ) ;
createSlackPostMessageRequest: public void createSlackPostMessageRequest ( NotificationDto notification ) { debug ( "[createSlackPostRequest]" ) ; if ( ! notification . getPropagate ( ) ) { return ; } if ( notification . getOrganizationId ( ) != null && notification . getUserId ( ) == null ) {
onActionItemClicked: public boolean onActionItemClicked ( ActionMode mode , MenuItem item ) { return false ; }
execute: public String execute ( Client client , String command ) { String [ ] parameters = parseCommand ( command ) ; return executeParams ( client , parameters , client ) ;
getItemPosition: public int getItemPosition ( Object object ) { Fragment fragment = ( Fragment ) object ; if ( mTempArray . indexOfValue ( fragment . getTag ( ) ) > - 1 ) { return super . getItemPosition ( object ) ; } return POSITION_NONE ;
create: public final AllowedMentions create ( MessageAllowedMentions messageAllowedMentions ) { return null ;
getHighlightForX: protected Highlight getHighlightForX ( float xVal , float x , float y ) { List < Highlight > closestValues = getHighlightsAtXValue ( xVal , x , y ) ; if ( closestValues . isEmpty ( ) ) { return null ; } float leftAxisMinDist = getMinimumDistance ( closestValues , y , YAxis . AxisDependency . LEFT ) ; float rightAxisMinDist = getMinimumDistance ( closestValues , y , YAxis . AxisDependency . RIGHT ) ; YAxis . AxisDependency axis = leftAxisMinDist < rightAxisMinDist ? YAxis . AxisDependency . LEFT : YAxis . AxisDependency . RIGHT ; Highlight detail = getClosestHighlightByPixel ( closestValues , x , y , axis , mChart . getMaxHighlightDistance ( ) ) ; return detail ;
getRendererRightYAxis: public YAxisRenderer getRendererRightYAxis ( ) { return mAxisRendererRight ;
obtain: public static Event obtain ( EntityReceived entity , int amount ) { ActiveReceivedContentEvent e = obtain ( ActiveReceivedContentEvent . class ) ; if ( e == null ) return null ; return e . init ( entity , amount ) ;
setY: No method body
turnOffDebugModeForLoggerClass: public boolean turnOffDebugModeForLoggerClass ( Class c ) { return c == null ? false : debugLoggers . remove ( c ) ;
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . reservations ( ) . delete ( Identifier . fromId ( 1 ) , options ) ;
getLastmod: public String getLastmod ( ) { return lastmod . format ( DateTimeFormatter . ISO_LOCAL_DATE ) ;
setLabel: No method body
cast: private static ServerMessageHandler < Packet > cast ( final ServerMessageHandler < ? > toCast ) { return ( ServerMessageHandler < Packet > ) toCast ;
validate: public FrontendResourcePageForm validate ( BindingResult br ) { if ( StringUtils . isBlank ( dto . name ) ) { br . rejectValue ( "dto.name" , "not.empty" ) ; } if ( not ( Pattern . matches ( "[a-z\\-\\/0-9]+" , dto . name ) ) ) { br . rejectValue ( "dto.name" , "simple.path" ) ; } if ( StringUtils . startsWith ( dto . name , "/" ) ) { br . rejectValue ( "dto.name" , "not.slash.prefix" ) ; } return this ;
request: public void request ( long n ) { byteBufferSubscription . request ( Long . MAX_VALUE ) ; handleSubscriptionRequest ( n ) ;
uploadCdn: public AjaxResult uploadCdn ( @ RequestPart MultipartFile file ) throws Exception { if ( ObjectUtils . allNull ( file ) ) { throw new RuntimeException ( "未上传文件！" ) ; } String filename = file . getOriginalFilename ( ) ; String url = aliyunStorageService . putObjectCdn ( null , filename , file . getInputStream ( ) , "application/octet-stream" ) ; return AjaxResult . success ( "上传成功！" , url ) ;
select: No method body
onItemClick: public void onItemClick ( View view , ListAssetItemEntity item ) { if ( item . getPropertyid ( ) == 0 ) { assetTypeIv . setImageResource ( R . mipmap . icon_btc_logo_small ) ; assetTypeTv . setText ( "BTC" ) ; amountUnitTv . setText ( "BTC" ) ; amountEdit . setText ( "0" ) ; } else { assetTypeIv . setImageResource ( R . mipmap . icon_usdt_logo_small ) ; assetTypeTv . setText ( "dollar" ) ; amountUnitTv . setText ( "dollar" ) ; amountEdit . setText ( "0" ) ; } mAssetId = item . getPropertyid ( ) ; getChannelBalance ( mAssetId ) ;
size: No method body
addNo: private void addNo ( ArrayMap < String , PopupButtonStyle > buttons ) { buttons . put ( buttonNo ( ) , new PopupButtonStyle ( new ClickOverListener ( )
getWorkflow: No method body
addMember: public void addMember ( PlayerClient playerClient ) { String account = playerClient . getAccount ( ) ; if ( account == null ) return ; synchronized ( members ) { members . put ( account , playerClient ) ; } if ( Log . INFO ) Log . info ( "New player joined party " + this . partyId + ": " + account ) ;
setInitialTickets: public void setInitialTickets ( int initialTickets ) { this . initialTickets = initialTickets ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; key = jsonData . getString ( "key" , "" ) ; order = jsonData . getInt ( "order" , 0 ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { msv2ActionPerformed ( evt ) ;
webBuilder: public WebClient . Builder webBuilder ( ) { return WebClient . builder ( ) ;
verifyChanBackup: public Single < lnrpc . LightningOuterClass . VerifyChanBackupResponse > verifyChanBackup ( lnrpc . LightningOuterClass . ChanBackupSnapshot request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . verifyChanBackup ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
isEnemies: public boolean isEnemies ( Team a , Team b ) { return true ;
setCustomSound: public void setCustomSound ( int resId ) { mSoundId = mSoundPool . load ( mContext , resId , 1 ) ;
unregisterCRUDController: public void unregisterCRUDController ( String key ) { exposed . remove ( key ) ; super . unregisterCRUDController ( key ) ;
execute: public String execute ( String [ ] args , Client client ) { boolean graceful = true ; if ( args . length > 1 ) { graceful = "true" . equals ( args [ 1 ] ) ; } GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode != null ) { switch ( gameMode . getID ( ) ) { case lobby : default : { BrainOutServer . TriggerShutdown ( ) ; return "Shutting lobby down..." ; } } } if ( graceful )
renderRooms: private void renderRooms ( List < GameService . Room > rooms , JSONObject status ) { content . clear ( ) ; Group group = new Group ( ) ; float w = 115 ; float h = 94 ; float globalWidth = ( globalConflict . getWidth ( ) + 0.5f ) * ( w * 0.75f + 2 ) ; float globalHeight = ( globalConflict . getHeight ( ) + 0.5f ) * ( h + 2 ) ; group . setSize ( 1000 , 560 ) ; float offsetX = ( group . getWidth ( ) - globalWidth ) / 2 ; float offsetY = ( group . getHeight ( ) - globalHeight ) / 2 ; ObjectMap < String , Button > buttons = new ObjectMap < > ( ) ; GlobalConflict . ConflictData data = globalConflict . getData ( status , conflictStart ) ; for ( GlobalConflict . ConflictData . ZoneData zoneData : data . getZones ( ) ) { GlobalConflict . Zone zone = zoneData . getZone ( ) ; Button b = new Button ( BrainOutClient . Skin , zoneData . getOwner ( ) == GlobalConflict . Owner . neutral ? "hex-neutral" : ( zoneData . getOwner ( ) == myOwner ? "hex-blue" : "hex-orange" ) ) ; buttons . put ( zone . getKey ( ) , b ) ; if ( zoneData . getOwner ( ) == GlobalConflict . Owner . neutral ) { b . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { if ( zoneData . getStatus ( ) == GlobalConflict . ZoneStatus . full ) { Menu . playSound ( MenuSound . denied ) ; return ; } pop ( ) ; if ( zoneData . getStatus ( ) == GlobalConflict . ZoneStatus . ongoing ) { callback . selected ( zoneData . getRoom ( ) ) ; } else { callback . newOne ( zoneData . getKey ( ) ) ; } } } ) ; } b . setSize ( w , h ) ; float x = zone . getPhysicalX ( ) * ( w * 0.75f + 2 ) ; float y = zone . getPhysicalY ( ) * ( h + 2 ) ; b . setPosition ( x + offsetX , y + offsetY ) ; group . addActor ( b ) ; } for ( GameService . Room room : rooms ) { String zone = room . settings . optString ( "zone" ) ; if ( zone == null ) continue ; GlobalConflict . ConflictData . ZoneData zoneData = data . getByKey ( zone ) ; if ( zoneData == null ) continue ; zoneData . setMaxPlayers ( room . maxPlayers / 2 ) ; zoneData . setMyPlayers ( room . settings . optInt ( "players-" + myOwner . toString ( ) , 0 ) ) ; if ( zoneData . getMyPlayers ( ) >= zoneData . getMaxPlayers ( ) ) { zoneData . setStatus ( GlobalConflict . ZoneStatus . full ) ; continue ; } if ( zoneData . getStatus ( ) == GlobalConflict . ZoneStatus . ongoing ) continue ; zoneData . setStatus ( GlobalConflict . ZoneStatus . ongoing ) ; zoneData . setRoomId ( room ) ; } for ( GlobalConflict . ConflictData . ZoneData zone : data . getZones ( ) ) { Button b = buttons . get ( zone . getKey ( ) ) ; if ( zone . getOwner ( ) != GlobalConflict . Owner . neutral ) { boolean hasNeutralNeighbor = false ; for ( GlobalConflict . ConflictData . ZoneData neighbor : zone . getNeighbors ( ) ) { if ( neighbor . getOwner ( ) == GlobalConflict . Owner . neutral ) { hasNeutralNeighbor = true ; break ; } } if ( hasNeutralNeighbor ) { Image im = new Image ( BrainOutClient . Skin , zone . getOwner ( ) == myOwner ? "assault-icon-friend" : "assault-icon-enemy" ) ; im . setScaling ( Scaling . none ) ; im . setTouchable ( Touchable . disabled ) ; im . setColor ( 1 , 1 , 1 , 0.25f ) ; b . add ( im ) . size ( 64 , 64 ) ; } Tooltip . RegisterToolTip ( b , zone . getOwner ( ) == myOwner ? L . get ( "MENU_YOUR_ZONE" ) : L . get ( "MENU_ENEMY_ZONE" ) , this ) ; continue ; } switch ( zone . getStatus ( ) ) { case ongoing : { String statusText = zone . getMyPlayers ( ) + " / " + zone . getMaxPlayers ( ) ; Label s = new Label ( statusText , BrainOutClient . Skin , zone . getMyPlayers ( ) == 0 ? "title-red" : "title-yellow" ) ; s . setAlignment ( Align . center ) ; b . add ( s ) . expandX ( ) . fill ( ) ; b . addAction ( Actions . repeat ( RepeatAction . FOREVER , Actions . sequence ( Actions . delay ( 0.5f ) , Actions . run ( ( ) -> b . setStyle ( BrainOutClient . Skin . get ( "hex-live" , Button . ButtonStyle . class ) ) ) , Actions . delay ( 0.5f ) , Actions . run ( ( ) -> b . setStyle ( BrainOutClient . Skin . get ( "hex-neutral" , Button . ButtonStyle . class ) ) ) ) ) ) ; String text = "" ; GameService . Room room = zone . getRoom ( ) ; if ( room != null ) { RoomSettings roomSettings = new RoomSettings ( ) ; roomSettings . read ( room . settings ) ; text += L . get ( "MENU_PLAYERS" ) + ": " + room . players + " / " + room . maxPlayers + "\n" ; if ( roomSettings . getMode ( ) . isDefined ( ) ) { text += L . get ( "MENU_MODE" ) + ": " + L . get ( "MODE_" + roomSettings . getMode ( ) . getValue ( ) . toUpperCase ( ) ) + "\n" ; } if ( roomSettings . getMap ( ) . isDefined ( ) ) { text += L . get ( "MENU_MAP" ) + ": " + L . get ( "MAP_" + roomSettings . getMap ( ) . getValue ( ) . toUpperCase ( ) ) + "\n" ; } } Tooltip . RegisterStandardToolTip ( b , L . get ( "MENU_JOIN_CONFLICT_ZONE" ) , text , this ) ; break ; } case full : { String statusText = zone . getMyPlayers ( ) + " / " + zone . getMaxPlayers ( ) ; Label s = new Label ( statusText , BrainOutClient . Skin , "title-gray" ) ; s . setAlignment ( Align . center ) ; b . add ( s ) . expandX ( ) . fill ( ) ; Tooltip . RegisterToolTip ( b , L . get ( "MENU_THIS_CONFLICT_ZONE_IS_FULL" ) , this ) ; break ; } default : { Image im = new Image ( BrainOutClient . Skin , "icon-shop-special-healthbox" ) ; im . setScaling ( Scaling . none ) ; im . setTouchable ( Touchable . disabled ) ; im . setColor ( 1 , 1 , 1 , 0.25f ) ; b . add ( im ) . size ( 32 , 32 ) ; Tooltip . RegisterToolTip ( b , L . get ( "MENU_START_NEW_CONFLICT" ) , this ) ; b . addListener ( new ClickListener ( ) { @ Override public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { super . enter ( event , x , y , pointer , fromActor ) ; im . setColor ( 1 , 1 , 1 , 1 ) ; } @ Override public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { super . exit ( event , x , y , pointer , toActor ) ; im . setColor ( 1 , 1 , 1 , 0.25f ) ; } } ) ; break ; } } } content . add ( group ) . size ( 1000 , 560 ) . row ( ) ; if ( prevOwner != null )
updateSkin: protected void updateSkin ( AnimationComponent animation , Skeleton skeleton ) { if ( animation . getSkin ( ) != null )
getBundleData: protected void getBundleData ( Bundle bundle ) { scanCode = bundle . getInt ( KEY_SCAN_CODE ) ;
getScale: public float getScale ( ) { return 1.0f ;
getByString: public static EmojiCategory getByString ( String str ) { for ( EmojiCategory value : values ( ) ) { if ( value . stringRep . equals ( str ) ) { return value ; } } return null ;
createSubscriberBulk: public CreateBulkSubscriberResponse createSubscriberBulk ( final BulkSubscriberRequest request ) throws IOException , NovuNetworkException { return restHandler . extractResponse ( subscribersApi . createBulkSubscriber ( request ) . execute ( ) ) ;
calculateTotal: private void calculateTotal ( ) { total . setText ( calculateCreationPrice ( ) + " RU" ) ; if ( totalWeight != null && maxWeight > 0 )
getLastname: public String getLastname ( ) { return lastname ;
complete: public boolean complete ( float dt ) { if ( freeFrame ) { return true ; } freeFrame = updateAssetManagers ( ) ; return false ;
hasPoints: public boolean hasPoints ( Team team ) { ObjectMap < Team , Float > points = getGameMode ( ) . getPoints ( ) ; return points . get ( team , 0.0f ) > 0.0f ;
noYY: void noYY ( ) { assertEquals ( List . of ( "ay" , "by" , "cy" ) , NoYY . noYY ( List . of ( "a" , "b" , "c" ) ) ) ; assertEquals ( List . of ( "ay" , "by" ) , NoYY . noYY ( List . of ( "a" , "b" , "cy" ) ) ) ; assertEquals ( List . of ( "xxy" , "yay" , "zzy" ) , NoYY . noYY ( List . of ( "xx" , "ya" , "zz" ) ) ) ;
getExpectedInt: No method body
getNeutralColor: No method body
getErrorStringRes: public static int getErrorStringRes ( String code ) { if ( StringUtils . isEmpty ( code ) ) { return - 1 ; } Integer StringRes = mErrorTipsMap . get ( code ) ; return StringRes != null ? StringRes : R . string . error_code_common ;
close: public void close ( ) { syscallsExecutor . execute ( syscalls :: close ) ;
test_createEnvironment: public void test_createEnvironment ( ) throws IOException , NovuNetworkException , InterruptedException { CreateEnvironmentRequest createEnvironmentRequest = new CreateEnvironmentRequest ( ) ; createEnvironmentRequest . setName ( "name" ) ; createEnvironmentRequest . setParentId ( "parentId" ) ; SingleEnvironmentResponse singleEnvironmentResponse = new SingleEnvironmentResponse ( ) ; EnvironmentResponse data = new EnvironmentResponse ( ) ; data . setId ( "id" ) ; data . setName ( "name" ) ; data . setIdentifier ( "identifier" ) ; data . setOrganizationId ( "organizationId" ) ; data . setApiKeys ( Collections . singletonList ( new ApiKey ( ) ) ) ; Widget widget = new Widget ( ) ; widget . setNotificationCenterEncryption ( false ) ; data . setWidget ( widget ) ; data . setCreatedAt ( "createdAt" ) ; data . setUpdatedAt ( "updatedAt" ) ; data . setParentId ( "parentId" ) ; singleEnvironmentResponse . setData ( data ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( singleEnvironmentResponse ) ) ) ; SingleEnvironmentResponse response = environmentHandler . createEnvironment ( createEnvironmentRequest ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/environments" , request . getPath ( ) ) ; assertEquals ( "POST" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( singleEnvironmentResponse ) , gson . toJson ( response ) ) ;
setRegionUVs: public void setRegionUVs ( float [ ] regionUVs ) { this . regionUVs = regionUVs ;
getEntryForHighlight: public Entry getEntryForHighlight ( Highlight highlight ) { return getDataSet ( ) . getEntryForIndex ( ( int ) highlight . getX ( ) ) ;
getMessageId: public final Long getMessageId ( ) { return this . messageId ;
startClient: public static void startClient ( Activity activity , String packName , String pageName ) { Intent intent = new Intent ( ) ; ComponentName cmp = new ComponentName ( packName , pageName ) ; intent . setAction ( Intent . ACTION_MAIN ) ; intent . addCategory ( Intent . CATEGORY_LAUNCHER ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setComponent ( cmp ) ; activity . startActivity ( intent ) ;
getEventObjectType: public String getEventObjectType ( ) { return eventObjectType ;
getTransformedPositions: protected float [ ] getTransformedPositions ( ) { if ( mGetTransformedPositionsBuffer . length != mYAxis . mEntryCount * 2 ) { mGetTransformedPositionsBuffer = new float [ mYAxis . mEntryCount * 2 ] ; } float [ ] positions = mGetTransformedPositionsBuffer ; for ( int i = 0 ; i < positions . length ; i += 2 ) { positions [ i + 1 ] = mYAxis . mEntries [ i / 2 ] ; } mTrans . pointValuesToPixel ( positions ) ; return positions ;
allowWeightUpgrade: protected boolean allowWeightUpgrade ( ) { return false ;
getXValue: public float getXValue ( ) { return xValue ;
matchFileType: public static boolean matchFileType ( File file , FileType fileType ) { return Objects . equals ( getFileType ( file ) , fileType . getFileType ( ) ) ;
copyAddress: public void copyAddress ( ) { String toCopyAddress = walletAddress ; String toastString = getResources ( ) . getString ( R . string . toast_copy_address ) ; CopyUtil . SelfCopy ( BalanceDetailActivity . this , toCopyAddress , toastString ) ;
run: public void run ( ) { if ( millisLeft <= 0 ) { millisLeft = 0 ; } mListener . onTick ( millisLeft ) ;
isShowOnMinimap: public boolean isShowOnMinimap ( ) { return showOnMinimap ;
launchEffect: public void launchEffect ( ) { if ( effects . size == 0 && effect != null )
getX: public float getX ( ) { return itemData . getX ( ) ;
touchDown: public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { if ( super . touchDown ( screenX , screenY , pointer , button ) ) { return true ; } if ( touchDownButton != - 1 && touchDownButton != button ) return false ; touchDownButton = button ; if ( isMoveAlt ( ) ) { touchDownPosition . set ( screenX , screenY ) ; return true ; } if ( currentMode . mouseDown ( convertMousePosition ( screenX , screenY ) , button ) ) { setDragState ( DragState . down ) ; return true ; } return false ;
getBanner: public String getBanner ( ) { return null ;
reloadForm: public boolean reloadForm ( Long formId ) { debug ( "[reloadForm]" ) ; Form form = repositories . unsecure . form . findOne ( formId ) ; if ( form != null ) { if ( unregisterForm ( form ) ) { return registerForm ( form ) ; } } return false ;
MIUISetStatusBarLightMode: public static boolean MIUISetStatusBarLightMode ( Window window , boolean dark ) { boolean result = false ; if ( window != null ) { try { Class < ? > clazz = window . getClass ( ) ; if ( ! StringUtils . isEmpty ( clazz . getName ( ) ) && clazz . getName ( ) . contains ( "MiuiWindowManager" ) ) { Class layoutParams = Class . forName ( "android.view.MiuiWindowManager$LayoutParams" ) ; Field field = layoutParams . getField ( "EXTRA_FLAG_STATUS_BAR_DARK_MODE" ) ; int darkModeFlag = field . getInt ( layoutParams ) ; Method extraFlagField = clazz . getMethod ( "setExtraFlags" , int . class , int . class ) ; if ( dark ) { extraFlagField . invoke ( window , darkModeFlag , darkModeFlag ) ; } else { extraFlagField . invoke ( window , 0 , darkModeFlag ) ; } } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { if ( dark ) { window . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; } else { window . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_VISIBLE ) ; } } result = true ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return result ;
allowZoom: public boolean allowZoom ( ) { return watchAllowZoom ;
getString: public String getString ( ) { return stringValue ;
onClick: public void onClick ( View v ) { result . confirm ( ) ; dialog . dismiss ( ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new ShootingRangeTargetBlockComponentData ( componentObject , this ) ;
getCategory: public String getCategory ( ) { return category ;
orElse: public T orElse ( T other ) { return isReady ? value : other ;
getDuration: void getDuration ( ) { assertEquals ( 130 , dvd . getLength ( ) ) ;
noWrap: protected boolean noWrap ( ) { return false ;
jButton1ActionPerformed: private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { annunciator . acknowledge ( ) ; for ( UIUpdateable window : elementsToUpdate ) {
setBpp: public void setBpp ( int bpp ) { this . bpp = bpp ;
getRenderer: public static ColorWheelRenderer getRenderer ( ColorPickerView . WHEEL_TYPE wheelType ) { switch ( wheelType ) { case CIRCLE : return new SimpleColorWheelRenderer ( ) ; case FLOWER : return new FlowerColorWheelRenderer ( ) ; } throw new IllegalArgumentException ( "wrong WHEEL_TYPE" ) ;
loadContent: public void loadContent ( AssetManager assetManager ) { super . loadContent ( assetManager ) ; ParticleEffectLoader . ParticleEffectParameter parameter = new ParticleEffectLoader . ParticleEffectParameter ( ) ; parameter . atlasFile = atlas ; assetManager . load ( particleName , com . badlogic . gdx . graphics . g2d . ParticleEffect . class , parameter ) ;
validateActive: public boolean validateActive ( Active active ) { return ! ( active instanceof Player ) ;
sendTCP: public void sendTCP ( Object msg ) { clients . sendTCP ( msg ) ;
getAccessLevel: public FrontendResource . AccessLevel getAccessLevel ( ) { return accessLevel ;
getFlags: No method body
getChannelName: public String getChannelName ( ) { return channelName ;
canSpawn: public boolean canSpawn ( Team teamFor ) { return ( getTeam ( ) == teamFor && ( state == State . normal ) ) ;
setControllerEndpoints: public void setControllerEndpoints ( List < ControllerEndpointConversionDto > controllerEndpoints ) { this . controllerEndpoints = controllerEndpoints ;
RenderInstrument: public static Actor RenderInstrument ( Table renderTo , InstrumentInfo info , boolean unloaded ) { Shader blackShader = ( ( Shader ) BrainOut . ContentMgr . get ( "shader-black" ) ) ; InstrumentIcon instrumentIcon = new InstrumentIcon ( info , 1.0f , true ) ; instrumentIcon . setBounds ( 0 , 0 , 192 , 64 ) ; instrumentIcon . init ( ) ; ShaderedActor sh = new ShaderedActor ( instrumentIcon , blackShader ) ; WidgetGroup root = new WidgetGroup ( ) ; root . addActor ( sh ) ; InstrumentIcon orig = new InstrumentIcon ( info , 1.0f , true ) ; orig . setBounds ( 0 , 4 , 192 , 64 ) ; orig . init ( ) ; if ( unloaded ) { orig . disableAttachment ( "clip" ) ; } root . addActor ( orig ) ; renderTo . add ( root ) . size ( 196 , 68 ) . expand ( ) . row ( ) ; return root ;
downloadManifest: public void downloadManifest ( View view , DownloadCallback downloadCallback ) { String fileName = MANIFEST_FILE_NAME ; String downloadFileName = downloadVersion + fileName ; String downloadUrl = ConstantWithNetwork . getInstance ( ConstantInOB . networkType ) . getDownloadBaseUrl ( ) + downloadFileName ; Log . d ( TAG , "downloadManifest downloadUrl: " + downloadUrl ) ; String filePath = downloadDictionaryPath ; OnDownloadListener onDownloadListener = new OnDownloadListener ( ) { @ Override public void onDownloadComplete ( ) { downloadCallback . callback ( ) ; } @ Override public void onError ( Error error ) { view . findViewById ( R . id . refresh_btn ) . setVisibility ( View . VISIBLE ) ; if ( error . isServerError ( ) ) { ToastUtils . showToast ( mContext , fileName + "server occur error!" ) ; } else if ( error . isConnectionError ( ) ) { ToastUtils . showToast ( mContext , fileName + "connection occur error!" ) ; } else { ToastUtils . showToast ( mContext , fileName + "download occur error:" + error . toString ( ) ) ; } } } ; boolean isExist = checkNeutrinoFileExist ( ) ; if ( ! isExist ) {
clicked: public void clicked ( InputEvent event , float x , float y ) { setEditorMode ( EditorMode . Mode . actives ,
asmTest4: public void asmTest4 ( ) throws IOException , InterruptedException { ChangeBodyMessage msg = new ChangeBodyMessage ( ) ; msg . setClassName ( "w.core.ChangeTarget" ) ; msg . setMethod ( "hashCode" ) ; msg . setMode ( 1 ) ; msg . setParamTypes ( Arrays . asList ( ) ) ; msg . setBody ( "{return 1; }" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; System . out . println ( target . hashCode ( ) ) ; Assertions . assertEquals ( 1 , target . hashCode ( ) ) ;
get: public ShopCategoryPropertyKey get ( String shopCategoryPropertyKey ) throws ApiErrorException , ConnectionException { Class < ShopCategoryPropertyKey > responseModel = ( Class < ShopCategoryPropertyKey > ) ( Class < ? > ) ShopCategoryPropertyKey . class ; return this . request ( "get" , this . resolvePath ( "/shop-category-property-keys/%s" , shopCategoryPropertyKey ) , null , null , responseModel ) ;
getDescription: public String getDescription ( ) { return mDescription ;
onComponentUpdated: private void onComponentUpdated ( ComponentUpdatedEvent ev ) { Object msg = new UpdatedComponentMsg ( ev . data , ev . component ) ; final ActiveData activeData = ev . data ; final Component cmp = ev . component ; getClients ( ) . foreach ( client ->
addHeaderView: public void addHeaderView ( View view ) { if ( mWrapRecyclerAdapter != null ) {
responseContentType: No method body
changed: No method body
createUI: public Table createUI ( ) { this . data = new Table ( ) ; data . align ( Align . right | Align . bottom ) ; data . add ( new LoadingBlock ( ) ) . pad ( 32 ) ; return data ;
run: public void run ( ) { ActionPhaseState ps = ( ( ActionPhaseState ) BrainOutClient . getInstance ( ) . topState ( ) ) ; ps . addAction ( new MenuAction ( )
getT3: public Tuple3 getT3 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] ) ;
complete: No method body
setTeamWon: public void setTeamWon ( Team teamWon ) { this . teamWon = teamWon ;
applyForce: public void applyForce ( float x , float y ) { this . force . add ( x , y ) ;
unsettingProjectKeepsObjectModelOK: void unsettingProjectKeepsObjectModelOK ( ) { Project sr71 = new Project ( "SR71" , LocalDate . of ( 1962 , 3 , 4 ) , LocalDate . of ( 1964 , 7 , 4 ) ) ; task . setProject ( project ) ; task . setProject ( sr71 ) ; assertFalse ( project . getTasks ( ) . contains ( task ) ) ; assertTrue ( sr71 . getTasks ( ) . contains ( task ) ) ; assertEquals ( task . getProject ( ) , sr71 ) ;
discard: public void discard ( ) { this . setVisible ( false ) ;
getSpawnRange: No method body
getFileCRC32: public static String getFileCRC32 ( File file ) { long fileCRC32 = - 1 ; String fileCRC32Str = "" ; CRC32 crc32 = new CRC32 ( ) ; if ( ! file . isFile ( ) ) { return fileCRC32Str ; } FileInputStream in ; byte buffer [ ] = new byte [ 1024 ] ; try {
matchUp: public static int matchUp ( int [ ] v1 , int [ ] v2 ) { int count = 0 ; for ( int i = 0 ; i < v1 . length ; i ++ ) { if ( v1 [ i ] != v2 [ i ] && Math . abs ( v1 [ i ] - v2 [ i ] ) <= 2 ) { count ++ ; } } return count ;
addIfTyped: private void addIfTyped ( String command , String summary ) { final String s1 = ensurePrefix ( input ) ; final String s2 = ensurePrefix ( command ) ; if ( s1 . startsWith ( s2 ) || s2 . startsWith ( s1 ) ) {
getDoorPortal: public PortalData getDoorPortal ( ) { ActiveData activeData = findActiveData ( doorPortal ) ; if ( ! ( activeData instanceof PortalData ) ) return null ; return ( ( PortalData ) activeData ) ;
getContentHash: public String getContentHash ( ) { return contentHash == null ? "" : contentHash ; }
handleDiscoveryRequest: private void handleDiscoveryRequest ( HttpServerRequest request ) { RestateEndpoint . DiscoveryResponse discoveryResponse ; try { discoveryResponse = restateEndpoint . handleDiscoveryRequest ( request . getHeader ( ACCEPT ) ) ; } catch ( ProtocolException e ) { LOG . warn ( "Error when handling the discovery request" , e ) ; request . response ( ) . setStatusCode ( e . getCode ( ) ) . putHeader ( CONTENT_TYPE , "text/plain" ) . putHeader ( X_RESTATE_SERVER_KEY , X_RESTATE_SERVER_VALUE ) . end ( e . getMessage ( ) ) ; return ; } request
removeAttachment: public void removeAttachment ( String slotName ) { Log . info ( "Remove attachment " + slotName ) ; if ( getSkeleton ( ) == null ) return ; Slot slot = getSkeleton ( ) . findSlot ( slotName ) ; if ( slot != null && slot . getAttachment ( ) != null )
renderPanels: public void renderPanels ( Table panels ) { {
hasCategory: public boolean hasCategory ( ) { return category != null ;
read: public void read ( JSONObject obj , String key ) { if ( obj . has ( key ) )
checkMovement: private void checkMovement ( ) { if ( fp . isHungry ( ) ) return ; float passedNow = prevPosition . dst ( phy . getX ( ) , phy . getY ( ) ) ; prevPosition . set ( phy . getX ( ) , phy . getY ( ) ) ; if ( passedNow > 20 || passedNow < 1 ) { return ; } if ( passedDistance > 0 ) { passedDistance -= passedNow ; if ( passedDistance <= 0 ) { fp . consumeHunger ( 1 ) ; fp . updated ( playerData , this :: ownerOnly ) ; passedDistance = 0 ; } } else { generateHunger ( ) ; } prevPosition . set ( phy . getX ( ) , phy . getY ( ) ) ;
getScatterShapeHoleColor: public int getScatterShapeHoleColor ( ) { return mScatterShapeHoleColor ;
canDropConsumable: public boolean canDropConsumable ( ConsumableRecord record ) { return false ;
getBtcBalanceAction: private static void getBtcBalanceAction ( Context context ) { WalletServiceUtil . GetBtcBalanceCallback getBtcBalanceCallback = ( double btcBalance ) -> { Log . d ( TAG , "initOrUpdateDataStartApp: btcBalance" + btcBalance ) ; insertOrUpdateAssetDataAndUpdateValueData ( context , "0" , btcBalance ) ; getAssetsBalanceAction ( context ) ; } ; WalletServiceUtil . GetBtcBalanceErrorCallback getBtcBalanceErrorCallback = ( Exception e , Context mContext ) -> { Log . d ( TAG , e . getMessage ( ) ) ; getAssetsBalanceAction ( context ) ; e . printStackTrace ( ) ; } ; Log . d ( TAG , "initOrUpdateDataStartApp: start" ) ; WalletServiceUtil . getBtcBalance ( context , getBtcBalanceCallback , getBtcBalanceErrorCallback ) ;
getFile: public PackageFileHandle getFile ( String fileName ) { if ( fileName . endsWith ( ".mp3" ) ) { return new AndroidFileHandle ( fileName ) ; } return super . getFile ( fileName ) ;
init: private Event init ( LaunchData launchData , ActiveData who ) { this . launchData = launchData ; this . who = who ; return this ;
labelTransaction: public Single < walletrpc . Walletkit . LabelTransactionResponse > labelTransaction ( walletrpc . Walletkit . LabelTransactionRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . labelTransaction ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
lerpAngle: public boolean lerpAngle ( float angleRequired ) { PlayerData playerData = getPlayerData ( ) ; if ( playerData == null ) return false ; float angleHave = playerData . getAngle ( ) ; float result = MathUtils . lerpAngleDeg ( angleHave , angleRequired , 0.6f ) ; playerData . setAngle ( result ) ; float diff = Math . abs ( angleHave - angleRequired ) ; return diff < 5.0f || diff >= 355.0f ;
calculateLaunchAngeAdd: public float calculateLaunchAngeAdd ( ) { return MathUtils . lerp ( Constants . Weapon . RECOIL_LAUNCH_ANGLE_ADD_MIN ,
isGridEnabled: public boolean isGridEnabled ( ) { return gridEnabled ;
release: public void release ( ) { super . release ( ) ; if ( progressBar != null ) { progressBar . dispose ( ) ; } BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
getLight: public Light getLight ( ) { return light ;
initContent: protected void initContent ( Table data ) { final Label text = new Label ( this . text , BrainOutClient . Skin , "title-medium" ) ; text . setAlignment ( Align . center ) ; text . setWrap ( true ) ; data . add ( text ) . pad ( 16 ) . center ( ) . expand ( ) . fill ( ) . row ( ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
hasRender: public boolean hasRender ( ) { return false ;
isConflict: public boolean isConflict ( ) { return conflict ;
sendCustomMessage: No method body
onInit: public void onInit ( ) { super . onInit ( ) ; EnvironmentService env = EnvironmentService . Get ( ) ; ProfileService profileService = ProfileService . Get ( ) ; LoginService loginService = LoginService . Get ( ) ; if ( env == null || profileService == null || loginService == null ) return ; String conflictAccount = ( String ) env . getEnvironmentVariables ( ) . get ( "conflict-account" ) ; if ( conflictAccount == null ) { conflictAccount = defaultConflictAccount ( ) ; } profileService . getAccountProfile ( loginService . getCurrentAccessToken ( ) , conflictAccount ,
resolve: public final void resolve ( T t ) { transition ( State . Succeeded , t , null ) ;
getCurrentMode: public EditorMode getCurrentMode ( ) { return currentMode ;
getMaxPlayerAmount: public int getMaxPlayerAmount ( ) { Team bestTeam = getBestPlayerTeam ( ) ; if ( bestTeam != null ) { return getPlayersAmount ( bestTeam ) ; } return 0 ;
release: public void release ( ) { super . release ( ) ; if ( currentMusic == null ) return ; currentMusic . stop ( ) ;
delete: public void delete ( Identifier productIdentifier , Identifier variantIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/products/%s/variants/%s" , productIdentifier , variantIdentifier ) , query , null , null ) ;
bind: public < O > Builder bind ( ServiceDefinition < O > component , @ Nullable O options ) { this . services . add ( new ServiceAndOptions < > ( component , options ) ) ; return this ;
getAim: public AimState getAim ( ) { return aim ;
addItem: private void addItem ( String title , String description ) { items . add ( new Pair < > ( title , description ) ) ;
Z: public Observable < T > Z ( int number ) { return this ;
getOffsetY: public float getOffsetY ( ) { return offsetY ;
getLastWrite: public long getLastWrite ( ) { return handler . getLastWrite ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pushMenu ( new ConfirmationPopup ( L . get ( "MENU_LEAVE_TITLE" ) )
prepareBtcPaymentProbe: public RouterOuterClass . SendPaymentRequest prepareBtcPaymentProbe ( String destination , long amountSat , @ Nullable ByteString paymentAddress , @ Nullable List < LightningOuterClass . RouteHint > routeHints , @ Nullable Map < Integer , LightningOuterClass . Feature > destFeatures ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ PAYMENT_HASH_BYTE_LENGTH ] ; random . nextBytes ( bytes ) ; long feeLimit = calculateAbsoluteFeeLimit ( amountSat ) ; RouterOuterClass . SendPaymentRequest . Builder sprb = RouterOuterClass . SendPaymentRequest . newBuilder ( ) . setAssetId ( ( int ) mAssetId ) . setDest ( byteStringFromHex ( destination ) ) . setAmtMsat ( amountSat ) . setFeeLimitMsat ( feeLimit ) . setPaymentHash ( ByteString . copyFrom ( bytes ) ) . setNoInflightUpdates ( true ) . setTimeoutSeconds ( RefConstants . TIMEOUT_MEDIUM * RefConstants . TOR_TIMEOUT_MULTIPLIER ) . setMaxParts ( 1 ) ; if ( paymentAddress != null ) { sprb . setPaymentAddr ( paymentAddress ) ; } if ( destFeatures != null && ! destFeatures . isEmpty ( ) ) { for ( Map . Entry < Integer , LightningOuterClass . Feature > entry : destFeatures . entrySet ( ) ) { sprb . addDestFeaturesValue ( entry . getKey ( ) ) ; } } if ( routeHints != null && ! routeHints . isEmpty ( ) ) { sprb . addAllRouteHints ( routeHints ) ; } return sprb . build ( ) ;
getOrganizationId: public Long getOrganizationId ( ) { return organizationId ;
setSelectedCondition: public void setSelectedCondition ( boolean state ) { mTextView . setSelected ( state ) ;
setScanner: public void setScanner ( ClassPathBeanDefinitionScanner scanner ) { this . scanner = scanner ;
clicked: public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; pop ( ) ;
endResponse: private void endResponse ( ) { LOG . trace ( "Closing response" ) ; if ( ! this . httpServerResponse . ended ( ) ) { this . httpServerResponse . end ( ) ; } cancelSubscription ( ) ;
setFlipY: public void setFlipY ( boolean flipY ) { this . flipY = flipY ;
setFrameColor: public void setFrameColor ( Color color ) { frame . setForegroundPaint ( color ) ; frame . setBackgroundPaint ( color . darker ( ) ) ;
handleStart: private static int handleStart ( Future < HttpServer > fut ) { try {
getName: public String getName ( ) { return name ;
obtain: public static Event obtain ( PlayerClient player , Content item , int amount ) { FreePlayItemUsedEvent e = obtain ( FreePlayItemUsedEvent . class ) ; if ( e == null ) return null ; return e . init ( player , item , amount ) ;
release: public void release ( ) { BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
init: private void init ( Context context , AttributeSet attrs ) { if ( Build . VERSION . SDK_INT < 18 ) { setLayerType ( View . LAYER_TYPE_SOFTWARE , null ) ; } initAttr ( context , attrs ) ;
obtain: public static Event obtain ( Action action , boolean flag ) { GameControllerEvent e = obtain ( GameControllerEvent . class ) ; if ( e == null ) return null ; return e . init ( action , flag ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionIncrement5ActionPerformed ( evt ) ;
setTextReplaceNumberString: public static void setTextReplaceNumberString ( TextView textView , String str , String nullStr ) { if ( textView == null ) { return ; } textView . setText ( replaceNumberString ( str , nullStr , "" ) ) ;
onClick: public void onClick ( View v ) { mLoadingDialog = new LoadingDialog ( mContext ) ; mLoadingDialog . show ( ) ; mBasePopWindow . dismiss ( ) ; mLoadingDialog . dismiss ( ) ; mSendFailedPopupWindow = new SendFailedPopupWindow ( mContext ) ; mSendFailedPopupWindow . show ( view ) ;
removeSubscriberFromTopic: public SubscriberRemovalResponse removeSubscriberFromTopic ( final SubscriberAdditionRequest request , final String topicKey ) throws IOException , NovuNetworkException { try {
createOrUpdateCustomDataForCountry: public Map < String , Object > createOrUpdateCustomDataForCountry ( String shopKey , Integer shopCategoryId , String countryCode , Map < String , Object > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/shops/%s/categories/%s/countries/%s/custom-data" , shopKey , shopCategoryId , countryCode ) , query , null , responseModel , model ) ;
isDebugLogger: default boolean isDebugLogger ( ) { return debugLoggers . contains ( getClass ( ) ) ;
discoverTableName: public static String discoverTableName ( Class c ) { Table table = ( Table ) c . getAnnotation ( Table . class ) ; if ( table != null && StringUtils . isNotBlank ( table . name ( ) ) ) { return table . name ( ) ; } Identifier i = camelCaseToUnderscoredNamingStrategy . toPhysicalTableName ( Identifier . toIdentifier ( c . getSimpleName ( ) ) , null ) ; return i . getText ( ) ;
hasUpdate: public boolean hasUpdate ( ) { return activeData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) != null ;
getPageSize: public Integer getPageSize ( ) { return pageSize ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoSteamPressure3OnActionPerformed ( evt ) ;
getPrice: private StoreService . Store . Tier . Price getPrice ( StoreService . Store . Item item ) { StoreService . Store . Item . Billing billing = item . getBilling ( ) ; return billing . getTier ( ) . getPrices ( ) . getOrDefault (
setSoundEffectsEnabled: public void setSoundEffectsEnabled ( boolean soundEffectsEnabled ) { super . setSoundEffectsEnabled ( soundEffectsEnabled ) ; mSoundEffectEnable = soundEffectsEnabled ;
show: public void show ( ) { if ( mAlertDialog == null ) { Log . d ( TAG , "show" ) ; mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme ) . setContentView ( R . layout . layout_dialog_forget_password ) . setAnimation ( R . style . popup_anim_style ) . fullWidth ( ) . fullHeight ( ) . create ( ) ; } LinearLayout editListContent = mAlertDialog . findViewById ( R . id . edit_text_Content ) ; int [ ] editTextIds = new int [ 24 ] ; for ( int idx = 0 ; idx < editTextIds . length ; idx ++ ) { int id = View . generateViewId ( ) ; Log . d ( TAG , "initEditViewForSeeds: " + id ) ; editTextIds [ idx ] = id ; } for ( int row = 1 ; row <= 8 ; row ++ ) { RelativeLayout rowContent = new RelativeLayout ( mContext ) ; RelativeLayout . LayoutParams rowContentParams = new RelativeLayout . LayoutParams ( RelativeLayout . LayoutParams . WRAP_CONTENT , RelativeLayout . LayoutParams . WRAP_CONTENT ) ; rowContentParams . setMargins ( 0 , 0 , 0 , 2 ) ; rowContent . setLayoutParams ( rowContentParams ) ; rowContent . setLongClickable ( false ) ; LinearLayout rowInner = new LinearLayout ( mContext ) ; LinearLayout . LayoutParams rowInnerParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT , 1.0f ) ; rowInner . setOrientation ( LinearLayout . HORIZONTAL ) ; rowInner . setLayoutParams ( rowInnerParams ) ; rowInner . setLongClickable ( false ) ; for ( int cell = 1 ; cell <= 3 ; cell ++ ) { String noNum = NumberFormatter . formatNo ( 2 , ( row - 1 ) * 3 + cell ) + "." ; RelativeLayout cellContent = new RelativeLayout ( mContext ) ; LinearLayout . LayoutParams cellContentParams = new LinearLayout . LayoutParams ( 0 , LinearLayout . LayoutParams . WRAP_CONTENT , 1.0f ) ; cellContent . setLayoutParams ( cellContentParams ) ; cellContent . setLongClickable ( false ) ; LinearLayout cellInner = new LinearLayout ( mContext ) ; LinearLayout . LayoutParams cellInnerParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; cellInner . setOrientation ( LinearLayout . HORIZONTAL ) ; cellInner . setLayoutParams ( cellInnerParams ) ; cellInner . setLongClickable ( false ) ; TextView noText = new TextView ( mContext ) ; RelativeLayout . LayoutParams noTextParams = new RelativeLayout . LayoutParams ( RelativeLayout . LayoutParams . WRAP_CONTENT , RelativeLayout . LayoutParams . WRAP_CONTENT ) ; noText . setTextColor ( mContext . getResources ( ) . getColor ( R . color . color_white ) ) ; noText . setTextSize ( 14.0f ) ; noText . setText ( noNum ) ; noText . setLayoutParams ( noTextParams ) ; EditText cellEditText = new DisablePasteEditText ( mContext ) ; LinearLayout . LayoutParams cellEditTextParams = new LinearLayout . LayoutParams ( 0 , LinearLayout . LayoutParams . WRAP_CONTENT , 1.0f ) ; cellEditText . setBackground ( null ) ; cellEditText . setHint ( mContext . getResources ( ) . getString ( R . string . create_seed_input_hit ) ) ; cellEditText . setHintTextColor ( mContext . getResources ( ) . getColor ( R . color . color_white ) ) ; cellEditText . setTextSize ( 14.0f ) ; cellEditText . setTextColor ( mContext . getResources ( ) . getColor ( R . color . color_white ) ) ; cellEditText . setLayoutParams ( cellEditTextParams ) ; cellEditText . setMaxLines ( 1 ) ; cellEditText . setInputType ( InputType . TYPE_CLASS_TEXT ) ; SeedFilter seedFilter = new SeedFilter ( ) ; cellEditText . setFilters ( new InputFilter [ ] { seedFilter } ) ; int d = ( row - 1 ) * 3 + cell ; int id = editTextIds [ ( row - 1 ) * 3 + cell - 1 ] ; cellEditText . setId ( id ) ; if ( d < 24 ) { cellEditText . setImeOptions ( EditorInfo . IME_ACTION_NEXT ) ; cellEditText . setNextFocusUpId ( editTextIds [ ( row - 1 ) * 3 + cell ] ) ; int finalCell = cell ; int finalRow = row ; TextView . OnEditorActionListener listener = new TextView . OnEditorActionListener ( ) { @ Override public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { Log . d ( TAG , "onEditorAction: " + actionId ) ; if ( actionId == EditorInfo . IME_ACTION_NEXT ) { mAlertDialog . findViewById ( editTextIds [ ( finalRow - 1 ) * 3 + finalCell ] ) . requestFocus ( ) ; } return true ; } } ; cellEditText . setOnEditorActionListener ( listener ) ; } else { cellEditText . setImeOptions ( EditorInfo . IME_ACTION_DONE ) ; TextView . OnEditorActionListener listener = new TextView . OnEditorActionListener ( ) { @ Override public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( actionId == EditorInfo . IME_ACTION_DONE ) { clickForward ( ) ; } return true ; } } ; cellEditText . setOnEditorActionListener ( listener ) ; } cellInner . addView ( noText ) ; cellInner . addView ( cellEditText ) ; cellContent . addView ( cellInner ) ; rowInner . addView ( cellContent ) ; list . add ( cellEditText ) ; } rowContent . addView ( rowInner ) ; editListContent . addView ( rowContent ) ; } LinearLayout pageContent = mAlertDialog . findViewById ( R . id . layout_dialog_forget_password ) ; KeyboardScrollView . controlKeyboardLayout ( pageContent , editListContent ) ; mAlertDialog . findViewById ( R . id . btn_paste ) . setOnClickListener ( new View . OnClickListener ( ) { @ RequiresApi ( api = Build . VERSION_CODES . M ) @ Override public void onClick ( View v ) { clickPaste ( ) ; } } ) ; mAlertDialog . findViewById ( R . id . btn_back ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { clickBack ( ) ; } } ) ; mAlertDialog . findViewById ( R . id . btn_forward ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { clickForward ( ) ; } } ) ; mAlertDialog . show ( ) ;
getAxisMinLabels: public int getAxisMinLabels ( ) { return mAxisMinLabels ;
setConsumerParameterClassName: public void setConsumerParameterClassName ( String consumerParameterClassName ) { this . consumerParameterClassName = consumerParameterClassName ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ;
convertHashToString: private static String convertHashToString ( byte [ ] md5Bytes ) { String returnVal = "" ; for ( int i = 0 ; i < md5Bytes . length ; i ++ ) { returnVal += Integer . toString ( ( md5Bytes [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ; } return returnVal . toLowerCase ( ) ;
isQuestDoneForToday: public boolean isQuestDoneForToday ( UserProfile profile ) { long current = getCurrentDay ( ) ; return profile . getStats ( ) . get ( getID ( ) + "-time" , 0f ) == current ;
run: public void run ( ) { try {
sendAndSaveEmail: public Email sendAndSaveEmail ( User recipient , String emailTemplateName , PageModelMap model ) { debug ( "[sendAndSaveEmail] Sends {} to {}" , emailTemplateName , recipient ) ; return repositories . unsecure . email . save ( services . emailConstructor . prepareEmailWithTitleFromTemplate ( recipient , null , emailTemplateName , model ) ) ;
restoreChannelBackups: public Single < lnrpc . LightningOuterClass . RestoreBackupResponse > restoreChannelBackups ( lnrpc . LightningOuterClass . RestoreChanBackupRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . restoreChannelBackups ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
style: public PaintHolder style ( Paint . Style style ) { this . paint . setStyle ( style ) ; return this ;
delete: public void delete ( Identifier reservationIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/reservations/%s" , reservationIdentifier ) , null , null , null ) ;
acknowledge: No method body
setProperty: public void setProperty ( String id , String value ) { if ( props == null ) props = new ObjectMap < > ( ) ; props . put ( id , value ) ;
findSettableValue: private static String findSettableValue ( String name , Collection < String > supportedValues , String ... desiredValues ) { Log . i ( TAG , "Requesting " + name + " value from among: " + Arrays . toString ( desiredValues ) ) ; Log . i ( TAG , "Supported " + name + " values: " + supportedValues ) ; if ( supportedValues != null ) { for ( String desiredValue : desiredValues ) { if ( supportedValues . contains ( desiredValue ) ) { Log . i ( TAG , "Can set " + name + " to: " + desiredValue ) ; return desiredValue ; } } } Log . i ( TAG , "No supported values match" ) ; return null ;
renderBottomLine: protected Actor renderBottomLine ( ) { if ( userProfile == null || item == null ) return null ; int need = item . getLockItem ( ) . getParam ( ) + item . getLockItem ( ) . getDisplayOffset ( ) ; int have = Math . max ( item . getLockItem ( ) . getUnlockValue ( userProfile , 0 ) + item . getLockItem ( ) . getDisplayOffset ( ) , 0 ) ; Group progress = new Group ( ) ; ProgressBar scoreBar = new ProgressBar ( 0 , need , 1 , false , BrainOutClient . Skin , "progress-score" ) ; scoreBar . setBounds ( 0 , - 1 , 512 , ClientConstants . Menu . PlayerInfo . LABEL_HEIGHT ) ; scoreBar . setValue ( have ) ; progress . addActor ( scoreBar ) ; Label scoreValue = new Label ( String . valueOf ( have ) + " / " + need , BrainOutClient . Skin , "title-small" ) ; scoreValue . setAlignment ( Align . center ) ; scoreValue . setFillParent ( true ) ; progress . addActor ( scoreValue ) ; return progress ;
getCondensationRate: public double getCondensationRate ( ) { return condensationRate * 20 ;
testUpdateOrCreateProperty: public void testUpdateOrCreateProperty ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCategoryUpdateOrCreatePropertyRequest.json" ) ; ShopCategoryProperty requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , ShopCategoryProperty . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ShopCategoryProperty responseEntity = this . api . shopCategories ( ) . updateOrCreateProperty ( "acme" , "acme" , 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCategoryUpdateOrCreatePropertyResponse.json" ) ; assertThatJson ( expectedResponseJson )
release: public void release ( ) { if ( mFundPopupWindow != null ) {
selectTab: public void selectTab ( Object tab , boolean sendEvent ) { selectTab ( findTab ( tab ) , sendEvent ) ;
turnOffDebugModeForLoggerClassname: public boolean turnOffDebugModeForLoggerClassname ( String classname ) { debug ( "[turnOffDebugModeForLoggerClassname] {}" , classname ) ; return debugLogsDecorator . turnOffDebugModeForLoggerClassname ( classname ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; if ( jsonData . has ( "state" ) ) { state = GameModeDuel . DuelState . valueOf ( jsonData . getString ( "state" ) ) ; } deaths . clear ( ) ; if ( jsonData . has ( "dl" ) ) { for ( JsonValue value : jsonData . get ( "dl" ) ) { deaths . add ( value . asInt ( ) ) ; } } deathsRequired = jsonData . getInt ( "deaths" , 3 ) ; enemy = jsonData . getInt ( "enemy" , - 1 ) ;
onClick: public void onClick ( View v ) { if ( mCallback != null ) { mCallback . onClickConfirm ( mEditText . getText ( ) . toString ( ) , mRandomStr ) ; } mAlertDialog . dismiss ( ) ;
isAllowVersionMismatch: No method body
onInit: public void onInit ( ) { super . onInit ( ) ; GameUser gameUser = BrainOutClient . Env . getGameUser ( ) ; ObjectMap < String , File > files = new ObjectMap < > ( ) ; files . put ( "map" , mapFile ) ; Array < String > tags = new Array < > ( ) ; tags . add ( "map" ) ; for ( String mode : modes ) { tags . add ( mode ) ; } gameUser . publishWorkshopItem ( name , description , previewFile , files , tags . toArray ( String . class ) ,
play: protected void play ( ) { if ( currentMusic == null ) return ; currentMusic . play ( ) ; currentMusic . setOnCompletionListener ( music -> next ( ) ) ;
createUI: public Table createUI ( ) { return null ;
onClick: public void onClick ( View v ) { if ( PreventContinuousClicksUtil . isNotFastClick ( ) ) {
hasUpdate: public boolean hasUpdate ( ) { return true ;
main: public static void main ( String [ ] args ) { startApp ( App . class , args ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( Menu . MenuSound . select ) ; BrainOutClient . getInstance ( ) . topState ( ) . topMenu ( ) . pushMenu ( new BattlePassMenu (
addWhite: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tg1SpeedActionPerformed ( evt ) ;
goodAroundTheBeginning: public void goodAroundTheBeginning ( ) { assertTrue ( GoodAroundTheBeginning . goodAroundTheBeginning ( "good Sweet" ) ) ; assertTrue ( GoodAroundTheBeginning . goodAroundTheBeginning ( " good Sweet" ) ) ; assertFalse ( GoodAroundTheBeginning . goodAroundTheBeginning ( "goo" ) ) ;
getDefaultDataFolder: public static String getDefaultDataFolder ( ) { try {
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/WebhookSubscriptionCreateRequest.json" ) ; WebhookSubscription requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , WebhookSubscription . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; WebhookSubscription responseEntity = this . api . webhookSubscriptions ( ) . create ( requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/WebhookSubscriptionCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
setPercent: public void setPercent ( double percent ) { this . percent = percent ;
read: public void read ( Json json , JsonValue jsonData ) { if ( jsonData . has ( "winPoints" ) ) this . winPoints = jsonData . getInt ( "winPoints" ) ; if ( jsonData . has ( "takeFlagPoints" ) ) this . takeFlagPoints = jsonData . getInt ( "takeFlagPoints" ) ; if ( jsonData . has ( "holdFlagTime" ) ) this . holdFlagTime = jsonData . getInt ( "holdFlagTime" ) ; if ( jsonData . has ( "holdFlagPoints" ) ) this . holdFlagPoints = jsonData . getInt ( "holdFlagPoints" ) ; points . clear ( ) ; if ( jsonData . has ( "points" ) ) { JsonValue pointsValue = jsonData . get ( "points" ) ; if ( pointsValue . isObject ( ) ) { for ( JsonValue point : pointsValue ) { Team team = ( ( Team ) BrainOut . ContentMgr . get ( point . name ( ) ) ) ; int p = point . asInt ( ) ; if ( team != null ) { points . put ( team , p ) ; } } } } super . read ( json , jsonData ) ;
shouldValidateCorrectNoElseRule: public void shouldValidateCorrectNoElseRule ( ) { String rule = "name == 'test' or name.contains('test1') ? category == 'test2' or name.contains('test8') : null" ; boolean isValid = RuleSpelHelper . isRuleValid ( rule ) ; Assertions . assertTrue ( isValid ) ;
updateOrgRoleTest: public void updateOrgRoleTest ( ) { OrganizationRole role = new OrganizationRole ( ) ; role . setName ( ROLE_NAME ) ; reset ( organizationRoleRepository ) ; Mockito . when ( organizationRoleRepository . findByName ( anyString ( ) ) ) . thenReturn ( role ) ; OrganizationRole result = roleService . createOrUpdateOrgRole ( ROLE_NAME , ROLE_PRIVILEGES , false ) ; assertEquals ( ROLE_NAME , result . getName ( ) ) ; verify ( organizationRoleRepository , times ( 1 ) ) . save ( any ( OrganizationRole . class ) ) ;
getEntityKey: public String getEntityKey ( ) { return entityKey ;
setPlayState: public PlayState setPlayState ( PlayState . ID playState ) { setPlayState ( brainOut . newPlayState ( playState ) ) ; return this . playState ;
setLeftTitleText: public void setLeftTitleText ( CharSequence titleText ) { setText ( R . id . tv_left_title , String . valueOf ( titleText ) ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ;
getConnectedChannel: public ChannelFuture getConnectedChannel ( ) { return connectedChannel ;
release: public void release ( ) { for ( Widget widget : widgets ) { widget . release ( ) ; } widgets . clear ( ) ;
grabViewBounds: public static void grabViewBounds ( RecyclerView view ) { view . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( new ViewTreeObserver . OnGlobalLayoutListener ( ) {
getAll: public CommonResult < List < MenuDto > > getAll ( ) { List < MenuDto > menuDtoList = menuService . getAll ( ) ; return CommonResult . success ( menuDtoList ) ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < Campaign > responseEntity = this . api . campaigns ( ) . all ( "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CampaignAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( Campaign entity : responseEntity . getEntities ( ) ) {
hasUpdate: public boolean hasUpdate ( ) { return false ;
turnOnDebugModeForLoggerClassname: public boolean turnOnDebugModeForLoggerClassname ( String classname ) { debug ( "[turnOnDebugModeForLoggerClassname] {}" , classname ) ; return debugLogsDecorator . turnOnDebugModeForLoggerClassname ( classname ) ;
setLinear: public void setLinear ( int frame ) { curves [ frame ] = LINEAR ;
withdrawItemFromMarket: private boolean withdrawItemFromMarket ( RealEstateItemInventoryPanel . RealEstateItemInventoryRecord record , int amount , RealEstateItemInventoryPanel rsPanel ) { String rsItemKey = rsPanel . getRealEstateItemKey ( ) ; if ( rsItemKey == null ) { return false ; } FreePlayMap map = rsPanel . getRsItem ( ) . getMap ( FreePlayMap . class ) ; if ( map == null ) return false ; Content c = record . getRecord ( ) . getItem ( ) . getContent ( ) ; if ( c == null ) return false ; JSONObject args = new JSONObject ( ) ; args . put ( "map" , map . getDimension ( ) ) ; args . put ( "key" , rsItemKey ) ; args . put ( "record" , record . getKey ( ) ) ; args . put ( "amount" , amount ) ; BrainOutClient . SocialController . sendRequest ( "withdraw_market_rs_item" , args , new SocialController . RequestCallback ( ) { @ Override public void success ( JSONObject response ) { InventoryMoveSoundComponent snd = c . getComponent ( InventoryMoveSoundComponent . class ) ; if ( snd != null ) { snd . play ( playerData ) ; } rsPanel . refresh ( ) ; } @ Override public void error ( String reason ) { if ( Log . ERROR ) Log . error ( reason ) ; Menu . playSound ( MenuSound . denied ) ; } } ) ; return true ;
getID: public ID getID ( ) { return ID . detected ;
all: public ApiCollection < MasterCategory > all ( ApiOptions options ) throws ApiErrorException , ConnectionException { Class < MasterCategory > responseModel = ( Class < MasterCategory > ) ( Class < ? > ) MasterCategory . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/master-categories" ) , query , null , responseModel ) ;
f: public String f ( ) { return null ; }
bufferToMessages: public static List < MessageLite > bufferToMessages ( List < ByteBuffer > byteBuffers ) { AssertSubscriber < InvocationInput > subscriber = AssertSubscriber . create ( Long . MAX_VALUE ) ; Multi . createFrom ( ) . iterable ( byteBuffers ) . subscribe ( new MessageDecoder ( subscriber ) ) ; subscriber . awaitCompletion ( ) ; return subscriber . getItems ( ) . stream ( )
onChartFling: No method body
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new ServerElevatorFloorComponentData ( componentObject , this ) ;
setShowText: public void setShowText ( String showText ) { this . mShowText = showText ;
getCriterion: public VoucherCriterion getCriterion ( String shopKey , String countryCode , Integer voucherId , Integer voucherCriterionId , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < VoucherCriterion > responseModel = ( Class < VoucherCriterion > ) ( Class < ? > ) VoucherCriterion . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/countries/%s/vouchers/%s/criteria/%s" , shopKey , countryCode , voucherId , voucherCriterionId ) , query , null , responseModel ) ;
onSuccess: public void onSuccess ( @ Nullable T value ) { callback . onSuccess ( mapper . apply ( value ) ) ;
save: private void save ( ) { ObjectSet < String > modes = new ObjectSet < > ( ) ; for ( ObjectMap . Entry < String , CheckBox > entry : gameModes ) { if ( entry . value . isChecked ( ) ) modes . add ( entry . key ) ; } popMeAndPushMenu ( new UpdateMapMenu (
all: public ApiCollection < AttributeGroup > all ( ) throws ApiErrorException , ConnectionException { Class < AttributeGroup > responseModel = ( Class < AttributeGroup > ) ( Class < ? > ) AttributeGroup . class ; return this . requestCollection ( "get" , this . resolvePath ( "/attribute-groups" ) , null , null , responseModel ) ;
update: public void update ( float dt ) { super . update ( dt ) ; if ( time < 1 )
openAllNotifications: public Object openAllNotifications ( @ PathVariable ( ORGANIZATIONID ) Long organizationId , @ PathVariable ( USERID ) Long userId , @ Qualifier ( "notification" ) Pageable notificationPageable ) { debug ( "[openAllNotifications] UserId: {} OrgId: {}" , userId , organizationId ) ; return getAllNotifications ( userId , organizationId , notificationPageable ) . mav ( "notification-all" ) ;
setCurrentShape: private void setCurrentShape ( Shape shape ) { this . currentShape = shape ;
saveWalletState: public static void saveWalletState ( Context context , int value ) { putInt ( SETTINGS , context , WALLET_STATE , value ) ;
invokeMessage: public static < T , R > Protocol . CallEntryMessage invokeMessage ( Target target , Serde < T > reqSerde , T parameter , Serde < R > resSerde , R result ) { return invokeMessage ( target , reqSerde , parameter )
generateLayoutParams: public LayoutParams generateLayoutParams ( AttributeSet attrs ) { return new MarginLayoutParams ( getContext ( ) , attrs ) ;
clearSources: private void clearSources ( ) { for ( DragAndDrop . Source source : sources ) { dropInto . removeSource ( source ) ; } sources . clear ( ) ;
derivative: void derivative ( ) { assertEquals ( new ArrayPoly ( new double [ ] { 2 , 6 , 12 } ) , p . derivative ( ) ) ;
getPing: public long getPing ( ) { return ping ;
prepareHttpHeaders: public static HttpHeaders prepareHttpHeaders ( HttpRequestTask task ) { return prepareHttpHeaders ( task . getHeadersMap ( ) ) ;
setMixY: public void setMixY ( float mixY ) { this . mixY = mixY ;
getResponseSerde: public Serde < RES > getResponseSerde ( ) { return responseSerde ;
render: public void render ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ; super . render ( ) ;
toString: public String toString ( ) { return background . getTitle ( ) . get ( ) ;
precisionController: private void precisionController ( ) { UI . uiThreads . add ( new Thread ( ( ) -> { while ( true ) { final boolean [ ] travelling = { false } ; final boolean [ ] sequenceBlock = { autoControl . fasrControl . getSequenceBlock ( ) } ; try { selectedControlRods . forEach ( channel -> { if ( rodsOut . getModel ( ) . isPressed ( ) ) { if ( selectedControlRods . size ( ) > 4 ) { rodLimit . setBackground ( Annunciator . YELLOWON_COLOR ) ; } else { if ( sequenceBlock [ 0 ] ) { if ( channel instanceof FASRChannel ) { if ( channel . getPosition ( ) > 0 ) { channel . setState ( 0 ) ; travelling [ 0 ] = true ; } } else { rodSeq . setBackground ( Annunciator . YELLOWON_COLOR ) ; channel . setState ( 1 ) ; } } else if ( channel . getPosition ( ) > 0 ) { channel . setState ( 0 ) ; travelling [ 0 ] = true ; } } } else if ( rodsIn . getModel ( ) . isPressed ( ) ) { if ( channel . getPosition ( ) < 1 ) { channel . setState ( 2 ) ; travelling [ 0 ] = true ; } } else { channel . setState ( 1 ) ; rodSeq . setBackground ( Annunciator . YELLOWOFF_COLOR ) ; rodLimit . setBackground ( Annunciator . YELLOWOFF_COLOR ) ; } } ) ; if ( travelling [ 0 ] ) { rodTravel . setBackground ( Annunciator . GREENON_COLOR ) ; } else { rodTravel . setBackground ( Annunciator . GREENOFF_COLOR ) ; } if ( ! sequenceBlock [ 0 ] ) { rodSeq . setBackground ( Annunciator . YELLOWOFF_COLOR ) ; } if ( debounce ) { Thread . sleep ( 50 ) ; debounce = false ; } if ( precisionIncrement2 . getModel ( ) . isPressed ( ) ) { precisionIncrement2ActionPerformed ( null ) ; } else if ( precisionDecrement2 . getModel ( ) . isPressed ( ) ) { precisionDecrement2ActionPerformed ( null ) ; } Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; return ; } } } ) ) ; uiThreads . get ( uiThreads . size ( ) - 1 ) . start ( ) ;
getBackground: protected TextureRegion getBackground ( ) { return BrainOutClient . getRegion ( "bg-freeplay" ) ;
addExtraHeight: protected void addExtraHeight ( float extra ) { extraHeight += extra ;
getAttachmentName: public @ Null String getAttachmentName ( ) { return attachmentName ;
intToIp: private static String intToIp ( int i ) { return ( i & 0xFF ) + "." + ( ( i > > 8 ) & 0xFF ) + "." + ( ( i > > 16 ) & 0xFF ) + "." + ( i > > 24 & 0xFF ) ;
getLevelGap: public int getLevelGap ( ) { return levelGap ;
getActiveQuests: public Array < Quest > getActiveQuests ( ) { return activeQuests ;
newAction: protected Action newAction ( ActionType actionType , JSONObject data ) { switch ( actionType )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem1ActionPerformed ( evt ) ;
release: public void release ( ) { if ( mBasePopWindow != null ) {
mav: public Object mav ( HttpServletRequest request ) { return mav ( request , null ) ;
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; AttributeGroup responseEntity = this . api . attributeGroups ( ) . get ( "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/AttributeGroupGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
isHorizontalHighlightIndicatorEnabled: No method body
extractResponse: public < T , R > R extractResponse ( final Response < T > response , final R body ) throws NovuNetworkException , IOException { if ( response . isSuccessful ( ) ) {
getUsingAssetsList: public List < AssetsItem > getUsingAssetsList ( ) { List < AssetsItem > assetsList = new ArrayList < > ( ) ; String sql = "select * from assets where has_balance = 1" ; SQLiteDatabase db = mInstance . getReadableDatabase ( ) ; Cursor cursor = db . rawQuery ( sql , new String [ ] { } ) ; while ( cursor . moveToNext ( ) ) { String propertyId ; int propertyIdIndex = cursor . getColumnIndex ( "property_id" ) ; if ( propertyIdIndex >= 0 ) { propertyId = cursor . getString ( propertyIdIndex ) ; } else { propertyId = "" ; } String token_name ; int tokenNameIndex = cursor . getColumnIndex ( "token_name" ) ; if ( tokenNameIndex >= 0 ) { token_name = cursor . getString ( tokenNameIndex ) ; } else { token_name = "" ; } AssetsItem asset = new AssetsItem ( propertyId , token_name , AssetsItem . ASSET_USING ) ; assetsList . add ( asset ) ; } cursor . close ( ) ; return assetsList ;
getOrganizationRoles: public Map < Long , Set < String > > getOrganizationRoles ( ) { return organizationRoles ;
getProgressTaskKey: private String getProgressTaskKey ( ) { return "prg_" + taskKey ;
getUserId: public String getUserId ( ) { return userId ;
createAnyDeferred: default Deferred < Integer > createAnyDeferred ( List < Deferred < ? > > children ) { return DeferredResults . any (
toAuditString: public String toAuditString ( ) { return null ;
hasRender: public boolean hasRender ( ) { return false ;
conversationUid: public MessageBuilder < JRPCMessage > conversationUid ( final @ NonNull ConversationUID uid ) { this . conversationUID = uid ; return this ;
testUpdateMasterCategories: public void testUpdateMasterCategories ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductUpdateMasterCategoriesRequest.json" ) ; ProductMasterCategories requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , ProductMasterCategories . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ProductMasterCategories responseEntity = this . api . products ( ) . updateMasterCategories ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductUpdateMasterCategoriesResponse.json" ) ; assertThatJson ( expectedResponseJson )
getAttachSlot: protected String getAttachSlot ( ) { switch ( getContentComponent ( ) . getAttachTo ( ) )
show: public void show ( final View view , String address , long assetId , long balanceAccount ) { if ( mBasePopWindow == null ) {
findByName: No method body
received: public boolean received ( final UpdatedComponentMsg msg ) { Gdx . app . postRunnable ( ( ) -> { ClientMap map = Map . Get ( msg . d , ClientMap . class ) ; if ( map == null ) return ; map . updateActiveDataComponent ( msg . id , msg . data , msg . clazz , true ) ; } ) ; return true ;
offsetTop: public float offsetTop ( ) { return mContentRect . top ;
allowZoom: public boolean allowZoom ( ) { return false ;
computePermissions: public static long computePermissions ( long guildMemberId , Channel channel , Channel guildChannel , long ownerId , GuildMember member , Map < Long , GuildRole > roles , Map < Long , StageInstance > stageInstances , boolean hasJoinedInternal ) { return 0 ;
acceptJiraToken: public Object acceptJiraToken ( @ RequestParam ( CODE ) String code , @ RequestParam ( STATE ) Long orgId ) throws Exception { debug ( "[acceptJiraToken]" ) ; integrationService . getJiraToken ( orgId , code ) ; String configUrl = services . url . moduleSettings ( INTEGRATION , null , orgId ) ; return "generic-forms::go-to(url='" + configUrl + "')" ;
insertBeginning: public static long insertBeginning ( List < String > list , String item , int times ) { long begin = System . nanoTime ( ) ; for ( int i = 0 ; i < times ; i ++ ) { list . addFirst ( item ) ; } return System . nanoTime ( ) - begin ;
getVerifyCode: public void getVerifyCode ( String phone ) { this . mPhoneNum = phone ; this . mNeedCountdown = true ; if ( mVerifyImageDialog == null ) { mVerifyImageDialog = new VerifyImageDialog ( getContext ( ) ) ; mVerifyImageDialog . setCallback ( new MyVerifyImageDialogCallback ( ) ) ; } mVerifyImageDialog . show ( String . valueOf ( System . currentTimeMillis ( ) ) ) ;
doLaunch: private void doLaunch ( ) { PlaceAnimationComponentData crc = getComponentObject ( ) . getComponent ( PlaceAnimationComponentData . class ) ; timer = placeBlockData . getPlaceBlock ( ) . getPlaceTime ( ) ; setState ( State . done ) ; switch ( mode ) { case add : { if ( ! place ( placeX , placeY ) ) return ; break ; } case remove : { if ( ! remove ( placeX , placeY , Constants . Layers . BLOCK_LAYER_FOREGROUND ) ) return ; break ; } } BrainOut . EventMgr . sendDelayedEvent ( getComponentObject ( ) , LaunchEffectEvent . obtain ( LaunchEffectEvent . Kind . shoot ,
getX: public float getX ( ) { return 0 ;
setRotation: public void setRotation ( float rotation ) { this . rotation = rotation ;
deleteWorkflowGroup: public DeleteWorkflowGroup deleteWorkflowGroup ( final String id ) throws NovuNetworkException , IOException { return restHandler . extractResponse ( this . workflowGroupApi . deleteWorkflowGroup ( id ) . execute ( ) ) ;
setPlanId: public void setPlanId ( String planId ) { this . planId = planId ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; fileName = jsonData . getString ( "sound" ) ; key = jsonData . getString ( "key" ) ; loop = jsonData . getBoolean ( "loop" , false ) ; soundDistance = jsonData . getFloat ( "distance" , 1.0f ) ; if ( jsonData . has ( "pitch" ) ) { this . pitch = new RandomValue ( 1.0f , 1.0f ) ; pitch . read ( json , jsonData . get ( "pitch" ) ) ; } distantDelay = jsonData . getBoolean ( "distantDelay" , false ) ; delayCheck = jsonData . getFloat ( "delayCheck" , 0.25f ) ;
setBodySize: public void setBodySize ( int bodySize ) { this . bodySize = bodySize ;
stacks: public boolean stacks ( ConsumableItem item ) { if ( isPrivate ( ) && getPrivate ( ) != item . getPrivate ( ) ) return false ; return item instanceof OwnableConsumableItem && ( ( OwnableConsumableItem ) item ) . getContent ( ) == ownableContent ;
testApproximation: public void testApproximation ( ) { float [ ] points = new float [ ] { 10 , 20 , 20 , 30 , 25 , 25 , 30 , 28 , 31 , 31 , 33 , 33 , 40 , 40 , 44 , 40 , 48 , 23 , 50 , 20 , 55 , 20 , 60 , 25 } ; assertEquals ( 24 , points . length ) ; Approximator a = new Approximator ( ) ; float [ ] reduced = a . reduceWithDouglasPeucker ( points , 2 ) ; assertEquals ( 18 , reduced . length ) ;
getComponent: public AnimationComponentData getComponent ( ComponentObject componentObject ) { return new AnimationComponentData ( componentObject , this ) ;
setScale: public void setScale ( float scale ) { if ( scale == 0 ) throw new IllegalArgumentException ( "scale cannot be 0." ) ; this . scale = scale ;
received: public boolean received ( final ServerInfo serverInfo ) { Gdx . app . postRunnable ( ( ) -> { ClientController controller = getController ( ) ; controller . setOwnerKey ( serverInfo . ownerKey ) ; controller . setCurrentPartyId ( serverInfo . partyId ) ; BrainOutClient . PackageMgr . clearDefines ( ) ; for ( ServerInfo . KeyValue define : serverInfo . defines ) { BrainOutClient . PackageMgr . setDefine ( define . name , define . value ) ; } controller . setId ( serverInfo . id ) ; controller . setServerTime ( serverInfo . time ) ; for ( ServerInfo . KeyValue lvl : serverInfo . levels ) { controller . setLevelsName ( lvl . name , lvl . value ) ; } for ( ServerInfo . Price price : serverInfo . prices ) { controller . setPrice ( price . name , price . value ) ; } controller . setMaxPlayers ( serverInfo . maxPlayers ) ; Gdx . app . postRunnable ( ( ) -> controller . setPlayState ( serverInfo . playState , serverInfo . playData ) ) ; sendFriendList ( ) ; if ( serverInfo . preset != null ) { try { Preset preset = new Preset ( ) ; JsonReader reader = new JsonReader ( ) ; JsonValue presetValue = reader . parse ( serverInfo . preset ) ; preset . read ( new Json ( ) , presetValue ) ; controller . setPreset ( preset ) ; } catch ( Exception ignored ) { controller . setPreset ( null ) ; } } else { controller . setPreset ( null ) ; } if ( serverInfo . userProfile != null ) { JSONObject o ; try { byte [ ] data = serverInfo . userProfile ; String decompressed = Compressor . DecompressToString ( data ) ; o = new JSONObject ( decompressed ) ; } catch ( Exception ignored ) { o = null ; } if ( o != null ) { getController ( ) . getUserProfile ( ) . read ( o ) ; BrainOutClient . SocialController . userProfileUpdated ( getController ( ) . getUserProfile ( ) ) ; } } } ) ; return true ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { tgValvesOpen12ItemStateChanged ( evt ) ;
getInterpolation: public float getInterpolation ( float input ) { return - input * ( input - 2f ) ;
onError: public void onError ( Throwable t ) { mEmitter . tryOnError ( t ) ;
getDragState: public DragState getDragState ( ) { return dragState ;
render: public void render ( Data from , Table to ) { Label valueLabel = new Label ( text , BrainOutClient . Skin , "title-small" ) ; valueLabel . setAlignment ( Align . right ) ; to . add ( valueLabel ) . expandX ( ) . fillX ( ) ;
permissionExists: private static boolean permissionExists ( String permission ) { Integer minVersion = MIN_SDK_PERMISSIONS . get ( permission ) ; return minVersion == null || Build . VERSION . SDK_INT >= minVersion ;
setHost: public void setHost ( String host ) { this . host = host ;
handleFilesystemWrite: private File handleFilesystemWrite ( Long orgId , String uuid , String fileName , long totalFileSize , String originalFilename , InputStream inputStream , File f , String mimeType , StorageType actualStorageType ) { String targetFileName = prepareStoredFileName ( orgId , uuid , fileName ) ; var ioResult = tryIOOperation ( ( ) -> { try ( FileOutputStream fileOnDisk = new FileOutputStream ( targetFileName ) ) { IOUtils . copy ( inputStream , fileOnDisk ) ; } } ) ; if ( ! ioResult ) { error ( "[saveAndPrepareFileEntity] Error while attempting to write [{}, {}, {}] [{}]" , orgId , uuid , fileName , targetFileName ) ; if ( writableFailoverStoreageFilesystem ) { String failoverPath = targetFileName . replaceFirst ( storageFilesystemPath , failoverStorageFilesystemPath ) ; ioResult = tryIOOperation ( ( ) -> { try ( FileOutputStream fileOnDisk = new FileOutputStream ( failoverPath ) ) { IOUtils . copy ( inputStream , fileOnDisk ) ; } } ) ; if ( ! ioResult ) { error ( "[saveAndPrepareFileEntity] Error while attempting to write to failover path [{}, {}, {}] [{}]}" , orgId , uuid , fileName , targetFileName ) ; } } } if ( ioResult ) { f = new File ( orgId , originalFilename , mimeType , totalFileSize , uuid , actualStorageType , targetFileName ) ; } return f ;
compileReplacement: private ClassReader compileReplacement ( MethodNode mn ) { try {
gotOwnable: public void gotOwnable ( OwnableContent ownableContent , String reason , ClientProfile . OnwAction ownAction , int amount ) { gotOwnable ( ownableContent , reason , ownAction , amount , true ) ;
setUseValueColorForLine: public void setUseValueColorForLine ( boolean enabled ) { mUseValueColorForLine = enabled ;
hasRender: public boolean hasRender ( ) { return false ;
getServerSyncedTime: public static long getServerSyncedTime ( ) { try {
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ColumnType that = ( ColumnType ) o ; return Arrays . equals ( inSQL , that . inSQL ) && Objects . equals ( inJava , that . inJava ) && Objects . equals ( inJavaWithPackage , that . inJavaWithPackage ) && Objects . equals ( inJBDCSet , that . inJBDCSet ) && Objects . equals ( inJBDCGet , that . inJBDCGet ) ;
putAmmo: public void putAmmo ( int amount , Bullet bullet , int quality ) { if ( bullet != null )
renderShape: private void renderShape ( Table panel , ButtonGroup < ImageButton > shapeGroup , Shape shape , String icon , String title ) { final ImageButton button = new ImageButton ( BrainOutClient . Skin , icon ) ; Tooltip . RegisterToolTip ( button , L . get ( title ) , getMenu ( ) ) ; if ( getCurrentShape ( ) == shape ) button . setChecked ( true ) ; button . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( Menu . MenuSound . select ) ; setCurrentShape ( shape ) ; } } ) ; panel . add ( button ) ; shapeGroup . add ( button ) ;
onSingleTap: No method body
delete: public void delete ( List < ProductSorting > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/product-sortings" ) , query , null , null , model ) ;
obtain: public static Event obtain ( Kind kind , LaunchData launchData ) { LaunchEffectEvent e = obtain ( LaunchEffectEvent . class ) ; if ( e == null ) return null ; return e . init ( kind , launchData ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
mybatisVersion: private static String mybatisVersion ( ) { try {
obtain: public static Event obtain ( Bullet bullet , int ownerId , Bullet . BulletSlot slot , float x , float y , float angles [ ] , boolean silent ) { LaunchBulletEvent e = obtain ( LaunchBulletEvent . class ) ; if ( e == null ) return null ; return e . init ( bullet , ownerId , slot , x , y , angles , silent ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case newRemoteClient : { NewRemoteClientEvent e = ( ( NewRemoteClientEvent ) event ) ; newRemoteClient ( e . remoteClient ) ; break ; } case remoteClientUpdated : { RemoteClientUpdatedEvent e = ( ( RemoteClientUpdatedEvent ) event ) ; if ( e . remoteClient != null && e . remoteClient . getId ( ) == playerData . getOwnerId ( ) ) { updateTeam ( ) ; } break ; } case voice : { voice ( ) ; break ; } case componentUpdated : { componentUpdated ( ) ; break ; } case gameController : { GameControllerEvent gcEvent = ( ( GameControllerEvent ) event ) ; switch ( gcEvent . action ) { case hideInterface : { if ( nickName != null ) nickName . setVisible ( ! gcEvent . flag ) ; if ( teamIcon != null ) teamIcon . setVisible ( ! gcEvent . flag ) ; if ( voiceIcon != null ) voiceIcon . setVisible ( ! gcEvent . flag ) ; } } break ; } } return super . onEvent ( event ) ;
show: public void show ( ) { if ( mAlertDialog == null ) { mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme_loading ) . setContentView ( com . omni . wallet . framelibrary . R . layout . layout_dialog_loading ) . setCanceledOnTouchOutside ( false ) . setCancelable ( mCancelable ) . setOnDismissListener ( mDismissListener ) . create ( ) ; } ImageView waitingIcon = mAlertDialog . getViewById ( R . id . iv_dialog_loading ) ; if ( ! mAlertDialog . isShowing ( ) ) { mAlertDialog . show ( ) ; } waitingIcon . setLayerType ( View . LAYER_TYPE_HARDWARE , null ) ; mRotationAnimator = ObjectAnimator . ofFloat ( waitingIcon , "rotation" , 0 , 359f ) ; mRotationAnimator . setInterpolator ( new LinearInterpolator ( ) ) ; mRotationAnimator . setDuration ( 4000 ) ; mRotationAnimator . setRepeatCount ( ObjectAnimator . INFINITE ) ; mRotationAnimator . start ( ) ;
readTask: protected void readTask ( JsonValue jsonData ) { String itemName = jsonData . getString ( "item" ) ; item = BrainOut . ContentMgr . get ( itemName , ConsumableContent . class ) ;
getLayout: public String getLayout ( ) { return layout ;
cosDeg: public static float cosDeg ( float degrees ) { return ( float ) Math . cos ( degrees * degRad ) ;
getCard: public CardData getCard ( CaseData caseData , String dimension ) { return new ContentCardData ( this , caseData , dimension ) ;
getModuleForName: public Module getModuleForName ( @ NotNull String moduleName ) { return modulesByName . get ( moduleName ) ;
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { json . writeValue ( "tickets" , tickets ) ; json . writeValue ( "intickets" , initialTickets ) ; super . write ( json , componentWriter , owner ) ;
getMode: public Mode getMode ( ) { return mode ;
getSpriteName: public String getSpriteName ( ) { return spriteName ;
purchase: private void purchase ( ) { if ( ! BrainOutClient . Env . storeEnabled ( ) ) return ; JSONObject offlinePrice = item . getPublicPayload ( ) . optJSONObject ( "offline-price" ) ; if ( offlinePrice != null ) { purchaseOffline ( ) ; return ; } Store . Tier . Price price = getPrice ( ) ; if ( price == null ) { return ; } String component = BrainOutClient . Env . getStoreComponent ( ) ; String store = item . getStore ( ) . getName ( ) ; String currency = price . getCurrency ( ) ; String itemName = item . getId ( ) ; HashMap < String , String > env = new HashMap < > ( ) ; BrainOutClient . Env . getStoreEnvironment ( env ) ; BrainOutClient . ClientController . createNewOrder ( store , itemName , amount , currency , component , env ) ; pushMenu ( new NewOrderResultMenu ( "" )
failed: public static < T > CommonResult < T > failed ( T data ) { return new CommonResult < T > ( HttpStatus . ERROR , "调用失败！" , data ) ;
getV5: public Object getV5 ( ) { return list [ 5 ] ; }
setDbLogStatement: public void setDbLogStatement ( String dbLogStatement ) { this . dbLogStatement = dbLogStatement ;
removeFooterView: public void removeFooterView ( View view ) { int index = mFooterViews . indexOfValue ( view ) ; if ( index < 0 ) return ; mFooterViews . removeAt ( index ) ; notifyDataSetChanged ( ) ;
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . campaigns ( ) . delete ( "acme" , 1 , options ) ;
initView: protected void initView ( ) { initRecyclerView ( ) ;
toBufferedImage: public static BufferedImage toBufferedImage ( java . awt . Image img ) { if ( img instanceof BufferedImage ) { return ( BufferedImage ) img ; } BufferedImage bimage = new BufferedImage ( img . getWidth ( null ) , img . getHeight ( null ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D bGr = bimage . createGraphics ( ) ; bGr . drawImage ( img , 0 , 0 , null ) ; bGr . dispose ( ) ; return bimage ;
setTextColor: public void setTextColor ( int color ) { mTextColor = color ;
cancel: No method body
GetDefaultCurrency: private static String GetDefaultCurrency ( ) { return BrainOutClient . Env . getDefaultCurrency ( ) ;
run: public void run ( ) { int lastElement = 0 ; while ( ! isInterrupted ( ) ) { try { synchronized ( integerDeque ) { lastElement = integerDeque . removeLast ( ) ; } } catch ( NoSuchElementException e ) { Thread . yield ( ) ; } } System . out . printf ( "Total number of consumed elements: %d" , lastElement ) ;
onTimeout: public Conversation < TRequest , TResponse > onTimeout ( final BiConsumer < TRequest , Set < MessageContext < TResponse > > > timeoutHandler ) { this . timeoutHandler = timeoutHandler ; return this ;
shuffle: private void shuffle ( ) { queue . clear ( ) ; for ( SetItem item : sets ) { if ( forceMode != null ) { if ( ! item . modesList . contains ( forceMode , false ) ) continue ; } if ( ! item . valid ( ) ) { continue ; } queue . add ( new QueuedItem ( item ) ) ; } if ( rotary == Rotary . random )
renderAxisLabels: public void renderAxisLabels ( Canvas c ) { if ( ! mXAxis . isEnabled ( ) || ! mXAxis . isDrawLabelsEnabled ( ) ) return ; float yoffset = mXAxis . getYOffset ( ) ; mAxisLabelPaint . setTypeface ( mXAxis . getTypeface ( ) ) ; mAxisLabelPaint . setTextSize ( mXAxis . getTextSize ( ) ) ; mAxisLabelPaint . setColor ( mXAxis . getTextColor ( ) ) ; MPPointF pointF = MPPointF . getInstance ( 0 , 0 ) ; if ( mXAxis . getPosition ( ) == XAxisPosition . TOP ) { pointF . x = 0.5f ; pointF . y = 1.0f ; drawLabels ( c , mViewPortHandler . contentTop ( ) - yoffset , pointF ) ; } else if ( mXAxis . getPosition ( ) == XAxisPosition . TOP_INSIDE ) { pointF . x = 0.5f ; pointF . y = 1.0f ; drawLabels ( c , mViewPortHandler . contentTop ( ) + yoffset + mXAxis . mLabelRotatedHeight , pointF ) ; } else if ( mXAxis . getPosition ( ) == XAxisPosition . BOTTOM ) { pointF . x = 0.5f ; pointF . y = 0.0f ; drawLabels ( c , mViewPortHandler . contentBottom ( ) + yoffset , pointF ) ; } else if ( mXAxis . getPosition ( ) == XAxisPosition . BOTTOM_INSIDE ) { pointF . x = 0.5f ; pointF . y = 0.0f ; drawLabels ( c , mViewPortHandler . contentBottom ( ) - yoffset - mXAxis . mLabelRotatedHeight , pointF ) ; } else { pointF . x = 0.5f ; pointF . y = 1.0f ; drawLabels ( c , mViewPortHandler . contentTop ( ) - yoffset , pointF ) ; pointF . x = 0.5f ; pointF . y = 0.0f ; drawLabels ( c , mViewPortHandler . contentBottom ( ) + yoffset , pointF ) ; } MPPointF . recycleInstance ( pointF ) ;
isKarmaQuestTarget: private boolean isKarmaQuestTarget ( ) { RemoteClient o = BrainOutClient . ClientController . getRemoteClients ( ) . get ( playerData . getOwnerId ( ) ) ; RemoteClient me = BrainOutClient . ClientController . getMyRemoteClient ( ) ; if ( o == null || me == null ) return false ; if ( o . getInfoBoolean ( "bot" , false ) ) return false ; DailyQuest c = BrainOutClient . ContentMgr . get ( "quest-daily-kill" , DailyQuest . class ) ; if ( c == null ) return false ; if ( c . isComplete ( BrainOutClient . ClientController . getUserProfile ( ) , BrainOutClient . ClientController . getMyAccount ( ) ) ) { return false ; } int karma = o . getInfoInt ( "karma" , 0 ) ; int myKarma = me . getInfoInt ( "karma" , 0 ) ; if ( karma > 1 && myKarma < - 1 ) { return true ; } return karma < - 1 && myKarma > 1 ;
getTarget: No method body
updateTransform: public void updateTransform ( ) { try { state . apply ( skeleton ) ; } catch ( NullPointerException | ArrayIndexOutOfBoundsException e ) { } skeleton . updateWorldTransform ( ) ;
doResetAndHold: public void doResetAndHold ( boolean resetHandAnimations ) { onReset ( resetHandAnimations ) ; setState ( State . fetchWait ) ;
getClasses: public static Class < ? > [ ] getClasses ( String [ ] classNames ) { try { if ( classNames != null ) { List < Class < ? > > classes = new ArrayList < > ( ) ; for ( String cs : classNames ) { classes . add ( Class . forName ( cs ) ) ; } return classes . toArray ( new Class [ 0 ] ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } return ( Class < ? > [ ] ) new Class [ 0 ] ;
e: public User e ( ) { return null ; }
setNetwork: public void setNetwork ( Context context , String network ) { PreferencesUtils . saveNetworkToLocal ( context , network ) ; this . network = network ;
getBadgeId: public String getBadgeId ( ) { return "trophy-" + index ;
updateSteamOutflow: public void updateSteamOutflow ( double flow , double tempC ) { throw new UnsupportedOperationException ( "Unimplemented method 'updateSteamOutflow'" ) ;
getGamepadSensitivity: public float getGamepadSensitivity ( ) { float f = gamepadSensitivity . getFloatValue ( ) ; return 0.5f + f ;
list: public CommonResult < CommonPage < Resource > > list ( @ RequestBody @ Valid ResourcePageListParam param ) { List < Resource > listPage = resourceService . getResourceListPage ( param . getPageNum ( ) , param . getPageSize ( ) , param . getQueryKey ( ) ) ; return CommonResult . success ( CommonPage . restPage ( listPage ) ) ;
write: public void write ( Json json ) { if ( elevator != null ) json . writeValue ( "elevator" , elevator ) ; if ( doorPortal != null ) json . writeValue ( "door-portal" , doorPortal ) ; if ( doorAnimation != null ) json . writeValue ( "door-animation" , doorAnimation ) ; if ( buttonSprite != null )
returnAwakeableId: No method body
write: public void write ( Json json ) { json . writeValue ( "du" , durability ) ;
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/PromotionCreateRequest.json" ) ; Promotion requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Promotion . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Promotion responseEntity = this . api . promotions ( ) . create ( requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/PromotionCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
attachTo: No method body
getAngle: public float getAngle ( ) { return activeData . getAngle ( ) ;
getObject: public InputStream getObject ( @ NonNull String bucketName , @ NonNull String objectName ) { GetObjectArgs getObjectArgs = GetObjectArgs . builder ( ) . bucket ( bucketName ) . object ( ossProperties . getMinio ( ) . getPrefix ( ) + objectName ) . build ( ) ; try {
getTeam: public Team getTeam ( ) { return team ;
giveBackGroupRequestPayment: private void giveBackGroupRequestPayment ( ) { String currency = Constants . Clans . CURRENCY_JOIN_CLAN ; float amount = BrainOutServer . Settings . getPrice ( "joinClan" ) ; if ( amount > 0 )
validate: protected boolean validate ( ActiveData activeData ) { return true ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fill ;
setCollided: public void setCollided ( boolean collided ) { this . collided = collided ;
getWritePrivilege: public String getWritePrivilege ( ) { return writePrivilege ;
success: public void success ( String roomId ) { BrainOutClient . Env . setCurrentRoom ( roomId ) ;
getInstance: public static JdkFileWatchService getInstance ( ) { return instance ;
check: private void check ( ) { if ( getMode ( ) == null ) return ; final ServerRealization serverRealization = ( ( ServerRealization ) getMode ( ) . getRealization ( ) ) ; serverRealization . check ( ) ; if ( getMode ( ) . getEndTime ( ) != 0 ) { long now = System . currentTimeMillis ( ) / 1000L ; if ( now > getMode ( ) . getEndTime ( ) ) { serverRealization . timedOut ( gameResult ) ; getMode ( ) . setPhase ( GameMode . Phase . finished ) ; finishedTimer = BrainOutServer . Settings . getModeDelay ( ) ; BrainOutServer . PostRunnable ( ( ) -> { if ( serverRealization . hasFinishedTimer ( ) ) { BrainOutServer . Controller . getClients ( ) . sendTCP ( new ModeWillFinishInMsg ( finishedTimer ) ) ; } serverRealization . finished ( ) ; } ) ; return ; } } if ( serverRealization . isComplete ( gameResult ) )
awaitAll: protected TestInvocationBuilder awaitAll ( ) { return testDefinitionForService (
getName: public String getName ( ) { return name ;
setValueTypeface: public void setValueTypeface ( Typeface tf ) { for ( IDataSet set : mDataSets ) {
run: public void run ( ) { BrainOutClient . ClientController . setState ( new CSError ( L . get ( "MENU_FAILED_TO_CONNECT" ) ,
getExperiments: public static StoreExperiments getExperiments ( ) { return new StoreExperiments ( ) ;
main: public static void main ( String [ ] args ) { int count = 987 ; int hexaVal = 0x7e4 ; int binary = 0b11010 ; int octalVal = 067 ; float floatVal = 4534.99F ; double cost = 19765.567D ; char alpha = 'p' ; char ch1 = '!' ; char ch2 = 65 ; String str = "Java" ; String name = null ; boolean boolVal = true ; System . out . println ( count ) ; System . out . println ( hexaVal ) ; System . out . println ( binary ) ; System . out . println ( octalVal ) ; System . out . println ( floatVal ) ; System . out . println ( cost ) ; System . out . println ( alpha ) ; System . out . println ( ch1 ) ; System . out . println ( ch2 ) ; System . out . println ( str ) ; System . out . println ( name ) ; System . out . println ( boolVal ) ;
threadInterrupt: public Object threadInterrupt ( @ PathVariable ( ID ) Long threadId ) { debug ( "[threadInterrupt]" ) ; return interruptThread ( threadId )
menuIsOpen: public void menuIsOpen ( boolean isOpen ) { if ( ! isOpen ) {
setCached: public void setCached ( T cached ) { this . cached = cached ;
getBlueprint: public Blueprint getBlueprint ( final String templateId ) throws IOException , NovuNetworkException { Response < Blueprint > response = blueprintsApi . getBlueprint ( templateId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
postRender: public void postRender ( ) { super . postRender ( ) ; if ( noise != null )
saveTouchStart: private void saveTouchStart ( MotionEvent event ) { mSavedMatrix . set ( mMatrix ) ; mTouchStartPoint . x = event . getX ( ) ; mTouchStartPoint . y = event . getY ( ) ; mClosestDataSetToTouch = mChart . getDataSetByTouchPoint ( event . getX ( ) , event . getY ( ) ) ;
getFills: No method body
renderInstrument: protected void renderInstrument ( Table renderTo , Instrument instrument , Skin skin , CardData cardData ) { PartialInstrumentCardData contentCardData = ( ( PartialInstrumentCardData ) cardData ) ; ContentLockTree . LockItem lockItem = contentCardData . getCardContent ( ) . getLockItem ( ) ; Shader grayShader = ( ( Shader ) BrainOut . ContentMgr . get ( "shader-grayed" ) ) ; Shader blackShader = ( ( Shader ) BrainOut . ContentMgr . get ( "shader-black" ) ) ; InstrumentInfo info = new InstrumentInfo ( ) ; info . instrument = instrument ; info . skin = skin ; float scale ; InstrumentAnimationComponent iac = instrument . getComponentFrom ( InstrumentAnimationComponent . class ) ; if ( iac != null ) { scale = iac . getIconScale ( ) ; } else { scale = 1.0f ; } InstrumentIcon instrumentIcon = new InstrumentIcon ( info , 2.0f * scale , true ) ; instrumentIcon . setBounds ( 0 , 4 , 192 , 64 ) ; instrumentIcon . init ( ) ; InstrumentIcon shadow = new InstrumentIcon ( info , 2.0f * scale , true ) ; shadow . setBounds ( 0 , 0 , 192 , 64 ) ; shadow . init ( ) ; ShaderedActor shadowShader = new ShaderedActor ( shadow , blackShader ) ; WidgetGroup root = new WidgetGroup ( ) ; root . addActor ( shadowShader ) ; if ( lockItem != null ) { PartialShaderedActor sh = new PartialShaderedActor ( instrumentIcon , grayShader , contentCardData . getParts ( ) , lockItem . getParam ( ) ) ; root . addActor ( sh ) ; } else { root . addActor ( instrumentIcon ) ; } renderTo . add ( root ) . size ( 196 , 68 ) . expand ( ) . row ( ) ;
getClosestHighlight: protected Highlight getClosestHighlight ( int index , float x , float y ) { IPieDataSet set = mChart . getData ( ) . getDataSet ( ) ; final Entry entry = set . getEntryForIndex ( index ) ; return new Highlight ( index , entry . getY ( ) , x , y , 0 , set . getAxisDependency ( ) ) ;
stayOnTop: public boolean stayOnTop ( ) { return onTop ;
update: public Redirect update ( String shopKey , Integer redirectId , Redirect model ) throws ApiErrorException , ConnectionException { Class < Redirect > responseModel = ( Class < Redirect > ) ( Class < ? > ) Redirect . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/redirects/%s" , shopKey , redirectId ) , null , null , responseModel , model ) ;
byte2HexLowerCase: public static String byte2HexLowerCase ( byte [ ] bytes ) { return byte2Hex ( bytes ) . toLowerCase ( ) ;
onSingleClick: No method body
getStream: private static InputStream getStream ( Context context , String assetsFileName ) { try {
init: private Event init ( Status code ) { this . code = code ; return this ;
validate: public RoleForm validate ( BindingResult br ) { if ( isBlank ( dto . name ) ) { br . rejectValue ( "dto.name" , "not.empty" ) ; } if ( isBlank ( dto . type ) ) { br . rejectValue ( "dto.type" , "not.empty" ) ; } return this ;
drawCircleBorder: private void drawCircleBorder ( Canvas canvas , int radius , int color ) { Paint paint = new Paint ( ) ; paint . setAntiAlias ( true ) ; paint . setFilterBitmap ( true ) ; paint . setDither ( true ) ; paint . setColor ( color ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeWidth ( mBorderThickness ) ; canvas . drawCircle ( defaultWidth / 2 , defaultHeight / 2 , radius , paint ) ;
setUserJob: public void setUserJob ( String userJob ) { this . userJob = userJob ;
getMixX: public float getMixX ( ) { return mixX ;
createNewRoleByTypeOrgTest: public void createNewRoleByTypeOrgTest ( ) { OrganizationRole role = new OrganizationRole ( ) ; mockAndAuthenticateUser ( 1l , "test@openkoda.com" , "TEST" , "(canManageBackend)" ) ; Mockito . when ( globalRoleRepository . findByName ( anyString ( ) ) ) . thenReturn ( null ) ; Mockito . when ( organizationRoleRepository . findByName ( anyString ( ) ) ) . thenReturn ( role ) ; Role result = roleService . createRole ( ROLE_NAME , RoleService . ROLE_TYPE_ORG , ROLE_PRIVILEGES_EMPTY ) ; assertNotNull ( result ) ;
formatAsSatoshiDisplayAmount: private String formatAsSatoshiDisplayAmount ( long value ) { Locale loc = mContext . getResources ( ) . getConfiguration ( ) . locale ; NumberFormat nf = NumberFormat . getNumberInstance ( loc ) ; DecimalFormat df = ( DecimalFormat ) nf ; df . setMinimumIntegerDigits ( 1 ) ; df . setMaximumIntegerDigits ( 16 ) ; return df . format ( value ) ;
setValueLineColor: public void setValueLineColor ( int valueLineColor ) { this . mValueLineColor = valueLineColor ;
release: public void release ( ) { super . release ( ) ; if ( effectData != null )
closeLoading: public static void closeLoading ( LoadingDialog loadingDialog ) { if ( loadingDialog . isShowing ( ) ) {
isInsideSideEffect: public boolean isInsideSideEffect ( ) { return this . stateMachine . isInsideSideEffect ( ) ;
getName: public String getName ( ) { return name ;
getY: public float getY ( ) { return flagData . getY ( ) + 0.25f * ( float ) Math . cos ( ( double ) counter * 8f ) ;
getGreetings: public String getGreetings ( ) { return greetings ;
getHookedInstrumentRecord: public ConsumableRecord getHookedInstrumentRecord ( ) { return hookedInstrument ;
getFormSize: No method body
isContact: public boolean isContact ( BlockData . ContactPayload payload , float x , float y , Vector2 speed , Vector2 impulse , BlockData blockData , Map map , int blockX , int blockY , Vector2 moveForce , float reduce ) { if ( payload instanceof SimplePhysicsComponentData . PhysicsPayload ) { SimplePhysicsComponentData . PhysicsPayload p = ( ( SimplePhysicsComponentData . PhysicsPayload ) payload ) ; BlockTeamComponent teamComponent = blockData . getCreator ( ) . getComponent ( BlockTeamComponent . class ) ; if ( teamComponent != null ) { if ( teamComponent . getTeam ( ) == p . activeData . getTeam ( ) ) { return false ; } } return isContactBox ( x , y , speed , impulse , 0 , 0 , 1f , 1f , moveForce , reduce ) ; } return false ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { waterInVClose4ItemStateChanged ( evt ) ;
tryResolve: boolean tryResolve ( int newResolvedSingle ) { if ( this . isCompleted ( ) ) { return true ; } SingleDeferredInternal < ? > resolvedSingle = this . unresolvedSingles . remove ( newResolvedSingle ) ; if ( resolvedSingle != null ) { if ( ! resolvedSingle . toResult ( ) . isSuccess ( ) ) { this . resolve ( ( Result < Void > ) resolvedSingle . toResult ( ) ) ; return true ; } } Iterator < CombinatorDeferred < ? > > it = this . unresolvedCombinators . iterator ( ) ; while ( it . hasNext ( ) ) { CombinatorDeferred < ? > combinator = it . next ( ) ; if ( combinator . tryResolve ( newResolvedSingle ) ) { it . remove ( ) ; if ( ! combinator . toResult ( ) . isSuccess ( ) ) { this . resolve ( ( Result < Void > ) combinator . toResult ( ) ) ; return true ; } } } if ( this . unresolvedSingles . isEmpty ( ) && this . unresolvedCombinators . isEmpty ( ) ) { this . resolve ( Result . empty ( ) ) ; return true ; } return false ;
getBestPlayerTeam: public Team getBestPlayerTeam ( ) { Team bestTeam = null ; int max = 0 ; for ( ObjectMap . Entry < Team , Array < Client > > clients : teams ) { if ( clients . key instanceof SpectatorTeam ) { continue ; } int cnt = 0 ; for ( Client client : clients . value ) { if ( client instanceof PlayerClient ) { cnt ++ ; } } if ( max < cnt ) { max = cnt ; bestTeam = clients . key ; } } return bestTeam ;
getBoneIndex: public int getBoneIndex ( ) { return boneIndex ;
setFirstName: public void setFirstName ( String firstName ) { this . firstName = firstName ;
prepareBarHighlight: protected void prepareBarHighlight ( float x , float y1 , float y2 , float barWidthHalf , Transformer trans ) { float left = x - barWidthHalf ; float right = x + barWidthHalf ; float top = y1 ; float bottom = y2 ; mBarRect . set ( left , top , right , bottom ) ; trans . rectToPixelPhase ( mBarRect , mAnimator . getPhaseY ( ) ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { exchangeRU ( ) ;
start: boolean start ( ) { this . client = new JRPCClient ( plugin . getDataFolder ( ) . getPath ( ) , false ) ; this . messageProcessor = new DefaultMessageProcessor ( this . client ) ; try {
testRunSpecificId: void testRunSpecificId ( ) throws URISyntaxException { WriteDocumentsToElasticsearchIndexChain writeChain = new WriteDocumentsToElasticsearchIndexChain ( "my-index" , RestClient . builder ( new HttpHost ( "localhost" , 9200 ) ) , new ObjectMapper ( ) , doc -> Base64 . getEncoder ( ) . encodeToString ( doc . get ( PromptConstants . SOURCE ) . getBytes ( ) ) ) ; Chain < Path , Void > fillElasticsearchIndexChain = new ReadDocumentsFromPdfChain ( ) . chain ( writeChain ) ; Path pdfDirectoryPath = Paths . get ( WriteDocumentsToElasticsearchIndexChainIT . class . getResource ( "/pdf/qa" ) . toURI ( ) ) ; fillElasticsearchIndexChain . run ( pdfDirectoryPath ) ;
dragStop: public void dragStop ( InputEvent event , float x , float y , int pointer , DragAndDrop . Payload payload , DragAndDrop . Target target ) { CardPayload p = ( ( CardPayload ) payload ) ; if ( target == null )
isBackupEvent: private boolean isBackupEvent ( ScheduledSchedulerDto eventParameter ) { return eventParameter != null && eventParameter . eventData . toLowerCase ( ) . equals ( BACKUP ) ;
remove: public void remove ( Object o ) { for ( int i = 0 ; i < size ; i ++ ) {
release: public void release ( ) { Array < ConsumableRecord > toRemove = new Array < ConsumableRecord > ( ) ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : data ) { toRemove . add ( entry . value ) ; } for ( ConsumableRecord id : toRemove )
getX: public float getX ( ) { return launchData . getX ( ) ;
getCurrentLastMessageId: public static Long getCurrentLastMessageId ( ) { if ( StoreStream . getChat ( ) . getInteractionState ( ) == null ) return null ; return StoreStream . getChat ( ) . getInteractionState ( ) . getLastMessageId ( ) ;
toString: public String toString ( ) { return this . name ;
drawExterior: private void drawExterior ( Canvas canvas , Rect frame , int width , int height ) { paint . setColor ( maskColor ) ; canvas . drawRect ( 0 , 0 , width , frame . top , paint ) ; canvas . drawRect ( 0 , frame . top , frame . left , frame . bottom + 1 , paint ) ; canvas . drawRect ( frame . right + 1 , frame . top , width , frame . bottom + 1 , paint ) ; canvas . drawRect ( 0 , frame . bottom + 1 , width , height , paint ) ;
start: public void start ( ) { startTime = System . nanoTime ( ) ;
validateColumnTypes: public Boolean validateColumnTypes ( String tableName , Map < String , FrontendMappingFieldDefinition > columns , StringBuilder validationLog , StringBuilder updateDatabaseScript ) { debug ( "[validateColumnTypes]" ) ; boolean validationSuccess = true ; if ( isNotBlank ( tableName ) ) { try { Map < String , String > tableColumns = getTableColumns ( tableName ) ; if ( tableColumns . isEmpty ( ) ) { validationLog . append ( String . format ( "Table %s does not exist. Will be created on form import.\r\n" , tableName ) ) ; } for ( Map . Entry < String , FrontendMappingFieldDefinition > column : columns . entrySet ( ) . stream ( ) . filter ( e -> e . getValue ( ) . getType ( ) != FieldType . files ) . collect ( toSet ( ) ) ) { String columnName = toColumnName ( column . getKey ( ) ) ; if ( ! tableColumns . containsKey ( columnName ) ) { validationLog . append ( String . format ( "Column %s not present in table %s\r\n" , columnName , tableName ) ) ; updateDatabaseScript . append ( String . format ( "ALTER TABLE %s ADD COLUMN IF NOT EXISTS %s %s;\r\n" , tableName , columnName , column . getValue ( ) . getType ( ) . getDbType ( ) . getValue ( ) ) ) ; FieldType columnFieldType = column . getValue ( ) . getType ( ) ; if ( columnFieldType . equals ( FieldType . organization_select ) ) { updateDatabaseScript . append ( String . format ( "alter table %s add constraint %s foreign key (%s) references %s(%s);\r\n" , tableName , "fk_" + columnName , columnName , "organization" , "id" ) ) ; } } else if ( ! column . getValue ( ) . getType ( ) . getDbType ( ) . getColumnType ( ) . equals ( tableColumns . get ( columnName ) ) ) { validationSuccess = false ; validationLog . append ( String . format ( "Table %s column %s type %s does not match db state (%s)\r\n" , tableName , columnName , column . getValue ( ) . getType ( ) . getDbType ( ) . getColumnType ( ) , tableColumns . get ( columnName ) ) ) ; } } } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } return validationSuccess ;
quitSynchronously: public void quitSynchronously ( ) { state = State . DONE ; cameraManager . stopPreview ( ) ; Message quit = Message . obtain ( decodeThread . getHandler ( ) , R . id . quit ) ; quit . sendToTarget ( ) ; try { decodeThread . join ( 500L ) ; } catch ( InterruptedException e ) { } removeMessages ( R . id . decode_succeeded ) ; removeMessages ( R . id . decode_failed ) ;
copyAndReverse: private List < String > copyAndReverse ( List < String > sentence ) { List < String > reversed = new ArrayList < > ( sentence ) ; Reverse . reverse ( reversed ) ; return reversed ;
hasPrivileges: public boolean hasPrivileges ( ) { return privileges != null ;
throwIllegalStateException: protected TestInvocationBuilder throwIllegalStateException ( ) { return testDefinitionForService (
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case earn : { if ( isAlreadyEarned ) return false ; EarnEvent earnEvent = ( ( EarnEvent ) event ) ; Client client = BrainOutServer . Controller . getClients ( ) . get ( earnEvent . playerData . getOwnerId ( ) ) ; return earn ( client ) ; } } return false ;
gotBlocksInOurWay: private void gotBlocksInOurWay ( Queue < WayPointMap . BlockCoordinates > blocks ) { if ( getStack ( ) . getTasks ( ) . size > 0 && getStack ( ) . getTasks ( ) . last ( ) instanceof TaskDestroyBlocks ) return ; pushTask ( new TaskDestroyBlocks ( getStack ( ) , blocks ) ) ;
getY: public float getY ( ) { return getGenerator ( ) . getY ( ) ;
received: public boolean received ( final Editor2ActiveAddMsg msg ) { String id = msg . id ; float x = msg . x , y = msg . y ; Map map = Map . Get ( msg . d ) ; if ( map == null ) return true ; BrainOutServer . PostRunnable ( ( ) -> { Active active = ( ( Active ) BrainOut . ContentMgr . get ( id ) ) ; if ( active != null ) { Editor2EnabledComponent cmp = active . getComponent ( Editor2EnabledComponent . class ) ; if ( cmp == null ) return ; ActiveData activeData = active . getData ( map . getDimension ( ) ) ; activeData . setLayer ( cmp . getLayer ( ) ) ; activeData . setPosition ( x , y ) ; map . addActive ( map . generateServerId ( ) , activeData , true ) ; } } ) ; return true ;
getUserJob: public String getUserJob ( Context context ) { userJob = PreferencesUtils . getUserJobFromLocal ( context ) ; return userJob ;
isUnsubscribed: public boolean isUnsubscribed ( ) { return false ; }
emptyInputOutput: public void emptyInputOutput ( Context context ) { var client = EmptyClient . fromContext ( context ) ; client . emptyInputOutput ( ) . await ( ) ;
releaseWebView: public void releaseWebView ( ) { if ( mWebView != null ) { LogUtils . e ( TAG , "WebView被释放===>" ) ; ViewParent parent = mWebView . getParent ( ) ; if ( parent != null ) { ( ( ViewGroup ) parent ) . removeView ( mWebView ) ; } mWebView . stopLoading ( ) ; mWebView . getSettings ( ) . setJavaScriptEnabled ( false ) ; mWebView . clearHistory ( ) ; mWebView . loadUrl ( "about:blank" ) ; mWebView . removeAllViews ( ) ; mWebView . destroy ( ) ; } if ( mWebViewLoadUtils != null ) {
selected: public void selected ( ) { cutterEnabled = false ; if ( currentBlock == null )
decode: public static byte [ ] decode ( byte [ ] in , int len ) { int length = len / 4 * 3 ; if ( length == 0 ) { return new byte [ ] { } ; } byte [ ] out = new byte [ length ] ; int pad = 0 ; byte chr ; for ( ; ; len -- ) { chr = in [ len - 1 ] ; if ( ( chr == '\n' ) || ( chr == '\r' ) || ( chr == ' ' ) || ( chr == '\t' ) ) { continue ; } if ( chr == '=' ) { pad ++ ; } else { break ; } } int outIndex = 0 ; int inIndex = 0 ; int bits = 0 ; int quantum = 0 ; for ( int i = 0 ; i < len ; i ++ ) { chr = in [ i ] ; if ( ( chr == '\n' ) || ( chr == '\r' ) || ( chr == ' ' ) || ( chr == '\t' ) ) { continue ; } if ( ( chr >= 'A' ) && ( chr <= 'Z' ) ) { bits = chr - 65 ; } else if ( ( chr >= 'a' ) && ( chr <= 'z' ) ) { bits = chr - 71 ; } else if ( ( chr >= '0' ) && ( chr <= '9' ) ) { bits = chr + 4 ; } else if ( chr == '+' ) { bits = 62 ; } else if ( chr == '/' ) { bits = 63 ; } else { return null ; } quantum = ( quantum << 6 ) | ( byte ) bits ; if ( inIndex % 4 == 3 ) { out [ outIndex ++ ] = ( byte ) ( quantum > > 16 ) ; out [ outIndex ++ ] = ( byte ) ( quantum > > 8 ) ; out [ outIndex ++ ] = ( byte ) quantum ; } inIndex ++ ; } if ( pad > 0 ) { quantum = quantum << ( 6 * pad ) ; out [ outIndex ++ ] = ( byte ) ( quantum > > 16 ) ; if ( pad == 1 ) { out [ outIndex ++ ] = ( byte ) ( quantum > > 8 ) ; } } byte [ ] result = new byte [ outIndex ] ; System . arraycopy ( out , 0 , result , 0 , outIndex ) ; return result ;
max: void max ( ) { assertEquals ( 5 , MinMax . max ( List . of ( 1 , 2 , 3 , 4 , 5 ) , ( o1 , o2 ) -> o1 . compareTo ( o2 ) ) ) ; assertEquals ( "zazza" , MinMax . max ( List . of ( "abaco" , "barco" , "zazza" ) , ( o1 , o2 ) -> o1 . compareTo ( o2 ) ) ) ;
publishTransaction: No method body
forceSync: public void forceSync ( ) { rpm = 3000 ; synced = true ;
getTime: public float getTime ( ) { return time ;
getLastSpawnPoint: public Spawnable getLastSpawnPoint ( ) { return lastSpawnPoint ;
setDr: public void setDr ( int dr ) { this . dr = dr ;
deepCopy: public static int [ ] [ ] deepCopy ( int [ ] [ ] original ) { int [ ] [ ] copy = new int [ original . length ] [ ] ; for ( int i = 0 ; i < original . length ; i ++ ) { copy [ i ] = Arrays . copyOf ( original [ i ] , original [ i ] . length ) ; } return copy ;
received: public boolean received ( final CaseOpenResultMsg msg ) { Gdx . app . postRunnable ( ( ) -> { CaseData gameCaseData = null ; switch ( msg . result ) { case success : { Content content = BrainOutClient . ContentMgr . get ( msg . id ) ; if ( content instanceof Case ) { Case gameCase = ( ( Case ) content ) ; gameCaseData = gameCase . getData ( ) ; JsonValue value = new JsonReader ( ) . parse ( msg . data ) ; gameCaseData . read ( new Json ( ) , value ) ; gameCaseData . init ( ) ; } break ; } } BrainOutClient . EventMgr . sendDelayedEvent ( CaseOpenResultEvent . obtain ( msg . result , gameCaseData ) ) ; } ) ; return true ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoSteamPressure1Off1ActionPerformed ( evt ) ;
density: public ColorPickerDialogBuilder density ( int density ) { colorPickerView . setDensity ( density ) ; return this ;
onResponse: public void onResponse ( byte [ ] bytes ) { try {
test_getApiKeys: public void test_getApiKeys ( ) throws IOException , NovuNetworkException , InterruptedException { ApiKeyResponse apiKeyResponse = new ApiKeyResponse ( ) ; apiKeyResponse . setData ( Collections . singletonList ( new ApiKey ( ) ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( apiKeyResponse ) ) ) ; ApiKeyResponse response = environmentHandler . getApiKeys ( ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/environments/api-keys" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( apiKeyResponse ) , gson . toJson ( response ) ) ;
setLightsVisible: public void setLightsVisible ( boolean lightsVisible ) { this . lightsVisible = lightsVisible ;
error: public void error ( String reason ) { loadingMenu . pop ( ) ; pushMenu ( new AlertPopup ( L . get ( "MENU_PURCHASE_ERROR" ) ) ) ;
onClick: public void onClick ( View v ) { ToastUtils . showToast ( mContext , "Not yet open, please wait" ) ; shareLayout . setVisibility ( View . GONE ) ;
setLogoColor: public void setLogoColor ( @ ColorInt int color ) { options . putInt ( EXTRA_UCROP_LOGO_COLOR , color ) ;
fail: public void fail ( Request request , Request . Result status ) { Gdx . app . postRunnable ( ( ) ->
getShadowColorSameAsCandle: No method body
getSpeedFrom: public float getSpeedFrom ( ) { return speedFrom ;
newThread: public Thread newThread ( Runnable r ) { return new Thread ( r , "myThreadPool thread:" + integer . getAndIncrement ( ) ) ;
getValue: public String getValue ( int i ) { return values . get ( i ) ;
getSmallRMBText: public static SpannableString getSmallRMBText ( Context context , int smallSize , long showPrice ) { if ( StringUtils . isEmpty ( String . valueOf ( showPrice ) ) ) { return new SpannableString ( "——" ) ; } String text = getRMBStr ( context ) + showPrice ; try { DecimalFormat df = new DecimalFormat ( "#,###" ) ; text = getRMBStr ( context ) + df . format ( showPrice ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } SpannableString spannableString = new SpannableString ( text ) ; int textSize = DisplayUtil . sp2px ( context , smallSize ) ; spannableString . setSpan ( new AbsoluteSizeSpan ( textSize ) , 0 , 1 , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; return spannableString ;
setAmount: public void setAmount ( double amount ) { this . amount = amount ;
onClick: public void onClick ( View v ) { mAlertDialog . dismiss ( ) ;
addValue: private void addValue ( String v ) { if ( value . length ( ) >= CODE_LENGTH ) value = "" ; value = value + v ; if ( value . length ( ) >= CODE_LENGTH ) { try { int intValue = Integer . valueOf ( value ) ; intValue = Walkietalkie . validateFrequency ( intValue ) ; changed . changed ( intValue ) ; value = String . valueOf ( intValue ) ; playSound ( changeFrequency ) ; } catch ( NumberFormatException ignored ) { } } renderDigits ( ) ;
finished: public void finished ( ) { BrainOutServer . Controller . setSpeed ( 0.5f ) ; BrainOut . Timer . schedule ( new TimerTask ( )
canRenderLights: private boolean canRenderLights ( ) { return BrainOutClient . ClientSett . isLightsEnabled ( ) ;
getEventClassName: public String getEventClassName ( ) { return eventClassName ;
show: public void show ( ) { if ( mAlertDialog == null ) { Log . d ( TAG , "show" ) ; mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme ) . setContentView ( R . layout . layout_dialog_forget_password_next ) . setAnimation ( R . style . popup_anim_style ) . fullWidth ( ) . fullHeight ( ) . create ( ) ; } EditText passwordInputEditText = mAlertDialog . findViewById ( R . id . password_input ) ; PasswordFilter passwordFilter = new PasswordFilter ( ) ; passwordInputEditText . setFilters ( new InputFilter [ ] { new InputFilter . LengthFilter ( 16 ) , passwordFilter } ) ; passwordInputEditText . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable s ) { passwordChangeCheck ( ) ; } } ) ; EditText passwordInputRepeatEditText = mAlertDialog . findViewById ( R . id . password_input_repeat ) ; passwordInputRepeatEditText . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { passwordRepeatChangeCheck ( ) ; } @ Override public void afterTextChanged ( Editable s ) { passwordRepeatChangeCheck ( ) ; } } ) ; mAlertDialog . findViewById ( R . id . pass_switch ) . setOnClickListener ( v -> clickPwdEye ( ) ) ; mAlertDialog . findViewById ( R . id . pass_switch_repeat ) . setOnClickListener ( v -> clickConfirmPwdEye ( ) ) ; mAlertDialog . findViewById ( R . id . btn_back ) . setOnClickListener ( v -> clickBack ( ) ) ; mAlertDialog . findViewById ( R . id . btn_forward ) . setOnClickListener ( v -> clickForward ( ) ) ; mAlertDialog . show ( ) ;
getOrDefault: public < T > T getOrDefault ( PageAttr < T > key , Object defaultValue ) { return ( T ) super . getOrDefault ( key . name , defaultValue ) ;
close: protected void close ( ) { if ( closed != null )
getSearchPredicateForEntityBasedPrivilege: default Predicate getSearchPredicateForEntityBasedPrivilege ( CriteriaBuilder cb , Predicate search , boolean isOrganizationEntity , boolean hasManyOrganizationsEntity , OrganizationUser user , Expression organizationIdPath , Expression organizationIdsPath , Path requiredPrivilegePath ) { Predicate entityWithRequiredPrivilegeCheck ; if ( isOrganizationEntity ) { Predicate globalEntityCheck = cb . and ( requiredPrivilegePath . isNotNull ( ) , requiredPrivilegePath . in ( user . getGlobalPrivileges ( ) ) ) ; Expression orgPrivilegePair = cb . concat ( organizationIdPath , requiredPrivilegePath ) ; Predicate organizationEntityCheck = cb . and ( organizationIdPath . isNotNull ( ) , requiredPrivilegePath . isNotNull ( ) , orgPrivilegePair . in ( user . getOrganizationWithPrivilegePairs ( ) ) ) ; entityWithRequiredPrivilegeCheck = cb . or ( globalEntityCheck , organizationEntityCheck ) ; debug ( "[getSearchPredicateForExternallyProvidedPrivilege] (entityPrivilege != null AND entityPrivilege in {}) OR " + "(orgId != null AND entityPrivilege != null AND orgId+entityPrivilege in {})" , user . getGlobalPrivileges ( ) , user . getOrganizationWithPrivilegePairs ( ) ) ; } else if ( hasManyOrganizationsEntity ) { Predicate globalEntityCheck = cb . and ( requiredPrivilegePath . isNotNull ( ) , requiredPrivilegePath . in ( user . getGlobalPrivileges ( ) ) ) ; Expression orgsWithPrivilege = cb . function ( "arrays_suffix" , Array . class , organizationIdsPath , requiredPrivilegePath ) ; Predicate inAnyOrgCheck = cb . isTrue ( cb . function ( "arrays_overlap" , Boolean . class , orgsWithPrivilege , cb . literal ( user . getOrganizationWithPrivilegePairs ( ) ) ) ) ; Predicate organizationEntityCheck = cb . and ( organizationIdsPath . isNotNull ( ) , inAnyOrgCheck ) ; entityWithRequiredPrivilegeCheck = cb . or ( globalEntityCheck , organizationEntityCheck ) ; } else { entityWithRequiredPrivilegeCheck = cb . and ( requiredPrivilegePath . isNotNull ( ) , requiredPrivilegePath . in ( user . getGlobalPrivileges ( ) ) ) ; } search = cb . and ( cb . or ( requiredPrivilegePath . isNull ( ) , entityWithRequiredPrivilegeCheck ) , search ) ; return search ;
getShootMode: public Weapon . ShootMode getShootMode ( ) { Array < Weapon . ShootMode > shootModes = this . shootModes . asEnumArray ( Weapon . ShootMode . class ) ; if ( shootMode >= shootModes . size ) return shootModes . first ( ) ; return shootModes . get ( shootMode ) ;
showStepSuccess: private void showStepSuccess ( View rootView ) { ImageView assetTypeSuccessIv = rootView . findViewById ( R . id . iv_asset_type_success ) ; TextView assetTypeSuccessTv = rootView . findViewById ( R . id . tv_asset_type_success ) ; TextView amountSuccessTv = rootView . findViewById ( R . id . tv_amount_success ) ; TextView amountUnitSuccessTv = rootView . findViewById ( R . id . tv_amount_unit_success ) ; TextView timeSuccessTv = rootView . findViewById ( R . id . tv_time_success ) ; TextView timeUnitSuccessTv = rootView . findViewById ( R . id . tv_time_unit_success ) ; ImageView qrCodeIv = rootView . findViewById ( R . id . iv_success_qrcode ) ; TextView paymentSuccessTv = rootView . findViewById ( R . id . tv_success_payment ) ; ImageView copyIv = rootView . findViewById ( R . id . iv_success_copy ) ; if ( mAssetId == 0 ) { assetTypeSuccessIv . setImageResource ( R . mipmap . icon_btc_logo_small ) ; assetTypeSuccessTv . setText ( "BTC" ) ; amountUnitSuccessTv . setText ( "BTC" ) ; } else { assetTypeSuccessIv . setImageResource ( R . mipmap . icon_usdt_logo_small ) ; assetTypeSuccessTv . setText ( "dollar" ) ; amountUnitSuccessTv . setText ( "dollar" ) ; } amountSuccessTv . setText ( amountInput ) ; timeSuccessTv . setText ( timeInput ) ; timeUnitSuccessTv . setText ( timeType ) ; paymentSuccessTv . setText ( qrCodeUrl ) ; Bitmap mQRBitmap = CodeUtils . createQRCode ( qrCodeUrl , DisplayUtil . dp2px ( mContext , 100 ) ) ; qrCodeIv . setImageBitmap ( mQRBitmap ) ; qrCodeIv . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { InvoiceQRCodeDialog mInvoiceQRCodeDialog = new InvoiceQRCodeDialog ( mContext ) ; mInvoiceQRCodeDialog . show ( qrCodeUrl ) ; } } ) ; qrCodeIv . setOnLongClickListener ( new View . OnLongClickListener ( ) { @ Override public boolean onLongClick ( View v ) { String fileName = "invoice_" + User . getInstance ( ) . getAlias ( mContext ) + ".jpg" ; BitmapUtils . saveBitmap2Gallery ( mContext , mQRBitmap , fileName ) ; ToastUtils . showToast ( mContext , "QR code saved successfully" ) ; return true ; } } ) ; copyIv . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { String toCopyAddress = qrCodeUrl ; String toastString = mContext . getResources ( ) . getString ( R . string . toast_copy_address ) ; CopyUtil . SelfCopy ( mContext , toCopyAddress , toastString ) ; } } ) ; rootView . findViewById ( R . id . layout_back ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { rootView . findViewById ( R . id . lv_create_invoice_step_one ) . setVisibility ( View . VISIBLE ) ; rootView . findViewById ( R . id . lv_create_invoice_success ) . setVisibility ( View . GONE ) ; rootView . findViewById ( R . id . layout_cancel ) . setVisibility ( View . VISIBLE ) ; rootView . findViewById ( R . id . layout_close ) . setVisibility ( View . GONE ) ; showStepOne ( rootView ) ; } } ) ; RelativeLayout shareLayout = rootView . findViewById ( R . id . layout_share_success ) ; rootView . findViewById ( R . id . layout_parent ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { shareLayout . setVisibility ( View . GONE ) ; } } ) ; rootView . findViewById ( R . id . layout_share_to_success ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { shareLayout . setVisibility ( View . VISIBLE ) ; } } ) ; rootView . findViewById ( R . id . iv_facebook_share ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ToastUtils . showToast ( mContext , "Not yet open, please wait" ) ; shareLayout . setVisibility ( View . GONE ) ; } } ) ; rootView . findViewById ( R . id . iv_twitter_share ) . setOnClickListener ( new View . OnClickListener ( ) {
initView: protected void initView ( ) { mNetworkTypeTv . setText ( User . getInstance ( ) . getNetwork ( mContext ) ) ; if ( balanceAmount == 0 ) { DecimalFormat df = new DecimalFormat ( "0.00" ) ; mBalanceAmountTv . setText ( "My account " + df . format ( Double . parseDouble ( String . valueOf ( balanceAmount ) ) / 100000000 ) ) ; } else { DecimalFormat df = new DecimalFormat ( "0.00######" ) ; mBalanceAmountTv . setText ( "My account " + df . format ( Double . parseDouble ( String . valueOf ( balanceAmount ) ) / 100000000 ) ) ; } mWalletAddressTv . setText ( walletAddress ) ; mSearchEdit . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable s ) { mCurrentSearchString = s . toString ( ) ; final List < ChannelListItem > filteredChannelList = filter ( mChannelItems , s . toString ( ) ) ; mAdapter . replaceAll ( filteredChannelList ) ; mRecyclerView . scrollToPosition ( 0 ) ; } } ) ; Wallet . getInstance ( ) . registerChannelsUpdatedSubscriptionListener ( this ) ; initRecyclerView ( ) ; Wallet . getInstance ( ) . fetchChannelsFromLND ( ) ; updateChannelsDisplayList ( ) ;
getActivateText: public String getActivateText ( ) { return getContentComponent ( ) . getActivateText ( ) . get ( ) ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; sound = assetManager . get ( fileName , com . badlogic . gdx . audio . Sound . class ) ;
init: private Event init ( ) { return this ;
canResetPassword: default boolean canResetPassword ( ) { return hasGlobalPrivilege ( Privilege . canResetPassword ) ;
cancel: No method body
onInit: public void onInit ( ) { BrainOut . EventMgr . subscribe ( Event . ID . setMyPlayer , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . kill , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . onScreenMessage , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . notify , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . weaponStateUpdated , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . gameController , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . selectSlot , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . selectPreviousSlot , this ) ; initWidgets ( ) ; CSGame csGame = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( csGame != null ) { myPlayerData = csGame . getPlayerData ( ) ; } updatePlayerInfo ( ) ; initPlayStateWidgets ( ) ;
getComponent: public BlockDamageComponentData getComponent ( ComponentObject componentObject ) { return new BlockDamageComponentData ( ( BlockData ) componentObject , this ) ;
setView: public SafeDialogBuilder setView ( View view ) { super . setView ( view ) ; return this ;
saveChannelBackupPath: public static void saveChannelBackupPath ( Context context , String value ) { putString ( SETTINGS , context , CHANNEL_BACKUP_PATH_ARRAY , value ) ;
hasRender: public boolean hasRender ( ) { return true ;
getAccountCreationTime: public static long getAccountCreationTime ( User user ) { return toTimestamp ( user . getId ( ) ) ;
createNewForm: public F createNewForm ( Long organizationId , E entity ) { try {
upgraded: public void upgraded ( ObjectMap < String , Upgrade > upgrades ) { for ( ObjectMap . Entry < String , Slot > slot : slots )
renderContents: private void renderContents ( Table contents ) { JSONObject image = entry . data . optJSONObject ( "image" ) ; JSONObject titleValue = entry . data . optJSONObject ( "title" ) ; JSONObject descriptionValue = entry . data . optJSONObject ( "description" ) ; if ( image == null || titleValue == null || descriptionValue == null ) return ; String version = titleValue . optString ( "version" , null ) ; if ( version != null && ! version . isEmpty ( ) ) { VersionCompare v = new VersionCompare ( version ) ; VersionCompare current = new VersionCompare ( Version . VERSION ) ; if ( current . compareTo ( v ) < 0 ) { return ; } } String titleText = titleValue . optString ( BrainOutClient . LocalizationMgr . getCurrentLanguage ( ) . toLowerCase ( ) , titleValue . optString ( LocalizationManager . GetDefaultLanguage ( ) . toLowerCase ( ) , null ) ) ; String descriptionText = descriptionValue . optString ( BrainOutClient . LocalizationMgr . getCurrentLanguage ( ) . toLowerCase ( ) , descriptionValue . optString ( LocalizationManager . GetDefaultLanguage ( ) . toLowerCase ( ) , null ) ) ; if ( titleText == null || descriptionText == null ) return ; String imageUrl = image . optString ( BrainOutClient . LocalizationMgr . getCurrentLanguage ( ) . toLowerCase ( ) , image . optString ( LocalizationManager . GetDefaultLanguage ( ) . toLowerCase ( ) , null ) ) ; if ( imageUrl == null ) return ; Image background = new Image ( ) ; background . setScaling ( Scaling . fit ) ; Avatars . GetAndCache ( imageUrl , ( has , avatar ) -> { if ( has ) { background . setDrawable ( new TextureRegionDrawable ( avatar ) ) ; } } ) ; contents . add ( background ) . pad ( 16 ) . expandX ( ) . fillX ( ) . row ( ) ; { Label title = new Label ( DateFormat . getDateTimeInstance ( ) . format ( entry . dateCreate ) , BrainOutClient . Skin , "title-small" ) ; contents . add ( title ) . expandX ( ) . fillX ( ) . pad ( 8 ) . padTop ( 16 ) . row ( ) ; } { Label title = new Label ( titleText , BrainOutClient . Skin , "title-yellow" ) ; contents . add ( title ) . expandX ( ) . fillX ( ) . pad ( 8 ) . row ( ) ; } { Label description = new Label ( descriptionText , BrainOutClient . Skin , "title-small" ) ; description . setWrap ( true ) ; contents . add ( description ) . expandX ( ) . fillX ( ) . pad ( 8 ) . row ( ) ; } JSONObject action = entry . data . optJSONObject ( "action" ) ; if ( action != null )
roundToNextSignificant: public static float roundToNextSignificant ( double number ) { if ( Double . isInfinite ( number ) || Double . isNaN ( number ) || number == 0.0 ) return 0 ; final float d = ( float ) Math . ceil ( ( float ) Math . log10 ( number < 0 ? - number : number ) ) ; final int pw = 1 - ( int ) d ; final float magnitude = ( float ) Math . pow ( 10 , pw ) ; final long shifted = Math . round ( number * magnitude ) ; return shifted / magnitude ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem4ActionPerformed ( evt ) ;
isAxisMaxCustom: public boolean isAxisMaxCustom ( ) { return mCustomAxisMax ;
setDeformAttachment: public void setDeformAttachment ( @ Null VertexAttachment deformAttachment ) { this . deformAttachment = deformAttachment ;
MarketObjectToConsumableRecord: public static ConsumableRecord MarketObjectToConsumableRecord ( String item , JSONObject payload , int amount ) { ConsumableItem i ; switch ( item ) { case "instrument" : { String c = payload . optString ( "c" ) ; if ( c == null ) { return null ; } Instrument instrument = BrainOut . ContentMgr . get ( c , Instrument . class ) ; if ( instrument == null ) { return null ; } InstrumentData instrumentData = instrument . getData ( "default" ) ; String skin = payload . optString ( "s" , null ) ; if ( skin != null ) { InstrumentSkin ss = BrainOut . ContentMgr . get ( skin , InstrumentSkin . class ) ; instrumentData . setSkin ( ss ) ; } else { instrumentData . setSkin ( instrument . getDefaultSkin ( ) ) ; } if ( instrument . getSlotItem ( ) != null && instrument . getSlotItem ( ) . getUpgrades ( ) != null ) { for ( ObjectMap . Entry < String , Array < Upgrade > > entry : instrument . getSlotItem ( ) . getUpgrades ( ) ) { String has = payload . optString ( entry . key , null ) ; if ( has == null ) continue ; for ( Upgrade upgrade : entry . value ) { if ( upgrade . getID ( ) . equals ( has ) ) { instrumentData . getInfo ( ) . upgrades . put ( entry . key , upgrade ) ; break ; } } } } i = new InstrumentConsumableItem ( instrumentData , "default" ) ; break ; } case "consumable" : { String c = payload . optString ( "c" ) ; if ( c == null ) { return null ; } ConsumableContent content ; if ( payload . has ( "u" ) ) { content = BrainOut . ContentMgr . get ( c , DecayConsumableContent . class ) ; if ( content == null ) { return null ; } i = content . acquireConsumableItem ( ) ; ( ( DecayConsumableItem ) i ) . setUses ( payload . getInt ( "u" ) ) ; } else { content = BrainOut . ContentMgr . get ( c , ConsumableContent . class ) ; if ( content == null ) { return null ; } i = content . acquireConsumableItem ( ) ; } break ; } case "armor" : { String c = payload . optString ( "c" ) ; if ( c == null ) { return null ; } Armor content = BrainOut . ContentMgr . get ( c , Armor . class ) ; if ( content == null ) return null ; ArmorConsumableItem aci = content . acquireConsumableItem ( ) ; for ( String key : payload . keySet ( ) ) { if ( ! key . startsWith ( "p-" ) ) continue ; String param = key . substring ( 2 ) ; aci . getProtect ( ) . put ( param , payload . optFloat ( key , 0 ) ) ; } i = aci ; break ; } case "skin" : { String c = payload . optString ( "c" ) ; if ( c == null ) { return null ; } PlayerSkin content = BrainOut . ContentMgr . get ( c , PlayerSkin . class ) ; if ( content == null ) return null ; i = new PlayerSkinConsumableItem ( content ) ; break ; } case "realestate" : { String c = payload . optString ( "c" ) ; if ( c == null ) { return null ; } RealEstateContent content = BrainOut . ContentMgr . get ( c , RealEstateContent . class ) ; if ( content == null ) return null ; RealEstateConsumableItem rs = new RealEstateConsumableItem ( content ) ; i = rs ; rs . setLocation ( payload . optString ( "l" ) ) ; rs . setId ( payload . optString ( "id" ) ) ; break ; } case "rsitem" : { String c = payload . optString ( "c" ) ; if ( c == null ) { return null ; } RealEstateItem content = BrainOut . ContentMgr . get ( c , RealEstateItem . class ) ; if ( content == null ) return null ; RealEstateItemConsumableItem rs = new RealEstateItemConsumableItem ( content ) ; i = rs ; break ; } case "radio" : { String c = payload . optString ( "c" ) ; if ( c == null ) { return null ; } Walkietalkie content = BrainOut . ContentMgr . get ( c , Walkietalkie . class ) ; if ( content == null ) return null ; WalkietalkieConsumableItem w = new WalkietalkieConsumableItem ( content ) ; w . setFrequency ( payload . optInt ( "f" , Walkietalkie . getRandomFrequency ( ) ) ) ; i = w ; break ; } case "ru" : default : { return null ; } } ConsumableRecord record = new ConsumableRecord ( i , amount , 0 ) ; if ( payload . has ( "q" ) ) { record . setQuality ( payload . getInt ( "q" ) ) ; } record . init ( ) ; return record ;
getSound: public Sound getSound ( ) { return sound ;
setScaleEnabled: public void setScaleEnabled ( boolean enabled ) { this . mScaleXEnabled = enabled ; this . mScaleYEnabled = enabled ;
getDelayTime: public int getDelayTime ( ) { return mDelayTime ;
setCurrentStatus: No method body
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { Bone bone = skeleton . bones . get ( boneIndex ) ; if ( ! bone . active ) return ; float [ ] frames = this . frames ; if ( time < frames [ 0 ] ) { switch ( blend ) { case setup : bone . shearX = bone . data . shearX ; return ; case first : bone . shearX += ( bone . data . shearX - bone . shearX ) * alpha ; } return ; } float x = getCurveValue ( time ) ; switch ( blend ) {
clickChannelList: public void clickChannelList ( ) { Bundle bundle = new Bundle ( ) ; bundle . putLong ( ChannelsActivity . KEY_BALANCE_AMOUNT , balanceAmount ) ; bundle . putString ( ChannelsActivity . KEY_WALLET_ADDRESS , walletAddress ) ; bundle . putString ( ChannelsActivity . KEY_PUBKEY , pubkey ) ; if ( assetId == 0 ) { bundle . putString ( ChannelsActivity . KEY_CHANNEL , "btc" ) ; } else { bundle . putString ( ChannelsActivity . KEY_CHANNEL , "asset" ) ; } switchActivity ( ChannelsActivity . class , bundle ) ;
find: protected PageModelMap find ( long schedulerId ) { debug ( "[find] schedulerId {}" , schedulerId ) ; return Flow . init ( )
received: public boolean received ( final CancelPlayerProgressMsg msg ) { if ( playerController == null || playerData == null ) return true ; BrainOutServer . PostRunnable ( ( ) -> { if ( playerData == null ) return ; final ActiveProgressComponentData pc = playerData . getComponent ( ActiveProgressComponentData . class ) ; if ( pc == null ) return ; pc . cancel ( ) ; } ) ; return true ;
getPendingTxsAsset: private void getPendingTxsAsset ( ) { mPendingTxsAssetData . clear ( ) ; SharedPreferences txidSp = mContext . getSharedPreferences ( "SP_TXID_LIST" , Activity . MODE_PRIVATE ) ; String txidListJson = txidSp . getString ( "txidListKey" , "" ) ; if ( ! StringUtils . isEmpty ( txidListJson ) ) {
mixWater: public static double [ ] mixWater ( double destinationMass , double destinationTemp , double addedMass , double addedTemp ) { double [ ] result = { 0.0 , 0.0 } ; if ( addedMass <= 0 ) { result [ 0 ] = destinationMass ; result [ 1 ] = destinationTemp ; return result ; } final double totalMass = destinationMass + addedMass ; final double totalEnthalpy = tables . getWaterEnthalpyByTemperature ( addedTemp ) * addedMass + tables . getWaterEnthalpyByTemperature ( destinationTemp ) * destinationMass ; result [ 0 ] = totalMass ; result [ 1 ] = tables . getWaterTemperatureByEnthalpy ( totalEnthalpy / totalMass ) ; return result ;
main: public static void main ( String [ ] args ) { RandomGenerator rnd = RandomGenerator . getDefault ( ) ; int rightPrice = rnd . nextInt ( 101 ) ; Scanner scanner = new Scanner ( System . in ) ; System . out . print ( "(a) Your guess for the right price [0, 100] ? " ) ; int aPrice = scanner . nextInt ( ) ; System . out . print ( "(b) Your guess for the right price [0, 100] ? " ) ; int bPrice = scanner . nextInt ( ) ; if ( Math . abs ( rightPrice - aPrice ) < Math . abs ( rightPrice - bPrice ) ) {
onAutoFocus: public synchronized void onAutoFocus ( boolean success , Camera theCamera ) { focusing = false ; autoFocusAgainLater ( ) ;
updateAddressReferenceKey: public CustomerAddress updateAddressReferenceKey ( String shopKey , String countryCode , Identifier customerIdentifier , Integer addressId , CustomerAddressReferenceKey model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomerAddress > responseModel = ( Class < CustomerAddress > ) ( Class < ? > ) CustomerAddress . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/addresses/%s/reference-key" , shopKey , countryCode , customerIdentifier , addressId ) , query , null , responseModel , model ) ;
getMaxDelay: public @ Nullable Duration getMaxDelay ( ) { return maxDelay ;
getJiraOrganizationName: public String getJiraOrganizationName ( ) { return jiraOrganizationName ;
getSound: No method body
isWsConnected: public synchronized boolean isWsConnected ( ) { return mCurrentStatus == WsStatus . CONNECTED ;
promptRestart: public static void promptRestart ( Context context ) { if ( ! canShowDialog ( context ) ) return ; newBuilder ( context )
setVisibleXRangeMaximum: public void setVisibleXRangeMaximum ( float maxXRange ) { float xScale = mXAxis . mAxisRange / ( maxXRange ) ; mViewPortHandler . setMinimumScaleX ( xScale ) ;
getDisplayMetrics: private DisplayMetrics getDisplayMetrics ( ) { return getResources ( ) . getDisplayMetrics ( ) ;
buildMiddleArea: private static List < Camera . Area > buildMiddleArea ( int areaPer1000 ) { return Collections . singletonList (
getUserRoleIds: public String getUserRoleIds ( ) { return userRoleIds ;
keyUp: public boolean keyUp ( int keyCode ) { KeyProperties . Keys action = BrainOutClient . ClientSett . getControls ( ) . getKey ( keyCode ) ; if ( action != null ) { switch ( action ) { case right : case left : { moving = 0 ; return true ; } } } return super . keyUp ( keyCode ) ;
getAmount: public int getAmount ( ) { return amount ;
assertThatDiscovery: public static EndpointManifestSchemaAssert assertThatDiscovery ( Object ... services ) { return new EndpointManifestSchemaAssert (
getShortLocalizedName: public String getShortLocalizedName ( ) { return L . get ( "QUEST_TASK_REVIVE_TEAMMATE" ) ;
lockInput: public boolean lockInput ( ) { return true ;
onProgressChanged: public void onProgressChanged ( WebView view , int newProgress ) { if ( progressBar != null ) {
getDraftContent: public String getDraftContent ( ) { return draftContent ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVOpen4ActionPerformed ( evt ) ;
testDeleteReductions: public void testDeleteReductions ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . campaigns ( ) . deleteReductions ( "acme" , 1 , options ) ;
getT6: public Tuple6 getT6 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] , list [ 5 ] ) ;
trackPayment: public Observable < routerrpc . RouterOuterClass . PaymentStatus > trackPayment ( routerrpc . RouterOuterClass . TrackPaymentRequest request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . trackPayment ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
onPageSelected: No method body
hasRender: public boolean hasRender ( ) { return false ;
success: public void success ( byte [ ] data , Map < String , List < String > > headers ) { try
initView: private void initView ( ) { mRootView = createTitleView ( ) ; for ( int i = 0 ; i < getTitleSize ( ) ; i ++ ) {
setNeutralColor: public void setNeutralColor ( int color ) { mNeutralColor = color ;
getCause: public Throwable getCause ( ) { return getError ( ) . getCause ( getErrorDescription ( ) ) ;
onKilledBy: public void onKilledBy ( ActionPhaseState ps , Map map , ActiveData killer , InstrumentInfo info ) { if ( getGameMode ( ) . getPhase ( ) == GameMode . Phase . game )
dequeue: public V dequeue ( ) { Entry < K , V > entry = queue . poll ( ) ; return entry != null ? entry . value : null ;
setConstantSpeed: public void setConstantSpeed ( boolean constantSpeed ) { this . constantSpeed = constantSpeed ;
getID: public ID getID ( ) { return ID . flagTaken ;
stop: public void stop ( ) { long elapsedTime = System . nanoTime ( ) - startTime ; totalRuntime += elapsedTime ; executionCount ++ ;
writeOutput: No method body
getOpenedBlock: public Block getOpenedBlock ( ) { return getContentComponent ( ) . getOpened ( ) ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights )
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , FieldType type , String additionalCss , PrivilegeBase requiredReadPrivilege , PrivilegeBase requiredWritePrivilege ) { return new FrontendMappingFieldDefinition ( formName , name , type , null , null , requiredReadPrivilege , requiredWritePrivilege , null , null , false , null , null , additionalCss , false , null , null , null , null , null , null , null , null , null , null , false , false ) ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights )
isShowSoftInput: public static boolean isShowSoftInput ( Context context , View view ) { InputMethodManager imm = ( InputMethodManager ) context . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; if ( view != null ) { return imm != null && imm . isActive ( view ) ; } return imm != null && imm . isActive ( ) ; }
computeScroll: public void computeScroll ( ) { if ( mDecelerationVelocity . x == 0.f && mDecelerationVelocity . y == 0.f ) return ; final long currentTime = AnimationUtils . currentAnimationTimeMillis ( ) ; mDecelerationVelocity . x *= mChart . getDragDecelerationFrictionCoef ( ) ; mDecelerationVelocity . y *= mChart . getDragDecelerationFrictionCoef ( ) ; final float timeInterval = ( float ) ( currentTime - mDecelerationLastTime ) / 1000.f ; float distanceX = mDecelerationVelocity . x * timeInterval ; float distanceY = mDecelerationVelocity . y * timeInterval ; mDecelerationCurrentPoint . x += distanceX ; mDecelerationCurrentPoint . y += distanceY ; MotionEvent event = MotionEvent . obtain ( currentTime , currentTime , MotionEvent . ACTION_MOVE , mDecelerationCurrentPoint . x , mDecelerationCurrentPoint . y , 0 ) ; float dragDistanceX = mChart . isDragXEnabled ( ) ? mDecelerationCurrentPoint . x - mTouchStartPoint . x : 0.f ; float dragDistanceY = mChart . isDragYEnabled ( ) ? mDecelerationCurrentPoint . y - mTouchStartPoint . y : 0.f ; performDrag ( event , dragDistanceX , dragDistanceY ) ; event . recycle ( ) ; mMatrix = mChart . getViewPortHandler ( ) . refresh ( mMatrix , mChart , false ) ; mDecelerationLastTime = currentTime ; if ( Math . abs ( mDecelerationVelocity . x ) >= 0.01 || Math . abs ( mDecelerationVelocity . y ) >= 0.01 )
setLabelPosition: public void setLabelPosition ( LimitLabelPosition pos ) { mLabelPosition = pos ;
search: default Page < T > search ( Specification < T > specification , int page , int size , String sortField , String sortDirection ) { return SearchableFunctionalRepositoryWithLongId . super . search ( DEFAULT_SCOPE , specification , page , size , sortField , sortDirection ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; for ( JsonValue value : jsonData . get ( "queue" ) )
registerStompEndpoints: public void registerStompEndpoints ( StompEndpointRegistry registry ) { registry . addEndpoint ( _HTML + "/websocket" ) . setHandshakeHandler (
getBones: public Array < Bone > getBones ( ) { return bones ;
initData: protected void initData ( ) { createSeeds ( ) ;
getProperty: public float getProperty ( InstrumentInfo info , String key , float def ) { Instrument . InstrumentProperties properties = info . instrument . getPrimaryProperties ( ) ; UpgradableProperty property = properties . property ( key ) ; if ( property != null ) { String value = property . asString ( ) ; for ( ObjectMap . Entry < String , Upgrade > entry : info . upgrades ) { if ( hover != null && entry . key . equals ( hover . upgradeClass ) ) { continue ; } Upgrade upgrade = entry . value ; if ( upgrade != null ) { Upgrade . UpgradeProperty upd = upgrade . getProperty ( key ) ; if ( upd != null ) { value = upd . apply ( value ) ; } } } if ( hover != null ) { Upgrade . UpgradeProperty upd = hover . upgrade . getProperty ( key ) ; if ( upd != null ) { value = upd . apply ( value ) ; } } return Float . valueOf ( value ) ; } return 0 ;
getSmallRMBText: public static SpannableString getSmallRMBText ( Context context , int smallSize , String showPrice ) { if ( StringUtils . isEmpty ( String . valueOf ( showPrice ) ) ) { return new SpannableString ( "——" ) ; } String text = getRMBStr ( context ) + showPrice ; try { DecimalFormat df ; if ( showPrice . contains ( "." ) || showPrice . contains ( "E" ) || showPrice . contains ( "e" ) ) { df = new DecimalFormat ( "#,##0.00" ) ; text = getRMBStr ( context ) + df . format ( Double . parseDouble ( showPrice ) ) ; } else { df = new DecimalFormat ( "#,###" ) ; text = getRMBStr ( context ) + df . format ( Long . parseLong ( showPrice ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } SpannableString spannableString = new SpannableString ( text ) ; int textSize = DisplayUtil . sp2px ( context , smallSize ) ; spannableString . setSpan ( new AbsoluteSizeSpan ( textSize ) , 0 , 1 , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; return spannableString ;
getAndSetState: No method body
serde: public Serde < T > serde ( ) { return serde ;
setCircleColors: public void setCircleColors ( int ... colors ) { this . mCircleColors = ColorTemplate . createColors ( colors ) ;
getValueMatrix: public Matrix getValueMatrix ( ) { return mMatrixValueToPx ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; particle = assetManager . get ( particleName , com . badlogic . gdx . graphics . g2d . ParticleEffect . class ) ;
addInterest: No method body
getMass: public float getMass ( ) { return mass ;
call: No method body
saveAudit: default Audit saveAudit ( Audit a ) { return save ( a ) ;
getComponent: public ReoccurringActiveEffectComponentData getComponent ( ComponentObject componentObject ) { return new ReoccurringActiveEffectComponentData ( ( ActiveData ) componentObject , this ) ;
canSeeEmail: default boolean canSeeEmail ( User user ) { return canSeeEmail ( user . getId ( ) ) ;
onStop: protected void onStop ( ) { super . onStop ( ) ; boolean isRunningSelf = isRunningForeground ( ) ; if ( ! isRunningSelf ) {
get: public ResponseEntity < TokenResponse > get ( @ PathVariable ( ID ) Long userId , @ RequestBody TokenRequest aTokenRequest ) { debug ( "[getToken] UserId: {}" , userId ) ; return ( ResponseEntity < TokenResponse > )
getTopic: public TopicResponse getTopic ( final String topicKey ) throws IOException , NovuNetworkException { Response < TopicResponse > response = topicApi . getTopic ( topicKey ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
getGenderByIdCard: public static String getGenderByIdCard ( String idCard ) { String sGender = "N" ; if ( idCard . length ( ) == CHINA_ID_MIN_LENGTH ) { idCard = convert15CardTo18 ( idCard ) ; } String sCardNum = idCard . substring ( 16 , 17 ) ; if ( Integer . parseInt ( sCardNum ) % 2 != 0 ) { sGender = "M" ; } else { sGender = "F" ; } return sGender ;
gameStarted: public void gameStarted ( String room ) { super . gameStarted ( room ) ; getGameUser ( ) . getSteamFriends ( ) . setRichPresence ( "connect" , "--join-room " + room ) ; getGameUser ( ) . getSteamFriends ( ) . setRichPresence (
getRequiredReadPrivilege: public String getRequiredReadPrivilege ( ) { return requiredReadPrivilege ;
sortPathConstraintAttachment: private void sortPathConstraintAttachment ( Skin skin , int slotIndex , Bone slotBone ) { Object [ ] entries = skin . attachments . orderedItems ( ) . items ; for ( int i = 0 , n = skin . attachments . size ; i < n ; i ++ ) {
renderButtons: private void renderButtons ( Table buttons ) { TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; callback . cancelled ( ) ; } } ) ; buttons . add ( cancel ) . size ( 192 , 32 ) . pad ( 8 ) ; TextButton start = new TextButton ( L . get ( "MENU_START" ) , BrainOutClient . Skin , "button-yellow" ) ; start . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pop ( ) ; callback . selected ( getName ( ) , getSettings ( ) , QuickPlayOptionsMenu . this ) ; } } ) ; buttons . add ( start ) . size ( 192 , 32 ) . pad ( 8 ) ;
success: public void success ( Queue < GameUser . WorkshopItem > items , int results , int totalResults ) { renderMaps ( items ) ;
getInt: public int getInt ( String key , int defaultValue ) { String result = getStr ( key , String . valueOf ( defaultValue ) ) ; try {
clear: public void clear ( ) { this . block = null ;
addValue: private void addValue ( String v ) { if ( value . length ( ) >= codeLength ) return ; value = value + v ; beep ( ) ; renderDigits ( ) ; if ( value . length ( ) >= codeLength )
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; timeOfDay = jsonData . getFloat ( "timeOfDay" ) ; timeLength = jsonData . getFloat ( "timeLength" ) ;
getRequiredWritePrivilege: public String getRequiredWritePrivilege ( ) { return requiredWritePrivilege ;
getSpecialNotes: public Array < LocalizedString > getSpecialNotes ( ) { return specialNotes ;
testDeleteAudience: public void testDeleteAudience ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . audiences ( ) . deleteAudience ( "645e0c241a93369ff53f26e0" , options ) ;
all: public ApiCollection < AttributeGroup > all ( ApiOptions options ) throws ApiErrorException , ConnectionException { Class < AttributeGroup > responseModel = ( Class < AttributeGroup > ) ( Class < ? > ) AttributeGroup . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/attribute-groups" ) , query , null , responseModel ) ;
main: public static void main ( String [ ] args ) { List < Student > students = StreamCreation . getStudentsAsList ( ) ; students . stream ( )
EncryptHumanReadable: public static String EncryptHumanReadable ( String data ) { try
onGameStarting: public void onGameStarting ( JSONObject payload ) { if ( Log . INFO ) Log . info ( "Game is being started!" ) ; Gdx . app . postRunnable ( ClanMenu . this :: renderConflictStarting ) ;
delete: public void delete ( Identifier productIdentifier , Identifier imageIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/products/%s/images/%s" , productIdentifier , imageIdentifier ) , query , null , null ) ;
isShowEmpty: public boolean isShowEmpty ( ) { return showEmpty ;
show: public void show ( final View view ) { if ( mBasePopWindow == null ) {
getUserInfo: No method body
nioBufferToProtobufBuffer: static ByteString nioBufferToProtobufBuffer ( ByteBuffer nioBuffer ) { return UnsafeByteOperations . unsafeWrap ( nioBuffer ) ;
getDataSetIndexByLabel: protected int getDataSetIndexByLabel ( List < T > dataSets , String label , boolean ignorecase ) { if ( ignorecase ) { for ( int i = 0 ; i < dataSets . size ( ) ; i ++ ) if ( label . equalsIgnoreCase ( dataSets . get ( i ) . getLabel ( ) ) ) return i ; } else { for ( int i = 0 ; i < dataSets . size ( ) ; i ++ ) if ( label . equals ( dataSets . get ( i ) . getLabel ( ) ) ) return i ; } return - 1 ;
onResume: public void onResume ( ) { super . onResume ( ) ; mCaptureHelper . onResume ( ) ;
failed: No method body
checkLicencePlate: void checkLicencePlate ( ) { assertDoesNotThrow ( ( ) -> CheckLicencePlate . checkLicencePlate ( "AA958LV" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> CheckLicencePlate . checkLicencePlate ( "BO95889" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> CheckLicencePlate . checkLicencePlate ( "1295889" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> CheckLicencePlate . checkLicencePlate ( "AA958L" ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> CheckLicencePlate . checkLicencePlate ( "AA958LVA" ) ) ;
isEnemy: public boolean isEnemy ( ) { return isEnemy ;
getHeight: public int getHeight ( ) { return height ;
onComplete: public void onComplete ( ) { subscriber . onComplete ( ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; if ( jsonData . has ( "group" ) ) { group = jsonData . getString ( "group" ) ; } enabled = jsonData . getBoolean ( "enabled" , enabled ) ; if ( jsonData . has ( "related-items" ) ) { JsonValue relatedItems = jsonData . get ( "related-items" ) ; for ( JsonValue item : relatedItems ) { Content relatedItem = BrainOut . ContentMgr . get ( item . asString ( ) , Content . class ) ; if ( relatedItem == null ) continue ; this . relatedItems . add ( relatedItem ) ; } } this . showRelatedItemsText = jsonData . getBoolean ( "show-related-items-text" , true ) ; this . findLocationFirst = jsonData . getBoolean ( "find-location-first" , false ) ; this . perTaskReward = jsonData . getBoolean ( "perTaskReward" , false ) ; this . perTargetItemReward = jsonData . getBoolean ( "perTargetItemReward" , false ) ; if ( jsonData . has ( "related-locations" ) ) { JsonValue relatedLocations = jsonData . get ( "related-locations" ) ; for ( JsonValue relatedLocation : relatedLocations ) { this . relatedLocations . add ( new LocalizedString ( relatedLocation . asString ( ) ) ) ; } } if ( jsonData . has ( "special-notes" ) ) { JsonValue specialNotes = jsonData . get ( "special-notes" ) ; for ( JsonValue specialNote : specialNotes ) { this . specialNotes . add ( new LocalizedString ( specialNote . asString ( ) ) ) ; } } this . coop = jsonData . getBoolean ( "coop" , coop ) ; this . awardPartner = jsonData . getBoolean ( "awardPartner" , awardPartner ) ; this . hasToLeave = jsonData . getBoolean ( "hasToLeave" , hasToLeave ) ; { tasks . clear ( ) ; JsonValue tasks = jsonData . get ( "tasks" ) ; if ( tasks != null && tasks . isObject ( ) ) { for ( JsonValue taskValue : tasks ) { String clazz = taskValue . getString ( "class" ) ; if ( clazz == null ) throw new RuntimeException ( "No class defined for task" ) ; Object newTask = BrainOut . R . newInstance ( clazz ) ; if ( ! ( newTask instanceof Task ) ) throw new RuntimeException ( "Class " + clazz + " is not a task" ) ; String taskId = getID ( ) + "-" + taskValue . name ( ) ; Task task = ( ( Task ) newTask ) ; task . setId ( taskId ) ; task . setQuest ( this ) ; task . read ( json , taskValue ) ; this . tasks . put ( taskId , task ) ; } } } {
onInit: public void onInit ( ) { BrainOutClient . EventMgr . subscribe ( Event . ID . mapListReceived , this ) ; super . onInit ( ) ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer > 0 ) return ; timer = 0.1f ; ActiveData enemy = checkForEnemies ( ) ; if ( enemy != null ) { pushTask ( new TaskFollowAndKnifeTarget ( getStack ( ) , enemy , new RandomValue ( 0.1f , 0.1f ) , new RandomValue ( 0.1f , 0.1f ) ) ) ; return ; } if ( BrainOutServer . Controller . getGameMode ( ) . isGameActive ( ) )
getRecord: public InventoryRecord getRecord ( ) { return record ;
lockInput: public boolean lockInput ( ) { return true ;
updateRemotePlayers: public void updateRemotePlayers ( Client player ) { Array < RemoteClientsMsg . RemotePlayer > remotePlayers = new Array < > ( ) ; remotePlayers . add ( new RemoteClientsMsg . RemotePlayer ( player . getId ( ) , player . getName ( ) , player . getAvatar ( ) , player . getClanAvatar ( ) , player . getClanId ( ) , player . getTeam ( ) , player . getRights ( ) , player . getInfo ( ) ) ) ; sendTCP ( new RemoteClientsMsg ( remotePlayers ) ) ;
setRequiredWritePrivilege: public void setRequiredWritePrivilege ( String requiredWritePrivilege ) { this . requiredWritePrivilege = requiredWritePrivilege ;
sendToUserChannel: public boolean sendToUserChannel ( User user , String channelName , Object payload ) { checkChannelName ( channelName ) ; sendToUserChannel ( user . getEmail ( ) , channelName , payload ) ; return true ;
chipLost: private void chipLost ( ServerChipSpawnerComponentData spawner , ChipData chipData , PlayerClient playerClient ) { if ( ! chips . contains ( spawner ) ) { return ; } chips . remove ( spawner ) ; spawner . setDeliveredTo ( null ) ; Team lostTeam = activeData . getTeam ( ) ; for ( ObjectMap . Entry < Integer , Client > clientEntry : BrainOutServer . Controller . getClients ( ) )
approve: No method body
apply: public static void apply ( WidgetGroup to , WithBadge badge ) { apply ( to , badge , BrainOutClient . ClientController . getUserProfile ( ) , Mode . hover , DEFAULT_CREATOR ) ;
newBoundingBoxAttachment: public BoundingBoxAttachment newBoundingBoxAttachment ( Skin skin , String name ) { return new BoundingBoxAttachment ( name ) ;
setBinaryStream: public OutputStream setBinaryStream ( long pos ) throws SQLException { return null ;
canZoomInMoreX: public boolean canZoomInMoreX ( ) { return mScaleX < mMaxScaleX ;
keyDown: public boolean keyDown ( int keyCode ) { KeyProperties . Keys action = BrainOutClient . ClientSett . getControls ( ) . getKey ( keyCode ) ; if ( action != null ) { switch ( action ) { case right : { moving = 1 ; return true ; } case left : { moving = - 1 ; return true ; } } } return super . keyDown ( keyCode ) ;
getCurrentEnvironment: public String getCurrentEnvironment ( ) { return currentEnvironment ;
getState: public ControllerState getState ( ) { return state ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { digitsValue = new Table ( ) ; renderDigits ( ) ; data . add ( new BorderActor ( digitsValue ) ) . pad ( 32 ) . row ( ) ; } { Table buttons = new Table ( ) ; addButtonsRow ( buttons , "1" , "2" , "3" ) . row ( ) ; addButtonsRow ( buttons , "4" , "5" , "6" ) . row ( ) ; addButtonsRow ( buttons , "7" , "8" , "9" ) . row ( ) ; addButtonsRow ( buttons , "0" ) . colspan ( 3 ) . row ( ) ; data . add ( new BorderActor ( buttons ) ) . pad ( 32 ) . row ( ) ; } return data ;
getRequiredReadPrivilege: public String getRequiredReadPrivilege ( ) { return requiredReadPrivilege ;
findByBase64UserIdTokenIsValidTrue: default @ NotNull Tuple2 < Token , String > findByBase64UserIdTokenIsValidTrue ( String base64UserIdToken ) { boolean isBasicHeader = base64UserIdToken != null ; if ( ! isBasicHeader ) { return Tuples . of ( null , INVALID ) ; } String base64 = base64UserIdToken . trim ( ) ; boolean isBase64 = Base64 . isBase64 ( base64 ) ; if ( ! isBase64 ) { return Tuples . of ( null , INVALID ) ; } String [ ] idAndToken = new String ( Base64 . decodeBase64 ( base64 ) ) . split ( ":" , 2 ) ; boolean isIdAndToken = idAndToken . length == 2 ; if ( ! isIdAndToken ) { return Tuples . of ( null , INVALID ) ; } String idString = idAndToken [ 0 ] ; String tokenString = idAndToken [ 1 ] ; Long id ; try { id = Long . parseLong ( idString ) ; } catch ( NumberFormatException e ) { return Tuples . of ( null , INVALID ) ; } Tuple t = this . findByUserIdAndTokenWithInvalidationReasons ( id , tokenString ) ; if ( t == null ) { return Tuples . of ( null , INVALID ) ; } Tuple3 < Token , Boolean , Boolean > tokenWithInvalidationReasons = t . getT3 ( ) ; if ( tokenWithInvalidationReasons . getT2 ( ) ) { return Tuples . of ( null , ALREADY_USED ) ; } if ( tokenWithInvalidationReasons . getT3 ( ) ) { return Tuples . of ( null , EXPIRED ) ; } return Tuples . of ( tokenWithInvalidationReasons . getT1 ( ) , "" ) ;
AddParamToRole: No method body
encodeURI: public String encodeURI ( String s ) { try {
getEditorTitle: public String getEditorTitle ( ) { return tag ;
instantiate: protected ObjectPool . Poolable instantiate ( ) { return new ZoomJob ( null , 0 , 0 , 0 , 0 , null , null , null ) ;
jMenuItem4ActionPerformed: private void jMenuItem4ActionPerformed ( java . awt . event . ActionEvent evt ) { UI . createOrContinue ( DearatorUI . class , true , false ) ;
getRecoverySeedString: public String getRecoverySeedString ( Context context ) { recoverySeedString = PreferencesUtils . getRecoverySeedString ( context ) ; if ( recoverySeedString == null ) { recoverySeedString = "" ; } return recoverySeedString ;
lockInput: public boolean lockInput ( ) { return true ;
getArea: public double getArea ( ) { return Math . PI * radius * radius ;
saveSeedChecked: public static void saveSeedChecked ( Context context , Boolean value ) { putBoolean ( SETTINGS , context , SEED_CHECKED , value ) ;
RegisterDimension: private static void RegisterDimension ( String dimension , Map map ) { Dimensions . put ( dimension , map ) ;
getInstrumentLaunch: public BonePointData getInstrumentLaunch ( ) { return instrumentLaunch ;
updateSpectatorInfo: private void updateSpectatorInfo ( ) { rightBottomPanel . clear ( ) ; Label mode = new Label ( L . get ( "MENU_SPECTATING_MODE" ) , BrainOutClient . Skin , "title-yellow" ) ; mode . setAlignment ( Align . center ) ; rightBottomPanel . add ( mode ) . expandX ( ) . fillX ( ) . row ( ) ; if ( Map . GetWatcher ( ) instanceof PlayerSpectator ) { PlayerSpectator spectating = ( ( PlayerSpectator ) Map . GetWatcher ( ) ) ; PlayerData playerData = spectating . getPlayerData ( ) ; if ( playerData . isAlive ( ) ) { int ownerId = playerData . getOwnerId ( ) ; RemoteClient remoteClient = BrainOutClient . ClientController . getRemoteClients ( ) . get ( ownerId ) ; if ( remoteClient != null ) { Label who = new Label ( remoteClient . getName ( ) , BrainOutClient . Skin , "title-small" ) ; who . setAlignment ( Align . center ) ; who . setWrap ( true ) ; rightBottomPanel . add ( who ) . expandX ( ) . fillX ( ) . row ( ) ; } } } final TextButton next = new TextButton ( L . get ( "MENU_NEXT" ) , BrainOutClient . Skin , "button-default" ) ; next . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; spectateNext ( ) ; updateSpectatorInfo ( ) ; } } ) ; rightBottomPanel . add ( next ) . size ( 192 , 64 ) . padTop ( 10 ) . expandX ( ) . fillX ( ) ;
toProtocolFailure: static Protocol . Failure toProtocolFailure ( Throwable throwable ) { if ( throwable instanceof TerminalException ) { return toProtocolFailure ( ( ( TerminalException ) throwable ) . getCode ( ) , throwable . getMessage ( ) ) ; } return toProtocolFailure ( TerminalException . INTERNAL_SERVER_ERROR_CODE , throwable . toString ( ) ) ;
onCreate: public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ;
draw: public String draw ( Curve curve ) { return "i'm a pencil drawing " + curve . draw ( ) ;
hasRender: public boolean hasRender ( ) { return false ;
newAction: protected Action newAction ( ActionType actionType , JsonValue data ) { switch ( actionType )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterInVStop1ActionPerformed ( evt ) ;
getContentBackgroundStyle: protected String getContentBackgroundStyle ( ) { return "form-border-red" ;
pauseDownloading: public void pauseDownloading ( ) { PRDownloader . pause ( downloadingId ) ;
isValid: No method body
getFileLength: public static String getFileLength ( String fileAbs ) { if ( ! StringUtils . isEmpty ( fileAbs ) ) { File file = new File ( fileAbs ) ; if ( file . exists ( ) ) { return getFormatSize ( file . length ( ) ) ; } else { return null ; } } return null ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer > 0 ) return ; timer = 0.3f ; if ( checkWeapons ( false ) ) return ; checkEnemy ( ) ;
getDrawOrders: public int [ ] [ ] getDrawOrders ( ) { return drawOrders ;
setType: public void setType ( String type ) { this . type = type ;
isDashedLineEnabled: public boolean isDashedLineEnabled ( ) { return mDashPathEffect == null ? false : true ;
getIncreasingPaintStyle: public Paint . Style getIncreasingPaintStyle ( ) { return mIncreasingPaintStyle ;
init: public void init ( ) { Array < Upgrade > upgrades = null ; if ( slot . equals ( Constants . Properties . SLOT_PRIMARY ) ) { upgrades = weaponData . getInfo ( ) . upgrades . values ( ) . toArray ( ) ; } Weapon weapon = weaponData . getWeapon ( ) ; initUpgrades ( upgrades ) ; UpgradableProperty resistance = weaponProperties . property ( Constants . Properties . WEAR_RESISTANCE ) ; if ( weapon . hasComponent ( WeaponDurabilityComponent . class ) && resistance != null ) { wearResistance = new UpgradableProperty ( resistance , upgrades ) ; } if ( magazines != null && magazines . size == 0 ) { magazines = new IntMap < > ( ) ; for ( int i = 0 ; i < magazinesCount . asInt ( ) ; i ++ ) { magazines . put ( i , new Magazine ( ) ) ; } } if ( disableWear ( ) ) { stuckIn = null ; } else { if ( weaponData . getOwner ( ) != null ) { originalOwner = BrainOutServer . Controller . getClients ( ) . get ( weaponData . getOwner ( ) . getOwnerId ( ) ) ; if ( originalOwner != null ) { stuckIn . init ( weapon . getID ( ) , originalOwner . getStuckContainer ( ) ) ; } } } if ( forceLoad ( ) || ( BrainOutServer . Settings . isWeaponAutoLoad ( ) && ! loadedFirstTime ) ) { if ( load ( true , false ) ) { if ( weaponProperties . hasChambering ( ) ) { fetch ( false ) ; } } loadedFirstTime = true ; } if ( weaponProperties . isUnlimited ( ) )
act: public void act ( float delta ) { super . act ( delta ) ; update ( this ) ; time -= delta ; if ( time < 0 )
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcStop1ItemStateChanged ( evt ) ;
onCreateView: public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { int layoutId = getLayoutId ( ) ; if ( isContentView ( layoutId ) ) { mRootView = inflater . inflate ( getLayoutId ( ) , container , false ) ; } initUI ( ) ; return mRootView ;
getY: public float getY ( ) { return activeData . getY ( ) ;
findCard: private TableCard findCard ( String card ) { for ( TableCard tableCard : tableCards ) { if ( tableCard . card . equals ( card ) ) return tableCard ; } return null ;
saveRecoverySeedString: public static void saveRecoverySeedString ( Context context , String value ) { putString ( SETTINGS , context , RECOVERY_SEED_STRING , value ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
setConfiguration: No method body
init: No method body
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . brands ( ) . delete ( 1 , options ) ;
getWebViewDownLoadPath: public static String getWebViewDownLoadPath ( Context context ) { return AppUtils . SDCachePath ( context ) + WEB_VIEW_DOWNLOAD_PATH ;
approve: No method body
hasUpdate: public boolean hasUpdate ( ) { return true ;
getFreeHeapMemory: public long getFreeHeapMemory ( ) { return freeHeapMemory ;
set: public void set ( int index , int value ) { if ( index >= v . length ) { int [ ] tmp = new int [ index * 2 ] ; System . arraycopy ( v , 0 , tmp , 0 , v . length ) ; v = tmp ; } v [ index ] = value ;
surfaceCreated: public void surfaceCreated ( SurfaceHolder holder ) { if ( holder == null ) { Log . e ( TAG , "*** WARNING *** surfaceCreated() gave us a null surface!" ) ; } if ( ! hasSurface ) {
refreshView: public static void refreshView ( ) { DiscordTools . HANDLER . post ( ( ) -> {
getCard: public CardData getCard ( CaseData caseData , String dimension ) { return new PartialInstrumentCardData ( this , caseData , dimension ) ;
doCreate: private void doCreate ( ) { if ( create . isDisabled ( ) ) return ; int resizeW , resizeH ; try { resizeW = Integer . valueOf ( widthInput . getText ( ) ) ; resizeH = Integer . valueOf ( heightInput . getText ( ) ) ; } catch ( NumberFormatException ignored ) { canceled ( ) ; return ; } pop ( ) ; callback . create ( name . getText ( ) , resizeW , resizeH ) ;
generateBooster: private void generateBooster ( Table boosters , String icon ) { Image image = new Image ( BrainOutClient . Skin , icon ) ; image . setScaling ( Scaling . none ) ; boosters . add ( image ) . size ( 32 , 32 ) ;
testAllContacts: public void testAllContacts ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < MerchantContact > responseEntity = this . api . merchants ( ) . allContacts ( Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/MerchantAllContactsResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( MerchantContact entity : responseEntity . getEntities ( ) ) {
FindGame: public static void FindGame ( String name , RoomSettings roomSettings , FindGameResult callback , boolean trackStarted ) { LoginService loginService = LoginService . Get ( ) ; GameService gameService = GameService . Get ( ) ; if ( loginService == null ) throw new RuntimeException ( "No login service!" ) ; if ( gameService == null ) throw new RuntimeException ( "No game service!" ) ; GameService . RoomsFilter findFilter = new GameService . RoomsFilter ( ) ; GameService . RoomSettings createSettings = new GameService . RoomSettings ( ) ; roomSettings . write ( findFilter ) ; roomSettings . write ( createSettings ) ; gameService . joinGame ( loginService . getCurrentAccessToken ( ) , name , findFilter , true ,
reset: public void reset ( ) { activeData = null ; action = null ; componentWriter = null ;
getBelowSum: public float getBelowSum ( int stackIndex ) { return getSumBelow ( stackIndex ) ;
getWebSocket: public WebSocket getWebSocket ( ) { return mWebSocket ;
hasUpdate: public boolean hasUpdate ( ) { return BrainOutClient . ClientSett . isLightsEnabled ( ) ;
setList: public void setList ( List < TenantDB > list ) { this . list = list ;
isGameFinished: public boolean isGameFinished ( ) { return getPhase ( ) == GameMode . Phase . finished ;
combinatorsMessage: public static Java . CombinatorAwaitableEntryMessage combinatorsMessage ( Integer ... order ) { return Java . CombinatorAwaitableEntryMessage . newBuilder ( )
runServerSideCode: No method body
error: public void error ( String reason ) { Menu . playSound ( MenuSound . denied ) ;
forward: public void forward ( final @ NonNull JRPCMessage message , final @ NonNull JRPCServerChannelHandler invoker ) { final Message . TargetType targetType = message . targetType ( ) ; final TargetSelector targetSelector = TargetSelectors . getByTargetType ( targetType ) ; Collection < JRPCClientInstance > sendTo = targetSelector . select ( message . target ( ) , getRegisteredClientsRaw ( ) ) ; final String target = ( targetType == Message . TargetType . TYPE || targetType == Message . TargetType . ALL ) ? "*" : message . target ( ) ; if ( sendTo . isEmpty ( ) || sendTo . stream ( ) . noneMatch ( Objects :: nonNull ) ) { final JRPCMessage errorMessage = buildDirectResponse ( new ErrorInformationResponse ( Errors . ERR_NO_TARGET_FOUND , "No suitable target found." ) , message . source ( ) , message . conversationId ( ) ) ; invoker . write ( errorMessage ) ; logger . info ( "{} No suitable target found whilst forwarding message. [Type: {}] [Source: {}] [Target: {}]" , "[MESSAGE FORWARD]" , targetType , message . source ( ) , target ) ; return ; } if ( ! config . isAllowSelfForward ( ) ) { sendTo . removeIf ( jrpcClientInstance -> jrpcClientInstance . getUniqueId ( ) . equals ( message . source ( ) ) ) ; if ( targetType == Message . TargetType . DIRECT && sendTo . isEmpty ( ) ) { logger . warn ( "Client {} tried to forward a message to themselves but allow-self-forward is set to false." , target ) ; final JRPCMessage errorMessage = buildDirectResponse ( new ErrorInformationResponse ( Errors . ERR_SELF_REFERENCE , "Clients are not allowed to directly reference themselves." ) , message . source ( ) , message . conversationId ( ) ) ; invoker . write ( errorMessage ) ; return ; } } sendTo . stream ( ) . filter ( Objects :: nonNull ) . forEach ( jrpcClientInstance -> jrpcClientInstance . getNetHandler ( ) . write ( message ) ) ; logForward ( targetType , message . source ( ) , target , message . data ( ) . length ) ;
onSuccess: No method body
setCenter: void setCenter ( ) { circle . setCenter ( new Point ( 6 , 6 ) ) ; assertEquals ( circle . getCenter ( ) , new Point ( 6 , 6 ) ) ;
getWorkflowOverridesResponse: private BulkWorkflowOverridesResponse getWorkflowOverridesResponse ( ) { BulkWorkflowOverridesResponse bulkWorkflowOverridesResponse = new BulkWorkflowOverridesResponse ( ) ; bulkWorkflowOverridesResponse . setData ( List . of ( getWorkflowOverride ( ) , getWorkflowOverride ( ) ) ) ; bulkWorkflowOverridesResponse . setHasMore ( true ) ; bulkWorkflowOverridesResponse . setPageSize ( 10L ) ; bulkWorkflowOverridesResponse . setPage ( 1L ) ; return bulkWorkflowOverridesResponse ;
getRealFilePath: public static String getRealFilePath ( final Context context , final Uri uri ) { if ( null == uri ) return null ; final String scheme = uri . getScheme ( ) ; String data = null ; if ( scheme == null ) data = uri . getPath ( ) ; else if ( ContentResolver . SCHEME_FILE . equals ( scheme ) ) { data = uri . getPath ( ) ; } else if ( ContentResolver . SCHEME_CONTENT . equals ( scheme ) ) { Cursor cursor = context . getContentResolver ( ) . query ( uri , new String [ ] { MediaStore . Images . ImageColumns . DATA } , null , null , null ) ; if ( null != cursor ) { if ( cursor . moveToFirst ( ) ) { int index = cursor . getColumnIndex ( MediaStore . Images . ImageColumns . DATA ) ; if ( index > - 1 ) { data = cursor . getString ( index ) ; } } cursor . close ( ) ; } } return data ;
getX: public float getX ( ) { return BulletData . this . getX ( ) ;
sendMessageToGPT: No method body
close: public void close ( ) { if ( this . connectedChannel != null ) { connectedChannel . channel ( ) . close ( ) . syncUninterruptibly ( ) ; this . connectedChannel = null ; } try {
render: public void render ( Batch spriteBatch , RenderContext context ) { effect . draw ( spriteBatch ) ;
search: No method body
searchPackages: public void searchPackages ( ) { FileHandle packagesDir = Gdx . files . local ( getPackagesFolder ( ) ) ; if ( packagesDir . isDirectory ( ) )
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , FieldType type , String additionalCss , PrivilegeBase requiredReadPrivilege , BiFunction < OrganizationUser , LongIdEntity , Boolean > canWriteCheck ) { return new FrontendMappingFieldDefinition ( formName , name , type , null , canWriteCheck , requiredReadPrivilege , null , null , null , false , null , null , additionalCss , false , null , null , null , null , null , null , null , null , null , null , false , false ) ;
onProgressInThread: No method body
getAll: public List < MenuDto > getAll ( ) { List < Menu > menuList = this . list ( ) ; List < MenuDto > menuDtos = new ArrayList < > ( ) ; if ( ! CollectionUtils . isEmpty ( menuList ) ) { menuDtos = MenuConverterMapper . INSTANCE . MenuToMenuDtoList ( menuList ) ; menuDtos = getMenuDtos ( menuDtos ) ; } return menuDtos ;
put: public < T > T put ( PageAttr < T > key , T value ) { return ( T ) this . put ( key . name , value ) ;
onSelectedCondition: public void onSelectedCondition ( Object conditionId , String showCondition ) { if ( mShowSelect ) { mTitleCreator . setShowCondition ( mIndex , showCondition ) ; } if ( mCallback != null ) {
checkEnemy: private boolean checkEnemy ( ) { GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; float maxDistance = 64f ; Array < ActiveData > a = getMap ( ) . getActivesForTag ( Constants . ActiveTags . PLAYERS , activeData -> { if ( activeData == getPlayerData ( ) ) return false ; if ( ! ( activeData instanceof PlayerData ) ) return false ; if ( activeData . getOwnerId ( ) >= 0 && getPlayerData ( ) . getOwnerId ( ) >= 0 ) { if ( ! gameMode . isEnemies ( activeData . getOwnerId ( ) , getPlayerData ( ) . getOwnerId ( ) ) ) return false ; ServerTeamVisibilityComponentData cmp = activeData . getComponent ( ServerTeamVisibilityComponentData . class ) ; if ( cmp != null && cmp . isVisibleTo ( getPlayerData ( ) . getOwnerId ( ) ) ) { if ( Vector2 . dst2 ( activeData . getX ( ) , activeData . getY ( ) , watchPoint . x , watchPoint . y ) < 16.0 * 16.0f ) { return true ; } } } else { if ( ! gameMode . isEnemies ( activeData . getTeam ( ) , getPlayerData ( ) . getTeam ( ) ) ) return false ; } return getController ( ) . checkVisibility ( activeData , maxDistance , null ) ; } ) ; if ( a . size > 0 ) { if ( enemyNoticedCallback . noticed ( getStack ( ) , a . first ( ) ) ) { pop ( ) ; } return true ; } return false ;
yes: public void yes ( ) { Gdx . app . postRunnable ( ( ) ->
acceptBasecampToken: public Object acceptBasecampToken ( @ RequestParam ( CODE ) String code , @ RequestParam ( STATE ) Long orgId ) throws Exception { debug ( "[acceptBasecampToken] OrgId: {}" , orgId ) ; integrationService . getBasecampToken ( orgId , code ) ; String configUrl = services . url . moduleSettings ( INTEGRATION , null , orgId ) ; return "generic-forms::go-to(url='" + configUrl + "')" ;
getBegin: public LocalDate getBegin ( ) { return begin ;
setPhone: public void setPhone ( Context context , String phone ) { this . phone = phone ; PreferencesUtils . saveMobileToLocal ( context , phone ) ;
request: public Request request ( ) { return syscalls . request ( ) ;
createComposite: public ProductVariant createComposite ( Identifier productIdentifier , ProductVariant model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ProductVariant > responseModel = ( Class < ProductVariant > ) ( Class < ? > ) ProductVariant . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/products/composite/%s/variants" , productIdentifier ) , query , null , responseModel , model ) ;
addSpoofInfo: private String addSpoofInfo ( String changeDescription ) { debug ( "[addSpoofInfo]" ) ; Long uId = ( Long ) SessionService . getInstance ( ) . getSessionAttribute ( SessionData . SPOOFING_USER ) ; changeDescription = "<b><i>Spoofed by user with id: " + uId + "</b></i></br>" + changeDescription ; return changeDescription ;
setPath: public void setPath ( String path ) { this . path = path ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem4ActionPerformed ( evt ) ;
populateTo: protected EmailConfig populateTo ( EmailConfig entity ) { entity . setHost ( getSafeValue ( entity . getHost ( ) , EMAIL_HOST ) ) ; entity . setPort ( getSafeValue ( entity . getPort ( ) , EMAIL_PORT ) ) ; entity . setUsername ( getSafeValue ( entity . getUsername ( ) , EMAIL_USERNAME ) ) ; entity . setPassword ( getSafeValue ( entity . getPassword ( ) , EMAIL_PASSWORD ) ) ; entity . setFrom ( getSafeValue ( entity . getFrom ( ) , EMAIL_FROM ) ) ; entity . setReplyTo ( getSafeValue ( entity . getReplyTo ( ) , EMAIL_REPLY_TO ) ) ; entity . setSmtpAuth ( getSafeValue ( entity . getSmtpAuth ( ) , EMAIL_SMTP_AUTH ) ) ; entity . setSsl ( getSafeValue ( entity . getSsl ( ) , EMAIL_SSL ) ) ; entity . setStarttls ( getSafeValue ( entity . getStarttls ( ) , EMAIL_STARTTLS ) ) ; entity . setMailgunApiKey ( getSafeValue ( entity . getMailgunApiKey ( ) , EMAIL_MAILGUN_API_KEY ) ) ; return entity ;
onMethodExit: protected void onMethodExit ( int opcode ) { mv . visitVarInsn ( LLOAD , startTimeVarIndex ) ; mv . visitLdcInsn ( ( long ) minCost ) ; mv . visitLdcInsn ( uuid . toString ( ) ) ; mv . visitLdcInsn ( traceId ) ; mv . visitLdcInsn ( className + "#" + method ) ; mv . visitLdcInsn ( ignoreZero ) ; mv . visitMethodInsn ( INVOKESTATIC , "w/core/model/TraceTransformer" , "traceSummary" , "(JJLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)V" , false ) ;
getEffectLayer: public int getEffectLayer ( ) { return particleEffect . getParticle ( ) . getEmitters ( ) . get ( 0 ) . isBehind ( ) ? 0 : 1 ;
loadPdDocuments: No method body
clearCache: public void clearCache ( @ NonNull ClearCacheEvent clearCacheEvent ) { redisTemplate . delete ( clearCacheEvent . getCacheKey ( ) ) ;
getSynced: public static Boolean getSynced ( Context context ) { return getBoolean ( SETTINGS , context , SYNCED ) ;
stopDeceleration: public void stopDeceleration ( ) { mDecelerationAngularVelocity = 0.f ;
failed: public void failed ( String reason ) { renderError ( Request . Result . failed ) ;
getScale: No method body
startCancellable: public void startCancellable ( float time , Runnable complete , Runnable cancelled ) { start ( time , true , complete , cancelled ) ;
resendVerificationEmailUserNull: public void resendVerificationEmailUserNull ( ) { when ( userRepository . findByEmailLowercase ( USER_EMAIL ) ) . thenReturn ( null ) ; boolean result = userService . resendAccountVerificationEmail ( USER_EMAIL ) ; assertFalse ( result ) ;
normalize: public final float normalize ( ) { final float magnitude = length ( ) ; if ( magnitude != 0.0f ) { x /= magnitude ; y /= magnitude ; z /= magnitude ; } return magnitude ;
computeIfAbsent: public V computeIfAbsent ( K key , Function < ? super K , ? extends V > mappingFunction ) { throw new UnsupportedOperationException ( ) ; }
startShootingRange: public boolean startShootingRange ( PlayerClient playerClient , String key , String weapon ) { if ( ! playerClient . isAlive ( ) ) return false ; PlayerData playerData = playerClient . getPlayerData ( ) ; if ( playerData == null ) return false ; ActiveData activeData = null ; for ( Map map : Map . All ( ) ) { activeData = map . getActiveForTag ( Constants . ActiveTags . SHOOTING_RANGE , activeData1 -> { if ( ! ( activeData1 . getContent ( ) instanceof ShootingRange ) ) return false ; ShootingRange shootingRange = ( ( ShootingRange ) activeData1 . getContent ( ) ) ; return shootingRange . getID ( ) . equals ( key ) ; } ) ; if ( activeData != null ) break ; } if ( ! ( activeData instanceof ShootingRangeData ) ) return false ; PlayerAnimationComponentData pac = playerData . getComponent ( PlayerAnimationComponentData . class ) ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; ServerPlayerControllerComponentData pcc = playerData . getComponentWithSubclass ( ServerPlayerControllerComponentData . class ) ; if ( poc == null || pcc == null || pac == null ) return false ; ModePayload modePayload = playerClient . getModePayload ( ) ; if ( ! ( modePayload instanceof LobbyPayload ) ) return false ; LobbyPayload lobbyPayload = ( ( LobbyPayload ) modePayload ) ; if ( lobbyPayload . isInTargetPracticing ( ) ) return false ; ShootingRangeData shootingRangeData = ( ( ShootingRangeData ) activeData ) ; ShootingRange shootingRange = ( ( ShootingRange ) shootingRangeData . getCreator ( ) ) ; if ( shootingRange == null ) return false ; if ( ! shootingRange . hasWeapon ( weapon ) ) return false ; lobbyPayload . setCurrentTarget ( shootingRange . getGroup ( ) ) ; lobbyPayload . setCurrentWeapon ( weapon ) ; ConsumableContainer cc = poc . getConsumableContainer ( ) ; cc . clear ( ) ; ShootingRange . WeaponPreset preset = shootingRange . getWeapons ( ) . get ( weapon ) ; for ( ObjectMap . Entry < ConsumableContent , Integer > item : preset . items ) { cc . putConsumable ( item . value , item . key . acquireConsumableItem ( ) ) ; } InstrumentInfo info = preset . info ; InstrumentData data = info . instrument . getData ( playerData . getDimension ( ) ) ; data . setSkin ( preset . info . skin ) ; for ( ObjectMap . Entry < String , Upgrade > entry : preset . info . upgrades ) { data . getUpgrades ( ) . put ( entry . key , entry . value ) ; } cc . putConsumable ( 1 , new InstrumentConsumableItem ( data , playerData . getDimension ( ) ) ) ; cc . init ( ) ; playerClient . moveTo ( shootingRangeData . getDimension ( ) , shootingRangeData . getX ( ) , shootingRangeData . getY ( ) ) ; BrainOutServer . Timer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { BrainOutServer . PostRunnable ( ( ) -> { playerClient . enablePlayer ( false ) ; playerClient . log ( "Starting shooting range group " + shootingRange . getGroup ( ) + " weapon " + weapon ) ; pcc . consumablesUpdated ( ) ; pcc . selectFirstInstrument ( poc ) ; pac . updated ( playerData ) ; final int WARMUP_TIME = 7 ; TimerTask warmup = new TimerTask ( ) { @ Override public void run ( ) { BrainOutServer . PostRunnable ( ( ) -> { int time = shootingRange . getTime ( ) ; lobbyPayload . startPracticing ( shootingRangeData , time , ServerLobbyRealization . this ) ; playerClient . sendTCP ( new ShootingRangeStartedMsg ( time ) ) ; playerClient . enablePlayer ( true ) ; playerClient . log ( "Shooting range go!" ) ; } ) ; } } ; BrainOutServer . Timer . schedule ( warmup , WARMUP_TIME * 1000L ) ; playerClient . sendTCP ( new ShootingRangeWarmupMsg ( WARMUP_TIME ) ) ; } ) ; } } , 1000 ) ; return true ;
toHex: public static String toHex ( byte [ ] bytes ) { char [ ] hexChars = new char [ bytes . length * 2 ] ; for ( int j = 0 ; j < bytes . length ; j ++ ) { int v = bytes [ j ] & 0xFF ; hexChars [ j * 2 ] = hexArray [ v > > > 4 ] ; hexChars [ j * 2 + 1 ] = hexArray [ v & 0x0F ] ; } return new String ( hexChars ) ;
isDrawBordersEnabled: public boolean isDrawBordersEnabled ( ) { return mDrawBorders ;
getMax: public int getMax ( ) { return max ;
appExit: public void appExit ( Context context ) { try {
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamOutVClose2ItemStateChanged ( evt ) ;
notificationMessage: public String notificationMessage ( ) { return String . format ( "Role: %s.Scope: %s." , name , category ) ;
loadContent: public void loadContent ( AssetManager assetManager ) { super . loadContent ( assetManager ) ; for ( String fileName : fileNames )
changed: public void changed ( ChangeEvent event , Actor actor ) { Menu . playSound ( MenuSound . select ) ; if ( checkBox . getSelected ( ) != anyRegion )
lineToWords: public static List < String > lineToWords ( String line ) { return Arrays . asList ( line . replaceAll ( "[^a-zA-Z ]" , "" ) . toLowerCase ( ) . split ( "\\s+" ) ) ;
channelRead0: protected void channelRead0 ( final ChannelHandlerContext context , final JRPCMessage message ) { try {
newCallback: public static < T > Callback < T > newCallback ( ) { return new Callback < > ( ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
setTitle: public SafeDialogBuilder setTitle ( int titleId ) { super . setTitle ( titleId ) ; return this ;
getAttachmentThreshold: public float getAttachmentThreshold ( ) { return attachmentThreshold ;
worldToLocal: public Vector2 worldToLocal ( Vector2 world ) { if ( world == null ) throw new IllegalArgumentException ( "world cannot be null." ) ; float det = a * d - b * c ; float x = world . x - worldX , y = world . y - worldY ; world . x = ( x * d - y * b ) / det ; world . y = ( y * a - x * c ) / det ; return world ;
release: public void release ( ) { super . release ( ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . socialMessage , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . socialMessageDeleted , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . socialMessageUpdated , this ) ; BrainOut . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
getSound: public Sound getSound ( ) { return sound ;
getLayoutId: No method body
pageList: No method body
asmSubCallStoreParamsString: protected int asmSubCallStoreParamsString ( MethodVisitor mv , int printFormat , String descriptor ) { int _i = subCallParamsToArray ( descriptor ) ; mv . visitVarInsn ( ALOAD , _i ) ; if ( printFormat == 1 ) { mv . visitMethodInsn ( INVOKESTATIC , "java/util/Arrays" , "toString" , "([Ljava/lang/Object;)Ljava/lang/String;" , false ) ; } else { mv . visitMethodInsn ( INVOKESTATIC , "w/Global" , "toJson" , "(Ljava/lang/Object;)Ljava/lang/String;" , false ) ; } int paramsVarIndex = newLocal ( Type . getType ( String . class ) ) ; mv . visitVarInsn ( ASTORE , paramsVarIndex ) ; return paramsVarIndex ;
read: public void read ( JSONObject from ) { ownerName = from . optString ( "ownerName" ) ; ownerId = from . optString ( "ownerId" ) ; ownerLevel = from . optInt ( "ownerLevel" , 1 ) ; xp = from . optInt ( "xp" , 0 ) ; info . instrument = ( ( Instrument ) BrainOut . ContentMgr . get ( from . getString ( "instrument" ) ) ) ; info . skin = ( ( Skin ) BrainOut . ContentMgr . get ( from . getString ( "skin" ) ) ) ; info . upgrades . clear ( ) ; JSONObject upgrades = from . getJSONObject ( "upgrades" ) ; Iterator keys = upgrades . keys ( ) ; while ( keys . hasNext ( ) )
received: public boolean received ( final RemoveObjectMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { Map map = Map . Get ( msg . d ) ; if ( map == null ) return ; ActiveData activeData = map . getActives ( ) . get ( msg . o ) ; if ( activeData == null ) return ; SpriteWithBlocksComponentData spi = activeData . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null ) { SpriteWithBlocksComponent sp = spi . getContentComponent ( ) ; int x_ = ( int ) activeData . getX ( ) , y_ = ( int ) activeData . getY ( ) ; for ( int j = 0 ; j < sp . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < sp . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; map . setBlock ( x , y , null , sp . getBlocksLayer ( ) , false , false ) ; } } map . removeActive ( activeData , true ) ; } else { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { UserSpriteWithBlocksComponent sp = us . getContentComponent ( ) ; int x_ = ( int ) activeData . getX ( ) , y_ = ( int ) activeData . getY ( ) ; for ( int j = 0 ; j < us . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < us . getWidth ( ) ; i ++ ) { int x = x_ + i , y = y_ + j ; map . setBlock ( x , y , null , sp . getBlocksLayer ( ) , false , false ) ; } } map . removeActive ( activeData , true ) ; } } } ) ; return true ;
getOutputAsync: No method body
isItemTaskRelated: public boolean isItemTaskRelated ( ConsumableItem item ) { if ( isComplete ( BrainOutClient . ClientController . getUserProfile ( ) , BrainOutClient . ClientController . getMyAccount ( ) ) ) return false ; ConsumableContent it = getItem ( BrainOutClient . ClientController . getMyAccount ( ) ) ; if ( it == null ) return false ; return item . getContent ( ) . getID ( ) . equals ( it . getID ( ) ) ;
onMoved: public void onMoved ( int fromPosition , int toPosition ) { notifyItemMoved ( fromPosition , toPosition ) ;
getMappingRegistry: MappingRegistry getMappingRegistry ( ) { return this . mappingRegistry ;
AddParamToUser: No method body
doGenerate: private void doGenerate ( ) { ChunkData chunk = this . chunk . get ( ) ; if ( chunk == null ) return ; World world = getWorld ( ) ; if ( world == null ) return ; BodyDef def = new BodyDef ( ) ; def . type = BodyDef . BodyType . StaticBody ; for ( int j = 0 ; j < Constants . Physics . PHYSIC_BLOCK_SIZE ; j ++ ) { int lY = localY * Constants . Physics . PHYSIC_BLOCK_SIZE + j ; int gY = idY * Constants . Physics . PHYSIC_BLOCK_SIZE + j ; Array < BlockData > blocks = chunk . getLayer ( Constants . Layers . BLOCK_LAYER_FOREGROUND ) ; if ( blocks == null ) continue ; for ( int i = 0 , index = chunk . getIndex ( localX * Constants . Physics . PHYSIC_BLOCK_SIZE , lY ) ; i < Constants . Physics . PHYSIC_BLOCK_SIZE ; i ++ , index ++ ) { int gX = idX * Constants . Physics . PHYSIC_BLOCK_SIZE + i ; BlockData blockData = blocks . get ( index ) ; if ( blockData != null && ! blockData . getCreator ( ) . doGeneratePhysics ( ) ) { setFlag ( i , j , false ) ; continue ; } if ( isTriangle ( blockData ) ) { byte mask = blockData . calculateNeighborMask ( chunk . getMap ( ) , gX , gY , Constants . Layers . BLOCK_LAYER_FOREGROUND ) ; switch ( mask ) { case 6 : case 9 : { Body box = world . createBody ( def ) ; EdgeShape poly = new EdgeShape ( ) ; poly . set ( - 0.5f * Constants . Physics . SCALE , - 0.5f * Constants . Physics . SCALE , 0.5f * Constants . Physics . SCALE , 0.5f * Constants . Physics . SCALE ) ; box . setTransform ( ( ( float ) gX + 0.5f ) * Constants . Physics . SCALE , ( ( float ) gY + 0.5f ) * Constants . Physics . SCALE , 0 ) ; box . createFixture ( poly , 1.0f ) ; poly . dispose ( ) ; bodies . add ( box ) ; setFlag ( i , j , false ) ; continue ; } case 3 : case 12 : { Body box = world . createBody ( def ) ; EdgeShape poly = new EdgeShape ( ) ; poly . set ( 0.5f * Constants . Physics . SCALE , - 0.5f * Constants . Physics . SCALE , - 0.5f * Constants . Physics . SCALE , 0.5f * Constants . Physics . SCALE ) ; box . setTransform ( ( ( float ) gX + 0.5f ) * Constants . Physics . SCALE , ( ( float ) gY + 0.5f ) * Constants . Physics . SCALE , 0 ) ; box . createFixture ( poly , 1.0f ) ; poly . dispose ( ) ; bodies . add ( box ) ; setFlag ( i , j , false ) ; continue ; } } } setFlag ( i , j , blockData != null && ! blockData . isFixture ( ) && blockData . getCreator ( ) . hasContact ( ) ) ; } } for ( int j = 0 ; j < Constants . Physics . PHYSIC_BLOCK_SIZE ; j ++ )
isOnMasterOnly: public boolean isOnMasterOnly ( ) { return onMasterOnly ;
render: public Table render ( boolean full ) { Table row = new Table ( BrainOutClient . Skin ) ; row . setBackground ( "form-border-red" ) ; Label textLabel = new Label ( BrainOut . LocalizationMgr . parse ( text ) , BrainOutClient . Skin , "title-gray" ) ; textLabel . setWrap ( true ) ; row . add ( textLabel ) . pad ( 4 ) . expandX ( ) . fillX ( ) . row ( ) ; Table actions = new Table ( ) ; for ( Action action : this . actions ) { Button btn ; if ( action . title != null ) { btn = new TextButton ( action . title , BrainOutClient . Skin , action . style ) ; } else { btn = new ImageButton ( BrainOutClient . Skin , action . style ) ; } btn . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( Menu . MenuSound . select ) ; action . callback . run ( btn ) ; } } ) ; actions . add ( btn ) . minWidth ( 96 ) . pad ( 4 ) ; } row . add ( actions ) . width ( ClientConstants . Menu . Chat . WIDTH - 30 ) . fillX ( ) . row ( ) ; return row ;
getItems: public ObjectMap < String , Content > getItems ( ) { return items ;
isHasChildFile: public boolean isHasChildFile ( ) { return hasChildFile ;
onTouchEvent: public boolean onTouchEvent ( MotionEvent ev ) { switch ( ev . getAction ( ) ) { case MotionEvent . ACTION_DOWN : stopRoll ( ) ; mPressX = ev . getX ( ) ; break ; case MotionEvent . ACTION_UP : performClick ( ) ; startRollDelayed ( ) ; if ( Math . abs ( ev . getX ( ) - mPressX ) < 25 ) { if ( mAdapter . getPageCount ( ) > 0 ) { int position = getCurrentItem ( ) % mAdapter . getPageCount ( ) ; if ( mBannerItemClickListener != null ) { mBannerItemClickListener . onItemClick ( position ) ; } } } break ; } return super . onTouchEvent ( ev ) ;
attachMagazine: public void attachMagazine ( int rounds , int quality ) { if ( ! isDetached ( ) ) return ; attachedMagazine = new Magazine ( rounds , quality ) ;
testDiscovery: public void testDiscovery ( ) throws IOException { BaseRestateLambdaHandler handler = new MyServicesHandler ( ) ; APIGatewayProxyRequestEvent request = new APIGatewayProxyRequestEvent ( ) ; request . setPath ( "/a/path/prefix/discover" ) ; request . setHeaders ( Map . of ( "accept" , ProtoUtils . serviceProtocolDiscoveryContentTypeHeader ( ) ) ) ; APIGatewayProxyResponseEvent response = handler . handleRequest ( request , mockContext ( ) ) ; assertThat ( response . getStatusCode ( ) ) . isEqualTo ( 200 ) ; assertThat ( response . getHeaders ( ) ) . containsEntry ( "content-type" , ProtoUtils . serviceProtocolDiscoveryContentTypeHeader ( ) ) ; assertThat ( response . getIsBase64Encoded ( ) ) . isTrue ( ) ; byte [ ] decodedStringResponse = Base64 . getDecoder ( ) . decode ( response . getBody ( ) ) ; EndpointManifestSchema discoveryResponse = new ObjectMapper ( ) . readValue ( decodedStringResponse , EndpointManifestSchema . class ) ; assertThat ( discoveryResponse . getServices ( ) )
getCustomData: public Map < String , Object > getCustomData ( String shopKey ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "get" , this . resolvePath ( "/shops/%s/custom-data" , shopKey ) , null , null , responseModel ) ;
ready: private void ready ( boolean ready ) { BrainOutClient . ClientController . sendTCP ( new ReadyMsg ( ready ) ) ;
onResponse: public void onResponse ( byte [ ] bytes ) { try {
init: private Event init ( String detectClass , ActiveData detected , EventKind eventKind ) { this . detectClass = detectClass ; this . detected = detected ; this . eventKind = eventKind ; return this ;
switchDimension: private void switchDimension ( EditorMap map ) { this . map = map ; setEditorMode ( EditorMode . Mode . blocks ) ; Map . SetWatcher ( getEditorWatcher ( ) ) ;
compare: No method body
deleteWhite: public void deleteWhite ( @ NonNull Long whiteId ) { eventPublisher . publishEvent ( new ClearCacheEvent ( SystemDictConstants . WHITE ) ) ; Assert . isTrue ( this . baseMapper . deleteById ( whiteId ) > 0 , "删除白名单失败！" ) ;
addInterest: void addInterest ( ) { bankAccount . addInterest ( ) ; assertEquals ( 1020 , bankAccount . getBalance ( ) ) ;
setDefaultState: public void setDefaultState ( ) { setStyle ( BrainOutClient . Skin . get ( "button-default" , TextButton . TextButtonStyle . class ) ) ; setText ( price + " RU" ) ;
unloadPackages: public void unloadPackages ( boolean clearDefines ) { unloadPackages ( clearDefines , null ) ;
init: public void init ( ) { dirty = new ObjectSet < > ( ) ; random = new Random ( ) ; final int mapWidth = map . getBlocks ( ) . getWidth ( ) , mapHeight = map . getBlocks ( ) . getHeight ( ) ; if ( cacheGrid != null ) { cacheGrid . clear ( ) ; } cacheGrid = new Array < > ( ) ; cacheGridWidth = mapWidth / CACHE_GRID_SIZE ; cacheGridHeight = mapHeight / CACHE_GRID_SIZE ; cacheGrid . setSize ( cacheGridWidth * cacheGridHeight ) ;
getSpacing: public float getSpacing ( ) { return spacing ;
getEditorWatcher: private EditorWatcher getEditorWatcher ( ) { return map . getEditorWatcher ( ) ;
test_getWorkflowOverrides: public void test_getWorkflowOverrides ( ) throws IOException , NovuNetworkException , InterruptedException { BulkWorkflowOverridesResponse workflowOverridesResponse = getWorkflowOverridesResponse ( ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( workflowOverridesResponse ) ) ) ; GetWorkflowOverrideRequest getWorkflowOverrideRequest = new GetWorkflowOverrideRequest ( ) ; getWorkflowOverrideRequest . setPage ( 1 ) ; getWorkflowOverrideRequest . setLimit ( 10 ) ; BulkWorkflowOverridesResponse response = workflowOverrideHandler . getWorkflowOverrides ( getWorkflowOverrideRequest ) ; assertNotNull ( response ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/workflow-overrides?limit=10&page=1" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( workflowOverridesResponse ) , gson . toJson ( response ) ) ;
start: public void start ( ) { try { watchService = FileSystems . getDefault ( ) . newWatchService ( ) ; Paths . get ( rootPath ) . register ( watchService , new WatchEvent . Kind [ ] { ENTRY_CREATE , ENTRY_MODIFY , ENTRY_DELETE } , HIGH , FILE_TREE ) ; } catch ( IOException e ) { logger . error ( "Start file watch service fail." , e ) ; } List < String > listenerNames = listeners . stream ( ) . map ( FileChangedListener :: toString ) . collect ( Collectors . toList ( ) ) ; String listenerNameStr = String . join ( COMMA , listenerNames ) ; logger . info ( "JdkFileWatchService Started in path {} with {} listeners {}." , rootPath , listenerNames . size ( ) , listenerNameStr ) ; Thread fileMonitorThread = new Thread ( ( ) -> { while ( true ) { try { WatchKey watchKey = watchService . poll ( 3 , TimeUnit . SECONDS ) ; if ( watchKey == null ) { continue ; } List < WatchEvent < ? > > events = watchKey . pollEvents ( ) ; for ( WatchEvent < ? > event : events ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( event . context ( ) == null || watchKey . watchable ( ) == null || event . count ( ) > 1 || kind == OVERFLOW ) { continue ; } String fileName = event . context ( ) . toString ( ) ; if ( fileName . endsWith ( TILDE ) || fileName . startsWith ( DOT ) ) { continue ; } File file = new File ( watchKey . watchable ( ) + File . separator + fileName ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "[{}] monitor file {} {}." , event . count ( ) , kind , file ) ; } if ( file . isDirectory ( ) ) { continue ; } listeners . stream ( ) . filter ( listener -> listener . isSuitable ( file ) ) . forEach ( listener -> { if ( kind == ENTRY_CREATE ) { listener . createdHandle ( file ) ; } else if ( kind == ENTRY_MODIFY ) { listener . modifiedHandle ( file ) ; } } ) ; } watchKey . reset ( ) ; } catch ( Throwable e ) { logger . error ( "File monitor handle event failed." , e ) ; } } } ) ; fileMonitorThread . setDaemon ( true ) ; fileMonitorThread . start ( ) ;
error: public void error ( String reason ) { waitLoadingMenu . pop ( ) ; gs . popMenu ( SelectTeamMenu . this ) ; select . failed ( reason ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { tgValvesClose12ItemStateChanged ( evt ) ;
hasProgress: public boolean hasProgress ( ) { return true ;
getNew: public T getNew ( ) { return wrapped . getNew ( ) ;
createEnvironment: public SingleEnvironmentResponse createEnvironment ( final CreateEnvironmentRequest request ) throws IOException , NovuNetworkException { Response < SingleEnvironmentResponse > response = environmentApi . createEnvironment ( request ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
hasRender: public boolean hasRender ( ) { return false ;
checkVersion: public static void checkVersion ( Context context ) { int localVersion = PreferencesUtils . getVersionFromLocal ( context ) ; int currentVersion = AppUtils . getAppVersionCode ( context ) ; if ( currentVersion > localVersion ) {
done: public void done ( T result ) { onFinally . call ( result ) ;
selected: No method body
build: public WsManager build ( ) { return new WsManager ( this ) ;
from: public static < T > T from ( String jsonString , Class < T > t ) { return gson . fromJson ( jsonString , t ) ;
translate: public void translate ( int dx , int dy ) { center . translate ( dx , dy ) ;
send: public void send ( Cancellation model ) throws ApiErrorException , ConnectionException { this . request ( "post" , this . resolvePath ( "/fulfillment/cancellations" ) , null , null , null , model ) ;
release: public void release ( ) { super . release ( ) ; stop ( ) ;
getPrice: private Store . Tier . Price getPrice ( ) { Store . Item . Billing billing = item . getBilling ( ) ; return billing . getTier ( ) . getPrices ( ) . getOrDefault (
show: public void show ( final View view , String address , long assetId , String invoiceAddr ) { if ( mBasePopWindow == null ) {
divisionSquaredTest: void divisionSquaredTest ( ) { assertEquals ( 4 , DivisionSquared . divisionSquared ( 4 , 2 ) ) ; assertEquals ( 4 , DivisionSquared . divisionSquared ( - 8 , 4 ) ) ; assertEquals ( 0 , DivisionSquared . divisionSquared ( 4 , 0 ) ) ; assertEquals ( 0 , DivisionSquared . divisionSquared ( - 8 , 0 ) ) ;
hasRender: public boolean hasRender ( ) { return false ;
removeFile: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { rodsOut1ActionPerformed ( evt ) ;
run: public void run ( ) { if ( volume != 0 )
initWith: private void initWith ( Context context , AttributeSet attrs ) { final TypedArray typedArray = context . obtainStyledAttributes ( attrs , ColorPickerConstants . getDeclaredPickerAttributes ( ) ) ; try { alphaSlider = typedArray . getBoolean ( R . styleable . ColorPickerPreference_alphaSlider , false ) ; lightSlider = typedArray . getBoolean ( R . styleable . ColorPickerPreference_lightnessSlider , false ) ; border = typedArray . getBoolean ( R . styleable . ColorPickerPreference_border , true ) ; density = typedArray . getInt ( R . styleable . ColorPickerPreference_density , 8 ) ; wheelType = ColorPickerView . WHEEL_TYPE . indexOf ( typedArray . getInt ( R . styleable . ColorPickerPreference_wheelType , 0 ) ) ; selectedColor = typedArray . getInt ( R . styleable . ColorPickerPreference_initialColor , 0xffffffff ) ; pickerColorEdit = typedArray . getBoolean ( R . styleable . ColorPickerPreference_pickerColorEdit , true ) ; pickerTitle = typedArray . getString ( R . styleable . ColorPickerPreference_pickerTitle ) ; if ( pickerTitle == null ) pickerTitle = "Choose color" ; pickerButtonCancel = typedArray . getString ( R . styleable . ColorPickerPreference_pickerButtonCancel ) ; if ( pickerButtonCancel == null ) pickerButtonCancel = "cancel" ; pickerButtonOk = typedArray . getString ( R . styleable . ColorPickerPreference_pickerButtonOk ) ; if ( pickerButtonOk == null ) pickerButtonOk = "ok" ; } finally { typedArray . recycle ( ) ; } setWidgetLayoutResource ( ColorPickerConstants . LAYOUT_COLOR_WIDGET ) ;
onReceive: public void onReceive ( Context context , Intent intent ) { long appId = intent . getLongExtra ( DownloadManager . EXTRA_DOWNLOAD_ID , - 1 ) ; if ( appId != - 1 && appId == mAppId ) { registerPackAddedReceiver ( context ) ; if ( ! StringUtils . isEmpty ( fileName ) && fileName . endsWith ( "apk" ) ) { openFileFromSDCard ( WebViewConfig . getWebViewDownLoadPath ( mContext ) , fileName , mimeType ) ; } else { ToastUtils . showToast ( mContext , fileName + "下载成功" ) ; } } unRegisterDownLoadSuccessReceiver ( context ) ;
triggerRebirth: public static void triggerRebirth ( Context context ) { triggerRebirth ( context , getRestartIntent ( context ) ) ;
getID: public String getID ( ) { return background . getID ( ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
getOutput: default Output < Res > getOutput ( ) throws IngressException { return getOutput ( RequestOptions . DEFAULT ) ;
getWorkflowGroup: public WorkflowGroupResponse getWorkflowGroup ( final String id ) throws NovuNetworkException , IOException { return restHandler . extractResponse ( this . workflowGroupApi . getWorkflowGroup ( id ) . execute ( ) ) ;
removeClusterAware: public boolean removeClusterAware ( long formId ) { debug ( "[removeClusterAware] {}" , formId ) ; if ( ClusterHelper . isCluster ( ) ) { return clusterEventSenderService . removeForm ( formId ) ; } return removeForm ( formId ) ;
getGuildId: public final Long getGuildId ( ) { return this . guildId ;
getBubbleData: No method body
getFlipX: public boolean getFlipX ( ) { return false ;
test_updateSubscriberPreferences: public void test_updateSubscriberPreferences ( ) throws IOException , NovuNetworkException , InterruptedException { UpdateSubscriberPreferenceRequest request = new UpdateSubscriberPreferenceRequest ( ) ; request . setEnabled ( false ) ; SingleSubscriberPrefResponse preferenceResponse = new SingleSubscriberPrefResponse ( ) ; SubscriberPreference subscriberPreference = new SubscriberPreference ( ) ; Preference preference = new Preference ( ) ; preference . setEnabled ( false ) ; subscriberPreference . setPreference ( preference ) ; preferenceResponse . setData ( subscriberPreference ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( preferenceResponse ) ) ) ; SingleSubscriberPrefResponse response = subscribersHandler . updateSubscriberPreferences ( request , "sId" , "tId" ) ; assertNotNull ( response ) ; final RecordedRequest recordedRequest = mockWebServer . takeRequest ( ) ; assertEquals ( "/subscribers/sId/preferences/tId" , recordedRequest . getPath ( ) ) ; assertEquals ( "PATCH" , recordedRequest . getMethod ( ) ) ; assertEquals ( preferenceResponse , response ) ;
delFile: public static boolean delFile ( String path ) { if ( StringUtils . isEmpty ( path ) ) { return false ; } File file = new File ( path ) ; if ( file . exists ( ) ) { return file . delete ( ) ; } return false ;
notifyDataSetChanged: public void notifyDataSetChanged ( ) { mBannerVp . notifyDataSetChanged ( ) ; initDotIndicator ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; JSONObject args = new JSONObject ( ) ; args . put ( "id" , task . getID ( ) ) ; WaitLoadingMenu loadingMenu = new WaitLoadingMenu ( "" ) ; BrainOutClient . getInstance ( ) . topState ( ) . pushMenu ( loadingMenu ) ; BrainOutClient . SocialController . sendRequest ( "skip_contract" , args ,
toDebugJson: public static String toDebugJson ( Map < String , Object > model ) { PageModelMap pageModelMap = new PageModelMap ( ) ; for ( Map . Entry < String , Object > e : model . entrySet ( ) ) { if ( PageAttr . getByName ( e . getKey ( ) ) != null ) { pageModelMap . put ( e . getKey ( ) , e . getValue ( ) ) ; } } pageModelMap . remove ( PageAttributes . modelAndView ) ; try {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jRadioButtonMenuItem4ActionPerformed ( evt ) ;
updateWeight: public void updateWeight ( ) { weight = 0 ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : data )
hasUpdate: public boolean hasUpdate ( ) { return false ;
getBalance: public int getBalance ( ) { return balance ;
findAllGlobalRoles: No method body
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { super . write ( json , componentWriter , owner ) ; json . writeObjectStart ( "defines" ) ; for ( ObjectMap . Entry < String , String > entry : BrainOutServer . PackageMgr . getDefines ( ) ) { json . writeValue ( entry . key , entry . value ) ; } json . writeObjectEnd ( ) ; json . writeArrayStart ( "packages" ) ; for ( ObjectMap . Entry < String , ContentPackage > entry : BrainOut . PackageMgr . getPackages ( ) ) { json . writeObjectStart ( ) ; json . writeValue ( "name" , entry . key ) ; json . writeValue ( "version" , entry . value . getVersion ( ) ) ; long crc32 = entry . value . getCRC32 ( ) ; json . writeValue ( "crc32" , crc32 , Long . class ) ; json . writeObjectEnd ( ) ; } json . writeArrayEnd ( ) ;
reactivate: private void reactivate ( ) { WaitLoadingMenu waitLoadingMenu = new WaitLoadingMenu ( "" ) ; pushMenu ( waitLoadingMenu ) ; JSONObject args = new JSONObject ( ) ; BrainOutClient . SocialController . sendRequest ( "reactivate" , args ,
validateBlock: private boolean validateBlock ( Block block ) { return block . hasComponent ( IconComponent . class ) && block . hasComponent ( Editor2EnabledComponent . class ) ;
updateContent: private void updateContent ( ) { content . clear ( ) ; items . clear ( ) ; for ( final ConsumableRecord c : available )
renderButtons: private void renderButtons ( Table buttons ) { { TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . back ) ; pop ( ) ; } } ) ; buttons . add ( cancel ) . expand ( ) . fill ( ) . uniformX ( ) ; } {
canceled: private void canceled ( ) { pop ( ) ;
setAnimation: public TrackEntry setAnimation ( int trackIndex , String animationName , boolean loop ) { Animation animation = data . skeletonData . findAnimation ( animationName ) ; if ( animation == null ) throw new IllegalArgumentException ( "Animation not found: " + animationName ) ; return setAnimation ( trackIndex , animation , loop ) ;
importPublicKey: No method body
render: public void render ( Data from , Table to ) { String value = String . format ( "%.2f" , from . getData ( ) ) ; if ( suffix != null ) { value += " " + L . get ( suffix ) ; } Label valueLabel = new Label ( value , BrainOutClient . Skin , "title-small" ) ; valueLabel . setAlignment ( Align . right ) ; to . add ( valueLabel ) . expandX ( ) . fillX ( ) ;
addingTaskKeepsObjectModelOK: void addingTaskKeepsObjectModelOK ( ) { project . addTask ( task ) ; assertTrue ( project . getTasks ( ) . contains ( task ) ) ; assertEquals ( task . getProject ( ) , project ) ;
get: public T get ( String key , T def ) { return values . get ( key , def ) ;
handleHiddenChannelClick: public static boolean handleHiddenChannelClick ( Context context , Channel channel ) { try {
removeHtmlTextBottomLine: public static void removeHtmlTextBottomLine ( TextView textView ) { Spannable s = new Spannable . Factory ( ) . newSpannable ( textView . getText ( ) ) ; URLSpan [ ] spans = s . getSpans ( 0 , s . length ( ) , URLSpan . class ) ; for ( URLSpan span : spans ) { int start = s . getSpanStart ( span ) ; int end = s . getSpanEnd ( span ) ; s . removeSpan ( span ) ; span = new URLSpanNoUnderline ( span . getURL ( ) ) ; s . setSpan ( span , start , end , 0 ) ; } textView . setText ( s ) ;
updateStats: protected void updateStats ( ) { super . updateStats ( ) ; if ( getGameMode ( ) . isGameActive ( false , false ) ) { updateCurrentState ( ) ; } if ( stats != null )
getDataSetForEntry: public T getDataSetForEntry ( Entry e ) { if ( e == null ) return null ; for ( int i = 0 ; i < mDataSets . size ( ) ; i ++ ) { T set = mDataSets . get ( i ) ; for ( int j = 0 ; j < set . getEntryCount ( ) ; j ++ ) { if ( e . equalTo ( set . getEntryForXValue ( e . getX ( ) , e . getY ( ) ) ) ) return set ; } } return null ;
deleteTenant: public DeleteTenantResponse deleteTenant ( final String identifier ) throws IOException , NovuNetworkException { try {
javassistTest: public void javassistTest ( ) throws IOException , InterruptedException { ChangeResultMessage msg = new ChangeResultMessage ( ) ; msg . setClassName ( "w.core.ChangeTarget" ) ; msg . setMethod ( "addWrapper" ) ; msg . setParamTypes ( Arrays . asList ( "int" , "int" ) ) ; msg . setInnerMethod ( "add" ) ; msg . setInnerClassName ( "*" ) ; msg . setBody ( "{try { $_ = 0;} catch (Exception e) {$_ = 1;}}" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; System . out . println ( target . addWrapper ( 1 , 1 ) ) ;
setUserId: public void setUserId ( Long userId ) { this . userId = userId ;
addMapping: public void addMapping ( String discriminatorValue , String className ) { this . mapping . put ( discriminatorValue , className ) ;
updateWorldTransform: public void updateWorldTransform ( float x , float y , float rotation , float scaleX , float scaleY , float shearX , float shearY ) { ax = x ; ay = y ; arotation = rotation ; ascaleX = scaleX ; ascaleY = scaleY ; ashearX = shearX ; ashearY = shearY ; Bone parent = this . parent ; if ( parent == null ) { Skeleton skeleton = this . skeleton ; float rotationY = rotation + 90 + shearY , sx = skeleton . scaleX , sy = skeleton . scaleY ; a = cosDeg ( rotation + shearX ) * scaleX * sx ; b = cosDeg ( rotationY ) * scaleY * sx ; c = sinDeg ( rotation + shearX ) * scaleX * sy ; d = sinDeg ( rotationY ) * scaleY * sy ; worldX = x * sx + skeleton . x ; worldY = y * sy + skeleton . y ; return ; } float pa = parent . a , pb = parent . b , pc = parent . c , pd = parent . d ; worldX = pa * x + pb * y + parent . worldX ; worldY = pc * x + pd * y + parent . worldY ; switch ( data . transformMode ) { case normal : { float rotationY = rotation + 90 + shearY ; float la = cosDeg ( rotation + shearX ) * scaleX ; float lb = cosDeg ( rotationY ) * scaleY ; float lc = sinDeg ( rotation + shearX ) * scaleX ; float ld = sinDeg ( rotationY ) * scaleY ; a = pa * la + pb * lc ; b = pa * lb + pb * ld ; c = pc * la + pd * lc ; d = pc * lb + pd * ld ; return ; } case onlyTranslation : { float rotationY = rotation + 90 + shearY ; a = cosDeg ( rotation + shearX ) * scaleX ; b = cosDeg ( rotationY ) * scaleY ; c = sinDeg ( rotation + shearX ) * scaleX ; d = sinDeg ( rotationY ) * scaleY ; break ; } case noRotationOrReflection : { float s = pa * pa + pc * pc , prx ; if ( s > 0.0001f ) { s = Math . abs ( pa * pd - pb * pc ) / s ; pa /= skeleton . scaleX ; pc /= skeleton . scaleY ; pb = pc * s ; pd = pa * s ; prx = atan2 ( pc , pa ) * radDeg ; } else { pa = 0 ; pc = 0 ; prx = 90 - atan2 ( pd , pb ) * radDeg ; } float rx = rotation + shearX - prx ; float ry = rotation + shearY - prx + 90 ; float la = cosDeg ( rx ) * scaleX ; float lb = cosDeg ( ry ) * scaleY ; float lc = sinDeg ( rx ) * scaleX ; float ld = sinDeg ( ry ) * scaleY ; a = pa * la - pb * lc ; b = pa * lb - pb * ld ; c = pc * la + pd * lc ; d = pc * lb + pd * ld ; break ; } case noScale : case noScaleOrReflection : { float cos = cosDeg ( rotation ) , sin = sinDeg ( rotation ) ; float za = ( pa * cos + pb * sin ) / skeleton . scaleX ; float zc = ( pc * cos + pd * sin ) / skeleton . scaleY ; float s = ( float ) Math . sqrt ( za * za + zc * zc ) ; if ( s > 0.00001f ) s = 1 / s ; za *= s ; zc *= s ; s = ( float ) Math . sqrt ( za * za + zc * zc ) ; if ( data . transformMode == TransformMode . noScale && ( pa * pd - pb * pc < 0 ) != ( skeleton . scaleX < 0 != skeleton . scaleY < 0 ) ) s = - s ; float r = PI / 2 + atan2 ( zc , za ) ; float zb = cos ( r ) * s ; float zd = sin ( r ) * s ; float la = cosDeg ( shearX ) * scaleX ; float lb = cosDeg ( 90 + shearY ) * scaleY ; float lc = sinDeg ( shearX ) * scaleX ; float ld = sinDeg ( 90 + shearY ) * scaleY ; a = za * la + zb * lc ; b = za * lb + zb * ld ; c = zc * la + zd * lc ; d = zc * lb + zd * ld ; break ; } } a *= skeleton . scaleX ; b *= skeleton . scaleX ; c *= skeleton . scaleY ; d *= skeleton . scaleY ;
updateSteamInflow: public void updateSteamInflow ( double flow , double tempC ) { double [ ] inflowData = NPPMath . mixWater ( steamInflow , steamInflowTemperature , flow , tempC ) ; steamInflow = inflowData [ 0 ] ; steamInflowTemperature = inflowData [ 1 ] ;
reset: public void reset ( ) { this . bulletData = null ; this . x = 0 ; this . y = 0 ; this . collider = null ; this . colliderName = null ;
run: public void run ( ) { BrainOutServer . PostRunnable ( ( ) ->
bumpFee: No method body
reset: public void reset ( ) { this . team = null ;
requiresFileUpload: public boolean requiresFileUpload ( ) { return Arrays . stream ( frontendMappingDefinition . fields ) . anyMatch ( a -> a . isFileUpload ( this ) ) ;
toAuditString: public String toAuditString ( ) { return " ID: " + id ;
setImmersive: private void setImmersive ( D params ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . KITKAT ) { return ; } StatusBarUtil . setStatusBarTopViewHeight ( params . mContext , getView ( R . id . view_top_bar ) ) ;
onClientDeath: public void onClientDeath ( Client playerClient , Client playerKiller , PlayerData playerData , InstrumentInfo info ) { super . onClientDeath ( playerClient , playerKiller , playerData , info ) ; if ( ! getGameMode ( ) . isGameActive ( false , false ) ) return ; if ( playerClient == null || playerKiller == null ) return ; boolean knife = info != null && info . instrument != null && "slot-melee" . equals ( info . instrument . getSlot ( ) . getID ( ) ) ; if ( playerKiller != playerClient ) { if ( knife ) { ModePayload modePayload = playerClient . getModePayload ( ) ; if ( modePayload instanceof GunGamePayload ) { GunGamePayload gg = ( ( GunGamePayload ) modePayload ) ; if ( gg . demote ( ) ) { giveRankWeapon ( playerClient , true ) ; } } } ModePayload modePayload = playerKiller . getModePayload ( ) ; if ( modePayload instanceof GunGamePayload ) { GunGamePayload gg = ( ( GunGamePayload ) modePayload ) ; if ( gg . getRank ( ) == getGameMode ( ) . getGunGameWeapons ( ) . size - 1 ) { playerWon = playerKiller . getId ( ) ; complete = true ; } else { if ( gg . promote ( knife ) ) { giveRankWeapon ( playerKiller , true ) ; playerKiller . addStat ( "gungame-levelup" , 1 ) ; if ( gg . getRank ( ) == 15 ) { playerKiller . addStat ( "gungame-levelup-15" , 1 ) ; } playerKiller . notify ( NotifyAward . rankUp , 0 , NotifyReason . gunGameLevelUpgrade , NotifyMethod . message , new RankND ( gg . getRank ( ) , getGameMode ( ) . getGunGameWeapons ( ) . size - 1 ) , true ) ; } } } } updated ( ) ;
getMenuDict: void getMenuDict ( ) throws JsonProcessingException { List < MenuDictDto > menuDict = menuService . getMenuDict ( ) ; assertNotNull ( menuDict ) ; log . info ( "获取菜单字典方法测试成功:{}" , objectMapper . writeValueAsString ( menuDict ) ) ;
isAtBottom: public final boolean isAtBottom ( ) { return this . isAtBottom ;
endLaunching: private void endLaunching ( ) { launching = false ;
getDefaultValue: public String getDefaultValue ( ) { String val = definition . substring ( definition . indexOf ( "DEFAULT" ) ) ; val = val . substring ( val . indexOf ( " " ) + 1 ) ; if ( val . contains ( " " ) ) val = val . substring ( 0 , val . indexOf ( " " ) ) ; return UString . removeOuterQuotes ( val ) ;
renderButton: protected void renderButton ( Table buttons , TextButton btn ) { buttons . add ( btn ) . size ( 192 , 64 ) . pad ( 16 ) ;
deleteWhite: No method body
init: public void init ( ) { BrainOutClient . EventMgr . subscribe ( Event . ID . settingsUpdated , this ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . simple , this ) ;
getName: public String getName ( ) { return name ;
isEnclosed: private boolean isEnclosed ( ) { LaunchData launchData = getLaunchData ( ) ; Map map = Map . Get ( launchData . getDimension ( ) ) ; if ( map == null ) return false ; return map . getWidth ( ) <= 64 ;
fetchWalletBalance: public void fetchWalletBalance ( ) { LightningOuterClass . WalletBalanceByAddressRequest walletBalanceByAddressRequest = LightningOuterClass . WalletBalanceByAddressRequest . newBuilder ( ) . setAddress ( User . getInstance ( ) . getWalletAddress ( mContext ) ) . build ( ) ; Obdmobile . oB_WalletBalanceByAddress ( walletBalanceByAddressRequest . toByteArray ( ) , new Callback ( ) {
getValue: public int getValue ( ) { int val = this . value ^ 0xA9B8C7D6 ; return
clicked: public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; pop ( ) ; ok ( ) ;
setCallback: public void setCallback ( VerifyImageDialogCallback callback ) { this . mCallback = callback ;
setSellDate: public void setSellDate ( LocalDateTime createdOn ) { this . createdOn = createdOn ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamInVStop1ActionPerformed ( evt ) ;
cantSpawn: protected void cantSpawn ( ) { sendTCP ( new ErrorMsg ( ErrorMsg . Code . cantSpawn ) ) ; teamChanged ( getTeam ( ) ) ;
restPost: public Map restPost ( String url , Map < String , String > body , Map < String , String > headers ) { return restClientService . post ( url , body , headers ) ;
setInt: public void setInt ( int intValue ) { this . intValue = intValue ;
initClientInstance: public static BrainOutClient initClientInstance ( ClientEnvironment env , ClientSettings clientSettings ) { instance = new BrainOutClient ( env , clientSettings ) ; return ( BrainOutClient ) instance ;
mouseMove: public boolean mouseMove ( Vector2 position ) { if ( getMenu ( ) . getDragAndDrop ( ) . isDragging ( ) ) return false ; ActiveData activeData = checkBlock ( position ) ; if ( activeData != null )
setUpRightPanel: protected void setUpRightPanel ( Table rightContent ) { super . setUpRightPanel ( rightContent ) ; rightContent . add ( spawnPointsContent ) . padRight ( 8 ) . width ( 192 ) . expandX ( ) . fillX ( ) . bottom ( ) . right ( ) . row ( ) ; rightContent . add ( spawnContent ) . pad ( 0 , 8 , 8 , 8 ) . expandX ( ) . fillX ( ) . bottom ( ) . row ( ) ;
subscribeHtlcEvents: public Observable < routerrpc . RouterOuterClass . HtlcEvent > subscribeHtlcEvents ( routerrpc . RouterOuterClass . SubscribeHtlcEventsRequest request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . subscribeHtlcEvents ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
getGamePadControls: public GamePadKeyProperties getGamePadControls ( String name ) { GamePadKeyProperties properties = gamePadControls . get ( name ) ; if ( properties == null ) { properties = new GamePadKeyProperties ( "gamepad" , "MENU_GAMEPAD" , null ) ; gamePadControls . put ( name , properties ) ; initGamePadCodes ( properties , false ) ; } return properties ;
write: public void write ( Json json ) { super . write ( json ) ; if ( realEstateInfo != null )
getDatabaseStructureFile: public static List < File > getDatabaseStructureFile ( Database db , List < JavaProjectGenDir > javaProjectGenDirs ) { List < File > files = new ArrayList < > ( ) ; for ( JavaProjectGenDir dir : javaProjectGenDirs ) { files . add ( new File ( dir . getParentFile ( ) + "/" + db . name + "_structure.json" ) ) ; } return files ;
setOnItemClickCallback: public void setOnItemClickCallback ( ItemCleckListener itemCleckListener ) { this . mCallback = itemCleckListener ;
firstToUpperCase: public static String firstToUpperCase ( String s ) { return ( "" + s . charAt ( 0 ) ) . toUpperCase ( ) + s . substring ( 1 ) ;
getServiceType: public ServiceType getServiceType ( ) { return serviceType ;
getInitialSteamMass: public double getInitialSteamMass ( ) { return initialSteamMass ;
getRequiredPrivilege: public String getRequiredPrivilege ( ) { return requiredPrivilege ;
obtain: public static FreePlayItemsTakenOutEvent obtain ( PlayerClient player , ObjectMap < ConsumableContent , Integer > items ) { FreePlayItemsTakenOutEvent e = obtain ( FreePlayItemsTakenOutEvent . class ) ; if ( e == null ) return null ; return e . init ( player , items ) ;
multiples: public static Set < Integer > multiples ( int i , int limit ) { Set < Integer > multiples = new HashSet < > ( ) ; for ( int j = 2 ; i * j <= limit ; j ++ ) { multiples . add ( i * j ) ; } return multiples ;
protectedMax: protected int protectedMax ( int a , int b ) { return a > b ? a : b ;
setTitleViewHidden: public void setTitleViewHidden ( ) { getTitleView ( ) . setVisibility ( View . GONE ) ;
addCard: public CardImage addCard ( String c ) { int updatedCardCount = getCardCount ( ) + 1 ; float space = getWidth ( ) - CARD_WIDTH ; int distance = ( int ) Math . min ( space / updatedCardCount , CARD_WIDTH + 4 ) ; float adjustedSpace = updatedCardCount * distance ; int offset = ( int ) ( ( getWidth ( ) - adjustedSpace ) / 2.0f ) ; int cardCount = getCardCount ( ) ; for ( int i = 0 ; i < cardCount ; i ++ ) { CardImage image = images . get ( i ) ; if ( image != null ) { image . addAction ( Actions . moveTo ( offset + i * distance , 0 , 0.25f , Interpolation . circle ) ) ; } } if ( this . cards != null ) { this . cards . add ( c ) ; } cardsCount ++ ; CardImage card = new CardImage ( c ) ; card . setScaling ( Scaling . none ) ; card . setBounds ( offset + cardCount * distance , 0 , CARD_WIDTH , CARD_HEIGHT ) ; images . put ( cardCount , card ) ; card . setVisible ( false ) ; addActor ( card ) ; if ( c != null ) { dragAndDrop . addSource ( new CardOnHandSource ( card , c ) ) ; } return card ;
getLabelPaint: public Paint getLabelPaint ( ) { return mLegendLabelPaint ;
getAngle: public float getAngle ( ) { return 0 ;
getMenuListPage: void getMenuListPage ( ) throws JsonProcessingException { Integer pageNumber = 1 ; Integer pageSize = 10 ; String queryKey = "" ; List < DepartDto > listPage = departService . getDepartListPage ( pageNumber , pageSize , queryKey ) ; assertNotNull ( listPage ) ; log . info ( "获取部门/组织列表（分页）方法测试成功:{}" , objectMapper . writeValueAsString ( listPage ) ) ;
isWsConnected: No method body
getApplication: public static Application getApplication ( ) { return App . app ;
otelContext: public Context otelContext ( ) { return otelContext ;
wrap: static < T , R > Function < T , R > wrap ( ThrowingFunction < T , R > fn ) { return fn . asFunction ( ) ;
getDrawListener: public OnDrawListener getDrawListener ( ) { return mDrawListener ;
onEvent: public void onEvent ( int event , @ Nullable String path ) { if ( event == FileObserver . MODIFY ) {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoSteamPressure2OffActionPerformed ( evt ) ;
getVariant: public String getVariant ( ) { return variant ;
trustManagerForCertificates: private X509TrustManager trustManagerForCertificates ( InputStream in ) throws GeneralSecurityException { CertificateFactory certificateFactory = CertificateFactory . getInstance ( "X.509" ) ; Collection < ? extends Certificate > certificates = certificateFactory . generateCertificates ( in ) ; if ( certificates . isEmpty ( ) ) { throw new IllegalArgumentException ( "expected non-empty set of trusted certificates" ) ; } char [ ] password = "password" . toCharArray ( ) ; KeyStore keyStore = newEmptyKeyStore ( password ) ; int index = 0 ; for ( Certificate certificate : certificates ) { String certificateAlias = Integer . toString ( index ++ ) ; keyStore . setCertificateEntry ( certificateAlias , certificate ) ; } KeyManagerFactory keyManagerFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; keyManagerFactory . init ( keyStore , password ) ; TrustManagerFactory trustManagerFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustManagerFactory . init ( keyStore ) ; TrustManager [ ] trustManagers = trustManagerFactory . getTrustManagers ( ) ; if ( trustManagers . length != 1 || ! ( trustManagers [ 0 ] instanceof X509TrustManager ) ) { throw new IllegalStateException ( "Unexpected default trust managers:" + Arrays . toString ( trustManagers ) ) ; } return ( X509TrustManager ) trustManagers [ 0 ] ;
diff: public static float diff ( float a , float b ) { float d = Math . abs ( a - b ) % 360 ; return d > 180 ? 360 - d : d ;
stuck: protected void stuck ( ) { pop ( ) ;
notificationMessage: public String notificationMessage ( ) { StringBuilder sb = new StringBuilder ( "Notification " ) ; if ( userId != null && organizationId != null ) { sb . append ( String . format ( "for %d(UID), within %d(OrgID) " , userId , organizationId ) ) ; } sb . append ( String . format ( "of type %s: \"%s\"" , notificationType , message ) ) ; return sb . toString ( ) ;
getID: public ID getID ( ) { return ID . steamStats ;
setIsStart: private static void setIsStart ( boolean isStart ) { NodeStart . isStart = isStart ;
reset: protected void reset ( AnimationState state ) { state . clearTracks ( ) ; state . clearListeners ( ) ;
onLayout: protected void onLayout ( boolean changed , int l , int t , int r , int b ) { int childCount = getChildCount ( ) ; int left = 0 + getPaddingLeft ( ) ; int right = 0 + getPaddingLeft ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) {
setLaunchData: public void setLaunchData ( LaunchData launchData ) { this . pos = launchData ;
changeTeam: public void changeTeam ( Team team , SocialController . RequestCallback callback ) { JSONObject args = new JSONObject ( ) ; args . put ( "team" , team . getID ( ) ) ; BrainOutClient . SocialController . sendRequest ( "change_team" , args , callback ) ;
isPersonalRequestOnly: public boolean isPersonalRequestOnly ( ) { return personalRequestOnly != null ;
init: void init ( ) { setEnabled ( BrainOutServer . Settings . isAutoBalanceEnabled ( ) ) ; setBalanceValue ( BrainOutServer . Settings . getAutoBalanceValue ( ) ) ;
b: public final List < Application > b ( ) { return this . applications ;
getExposedSorted: public LinkedHashSet < Entry < String , CRUDControllerConfiguration > > getExposedSorted ( ) { return getExposedSorted ( null ) ;
setScale: public void setScale ( float scale ) { scaleX = scale ; scaleY = scale ;
assertNegative: public static void assertNegative ( int n , @ NotNull String message ) { if ( n >= 0 ) throw new AssertionError ( message ) ;
isGitHubConfiguredGlobally: public boolean isGitHubConfiguredGlobally ( ) { IntegrationModuleGlobalConfiguration globalConfig = integrationService . getGlobalConfiguration ( ) ; String gitHubClientId = globalConfig . gitHubClientId ; String gitHubClientSecret = globalConfig . gitHubClientSecret ; return StringUtils . isNotBlank ( gitHubClientId ) && StringUtils . isNotBlank ( gitHubClientSecret ) ;
filter: No method body
run: public void run ( ) { mMenuPopWindow . dismiss ( ) ; mLoadingDialog . dismiss ( ) ; UnlockDialog mUnlockDialog = new UnlockDialog ( mContext ) ; mUnlockDialog . show ( ) ;
sendAimEvent: private void sendAimEvent ( int screenX , int screenY ) { aimPos . set ( screenX - BrainOutClient . getWidth ( ) / 2f , screenY - BrainOutClient . getHeight ( ) / 2f ) ; sendEvent ( GameControllerEvent . obtain ( GameControllerEvent . Action . aim , aimPos ) ) ;
getSearchableRepositoryMetadata: public static SearchableRepositoryMetadata getSearchableRepositoryMetadata ( String entityKey ) { return searchableRepositoryMetadataByEntityKey . get ( entityKey ) ;
main: public static void main ( String [ ] args ) { try { System . setErr ( new PrintStream ( new FileOutputStream ( "error.log" ) ) ) ; } catch ( FileNotFoundException e ) { } System . setProperty ( "java.awt.headless" , "true" ) ; ClientEnvironment environment = new DesktopEnvironment ( args ) ; ClientSettings settings ; try { settings = DesktopSettings . GetDesktopSettings ( environment ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; if ( Log . ERROR ) Log . error ( "Error loading settings: " + e . getMessage ( ) ) ; return ; } Lwjgl3ApplicationConfiguration cfg = new Lwjgl3ApplicationConfiguration ( ) ; String name = System . getenv ( "DESKTOP_PROFILE_NAME" ) ; if ( name != null ) { cfg . setTitle ( environment . getAppName ( ) + " - " + name ) ; } else { cfg . setTitle ( environment . getAppName ( ) ) ; } if ( settings . getFullscreen ( ) . getValue ( ) ) { ScreenResolutionProperty dm = settings . getDisplayMode ( ) ; Graphics . DisplayMode selected = null ; for ( Graphics . DisplayMode displayMode : Lwjgl3ApplicationConfiguration . getDisplayModes ( ) ) { if ( dm . getWidth ( ) == displayMode . width && dm . getHeight ( ) == displayMode . height && dm . getHz ( ) == displayMode . refreshRate && dm . getBpp ( ) == displayMode . bitsPerPixel ) { selected = displayMode ; break ; } } if ( selected == null ) { for ( Graphics . DisplayMode displayMode : Lwjgl3ApplicationConfiguration . getDisplayModes ( ) ) { if ( displayMode . width < 1024 ) continue ; if ( displayMode . width >= 2200 ) continue ; if ( displayMode . refreshRate > 60 ) continue ; if ( selected != null && ( selected . width > displayMode . width ) ) continue ; selected = displayMode ; } } if ( selected != null ) { environment . setTargetFullScreenDisplayMode ( selected ) ; } cfg . setWindowedMode ( 1024 , 768 ) ; } else { cfg . setWindowedMode ( settings . getDisplayMode ( ) . getWidth ( ) , settings . getDisplayMode ( ) . getHeight ( ) ) ; } if ( System . getenv ( "FORCE_X" ) != null && System . getenv ( "FORCE_Y" ) != null ) { cfg . setWindowPosition ( Integer . valueOf ( System . getenv ( "FORCE_X" ) ) , Integer . valueOf ( System . getenv ( "FORCE_Y" ) ) ) ; } cfg . useVsync ( settings . getvSync ( ) . getValue ( ) ) ; cfg . setAudioConfig ( 64 , 512 , 9 ) ; new Lwjgl3Application ( BrainOutDesktop . initDesktopInstance ( environment , settings ) , cfg ) ;
setMessage: public SafeDialogBuilder setMessage ( CharSequence message ) { super . setMessage ( message ) ; return this ;
stayOnTop: public boolean stayOnTop ( ) { return ! done ;
reversePowerTrip: private void reversePowerTrip ( ) { if ( ! reversePowerRecorded ) { if ( isTG1 ) { autoControl . recordEvent ( "TG-1 Reverse Power" ) ; } else { autoControl . recordEvent ( "TG-2 Reverse Power" ) ; } reversePowerRecorded = true ; } new Thread ( ( ) -> {
removeConnected: public void removeConnected ( final @ NonNull JRPCClientInstance instance ) { connected . remove ( instance ) ;
createIntegration: public SingleIntegrationResponse createIntegration ( final IntegrationRequest request ) throws NovuNetworkException , IOException { return restHandler . extractResponse ( this . integrationsApi . createIntegration ( request ) . execute ( ) ) ;
getX: public float getX ( ) { return BlockData . CURRENT_X + 0.5f ;
getEffect: public EffectData getEffect ( LaunchData launchData ) { return new GunshotTailSoundEffectData ( this , launchData ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case freePlayItemTakenOut : { FreePlayItemsTakenOutEvent ev = ( ( FreePlayItemsTakenOutEvent ) event ) ; ServerTask . Trigger ( this , ev . player , 1 ) ; } } return false ;
onEvent: public boolean onEvent ( Event event ) { if ( event . getID ( ) == Event . ID . damageBlock ) { return super . onEvent ( event ) ; } return super . onEvent ( event ) ;
convertAndSave: public EventListenerEntry convertAndSave ( EventListenerEntryConversionDto dto , String filePath ) { debug ( "[convertAndSave]" ) ; EventListenerEntry eventListenerEntry = new EventListenerEntry ( ) ; eventListenerEntry . setConsumerClassName ( dto . getConsumerClassName ( ) ) ; eventListenerEntry . setConsumerMethodName ( dto . getConsumerMethodName ( ) ) ; eventListenerEntry . setConsumerParameterClassName ( dto . getConsumerParameterClassName ( ) ) ; eventListenerEntry . setEventClassName ( dto . getEventClassName ( ) ) ; eventListenerEntry . setEventName ( dto . getEventName ( ) ) ; eventListenerEntry . setEventObjectType ( dto . getEventObjectType ( ) ) ; eventListenerEntry . setIndexString ( dto . getIndexString ( ) ) ; eventListenerEntry . setStaticData1 ( dto . getStaticData1 ( ) ) ; eventListenerEntry . setStaticData2 ( dto . getStaticData2 ( ) ) ; eventListenerEntry . setStaticData3 ( dto . getStaticData3 ( ) ) ; eventListenerEntry . setStaticData4 ( dto . getStaticData4 ( ) ) ; eventListenerEntry . setModuleName ( dto . getModule ( ) ) ; eventListenerEntry . setOrganizationId ( dto . getOrganizationId ( ) ) ; return repositories . secure . eventListener . saveOne ( eventListenerEntry ) ;
acquireSpawn: public SpawnMode acquireSpawn ( Client client , Team team ) { return SpawnMode . allowed ;
init: private Event init ( Action action , String string ) { this . action = action ; this . num = 0 ; this . string = string ; return this ;
consumeThirst: public void consumeThirst ( float thirst ) { this . thirst = Math . max ( this . thirst - thirst , 0 ) ;
createOrUpdateCustomDataForKey: public Map < String , Object > createOrUpdateCustomDataForKey ( String shopKey , String key , Map < String , Object > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/shops/%s/custom-data/%s" , shopKey , key ) , query , null , responseModel , model ) ;
getProtocolVersion: public ProtocolVersion getProtocolVersion ( ) { return PROTOCOL_VERSION ;
toAuditString: public String toAuditString ( ) { return NAME ;
calculateVelocity: private float calculateVelocity ( ) { if ( _velocitySamples . isEmpty ( ) ) return 0.f ; AngularVelocitySample firstSample = _velocitySamples . get ( 0 ) ; AngularVelocitySample lastSample = _velocitySamples . get ( _velocitySamples . size ( ) - 1 ) ; AngularVelocitySample beforeLastSample = firstSample ; for ( int i = _velocitySamples . size ( ) - 1 ; i >= 0 ; i -- ) { beforeLastSample = _velocitySamples . get ( i ) ; if ( beforeLastSample . angle != lastSample . angle ) { break ; } } float timeDelta = ( lastSample . time - firstSample . time ) / 1000.f ; if ( timeDelta == 0.f ) { timeDelta = 0.1f ; } boolean clockwise = lastSample . angle >= beforeLastSample . angle ; if ( Math . abs ( lastSample . angle - beforeLastSample . angle ) > 270.0 ) { clockwise = ! clockwise ; } if ( lastSample . angle - firstSample . angle > 180.0 ) { firstSample . angle = ( float ) ( lastSample . angle + 360.0 ) ; } else if ( firstSample . angle - lastSample . angle > 180.0 ) { lastSample . angle = ( float ) ( lastSample . angle + 360.0 ) ; } float velocity = Math . abs ( ( lastSample . angle - firstSample . angle ) / timeDelta ) ; if ( ! clockwise ) { velocity = - velocity ; } return velocity ;
getQuestIndex: public int getQuestIndex ( Quest quest ) { if ( ! quest . hasGroup ( ) ) return 0 ; String group = quest . getGroup ( ) ; int index = 0 ; for ( Quest q : quests ) { if ( q . hasGroup ( ) && q . getGroup ( ) . equals ( group ) ) { index ++ ; } if ( q == quest ) return index ; } return 0 ;
exit: public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { if ( toActor != null && toActor . isDescendantOf ( actor ) ) { return ; } remove ( ) ; hide ( ) ; super . exit ( event , x , y , pointer , toActor ) ;
run: public void run ( ) { Gdx . app . postRunnable ( ( ) -> doConnect ( ) ) ;
getGradientColors: public int [ ] getGradientColors ( ) { return mGradientColors ;
end: No method body
directTGQueue: public Queue directTGQueue ( ) { return new Queue ( AMQPConstant . TG_QUEUE ) ;
setBtcPrice: public void setBtcPrice ( Context context , String btcPrice ) { PreferencesUtils . saveBtcPriceToLocal ( context , btcPrice ) ; this . btcPrice = btcPrice ;
getMessageQueueTimeout: private int getMessageQueueTimeout ( ) { return config . getQueuedMessageTimeout ( ) > 0 ? config . getQueuedMessageTimeout ( ) : Integer . MAX_VALUE ;
setValue: public LayoutDatabaseOptions setValue ( @ Nullable Database db ) { removeAll ( ) ; if ( db == null ) return super . setValue ( db ) ; add ( Statics . checkbox ( "Use MariaDB4j" ) . setValue ( db . isWithMariadb4j ) . onValueChange ( e -> { db . isWithMariadb4j = e . value ; Data . save ( ) ; } ) . setTooltip ( "Expects you to have MariaDB4j 3.0.1 or LOWER added as dependency. <br>" + "Lower because the newer versions do not really support persistent databases. <br>" + "Also expects a MariaDB driver/client present." ) ) ; return super . setValue ( db ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamInVStop1ItemStateChanged ( evt ) ;
usingJackson: private static < T > Serde < T > usingJackson ( ThrowingBiConsumer < JsonGenerator , T > serializer , ThrowingFunction < JsonParser , T > deserializer ) { return new Serde < > ( ) {
getWidgets: public Array < Widget > getWidgets ( ) { return widgets ;
hasRender: public boolean hasRender ( ) { return false ;
release: public void release ( ) { super . release ( ) ; notifyAll ( new LeaveTable ( d ( ) , o ( ) ) ) ; deck . clear ( ) ; discard . clear ( ) ; participants . clear ( ) ;
setBinaryStream: public OutputStream setBinaryStream ( long pos ) throws SQLException { return null ;
animateTextView: public static void animateTextView ( final TextView tv ) { ValueAnimator va = new ValueAnimator ( ) ; va . setIntValues ( animatedColors ) ; va . setEvaluator ( new ArgbEvaluator ( ) ) ; va . addUpdateListener ( animation -> tv . setTextColor ( ( Integer ) animation . getAnimatedValue ( ) ) ) ; va . setRepeatMode ( ValueAnimator . REVERSE ) ; va . setRepeatCount ( - 1 ) ; va . setDuration ( animateSpeed ) ; va . start ( ) ;
update: public void update ( float dt ) { if ( released ) return ; if ( shootExtTimer > 0 )
init: public void init ( ) { super . init ( ) ; BrainOutServer . EventMgr . subscribe ( Event . ID . playerSaved , this ) ;
getPremiumSince: public final String getPremiumSince ( ) { return null ; }
disableAxisLineDashedLine: public void disableAxisLineDashedLine ( ) { mAxisLineDashPathEffect = null ;
queryBestRecord: public ConsumableRecord queryBestRecord ( ConsumableRecordWeightPredicate predicate ) { long bestValue = - 1 ; ConsumableRecord bestRecord = null ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : getData ( ) ) { long v = predicate . getWeight ( entry . value ) ; if ( v > bestValue ) { bestValue = v ; bestRecord = entry . value ; } } return bestRecord ;
deleteIntegration: No method body
removePerson: public boolean removePerson ( Person person ) { return phoneBook . remove ( person ) ;
handleIncomingCall: public static boolean handleIncomingCall ( @ NotNull ModelCall call ) { LogUtils . log ( TAG , "call update received: " + call ) ; if ( ! EmptyUtils . isEmpty ( call . getRinging ( ) ) && shouldHideCalls ( ) ) { long channelId = call . getChannelId ( ) ; LogUtils . log ( TAG , "auto rejecting active call with id=" + channelId ) ; StoreUtils . declineCall ( channelId ) ; return true ; } return false ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
onAnimationEffect: private void onAnimationEffect ( String custom ) { PlayerEffectsComponentData eff = playerData . getComponent ( PlayerEffectsComponentData . class ) ; PlayerAnimationComponentData anim = playerData . getComponent ( PlayerAnimationComponentData . class ) ; if ( eff == null || anim == null ) return ; BrainOutClient . EventMgr . sendEvent ( eff , LaunchEffectEvent . obtain (
findOrganizationsFlow: protected PageModelMap findOrganizationsFlow ( String aSearchTerm , Specification < Organization > aSpecification , Pageable aPageable ) { debug ( "[findOrganizationFlow] search {}" , aSearchTerm ) ; if ( aPageable . getSort ( ) == null ) { aPageable = PageRequest . of ( aPageable . getPageNumber ( ) , aPageable . getPageSize ( ) , Sort . Direction . DESC , "createdOn" ) ; } Pageable finalAPageable = aPageable ; return Flow . init ( )
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < EmailKey > responseEntity = this . api . emailKeys ( ) . all ( "acme" , "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/EmailKeyAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( EmailKey entity : responseEntity . getEntities ( ) ) {
hasWarmUp: public boolean hasWarmUp ( ) { return true ;
autoOpenShopOnSpawn: public boolean autoOpenShopOnSpawn ( ) { return true ;
getBackground: protected TextureRegion getBackground ( ) { return BrainOutClient . getRegion ( this . event . getEvent ( ) . group ? "bg-clan" : "bg-ingame" ) ;
getIterator: public Iterator < Module > getIterator ( ) { return modules . iterator ( ) ;
onShowHeader: public void onShowHeader ( ) { mRefreshDesc . setText ( R . string . text_load_pull ) ;
hoverItem: private void hoverItem ( ActiveData activeData ) { hoveredItems . add ( activeData ) ;
requiredArgs: public int requiredArgs ( ) { return 0 ;
getLogger: public InternalLogger getLogger ( ) { return logger ;
shouldGetDbSelectForMultipleConditionsRule: public void shouldGetDbSelectForMultipleConditionsRule ( ) { String rule = "name == 'test' or name.contains('test1') ? category == 'test2' or name.contains('test8') or {'test5','test6'}.contains(category) : category.contains('test3') and name != 'test7'" ; String tableName = "items" ; String select = RuleSpelHelper . getSelect ( rule , tableName ) ; assertEquals ( "SELECT CASE WHEN ((name == 'test') or name.contains('test1')) THEN (((category == 'test2') or name.contains('test8')) or {'test5','test6'}.contains(category)) ELSE (category.contains('test3') and (name != 'test7')) FROM items" , select ) ;
AddButtonsContainers: public static Table AddButtonsContainers ( Menu menu ) { Table container = new Table ( ) ; container . setTouchable ( Touchable . childrenOnly ) ; container . align ( Align . top ) ; container . setBounds ( BrainOutClient . getWidth ( ) - 212 , BrainOutClient . getHeight ( ) - 484 , 192 , 464 ) ; menu . addActor ( container ) ; return container ;
getAmountPerLaunch: public int getAmountPerLaunch ( ) { return bulletAtLaunch ;
getScore: protected int getScore ( ) { return user . getInt ( "tech-score" , 0 ) ;
setUid: public void setUid ( String uid ) { this . uid = uid ;
get: public AttributeGroup get ( String attributeGroupName , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < AttributeGroup > responseModel = ( Class < AttributeGroup > ) ( Class < ? > ) AttributeGroup . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/attribute-groups/%s" , attributeGroupName ) , query , null , responseModel ) ;
haveUpgrades: private boolean haveUpgrades ( ) { GameMode gameMode = BrainOutClient . ClientController . getGameMode ( ) ; if ( gameMode != null && gameMode . getID ( ) == GameMode . ID . free ) { return true ; } for ( final ObjectMap . Entry < String , Array < Upgrade > > entry : item . getUpgrades ( ) ) { boolean collapsable = true ; for ( final Upgrade upgrade : entry . value ) { if ( ! ( upgrade instanceof UpgradeChain . ChainedUpgrade ) ) { collapsable = false ; break ; } } if ( ! collapsable ) { return true ; } } return false ;
isManaged: public boolean isManaged ( ) { return true ;
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shopCountryPriceRoundings ( ) . delete ( "acme" , "acme" , 1 , options ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { float have = userProfile . getStats ( ) . get ( shopItem . getCurrency ( ) , 0.0f ) ; if ( have >= shopItem . getAmount ( ) )
closeRequest: private void closeRequest ( ) { if ( ! this . httpServerRequest . isEnded ( ) ) {
getMaxDuration: public @ Nullable Duration getMaxDuration ( ) { return maxDuration ;
run: public void run ( ) { client . addPlugin ( new FrescoFlipperPlugin ( ) ) ;
getMarkerPosition: protected float [ ] getMarkerPosition ( Highlight highlight ) { MPPointF center = getCenterCircleBox ( ) ; float r = getRadius ( ) ; float off = r / 10f * 3.6f ; if ( isDrawHoleEnabled ( ) ) { off = ( r - ( r / 100f * getHoleRadius ( ) ) ) / 2f ; } r -= off ; float rotationAngle = getRotationAngle ( ) ; int entryIndex = ( int ) highlight . getX ( ) ; float offset = mDrawAngles [ entryIndex ] / 2 ; float x = ( float ) ( r * Math . cos ( Math . toRadians ( ( rotationAngle + mAbsoluteAngles [ entryIndex ] - offset ) * mAnimator . getPhaseY ( ) ) ) + center . x ) ; float y = ( float ) ( r * Math . sin ( Math . toRadians ( ( rotationAngle + mAbsoluteAngles [ entryIndex ] - offset ) * mAnimator . getPhaseY ( ) ) ) + center . y ) ; MPPointF . recycleInstance ( center ) ; return new float [ ] { x , y } ;
hasMagazineManagement: public boolean hasMagazineManagement ( ) { return magazines != null ;
getCurrentDay: private long getCurrentDay ( ) { return getTime ( ) / cycle ;
drawDataSet: protected void drawDataSet ( Canvas c , IBarDataSet dataSet , int index ) { Transformer trans = mChart . getTransformer ( dataSet . getAxisDependency ( ) ) ; mBarBorderPaint . setColor ( dataSet . getBarBorderColor ( ) ) ; mBarBorderPaint . setStrokeWidth ( Utils . convertDpToPixel ( dataSet . getBarBorderWidth ( ) ) ) ; final boolean drawBorder = dataSet . getBarBorderWidth ( ) > 0.f ; float phaseX = mAnimator . getPhaseX ( ) ; float phaseY = mAnimator . getPhaseY ( ) ; if ( mChart . isDrawBarShadowEnabled ( ) ) { mShadowPaint . setColor ( dataSet . getBarShadowColor ( ) ) ; BarData barData = mChart . getBarData ( ) ; final float barWidth = barData . getBarWidth ( ) ; final float barWidthHalf = barWidth / 2.0f ; float x ; for ( int i = 0 , count = Math . min ( ( int ) ( Math . ceil ( ( float ) ( dataSet . getEntryCount ( ) ) * phaseX ) ) , dataSet . getEntryCount ( ) ) ; i < count ; i ++ ) { BarEntry e = dataSet . getEntryForIndex ( i ) ; x = e . getX ( ) ; mBarShadowRectBuffer . top = x - barWidthHalf ; mBarShadowRectBuffer . bottom = x + barWidthHalf ; trans . rectValueToPixel ( mBarShadowRectBuffer ) ; if ( ! mViewPortHandler . isInBoundsTop ( mBarShadowRectBuffer . bottom ) ) continue ; if ( ! mViewPortHandler . isInBoundsBottom ( mBarShadowRectBuffer . top ) ) break ; mBarShadowRectBuffer . left = mViewPortHandler . contentLeft ( ) ; mBarShadowRectBuffer . right = mViewPortHandler . contentRight ( ) ; c . drawRect ( mBarShadowRectBuffer , mShadowPaint ) ; } } BarBuffer buffer = mBarBuffers [ index ] ; buffer . setPhases ( phaseX , phaseY ) ; buffer . setDataSet ( index ) ; buffer . setInverted ( mChart . isInverted ( dataSet . getAxisDependency ( ) ) ) ; buffer . setBarWidth ( mChart . getBarData ( ) . getBarWidth ( ) ) ; buffer . feed ( dataSet ) ; trans . pointValuesToPixel ( buffer . buffer ) ; final boolean isCustomFill = dataSet . getFills ( ) != null && ! dataSet . getFills ( ) . isEmpty ( ) ; final boolean isSingleColor = dataSet . getColors ( ) . size ( ) == 1 ; final boolean isInverted = mChart . isInverted ( dataSet . getAxisDependency ( ) ) ; if ( isSingleColor ) { mRenderPaint . setColor ( dataSet . getColor ( ) ) ; } for ( int j = 0 , pos = 0 ; j < buffer . size ( ) ; j += 4 , pos ++ ) {
getFox: public Client getFox ( ) { for ( ObjectMap . Entry < Integer , Client > entry : BrainOutServer . Controller . getClients ( ) ) { Client client = entry . value ; ModePayload payload = client . getModePayload ( ) ; if ( payload instanceof FoxHuntPayload ) { if ( ( ( FoxHuntPayload ) payload ) . isFox ( ) ) { return client ; } } } return null ;
reverseOrder: protected boolean reverseOrder ( ) { return false ;
setTargetGroup: public void setTargetGroup ( String group ) { this . group = group ;
getPassword: public String getPassword ( ) { return password ;
generate: public static void generate ( ServerFreeRealization free , ConsumableContainer cnt ) { Bullet bullet = free . getRandomBullet ( ) ; if ( bullet == null ) return ; if ( Log . INFO ) Log . info ( "Generated ammo " + bullet . getID ( ) ) ; switch ( MathUtils . random ( 7 ) )
getColorResIdByName: public static int getColorResIdByName ( Context context , String nameStr ) { return context . getResources ( ) . getIdentifier ( nameStr , "color" , context . getPackageName ( ) ) ;
calculateWeapon: private void calculateWeapon ( byte [ ] taskHash , JSONObject eventProfile ) { if ( eventProfile != null && eventProfile . has ( getSelectedStringKey ( ) ) ) { String selectedWeaponKey = eventProfile . getString ( getSelectedStringKey ( ) ) ; weapon = BrainOut . ContentMgr . get ( selectedWeaponKey , Weapon . class ) ; if ( weapon != null ) { return ; } } Array < Weapon > weaponPool = BrainOut . ContentMgr . queryContent ( Weapon . class , c -> { InstrumentSlotItem slot = c . getSlotItem ( ) ; if ( slot == null ) return false ; if ( RandomWeightComponent . Get ( slot ) == 0 ) return false ; if ( slot . getDefaultSkin ( ) == null ) return false ; if ( slot . isLocked ( getUserProfile ( ) ) ) return false ; if ( c . getPrimaryProperties ( ) . isUnlimited ( ) ) return false ; return slot . getCategory ( ) . equals ( getTask ( ) . getKind ( ) ) ; } ) ; if ( weaponPool . size == 0 ) { throw new RuntimeException ( "Empty weapon pool." ) ; } int intHash = Math . abs ( new BigInteger ( taskHash ) . intValue ( ) ) ; weapon = weaponPool . get ( intHash % weaponPool . size ) ;
testDeleteCustomDataKeyForCountry: public void testDeleteCustomDataKeyForCountry ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shopCategories ( ) . deleteCustomDataKeyForCountry ( "acme" , 1 , "acme" , "acme" , options ) ;
store: No method body
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
getCorner: private CornerActor getCorner ( Corner corner ) { return actors [ corner . ordinal ( ) ] ;
resetZoom: public void resetZoom ( Matrix outputMatrix ) { outputMatrix . reset ( ) ; outputMatrix . set ( mMatrixTouch ) ; outputMatrix . postScale ( 1.0f , 1.0f , 0.0f , 0.0f ) ;
allowZoom: public boolean allowZoom ( ) { return false ;
canInviteFriend: public boolean canInviteFriend ( ) { return false ;
sendEmail: public boolean sendEmail ( String fullFrom , String fullTo , String subject , String html , String attachmentURL , List < File > attachments ) { debug ( "[sendEmail] {} -> {} Subject: {}" , fullFrom , fullTo , subject ) ; EmailConfig emailConfig = emailConfigRepository . findAll ( ) . stream ( ) . findFirst ( ) . orElse ( null ) ; RestTemplate rTemplate = new RestTemplate ( ) ; HttpHeaders headers = new HttpHeaders ( ) ; headers . setContentType ( MediaType . MULTIPART_FORM_DATA ) ; String mailgunKey = emailConfig != null ? StringUtils . defaultString ( emailConfig . getMailgunApiKey ( ) , mailgunApiKey ) : mailgunApiKey ; String authorizationHeader = "Basic " + new String ( Base64 . getEncoder ( ) . encode ( ( "api:" + mailgunKey ) . getBytes ( Charset . defaultCharset ( ) ) ) ) ; headers . set ( "Authorization" , authorizationHeader ) ; MultiValueMap < String , Object > mvmap = new LinkedMultiValueMap < > ( ) ; mvmap . add ( "from" , StringUtils . defaultIfBlank ( emailConfig != null ? emailConfig . getFrom ( ) : null , fullFrom ) ) ; mvmap . add ( "to" , fullTo ) ; mvmap . add ( "subject" , subject ) ; mvmap . add ( "h:Reply-To" , StringUtils . defaultIfBlank ( emailConfig != null ? emailConfig . getReplyTo ( ) : null , replyTo ) ) ; if ( StringUtils . isNotEmpty ( appLogoPath ) ) { mvmap . add ( "inline" , new ClassPathResource ( appLogoPath ) ) ; } mvmap . add ( "html" , html ) ; Path tmpFile = prepareTempAttachmentFile ( attachmentURL ) ; if ( tmpFile != null ) { mvmap . add ( "attachment" , new FileSystemResource ( tmpFile . toFile ( ) ) ) ; } HttpEntity < MultiValueMap < String , Object > > request = new HttpEntity < > ( mvmap , headers ) ; ResponseEntity < String > response = rTemplate . postForEntity ( mailgunApiUrl , request , String . class ) ; try { if ( tmpFile != null ) { Files . deleteIfExists ( tmpFile ) ; } } catch ( IOException e ) { error ( e , "Error while wiping attachment {}" , tmpFile ) ; } return true ;
setGroup: public void setGroup ( String group ) { this . group = group ;
saveToFile: private void saveToFile ( String pathToFile , String content ) { try {
getState: public State getState ( ) { return state ;
getCurrentWeapon: public String getCurrentWeapon ( ) { return currentWeapon ;
calcMinMax: public void calcMinMax ( ) { if ( mDataSets == null ) { mDataSets = new ArrayList < > ( ) ; } mDataSets . clear ( ) ; mYMax = - Float . MAX_VALUE ; mYMin = Float . MAX_VALUE ; mXMax = - Float . MAX_VALUE ; mXMin = Float . MAX_VALUE ; mLeftAxisMax = - Float . MAX_VALUE ; mLeftAxisMin = Float . MAX_VALUE ; mRightAxisMax = - Float . MAX_VALUE ; mRightAxisMin = Float . MAX_VALUE ; List < BarLineScatterCandleBubbleData > allData = getAllData ( ) ; for ( ChartData data : allData ) {
generateImages: public List < String > generateImages ( String prompt ) { if ( this . dalle . getN ( ) <= 1 ) { throw new JavaAIException ( "You must set the number of responses received from the DALL-E API > 1 to receive multiple responses." ) ; } this . dalle . setPrompt ( prompt ) ; var jsonResponse = this . connection . getJsonResponse ( this . dalle ) ; return this . dalle . getResponses ( jsonResponse ) ;
getDimension: public String getDimension ( ) { return BulletData . this . getDimension ( ) ;
update: public Object update ( @ PathVariable ( ID ) Long roleId , @ Valid RoleForm roleForm , BindingResult br ) { debug ( "[update] roleId {}" , roleId ) ; return updateRole ( roleId , roleForm , br )
onMeasure: protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; measureTextWidth ( ) ;
setUp: protected void setUp ( ) { mockWebServer = new MockWebServer ( ) ; NovuConfig novuConfig = new NovuConfig ( "1234" ) ; novuConfig . setBaseUrl ( mockWebServer . url ( "" ) . toString ( ) ) ; RestHandler restHandler = new RestHandler ( novuConfig ) ; layoutHandler = new LayoutHandler ( restHandler ) ;
getBundleData: protected void getBundleData ( Bundle bundle ) { scanCode = bundle . getInt ( KEY_SCAN_CODE ) ;
received: public boolean received ( Object object , Object to ) { Class type = object . getClass ( ) ; Method method = classToMethod . get ( type ) ; if ( method == null ) { if ( classToMethod . containsKey ( type ) ) return false ; try { method = to . getClass ( ) . getMethod ( "received" , new Class [ ] { type } ) ; } catch ( SecurityException ex ) { if ( ERROR ) error ( "kryonet" , "Unable to access method: received(Connection, " + type . getName ( ) + ")" , ex ) ; return false ; } catch ( NoSuchMethodException ex ) { if ( DEBUG ) debug ( "kryonet" , "Unable to find listener method: " + getClass ( ) . getName ( ) + "#received(Connection, " + type . getName ( ) + ")" ) ; return false ; } finally { classToMethod . put ( type , method ) ; } } try
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; shareLayout . setVisibility ( View . GONE ) ;
unloadContent: public void unloadContent ( ContentUnloadPredicate predicate ) { Array < String > removeList = new Array < > ( ) ; for ( ObjectMap . Entry < String , Content > entry : items ) { Content content = entry . value ; if ( predicate . test ( content ) ) continue ; content . dispose ( ) ; removeList . add ( entry . key ) ; } for ( String key : removeList )
addTab: public Tab addTab ( String title , Object key ) { return addTab ( title , key , new Tab ( ) ) ;
resolve: default < T > void resolve ( Serde < T > serde , @ NonNull T payload , RequestOptions options ) { try {
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "uses" , uses ) ; json . writeValue ( "max" , max ) ;
end_plus: public void end_plus ( ) { this . took += ( System . nanoTime ( ) - this . time ) / 1000000000.0f ;
getFormLineWidth: public float getFormLineWidth ( ) { return mFormLineWidth ;
calcAngle: private float calcAngle ( float value ) { return calcAngle ( value , mData . getYValueSum ( ) ) ;
getLabel: No method body
insert: public boolean insert ( String map , String mode ) { QueuedItem item = findItem ( map , mode ) ; if ( item == null ) return false ; queue . add ( item ) ; return true ;
getInvocationState: public InvocationState getInvocationState ( ) { return syscalls . getInvocationState ( ) ;
setHookedInstrument: public void setHookedInstrument ( InstrumentData hookedInstrument ) { if ( this . hookedInstrument == hookedInstrument ) return ; if ( this . hookedInstrument != null ) { BrainOut . EventMgr . sendDelayedEvent ( this . hookedInstrument , HookInstrumentEvent . obtain ( null , playerData ) ) ; } this . hookedInstrument = hookedInstrument ; if ( hookedInstrument != null ) { hookedInstrument . setOwner ( playerData ) ; } updateHookedInstrument ( ) ;
processVisibility: public VisibilityResult processVisibility ( Client toClient ) { ServerController CC = BrainOutServer . Controller ; ActiveData currentPlayerData = ( ( ActiveData ) getComponentObject ( ) ) ; if ( ! toClient . isInitialized ( ) ) return VisibilityResult . invisible ; GameMode gameMode = CC . getGameMode ( ) ; if ( gameMode == null ) return VisibilityResult . invisible ; ServerMap map = getMap ( ServerMap . class ) ; if ( map == null ) return VisibilityResult . invisible ; boolean bot = BrainOutServer . Controller . getClients ( ) . get ( currentPlayerData . getOwnerId ( ) ) instanceof BotClient ; ChunkData chunkData = map . getChunkAt ( ( int ) currentPlayerData . getX ( ) , ( int ) currentPlayerData . getY ( ) ) ; if ( chunkData != null && chunkData . hasFlag ( ChunkData . ChunkFlag . hideOthers ) ) { return VisibilityResult . invisible ; } ServerRealization serverRealization = ( ( ServerRealization ) gameMode . getRealization ( ) ) ; if ( serverRealization . spectatorsCanSeeEnemies ( ) && toClient . isSpectator ( ) ) { return VisibilityResult . direct ; } if ( currentPlayerData . getOwnerId ( ) >= 0 ) { if ( ! gameMode . isEnemies ( currentPlayerData . getOwnerId ( ) , toClient . getId ( ) ) ) return VisibilityResult . direct ; } PlayerData toPlayerData = toClient . getPlayerData ( ) ; if ( toPlayerData != null ) { if ( ! toPlayerData . getDimension ( ) . equals ( currentPlayerData . getDimension ( ) ) ) return VisibilityResult . invisible ; if ( ! gameMode . isEnemiesActive ( toPlayerData , currentPlayerData ) ) return VisibilityResult . direct ; SimplePhysicsComponentData phy = toPlayerData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; SimplePhysicsComponentData otherPhy = currentPlayerData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy == null || otherPhy == null ) { return VisibilityResult . invisible ; } float myHeight = phy . getHalfSize ( ) . y , otherHeight = otherPhy . getHalfSize ( ) . y ; tmp . set ( currentPlayerData . getX ( ) , currentPlayerData . getY ( ) + otherHeight ) ; tmp . sub ( toPlayerData . getX ( ) , toPlayerData . getY ( ) + myHeight ) ; float len = tmp . len ( ) ; if ( bot && len > 64 ) { return VisibilityResult . invisible ; } tmp . nor ( ) ; PlayerComponentData cpc = currentPlayerData . getComponent ( PlayerComponentData . class ) ; if ( cpc == null ) { return VisibilityResult . invisible ; } tmp2 . set ( 1.0f , 0f ) ; tmp2 . setAngle ( toPlayerData . getAngle ( ) ) ; if ( tmp2 . dot ( tmp ) < 0 && cpc . getState ( ) == Player . State . sit ) { return VisibilityResult . invisible ; } if ( ! map . trace ( toPlayerData . getX ( ) , toPlayerData . getY ( ) + myHeight , Constants . Layers . BLOCK_LAYER_UPPER , tmp . angleDeg ( ) , len , null ) && ! map . trace ( toPlayerData . getX ( ) , toPlayerData . getY ( ) + myHeight , Constants . Layers . BLOCK_LAYER_FOREGROUND , tmp . angleDeg ( ) , len , null ) ) { return VisibilityResult . direct ; } tmp . set ( currentPlayerData . getX ( ) , currentPlayerData . getY ( ) - otherHeight ) ; tmp . sub ( toPlayerData . getX ( ) , toPlayerData . getY ( ) + myHeight ) ; if ( ! map . trace ( toPlayerData . getX ( ) , toPlayerData . getY ( ) + myHeight , Constants . Layers . BLOCK_LAYER_UPPER , tmp . angleDeg ( ) , len , null ) && ! map . trace ( toPlayerData . getX ( ) , toPlayerData . getY ( ) + myHeight , Constants . Layers . BLOCK_LAYER_FOREGROUND , tmp . angleDeg ( ) , len , null ) ) { return VisibilityResult . direct ; } } if ( gameMode . isTeamVisibilityEnabled ( ) ) { for ( ObjectMap . Entry < Integer , Client > entry : CC . getClients ( ) ) { Client client = entry . value ; if ( client == toClient ) continue ; if ( client . getId ( ) == currentPlayerData . getOwnerId ( ) ) continue ; if ( gameMode . isEnemies ( client . getId ( ) , toClient . getId ( ) ) ) continue ; if ( client . isSpectator ( ) ) continue ; if ( isVisibleDirectlyRightNow ( client ) ) return VisibilityResult . indirect ; } } return VisibilityResult . invisible ;
isActive: public boolean isActive ( ) { return false ;
getBuilderStart: public Map < String , String > getBuilderStart ( ) { return builderStart ;
setCorner: public void setCorner ( Corner corner , Actor actor , int width , int height ) { actors [ corner . ordinal ( ) ] = new CornerActor ( actor , width , height ) ;
getCRC32: public long getCRC32 ( ) { return crc32 ;
update: public void update ( float dt ) { ActiveData activeData = ( ( ActiveData ) getComponentObject ( ) ) ; activeData . setX ( activeData . getX ( ) + dt * movement ) ;
init: No method body
onClick: public void onClick ( View v ) { mPercent2Tv . setSelected ( false ) ; mPercent3Tv . setSelected ( true ) ;
checkExternalPermission: public static boolean checkExternalPermission ( Context context ) { return PermissionUtils . hasSelfPermissions ( context , Manifest . permission . READ_EXTERNAL_STORAGE ,
getMembers: public final List < ThreadMember > getMembers ( ) { return null ;
isInBounds: public boolean isInBounds ( float x , float y ) { return isInBoundsX ( x ) && isInBoundsY ( y ) ;
write: public void write ( Json json ) { json . writeValue ( "v" , version ) ; json . writeValue ( "sz" , bodySize ) ; if ( extensions . size > 0 )
initBgPage: protected void initBgPage ( ) { if ( mBgView == null ) {
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , FrontendMappingFieldDefinition f , String actionLabelKey , String actionUrl , PrivilegeBase actionPrivilege ) { return new FrontendMappingFieldDefinition ( formName , f . name , f . type , f . canReadCheck , f . canWriteCheck , f . readPrivilege , f . writePrivilege , f . valueSupplier , f . datalistSupplier , true , f . fieldTypeFunction , f . datalistId , f . additionalCss , f . allowNull , f . url , f . htmlFragmentName , f . contentType , f . dtoToEntityValueConverter , f . entityToDtoValueConverter , actionPrivilege , actionUrl , actionLabelKey , f . sqlFormula , f . referencedEntityKey , f . nonDto , f . searchEnabled ) ;
getSelection: public Selection getSelection ( ) { return new PlayerSlotSelection ( ) ;
read: public void read ( Json json , JsonValue jsonValue ) { freezing = jsonValue . getFloat ( "fr" , freezing ) ;
updateAttribute: public AttributeGroupAttribute updateAttribute ( String attributeGroupName , String attributeValue , AttributeGroupAttribute model ) throws ApiErrorException , ConnectionException { Class < AttributeGroupAttribute > responseModel = ( Class < AttributeGroupAttribute > ) ( Class < ? > ) AttributeGroupAttribute . class ; return this . request ( "put" , this . resolvePath ( "/attribute-groups/%s/attributes/%s" , attributeGroupName , attributeValue ) , null , null , responseModel , model ) ;
getTopActivitySimpleName: public static String getTopActivitySimpleName ( ) { if ( activityStack . size ( ) == 0 ) { return "" ; } return activityStack . get ( activityStack . size ( ) - 1 ) . getClass ( ) . getSimpleName ( ) ;
init: public void init ( PlayState . InitCallback callback ) { BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ; if ( callback != null )
setDefaultLayout: public SetDefaultLayoutResponse setDefaultLayout ( final String layoutId ) throws IOException , NovuNetworkException { Response < Void > response = layoutApi . setDefaultLayout ( layoutId ) . execute ( ) ; return restHandler . extractResponse ( response , new SetDefaultLayoutResponse ( ) ) ;
render: public void render ( Batch batch , RenderContext context ) { if ( renderList != null )
update: public void update ( float dt ) { super . update ( dt ) ; restartIn -= dt ;
getChartHeight: public float getChartHeight ( ) { return mChartHeight ;
serialize: public byte [ ] serialize ( T value ) { try {
onCommand: public boolean onCommand ( final CommandSender sender , final Command command , final String label , final String [ ] args ) { if ( args . length < 2 ) { sender . sendMessage ( String . format ( "%sNot enough arguments provided" , ChatColor . RED ) ) ; return true ; } final String amount = args [ 0 ] ; final String size = args [ 1 ] ; if ( ! StringUtils . isNumeric ( amount ) ) { sender . sendMessage ( String . format ( "%sAmount arg and payload size must be numeric." , ChatColor . RED ) ) ; } final int requests = Integer . parseInt ( amount ) ; final int payloadSize = Integer . parseInt ( size ) ; final long timestamp = System . currentTimeMillis ( ) ; final AtomicInteger sentRequestsAmount = new AtomicInteger ( ) ; final AtomicReference < Long > requestsSentTimestamp = new AtomicReference < > ( ) ; sender . sendMessage ( String . format ( "%sRunning benchmark with %s request(s)." , ChatColor . GRAY , requests ) ) ; sendRequests ( requestsSentTimestamp , sentRequestsAmount , requests , payloadSize , sender , this :: onResponse ) . thenRun ( ( ) -> { sender . sendMessage ( String . format ( "Sent %d request(s) with a payload size of %d in %d millisecond(s)." , sentRequestsAmount . get ( ) , payloadSize , requestsSentTimestamp . get ( ) - timestamp ) ) ; } ) ; return true ;
received: public boolean received ( final DiscardCard msg ) { notifyCardEvent ( msg ) ; return true ;
update: public void update ( float dt ) { check -= dt ; if ( check < 0 ) { check ( ) ; check = 5.0f ; } if ( enabled )
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { aFWClose2ItemStateChanged ( evt ) ;
addLoadView: private void addLoadView ( ) { if ( ! mIsCanLoad ) { return ; } RecyclerView . Adapter adapter = getAdapter ( ) ; if ( adapter != null && mLoadCreator != null ) {
checkCountAndUnload: public static void checkCountAndUnload ( String uuid ) { if ( hitCounter . computeIfAbsent ( uuid , k -> new AtomicInteger ( ) ) . incrementAndGet ( ) >= getMaxHit ( ) ) {
hasRender: public boolean hasRender ( ) { return false ;
isDrawSteppedEnabled: public boolean isDrawSteppedEnabled ( ) { return mMode == Mode . STEPPED ;
enumsLabelToJsonString: private < E extends Enum < E > > String enumsLabelToJsonString ( E [ ] enumClass ) throws JSONException { JSONArray results = new JSONArray ( ) ; JSONObject result ; for ( E e : enumClass ) { result = new JSONObject ( ) ; result . put ( "k" , e . name ( ) ) ; result . put ( "v" , ( ( OptionWithLabel ) e ) . getLabel ( ) ) ; results . put ( result ) ; } return results . toString ( ) ;
update: public void update ( ) { double oldWaterTemp = waterTemperature ; double tg1SteamTemp = tg1 . getSteamTemperature ( ) / 1.45 ; double tg2SteamTemp = tg2 . getSteamTemperature ( ) / 1.45 ; double highestSteamTemp = tg1SteamTemp < tg2SteamTemp ? tg2SteamTemp : tg1SteamTemp ; thermalPower += ( tg1 . getSteamInflow ( ) / 600.0 ) * 10000 * ( tg1SteamTemp / 196.82 ) * ( ( tg1SteamTemp - waterTemperature ) / 170.0 ) ; thermalPower += ( tg2 . getSteamInflow ( ) / 600.0 ) * 10000 * ( tg2SteamTemp / 196.82 ) * ( ( tg2SteamTemp - waterTemperature ) / 170.0 ) ; double deltaWaterTemp = thermalPower * 50 / ( NPPMath . calculateSpecificHeatWater ( waterTemperature ) * waterMass ) ; waterTemperature += Double . isNaN ( deltaWaterTemp ) || Double . isInfinite ( deltaWaterTemp ) ? 0.0 : deltaWaterTemp ; if ( waterTemperature > highestSteamTemp && waterTemperature > oldWaterTemp ) { waterTemperature = highestSteamTemp * 0.94 ; } heatedWaterTemp = waterTemperature ; thermalPower = 0.0 ; super . update ( ) ;
applyWear: private void applyWear ( ) { if ( disableWear ( ) ) return ; WeaponDurabilityComponentData wdcd = weaponData . getComponent ( WeaponDurabilityComponentData . class ) ; if ( wdcd != null )
setReadView: public CRUDControllerConfiguration < D , E , F > setReadView ( String readView ) { this . readView = readView ; return this ;
switchCurrencies: public void switchCurrencies ( ) { if ( PrefsUtil . isFirstCurrencyPrimary ( ) ) {
reset: public void reset ( ) { this . bullet = null ; this . slot = null ; this . x = 0 ; this . y = 0 ; this . angles = null ; this . ownerId = - 1 ; this . silent = false ;
run: public void run ( ) { for ( Sound sound : ccg . getOpenEffect ( ) ) { sound . play ( ) ; } addAction ( Actions . sequence (
updateStats: protected void updateStats ( ) { super . updateStats ( ) ; if ( stats != null )
getPaintCenterText: public TextPaint getPaintCenterText ( ) { return mCenterTextPaint ;
setShowCropGrid: public void setShowCropGrid ( boolean show ) { options . putBoolean ( EXTRA_SHOW_CROP_GRID , show ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { trip5ActionPerformed ( evt ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { dwTankTempActionPerformed ( evt ) ;
searchByNameAndLastname: void searchByNameAndLastname ( ) { assertEquals ( Optional . empty ( ) , pbook . searchByNameAndLastname ( "marzia" , "bianchi" ) ) ; assertEquals ( Optional . of ( new PhoneBook . Person ( "marzia" , "neri" , "3335566777" ) ) ,
shouldParseRuleDtoWithoutElse: public void shouldParseRuleDtoWithoutElse ( ) { RuleDto ruleDto = initSimpleDto ( ) ; ruleDto . getIfStatements ( ) . put ( 1L , new TreeMap < > ( ) ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . LogicalOperator , "or" ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Field , "name" ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Operator , "contains" ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Value , "test1" ) ; ruleDto . getThenStatements ( ) . put ( 1L , new TreeMap < > ( ) ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . LogicalOperator , "or" ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Field , "name" ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Operator , "contains" ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Value , "test8" ) ; ruleDto . getElseStatements ( ) . get ( 0L ) . put ( RuleDto . StatementKey . Operator , "" ) ; String rule = RuleSpelHelper . parseToString ( ruleDto ) ; assertEquals ( "name == 'test' or name.contains('test1') ? category == 'test2' or name.contains('test8') : null" , rule ) ;
getEmail: public String getEmail ( ) { return email ;
showStepOne: private void showStepOne ( View rootView ) { localEdit = rootView . findViewById ( R . id . edit_local ) ; EditText waterDripEdit = rootView . findViewById ( R . id . edit_water_drip ) ; EditText remoteEdit = rootView . findViewById ( R . id . edit_remote ) ; waterDripEdit . setText ( nodePubkey ) ; remoteEdit . setText ( nodePubkey ) ; rootView . findViewById ( R . id . layout_defaylt_addr ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { rootView . findViewById ( R . id . lv_create_channel_step_one ) . setVisibility ( View . GONE ) ; rootView . findViewById ( R . id . lv_create_channel_step_two ) . setVisibility ( View . VISIBLE ) ; nodePubkey = localEdit . getText ( ) . toString ( ) ; showStepTwo ( rootView ) ; } } ) ; rootView . findViewById ( R . id . layout_scan_qrcode ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PermissionUtils . launchCamera ( ( Activity ) mContext , new PermissionUtils . PermissionCallback ( ) { @ Override public void onRequestPermissionSuccess ( ) { Intent intent = new Intent ( mContext , ScanChannelActivity . class ) ; mContext . startActivity ( intent ) ; } @ Override public void onRequestPermissionFailure ( List < String > permissions ) { LogUtils . e ( TAG , "扫码页面摄像头权限拒绝" ) ; } @ Override public void onRequestPermissionFailureWithAskNeverAgain ( List < String > permissions ) { LogUtils . e ( TAG , "扫码页面摄像头权限拒绝并且勾选不再提示" ) ; } } ) ; } } ) ; rootView . findViewById ( R . id . layout_fill_in ) . setOnClickListener ( new View . OnClickListener ( ) {
getState: public int getState ( ) { return state ;
oneMessage: void oneMessage ( ) { AssertSubscriber < InvocationInput > assertSubscriber = AssertSubscriber . create ( 1 ) ; Multi . createFrom ( ) . item ( ProtoUtils . messageToByteString ( startMessage ( 1 , "my-key" , entry ( "key" , "value" ) ) ) ) . subscribe ( new MessageDecoder ( assertSubscriber ) ) ; assertThat ( assertSubscriber . getLastItem ( ) . message ( ) )
constructFlow: protected < II , IO , ICP > Flow < II , IO , ICP > constructFlow ( Map < String , Object > params , ICP services , Function < ResultAndModel < II , ICP > , IO > f , Supplier < TransactionalExecutor > transactionalExecutorProvider , Consumer < Function > onThen ) { return new Flow < > ( params , services , f , transactionalExecutorProvider , onThen ) ;
removingTaskKeepsObjectModelOK: void removingTaskKeepsObjectModelOK ( ) { project . removeTask ( task ) ; assertFalse ( project . getTasks ( ) . contains ( task ) ) ; assertNull ( task . getProject ( ) ) ;
setMixShearY: public void setMixShearY ( float mixShearY ) { this . mixShearY = mixShearY ;
getFormattedValue: No method body
fileChangedHandle: private void fileChangedHandle ( File classFile ) { try {
gameCompleted: public void gameCompleted ( ) { super . gameCompleted ( ) ; if ( getGameUser ( ) == null || getGameUser ( ) . getSteamFriends ( ) == null ) return ; getGameUser ( ) . getSteamFriends ( ) . setRichPresence ( "connect" , "" ) ; getGameUser ( ) . getSteamFriends ( ) . setRichPresence (
getPlayerData: private LaunchData getPlayerData ( ) { if ( getData ( ) . getOwner ( ) != null ) { return getData ( ) . getOwner ( ) . getComponent ( PlayerAnimationComponentData . class ) . getPrimaryLaunchData ( ) ; } return null ;
runCommandToStream: No method body
info: public void info ( String format , Object ... arguments ) { logger . info ( marker , format , arguments ) ;
getTeam: public Team getTeam ( ) { return getController ( ) . getTeam ( ) ;
toResult: No method body
testReplacePackageGroupForWarehouses: public void testReplacePackageGroupForWarehouses ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/PackageGroupReplacePackageGroupForWarehousesRequest.json" ) ; List < PackageGroupWarehouse > requestEntity = this . jsonSerializer . unserializeList ( expectedRequestJson , PackageGroupWarehouse . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . packageGroups ( ) . replacePackageGroupForWarehouses ( "acme" , "acme" , 1 , requestEntity , options ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pop ( ) ; callback . selectedAny ( ) ;
subscribeLevel: private void subscribeLevel ( String kind , String scoreField ) { Levels levels = BrainOutServer . Controller . getLevels ( kind ) ; int playerLevel = getLevel ( kind , 1 ) ; for ( Levels . Level level : levels . getLevels ( ) )
startNode: private void startNode ( Context context ) { if ( StringUtils . isEmpty ( User . getInstance ( ) . getAlias ( context ) ) ) { Random random = new Random ( ) ; int randomNum = random . nextInt ( 100 ) + 1 ; alias = "alice" + "(" + randomNum + ")" ; User . getInstance ( ) . setAlias ( context , alias ) ; } else { alias = User . getInstance ( ) . getAlias ( context ) ; } LogUtils . e ( "================" , alias ) ; String lndDir = context . getApplicationContext ( ) . getExternalCacheDir ( ) . toString ( ) ; String startParams = ConstantWithNetwork . getInstance ( ConstantInOB . networkType ) . getStartParams ( ) ; Log . d ( TAG , "startNode startParams: " + startParams + alias ) ; LogUtils . e ( "================" , startParams + alias ) ; Obdmobile . start ( "--lnddir=" + lndDir + startParams + alias , new Callback ( ) {
onDestroy: protected void onDestroy ( ) { super . onDestroy ( ) ; EventBus . getDefault ( ) . unregister ( this ) ;
getYOrigin: public float getYOrigin ( ) { return yOrigin ;
getStudentsAsList: public static List < Student > getStudentsAsList ( ) { return new ArrayList < > ( List . of (
getX: public float getX ( ) { return itemData . getX ( ) ;
update: public ShopCategoryPropertyKey update ( String shopCategoryPropertyKey , ShopCategoryPropertyKey model ) throws ApiErrorException , ConnectionException { Class < ShopCategoryPropertyKey > responseModel = ( Class < ShopCategoryPropertyKey > ) ( Class < ? > ) ShopCategoryPropertyKey . class ; return this . request ( "put" , this . resolvePath ( "/shop-category-property-keys/%s" , shopCategoryPropertyKey ) , null , null , responseModel , model ) ;
beforeTransactionCompletion: public void beforeTransactionCompletion ( Map < Object , AuditedObjectState > auditMap , Transaction tx ) { try {
setNegativeButton: public SafeDialogBuilder setNegativeButton ( CharSequence text , DialogInterface . OnClickListener listener ) { super . setNegativeButton ( text , listener ) ; this . mNegativeListener = listener ; return this ;
run: public static < T > T run ( Context ctx , String name , Serde < T > serde , RetryPolicy retryPolicy , ThrowingSupplier < T > action ) throws TerminalException { Syscalls syscalls = ( ( ContextImpl ) ctx ) . syscalls ; CompletableFuture < CompletableFuture < ByteBuffer > > enterFut = new CompletableFuture < > ( ) ; syscalls . enterSideEffectBlock ( name , new EnterSideEffectSyscallCallback ( ) { @ Override public void onNotExecuted ( ) { enterFut . complete ( new CompletableFuture < > ( ) ) ; } @ Override public void onSuccess ( ByteBuffer result ) { enterFut . complete ( CompletableFuture . completedFuture ( result ) ) ; } @ Override public void onFailure ( TerminalException t ) { enterFut . complete ( CompletableFuture . failedFuture ( t ) ) ; } @ Override public void onCancel ( Throwable t ) { enterFut . cancel ( true ) ; } } ) ; CompletableFuture < ByteBuffer > exitFut = Util . awaitCompletableFuture ( enterFut ) ; if ( exitFut . isDone ( ) ) { return Util . deserializeWrappingException ( syscalls , serde , Util . awaitCompletableFuture ( exitFut ) ) ; } ExitSideEffectSyscallCallback exitCallback = new ExitSideEffectSyscallCallback ( ) { @ Override public void onSuccess ( ByteBuffer result ) { exitFut . complete ( result ) ; } @ Override public void onFailure ( TerminalException t ) { exitFut . completeExceptionally ( t ) ; } @ Override public void onCancel ( @ Nullable Throwable t ) { exitFut . cancel ( true ) ; } } ; T res = null ; Throwable failure = null ; try { res = action . get ( ) ; } catch ( Throwable e ) { failure = e ; } if ( failure != null ) { syscalls . exitSideEffectBlockWithException ( failure , retryPolicy , exitCallback ) ; } else { syscalls . exitSideEffectBlock ( Util . serializeWrappingException ( syscalls , serde , res ) , exitCallback ) ; } return Util . deserializeWrappingException ( syscalls , serde , Util . awaitCompletableFuture ( exitFut ) ) ;
removeOuterQuotes: public static String removeOuterQuotes ( String s ) { if ( s == null || s . isEmpty ( ) ) { return s ; } s = s . trim ( ) ; char firstChar = s . charAt ( 0 ) ; char lastChar = s . charAt ( s . length ( ) - 1 ) ; if ( ( firstChar == '\'' || firstChar == '"' || firstChar == '`' ) && ( lastChar == '\'' || lastChar == '"' || lastChar == '`' ) ) { return s . substring ( 1 , s . length ( ) - 1 ) ; } return s ; }
convert: public void convert ( ViewHolder holder , final int position , final ListAssetItemEntity item ) { if ( item . getPropertyid ( ) == 0 ) { holder . setImageResource ( R . id . iv_logo , R . mipmap . icon_btc_logo_small ) ; holder . setText ( R . id . tv_asset , "BTC" ) ; } else { holder . setImageResource ( R . id . iv_logo , R . mipmap . icon_usdt_logo_small ) ; holder . setText ( R . id . tv_asset , "dollar" ) ; } if ( item . getAmount ( ) == 0 ) { DecimalFormat df = new DecimalFormat ( "0.00" ) ; holder . setText ( R . id . tv_asset_amount , df . format ( Double . parseDouble ( String . valueOf ( item . getAmount ( ) ) ) / 100000000 ) ) ; } else { DecimalFormat df = new DecimalFormat ( "0.00######" ) ; holder . setText ( R . id . tv_asset_amount , df . format ( Double . parseDouble ( String . valueOf ( item . getAmount ( ) ) ) / 100000000 ) ) ; } holder . setOnItemClickListener ( new View . OnClickListener ( ) {
isReloading: public boolean isReloading ( ) { switch ( state ) { case reloading : case reloadingBoth : return true ; } return false ;
keySet: public Set keySet ( ) { return new UnmodifiableSetWithRemove ( super . keySet ( ) ) ; }
dp2px: private int dp2px ( float value ) { return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , value , getResources ( ) . getDisplayMetrics ( ) ) ;
received: public boolean received ( final EditorActionMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { switch ( msg . id ) { case saveMap : { final Client messageClient1 = getMessageClient ( ) ; if ( isEditor ( messageClient1 ) ) { saveMap ( ) ; } break ; } case unload : { unload ( ) ; break ; } } } ) ; return true ;
dictionary: public Map dictionary ( String entityKey , String customDescriptionFormula ) { SearchableRepositoryMetadata gsa = SearchableRepositories . getSearchableRepositoryMetadata ( entityKey ) ; return dictionary ( gsa , customDescriptionFormula ) ; }
fromMessage: public static MessageType fromMessage ( MessageLite msg ) { if ( msg instanceof Protocol . SuspensionMessage ) { return MessageType . SuspensionMessage ; } else if ( msg instanceof Protocol . ErrorMessage ) { return MessageType . ErrorMessage ; } else if ( msg instanceof Protocol . EndMessage ) { return MessageType . EndMessage ; } else if ( msg instanceof Protocol . EntryAckMessage ) { return MessageType . EntryAckMessage ; } else if ( msg instanceof Protocol . InputEntryMessage ) { return MessageType . InputEntryMessage ; } else if ( msg instanceof Protocol . OutputEntryMessage ) { return MessageType . OutputEntryMessage ; } else if ( msg instanceof Protocol . GetStateEntryMessage ) { return MessageType . GetStateEntryMessage ; } else if ( msg instanceof Protocol . SetStateEntryMessage ) { return MessageType . SetStateEntryMessage ; } else if ( msg instanceof Protocol . ClearStateEntryMessage ) { return MessageType . ClearStateEntryMessage ; } else if ( msg instanceof Protocol . ClearAllStateEntryMessage ) { return MessageType . ClearAllStateEntryMessage ; } else if ( msg instanceof Protocol . GetStateKeysEntryMessage ) { return MessageType . GetStateKeysEntryMessage ; } else if ( msg instanceof Protocol . GetPromiseEntryMessage ) { return MessageType . GetPromiseEntryMessage ; } else if ( msg instanceof Protocol . PeekPromiseEntryMessage ) { return MessageType . PeekPromiseEntryMessage ; } else if ( msg instanceof Protocol . CompletePromiseEntryMessage ) { return MessageType . CompletePromiseEntryMessage ; } else if ( msg instanceof Protocol . SleepEntryMessage ) { return MessageType . SleepEntryMessage ; } else if ( msg instanceof Protocol . CallEntryMessage ) { return MessageType . CallEntryMessage ; } else if ( msg instanceof Protocol . OneWayCallEntryMessage ) { return MessageType . OneWayCallEntryMessage ; } else if ( msg instanceof Protocol . AwakeableEntryMessage ) { return MessageType . AwakeableEntryMessage ; } else if ( msg instanceof Protocol . CompleteAwakeableEntryMessage ) { return MessageType . CompleteAwakeableEntryMessage ; } else if ( msg instanceof Java . CombinatorAwaitableEntryMessage ) { return MessageType . CombinatorAwaitableEntryMessage ; } else if ( msg instanceof Protocol . RunEntryMessage ) { return MessageType . RunEntryMessage ; } else if ( msg instanceof Protocol . CompletionMessage ) { throw new IllegalArgumentException ( "SDK should never send a CompletionMessage" ) ; } throw new IllegalStateException ( ) ;
deleteLayout: public DeleteLayoutResponse deleteLayout ( final String layoutId ) throws IOException , NovuNetworkException { try {
getDimension: public String getDimension ( ) { return owner . getDimension ( ) ;
done: public void done ( ) { packagesLoaded ( ) ; bound . clear ( ) ;
getPlayerStats: private String getPlayerStats ( ) { return String . valueOf ( BrainOutClient . ClientController . getRemoteClients ( ) . size ) + " / " +
onDismiss: public void onDismiss ( DialogInterface dialog ) { User . getInstance ( ) . setShowUpdateDialog ( false ) ; if ( mCallback != null ) {
search: No method body
getGridClippingRect: public RectF getGridClippingRect ( ) { mGridClippingRect . set ( mViewPortHandler . getContentRect ( ) ) ; mGridClippingRect . inset ( - mAxis . getGridLineWidth ( ) , 0.f ) ; return mGridClippingRect ;
charIsUpperCases: private static boolean charIsUpperCases ( char c ) { return 'a' <= c && 'z' >= c ;
init: @ PostConstruct void init ( ) { for ( String lang : languagesList ) { Locale locale = Locale . forLanguageTag ( lang ) ; languages . put ( lang , locale . getDisplayLanguage ( locale ) ) ; } AbstractForm . setSecureEntityDictionaryRepositoryOnce ( this ) ; instance = this ;
getResourceCategoryDict: public List < ResourceCategoryDictDto > getResourceCategoryDict ( ) { List < ResourceCategoryDictDto > resourceCategoryDictDtoList = ( List < ResourceCategoryDictDto > ) redisTemplate . opsForValue ( ) . get ( SystemDictConstants . RESOURCE_CATEGORY ) ; if ( CollectionUtils . isEmpty ( resourceCategoryDictDtoList ) ) { synchronized ( this ) { resourceCategoryDictDtoList = ( List < ResourceCategoryDictDto > ) redisTemplate . opsForValue ( ) . get ( SystemDictConstants . RESOURCE_CATEGORY ) ; if ( CollectionUtils . isEmpty ( resourceCategoryDictDtoList ) ) { List < ResourceCategory > resourceCategoryList = this . list ( ) ; if ( CollectionUtils . isEmpty ( resourceCategoryList ) ) return resourceCategoryDictDtoList ; resourceCategoryDictDtoList = resourceCategoryList . stream ( ) . map ( resourceCategory -> { ResourceCategoryDictDto categoryDto = new ResourceCategoryDictDto ( ) ; categoryDto . setResourceCategoryId ( resourceCategory . getId ( ) ) ; categoryDto . setCategoryName ( resourceCategory . getCategoryName ( ) ) ; return categoryDto ; } ) . collect ( Collectors . toList ( ) ) ; redisTemplate . opsForValue ( ) . set ( SystemDictConstants . RESOURCE_CATEGORY , resourceCategoryDictDtoList ) ; } } } return resourceCategoryDictDtoList ;
initTable: private void initTable ( int size ) { table = new MyList [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { table [ i ] = new MyArrayList ( ) ; } this . size = 0 ;
hoverItem: private void hoverItem ( ActiveData activeData ) { hoveredItems . add ( activeData ) ;
onInit: public void onInit ( ) { super . onInit ( ) ; MenuHelper . AddCloseButton ( this , this :: pop ) ; BrainOutClient . EventMgr . subscribe ( Event . ID . simple , this ) ;
addIdColumn: public Table addIdColumn ( ) { Column idColumn = new Column ( "id" ) ; idColumn . id = Main . idCounter . getAndIncrement ( ) ; idColumn . definition = "INT NOT NULL PRIMARY KEY" ; columns . add ( idColumn ) ; return this ;
isAtSpawnPoint: public boolean isAtSpawnPoint ( ) { return atSpawnPoint ;
getDraftHash: public String getDraftHash ( ) { return draftHash == null ? "" : draftHash ; }
getSlotItem: public InstrumentSlotItem getSlotItem ( ) { return slotItem ;
deleteCriterion: public void deleteCriterion ( String shopKey , String countryCode , Integer voucherId , Integer voucherCriterionId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/vouchers/%s/criteria/%s" , shopKey , countryCode , voucherId , voucherCriterionId ) , null , null , null ) ;
byteStringFromHex: private static ByteString byteStringFromHex ( String hexString ) { byte [ ] hexBytes = BaseEncoding . base16 ( ) . decode ( hexString . toUpperCase ( ) ) ; return ByteString . copyFrom ( hexBytes ) ;
init: public void init ( ) { spritesWidget = new AvailableRealEstateItemsWidget ( dimension , getMenu ( ) . getDragAndDrop ( ) , getMenu ( ) ) ; getMenu ( ) . addActor ( spritesWidget ) ; getMenu ( ) . setScrollFocus ( spritesWidget . getPane ( ) ) ; spritesWidget . setBounds (
g: public long g ( ) { return - 1 ; }
sendUDPExcept: private void sendUDPExcept ( UdpMessage msg ) { clients . sendUDPExcept ( msg , clientId ) ;
getVersionNumber: No method body
getScaleY: public float getScaleY ( ) { return scaleY ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionIncrementActionPerformed ( evt ) ;
get: public String get ( Map < String , String > carrier , String key ) { if ( carrier == null ) { return null ; } return carrier . get ( key ) ;
onClickItem: No method body
render: public void render ( Batch batch , RenderContext renderContext ) { ClientMap map = Map . GetWatcherMap ( ClientMap . class ) ; if ( map != null )
registerEventConsumer: synchronized public < T > boolean registerEventConsumer ( Class < T > eventClass , EventConsumer < T > eventConsumer ) { debug ( "[registerEventListener] eventConsumer: {}" , eventConsumer ) ; List < EventConsumer > eventConsumers = consumers . get ( eventClass ) ; if ( eventConsumers == null ) { eventConsumers = new ArrayList < > ( ) ; consumers . put ( eventClass , eventConsumers ) ; } return eventConsumers . add ( eventConsumer ) ;
replaceNullString: public static String replaceNullString ( String str ) { return replaceNullString ( str , "--" ) ;
initView: protected void initView ( ) { mTopView . getLayoutParams ( ) . height = StatusBarUtil . getStatusBarHeight ( mContext ) ; mCaptureHelper = new CaptureHelper ( this , mSurfaceView , mFinderView ) ; mCaptureHelper . setOnCaptureCallback ( new MyCaptureCallback ( ) ) ; mCaptureHelper . playBeep ( true ) ; mCaptureHelper . vibrate ( true ) ; mCaptureHelper . onCreate ( ) ; RelativeLayout . LayoutParams params = ( RelativeLayout . LayoutParams ) mLightLayout . getLayoutParams ( ) ; params . bottomMargin = DisplayUtil . getScreenHeight ( mContext ) / 2 - mFinderView . getFrameHeight ( ) / 2 - DisplayUtil . getViewHeight ( mLightLayout ) ;
testGetCustomData: public void testGetCustomData ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . campaigns ( ) . getCustomData ( Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CampaignGetCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
startOpenkodaApp: public static void startOpenkodaApp ( Class appClass , String [ ] args ) throws IOException , ClassNotFoundException , URISyntaxException { setProfiles ( args ) ; JDBCApp . main ( args ) ; if ( ! SpringProfilesHelper . isInitializationProfile ( ) ) { buildAndLoadDynamicClasses ( App . class . getClassLoader ( ) ) ; } App . startApp ( appClass , args , true ) ;
populateFrom: public PageBuilderForm populateFrom ( FrontendResource entity ) { debug ( "[populateFrom] {}" , entity ) ; dto . name = entity . getName ( ) ; dto . content = entity . isDraft ( ) ? entity . getDraftContent ( ) : entity . getContent ( ) ; return this ;
findLowerValuesFails: void findLowerValuesFails ( ) { for ( int i = 0 ; i < MAX_ELEMENTS ; i ++ ) {
selectSkin: private void selectSkin ( Skin skin , Runnable success , Runnable failed ) { JSONObject args = new JSONObject ( ) ; args . put ( "object" , record . getId ( ) ) ; args . put ( "skin" , skin . getID ( ) ) ; WaitLoadingMenu loading = new WaitLoadingMenu ( "" ) ; pushMenu ( loading ) ; BrainOutClient . SocialController . sendRequest ( "freeplay_weapon_skin" , args ,
setOnCancelListener: public SafeDialogBuilder setOnCancelListener ( DialogInterface . OnCancelListener onCancelListener ) { super . setOnCancelListener ( onCancelListener ) ; return this ;
deleteSubscriber: No method body
changed: public void changed ( ChangeEvent event , Actor actor ) { saveButton . setDisabled ( ! validate ( ) ) ;
enableDashedLine: public void enableDashedLine ( float lineLength , float spaceLength , float phase ) { mDashPathEffect = new DashPathEffect ( new float [ ] {
convert: private static byte [ ] convert ( InputStream is ) throws IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int nRead ; byte [ ] data = new byte [ 16384 ] ; while ( ( nRead = is . read ( data , 0 , data . length ) ) != - 1 ) { buffer . write ( data , 0 , nRead ) ; } buffer . flush ( ) ; return buffer . toByteArray ( ) ;
onClick: public void onClick ( View v ) { mMenuPopWindow . dismiss ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putLong ( ChannelsActivity . KEY_BALANCE_AMOUNT , balanceAmount ) ; bundle . putString ( ChannelsActivity . KEY_WALLET_ADDRESS , walletAddress ) ; bundle . putString ( ChannelsActivity . KEY_PUBKEY , pubKey ) ; Intent intent = new Intent ( mContext , ChannelsActivity . class ) ; mContext . startActivity ( intent , bundle ) ;
getAdditionalSettings: public ServerSettings . BaseConditions getAdditionalSettings ( ) { return null ;
getTemperature: public float getTemperature ( ) { return temperature ;
testSend: public void testSend ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/EmailSendRequest.json" ) ; Email requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Email . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . emails ( ) . send ( "acme" , "acme" , requestEntity , options ) ;
testSend: public void testSend ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ReturnItemSendRequest.json" ) ; List < ReturnItem > requestEntity = this . jsonSerializer . unserializeList ( expectedRequestJson , ReturnItem . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . returnItems ( ) . send ( requestEntity , options ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
findByUserIdAndTokenWithInvalidationReasons: No method body
getResourceCategoryListPage: void getResourceCategoryListPage ( ) throws JsonProcessingException { Integer pageNumber = 1 ; Integer pageSize = 10 ; String queryKey = "" ; List < ResourceCategory > listPage = resourceCategoryService . getResourceCategoryListPage ( pageNumber , pageSize , queryKey ) ; assertNotNull ( listPage ) ; log . info ( "获取资源类别列表（分页）方法测试成功:{}" , objectMapper . writeValueAsString ( listPage ) ) ;
write: public void write ( JsonWriter out , HttpResponseEntity value ) throws IOException { if ( value == null ) { out . nullValue ( ) ; return ; } out . beginObject ( ) ; out . name ( "info" ) ; gson . getAdapter ( Object . class ) . write ( out , value . getInfo ( ) ) ; out . name ( "data" ) ; gson . getAdapter ( Object . class ) . write ( out , value . getData ( ) ) ; out . name ( "code" ) ; gson . getAdapter ( String . class ) . write ( out , value . getCode ( ) ) ; out . endObject ( ) ;
isVisible: public boolean isVisible ( ) { return visible ;
onWindowFocusChanged: public void onWindowFocusChanged ( boolean hasFocus ) { super . onWindowFocusChanged ( hasFocus ) ; if ( hasFocus ) {
obtain: public static Event obtain ( float forceX , float forceY ) { AddImpulseEvent e = obtain ( AddImpulseEvent . class ) ; if ( e == null ) return null ; return e . init ( forceX , forceY ) ;
received: public boolean received ( final BattlePassTaskProgressUpdateMsg msg ) { Gdx . app . postRunnable ( ( ) -> { ClientBattlePassEvent bp = null ; for ( ClientEvent event : BrainOutClient . ClientController . getOnlineEvents ( ) ) { if ( ! ( event instanceof ClientBattlePassEvent ) ) { continue ; } if ( event . getEvent ( ) . id == msg . ev ) { bp = ( ( ClientBattlePassEvent ) event ) ; break ; } } if ( bp == null ) return ; if ( bp . getData ( ) . getTasks ( ) . size <= msg . idx ) return ; BattlePassTaskData ttd = bp . getData ( ) . getTasks ( ) . get ( msg . idx ) ; ttd . setCommittedProgress ( msg . cm ) ; ttd . setUncommittedProgress ( msg . unc ) ; } ) ; return true ;
px2sp: public static int px2sp ( Context context , float pxValue ) { final float fontScale = context . getResources ( ) . getDisplayMetrics ( ) . scaledDensity ; return px2dip ( pxValue , fontScale ) ;
setPremultipliedAlpha: public void setPremultipliedAlpha ( boolean pmaColorsAndBlendModes ) { pmaColors = pmaColorsAndBlendModes ; pmaBlendModes = pmaColorsAndBlendModes ;
addRent: public boolean addRent ( Rent rent ) { return rents . add ( rent ) ;
failed: No method body
onDelete: public void onDelete ( Map < Object , AuditedObjectState > auditMap , Object entity , Object id , Object [ ] entityState , String [ ] propertyNames , Type [ ] types ) { debug ( "[onDelete] entity {} id {}" , entity , id ) ; if ( isEntitySpecificListenerRegistered ( entity . getClass ( ) ) ) {
getItemsWeight: private float getItemsWeight ( ) { return existingItemsWeight + amount * itemWeight ;
updateSubscriberPreferences: public SingleSubscriberPrefResponse updateSubscriberPreferences ( final UpdateSubscriberPreferenceRequest request , final String subscriberId , final String templateId ) throws IOException , NovuNetworkException { try {
getAvailableLoggers: public List < Class > getAvailableLoggers ( ) { debug ( "[getAvailableLoggers]" ) ; return debugLogsDecorator . getAvailableLoggers ( ) ;
getNextMode: public GameMode . ID getNextMode ( ) { return nextMode ;
getDisableBuilding: public BooleanOption getDisableBuilding ( ) { return disableBuilding ;
SupercoverLine: public static void SupercoverLine ( float from_x , float from_y , float to_x , float to_y , float cell_width , float cell_height , PointCallback callback ) { float x0 = from_x / cell_width ; float y0 = from_y / cell_height ; float x1 = to_x / cell_width ; float y1 = to_y / cell_height ; float dx = Math . abs ( x1 - x0 ) ; float dy = Math . abs ( y1 - y0 ) ; int x = IPart ( x0 ) ; int y = IPart ( y0 ) ; int num = 1 ; int sx , sy ; float err ; if ( dx == 0 ) { sx = 0 ; err = Float . POSITIVE_INFINITY ; } else if ( x1 > x0 ) { sx = 1 ; num += IPart ( x1 ) - x ; err = RFpart ( x0 ) * dy ; } else { sx = - 1 ; num += x - IPart ( x1 ) ; err = FPart ( x0 ) * dy ; } if ( dy == 0 ) { sy = 0 ; err = Float . NEGATIVE_INFINITY ; } else if ( y1 > y0 ) { sy = 1 ; num += IPart ( y1 ) - y ; err -= RFpart ( y0 ) * dx ; } else { sy = - 1 ; num += y - IPart ( y1 ) ; err -= FPart ( y0 ) * dx ; } while ( true )
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamInVopen4ItemStateChanged ( evt ) ;
getPatchDownLoadDir: public static String getPatchDownLoadDir ( Context context ) { if ( StorageUtils . SdCardAvailable ( ) && StorageUtils . hasExternalStoragePermission ( context ) ) {
givenClass_whenInstantiatesObjectsAtRuntime_thenCorrect: public void givenClass_whenInstantiatesObjectsAtRuntime_thenCorrect ( ) throws Exception { final Class < ? > birdClass = Class . forName ( "com.nbicocchi.tutorials.reflection.Bird" ) ; final Constructor < ? > cons1 = birdClass . getConstructor ( ) ; final Constructor < ? > cons2 = birdClass . getConstructor ( String . class ) ; final Constructor < ? > cons3 = birdClass . getConstructor ( String . class , boolean . class ) ; final Bird bird1 = ( Bird ) cons1 . newInstance ( ) ; final Bird bird2 = ( Bird ) cons2 . newInstance ( "Weaver bird" ) ; final Bird bird3 = ( Bird ) cons3 . newInstance ( "dove" , true ) ; assertEquals ( "bird" , bird1 . getName ( ) ) ; assertEquals ( "Weaver bird" , bird2 . getName ( ) ) ; assertEquals ( "dove" , bird3 . getName ( ) ) ; assertFalse ( bird1 . walks ( ) ) ; assertTrue ( bird3 . walks ( ) ) ;
getMessageHandlers: public static Collection < ServerMessageHandler < Packet > > getMessageHandlers ( ) { return Arrays . stream ( values ( ) ) . map ( DefaultHandlerRegistry :: getHandler ) . map ( DefaultHandlerRegistry :: cast ) . collect ( Collectors . toList ( ) ) ;
setBestExposure: public static void setBestExposure ( Camera . Parameters parameters , boolean lightOn ) { int minExposure = parameters . getMinExposureCompensation ( ) ; int maxExposure = parameters . getMaxExposureCompensation ( ) ; float step = parameters . getExposureCompensationStep ( ) ; if ( ( minExposure != 0 || maxExposure != 0 ) && step > 0.0f ) {
getAccountName: public String getAccountName ( ) { return accountName ;
promiseHandle: No method body
formatResult: private void formatResult ( int printFormat ) { if ( printFormat == 1 ) {
getInactivityTimer: No method body
handleAutoZoom: private boolean handleAutoZoom ( int length , int width ) { if ( lastZoomTime > System . currentTimeMillis ( ) - 1000 ) { return true ; } if ( length < width / 5 ) { Camera camera = cameraManager . getOpenCamera ( ) . getCamera ( ) ; if ( camera != null ) { Camera . Parameters params = camera . getParameters ( ) ; if ( params . isZoomSupported ( ) ) { int maxZoom = params . getMaxZoom ( ) ; int zoom = params . getZoom ( ) ; params . setZoom ( Math . min ( zoom + maxZoom / 5 , maxZoom ) ) ; camera . setParameters ( params ) ; lastZoomTime = System . currentTimeMillis ( ) ; return true ; } else { Log . i ( TAG , "Zoom not supported" ) ; } } } return false ;
UnregisterDimension: public static void UnregisterDimension ( String dimension ) { Dimensions . remove ( dimension ) ;
update: public void update ( ) { double [ ] waterInflowData = NPPMath . mixWater ( waterMass , waterTemperature , waterInflow , waterInflowTemperature ) ; waterTemperature = waterInflowData [ 1 ] ; waterMass = waterInflowData [ 0 ] ; waterMass -= waterOutflow ; double vacuumBreakerFlow = ( pressure - 0.10142 ) * 20 ; specificHeatWater = NPPMath . calculateSpecificHeatWater ( waterTemperature ) ; specificVaporEnthalpy = NPPSim . tables . getSpecificVaporEnthalpyByTemperature ( waterTemperature ) ; specificDensityWater = NPPSim . tables . getWaterDensityByTemp ( waterTemperature ) ; double oldWaterTemp = waterTemperature ; waterTemperature += ( ( NPPSim . tables . getSteamEnthalpyByTemperature ( steamTemperature ) - NPPSim . tables . getSteamEnthalpyByTemperature ( waterTemperature ) ) * steamMass ) / ( specificHeatWater * waterMass ) ; specificHeatWater = NPPMath . calculateSpecificHeatWater ( waterTemperature ) ; deltaEnergy += ( NPPSim . tables . getSteamEnthalpyByTemperature ( waterTemperature ) - NPPSim . tables . getSteamEnthalpyByTemperature ( oldWaterTemp ) ) * steamMass ; steamTemperature = waterTemperature ; if ( initialSteamMass > 0 ) { initialSteamMass -= steamOutflow ; } else { steamMass -= steamOutflow ; } if ( pressure < 0.10142 ) { initialSteamMass -= vacuumBreakerFlow ; } else if ( pressure > 1.45 ) { steamMass -= ( pressure - 1.45 ) * 50 ; } double energy = 0 - deltaHeatingEnergy / 3 ; deltaHeatingEnergy -= deltaHeatingEnergy / 3 ; waterTemperature += ( energy / ( specificHeatWater * waterMass ) ) ; double potentialPressure = NPPSim . tables . getSteamPressureByTemp ( waterTemperature ) ; specificDensityWater = NPPSim . tables . getWaterDensityByTemp ( waterTemperature ) ; waterVolume = waterMass * specificDensityWater ; steamVolume = volume - waterVolume ; deltaSteamMass = steamVolume / NPPSim . tables . getSteamDensityByPressure ( potentialPressure ) - ( steamMass + initialSteamMass ) ; if ( 0.5 * steamInflow + deltaSteamMass < 0 ) { deltaSteamMass = 0 - 0.5 * steamInflow ; } else { deltaSteamMass *= 0.5 ; } specificVaporEnthalpy = NPPSim . tables . getSpecificVaporEnthalpyByTemperature ( waterTemperature ) ; deltaHeatingEnergy += deltaSteamMass * specificVaporEnthalpy ; waterMass -= deltaSteamMass ; steamMass += deltaSteamMass ; energy = 0 - deltaEnergy / 3 ; deltaEnergy -= deltaEnergy / 3 ; waterTemperature += ( energy / ( specificHeatWater * waterMass ) ) ; potentialPressure = NPPSim . tables . getSteamPressureByTemp ( waterTemperature ) ; specificDensityWater = NPPSim . tables . getWaterDensityByTemp ( waterTemperature ) ; waterVolume = waterMass * specificDensityWater ; steamVolume = volume - waterVolume ; deltaSteamMass = steamVolume / NPPSim . tables . getSteamDensityByPressure ( potentialPressure ) - ( steamMass + initialSteamMass ) ; if ( 0.0001 * steamMass + deltaSteamMass < 0 ) { deltaSteamMass = 0 - 0.0001 * steamMass ; } else { deltaSteamMass *= 0.0001 ; } specificVaporEnthalpy = NPPSim . tables . getSpecificVaporEnthalpyByTemperature ( waterTemperature ) ; deltaEnergy += deltaSteamMass * specificVaporEnthalpy ; waterMass -= deltaSteamMass ; steamMass += deltaSteamMass ; if ( steamMass < 0 ) { steamMass = 0 ; } specificDensityWater = NPPSim . tables . getWaterDensityByTemp ( waterTemperature ) ; waterVolume = waterMass * specificDensityWater ; waterLevel = ( waterVolume / nominalWaterVolume - 1 ) * 100 ; steamVolume = volume - waterVolume ; steamDensity = steamVolume / ( steamMass + initialSteamMass ) ; pressure = NPPSim . tables . getSteamPressureByDensity ( steamDensity ) ; resetFlows ( ) ;
retainPrivileges: void retainPrivileges ( Set < PrivilegeBase > privilegesToLeave ) { debug ( "[retainPrivileges]" ) ; if ( privilegesToLeave == null ) { return ; } retainedPrivileges = privilegesToLeave ; Set < String > privileges = privilegesToLeave . stream ( ) . map ( s -> s . name ( ) ) . collect ( Collectors . toSet ( ) ) ; globalPrivileges . retainAll ( privileges ) ; organizationPrivileges . forEach ( ( k , v ) -> v . retainAll ( privileges ) ) ;
update: public void update ( float dt ) { if ( dirty == null || cacheGrid == null || cacheGrid . size == 0 ) return ; dirtyTimer -= dt ; if ( dirtyTimer < 0 )
getAccountName: public String getAccountName ( ) { return accountName ;
stacks: public boolean stacks ( ConsumableItem item ) { return false ;
setErrorMessage: public void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ;
getX: public float getX ( ) { return itemData . getX ( ) + 0.5f ;
stop: public void stop ( IntentService service ) { try {
removeDataSet: public boolean removeDataSet ( int index ) { Log . e ( "MPAndroidChart" , "removeDataSet(int index) not supported for CombinedData" ) ; return false ;
getBadgeId: public String getBadgeId ( ) { return "battle-pass-tasks-daily" ;
update: public void update ( float dt ) { switch ( state ) { case idle : { if ( isLaunching ( ) ) { doLaunch ( ) ; } break ; } case done : { timer -= dt ; if ( timer <= 0 ) { setState ( State . idle ) ; } break ; } } if ( currentBlock != null ) { PlayerOwnerComponent poc = placeBlockData . getOwner ( ) . getComponent ( PlayerOwnerComponent . class ) ; if ( ! poc . getConsumableContainer ( ) . hasConsumable ( currentBlock ) ) { switchSource ( null ) ; } } MyPlayerComponent mpc = placeBlockData . getOwner ( ) . getComponent ( MyPlayerComponent . class ) ; this . placeX = mpc . getPosX ( ) ; this . placeY = mpc . getPosY ( ) ; placeLaunchData . setX ( placeX + 0.5f ) ; placeLaunchData . setY ( placeY + 0.5f ) ;
setOnClickListener: public void setOnClickListener ( int viewId , View . OnClickListener listener ) { mAlert . setOnClickListener ( viewId , listener ) ;
init: public static void init ( Resources res ) { mMetrics = res . getDisplayMetrics ( ) ; mMinimumFlingVelocity = ViewConfiguration . getMinimumFlingVelocity ( ) ; mMaximumFlingVelocity = ViewConfiguration . getMaximumFlingVelocity ( ) ;
addMoreRU: private void addMoreRU ( ) { int need = calculateCreationPrice ( ) - ruAvailable ; int haveRu = getProfileRU ( ) ; if ( haveRu == 0 || haveRu < need ) { pushMenu ( new AlertPopup ( L . get ( "MENU_NOT_ENOUGH_RU" ) ) ) ; return ; } pushMenu ( new TransferRUMenu ( Math . max ( need , 1 ) ,
clicked: public void clicked ( InputEvent event , float x , float y ) { setEditorMode ( EditorMode . Mode . actives ) ;
onClick: public void onClick ( View v ) { mLoadingDialog . show ( ) ; startNode ( ) ;
getMapSource: public MapSource getMapSource ( ) { return mapSource ;
getFrontendResource: private FrontendResource getFrontendResource ( FrontendResourceConversionDto dto ) { FrontendResource frontendResource = repositories . unsecure . frontendResource . findByNameAndAccessLevelAndOrganizationId ( dto . getName ( ) , dto . getAccessLevel ( ) , dto . getOrganizationId ( ) ) ; if ( frontendResource == null ) { frontendResource = new FrontendResource ( ) ; frontendResource . setName ( dto . getName ( ) ) ; frontendResource . setAccessLevel ( dto . getAccessLevel ( ) ) ; frontendResource . setOrganizationId ( dto . getOrganizationId ( ) ) ; } frontendResource . setIncludeInSitemap ( dto . getIncludeInSitemap ( ) ) ; frontendResource . setRequiredPrivilege ( dto . getRequiredPrivilege ( ) ) ; frontendResource . setType ( dto . getType ( ) ) ; frontendResource . setResourceType ( dto . getResourceType ( ) ) ; frontendResource . setModuleName ( dto . getModule ( ) ) ; frontendResource . setEmbeddable ( dto . isEmbeddable ( ) ) ; return frontendResource ;
setDelayText: public void setDelayText ( String start , String end ) { this . mDelayText = start + FORMAT_TAG + end ;
component9: public final boolean component9 ( ) { return this . isThreadStarterMessage ;
of: public static < T , R > HandlerSpecification < T , R > of ( String method , HandlerType handlerType , Serde < T > requestSerde , Serde < R > responseSerde ) { return new HandlerSpecification < > ( method , handlerType , null , requestSerde , responseSerde ) ;
isVisibleTo: No method body
hasLocalizedName: public boolean hasLocalizedName ( ) { return false ;
getLoop: public boolean getLoop ( ) { return loop ;
getAsCommaSeparatedAndSingleQuotedString: private String getAsCommaSeparatedAndSingleQuotedString ( ArrayList < String > values ) { return String . join ( "," , values . stream ( )
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/MasterCategoryCreateRequest.json" ) ; MasterCategory requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , MasterCategory . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; MasterCategory responseEntity = this . api . masterCategories ( ) . create ( requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/MasterCategoryCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
delete: public void delete ( String shopKey , Integer campaignId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/campaigns/%s" , shopKey , campaignId ) , null , null , null ) ;
updateUser: public void updateUser ( @ NonNull User user ) { log . debug ( "更新用户[user={}]" , user ) ; Assert . isTrue ( this . baseMapper . updateById ( user ) > 0 , "更新用户失败！" ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { mFW2OpenItemStateChanged ( evt ) ;
givenClassField_whenGetsType_thenCorrect: public void givenClassField_whenGetsType_thenCorrect ( ) throws Exception { final Field field = Class . forName ( "com.nbicocchi.tutorials.reflection.Bird" ) . getDeclaredField ( "walks" ) ; final Class < ? > fieldClass = field . getType ( ) ; assertEquals ( "boolean" , fieldClass . getSimpleName ( ) ) ;
onPause: protected void onPause ( ) { super . onPause ( ) ; if ( mWebView != null ) {
openUrlInBrowser: public static void openUrlInBrowser ( @ NotNull Context context , @ NotNull String url ) { try {
lockRender: public boolean lockRender ( ) { return true ;
defaultDocumentCreator: public static BiFunction < ObjectNode , String , Map < String , String > > defaultDocumentCreator ( final ObjectMapper objectMapper ) { return ( hitObjectNode , question ) -> {
init: public void init ( ActionPhaseMenu menu ) { topStats = new Table ( ) ; topStats . align ( Align . top | Align . center ) ; topStats . setFillParent ( true ) ; this . stats = new Table ( ) ; stats . align ( Align . left | Align . bottom ) ; stats . setBounds ( 16 , 16 , BrainOutClient . getWidth ( ) , BrainOutClient . getHeight ( ) / 2f ) ; updateStats ( ) ; menu . addActor ( stats ) ; menu . addActor ( topStats ) ;
buffered: public boolean buffered ( ) { return true ;
getTableView: public String getTableView ( ) { return tableView ;
removeRent: public boolean removeRent ( Rent rent ) { return rents . remove ( rent ) ;
classToString: private static String classToString ( Object obj ) { return obj == null ? "[null]" : handler . getClass ( ) . getName ( ) ;
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "l" , location ) ; json . writeValue ( "id" , id ) ;
setHighLightAlpha: public void setHighLightAlpha ( int alpha ) { mHighLightAlpha = alpha ;
set: void set ( ) { enhancedArray . set ( 0 , 0 ) ; enhancedArray . set ( 1 , 1 ) ; enhancedArray . set ( 2 , 4 ) ; enhancedArray . set ( 3 , 9 ) ; assertArrayEquals ( new int [ ] { 0 , 1 , 4 , 9 } , enhancedArray . toArray ( ) ) ; enhancedArray . set ( 5 , 25 ) ; assertArrayEquals ( new int [ ] { 0 , 1 , 4 , 9 , 0 , 25 , 0 , 0 , 0 , 0 } , enhancedArray . toArray ( ) ) ;
getWorldRotation: public float getWorldRotation ( ) { return getWorldRotationX ( ) ;
obtain: protected static < T extends Event > T obtain ( Class < T > classOf , int max ) { return Pools . get ( classOf , max ) . obtain ( ) ;
setLabel: public void setLabel ( String label ) { this . label = label ;
obtain: public static Event obtain ( Client client , PlayerData playerData , String payload ) { ActivateActiveEvent e = obtain ( ActivateActiveEvent . class ) ; if ( e == null ) return null ; return e . init ( client , playerData , payload ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
isLogin: public boolean isLogin ( ) { return isLogin ;
getLastMessage: private static Message getLastMessage ( ModelSearchResponse response ) { if ( EmptyUtils . isEmpty ( response . getHits ( ) ) ) return null ; for ( Message hit : response . getHits ( ) ) { Integer type = hit . F ( ) ; if ( type != null && type != MessageParserConstants . TYPE_USER_JOIN && type != MessageParserConstants . TYPE_RECIPIENT_ADD ) { return hit ; } } return null ;
getTempDir: public static File getTempDir ( ) { File f = new File ( getApplication ( ) . getCacheDir ( ) , "bluecord_temp" ) ; f . mkdirs ( ) ; return f ;
getCardType: public String getCardType ( String bankCode ) { if ( Pattern . matches ( s1 , bankCode ) || Pattern . matches ( s2 , bankCode ) || Pattern . matches ( s4 , bankCode ) || Pattern . matches ( s5 , bankCode ) || Pattern . matches ( s6 , bankCode ) || Pattern . matches ( s7 , bankCode )
setXp: public void setXp ( int xp ) { this . xp = xp ;
handle: public FileHandle handle ( ) { return this ;
onError: public void onError ( Context context , String errorCode , String errorMsg ) { super . onError ( context , errorCode , errorMsg ) ; isClickable = true ; post ( new Runnable ( ) {
setChallengeTs: public void setChallengeTs ( String challengeTs ) { this . challengeTs = challengeTs ;
getForm: public AbstractOrganizationRelatedEntityForm getForm ( String frontendMappingName , SearchableOrganizationRelatedEntity entity ) { FrontendMapping frontendMapping = frontendMappingMap . get ( frontendMappingName ) ; CRUDControllerConfiguration conf = CRUDControllerConfiguration . getBuilder ( "form" , frontendMapping . definition ( ) , frontendMapping . repository ( ) , ReflectionBasedEntityForm . class ) ; Long orgId = TenantResolver . getTenantedResource ( ) . organizationId ; if ( entity == null ) { entity = conf . createNewEntity ( orgId ) ; } ReflectionBasedEntityForm result = ( ReflectionBasedEntityForm ) conf . createNewForm ( orgId , entity ) ; if ( result . getBindingResult ( ) == null ) { result . setBindingResult ( new BeanPropertyBindingResult ( result , result . getFrontendMappingDefinition ( ) . name ) ) ; } return result ;
delayEmission: public final Promise < T > delayEmission ( long time , @ NotNull TimeUnit unit ) { return PromiseUtils . delayEmission ( Holder . executor , this , time , unit ) ;
setEmbeddable: public void setEmbeddable ( boolean embeddable ) { this . embeddable = embeddable ;
setLength: public void setLength ( int sum ) { this . mSum = sum ; this . mSelected = 0 ; draw ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { filter2RegActionPerformed ( evt ) ;
init: public void init ( ) { super . init ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( ( t , e ) -> ExceptionHandler . handle ( e ) ) ; FileHandle version = Gdx . files . local ( "version.txt" ) ; try
getEventName: public String getEventName ( ) { return eventName ;
act: public void act ( float delta ) { super . act ( delta ) ; state . update ( delta ) ; state . apply ( skeleton ) ; BrainOutClient . SkeletonRndr . update ( skeleton , null ) ;
isFastNet: public static boolean isFastNet ( Context context ) { ConnectivityManager manager = ( ConnectivityManager ) context . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; NetworkInfo networkInfo = manager . getActiveNetworkInfo ( ) ; if ( networkInfo != null && networkInfo . isConnected ( ) ) { String type = networkInfo . getTypeName ( ) ; if ( type . equalsIgnoreCase ( "WIFI" ) ) { return true ; } else if ( type . equalsIgnoreCase ( "MOBILE" ) ) { if ( isFastMobileNetwork ( context ) ) { return true ; } else return false ; } } return false ;
onClick: public void onClick ( View v ) { result . cancel ( ) ; dialog . dismiss ( ) ;
create: No method body
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new ClientSafeActivatorComponentData ( ( ActiveData ) componentObject , this ) ;
hasRender: public boolean hasRender ( ) { return false ;
Hourmin: public static String Hourmin ( String time ) { SimpleDateFormat sdr = new SimpleDateFormat ( "HH:mm" ) ; int i = Integer . parseInt ( time ) ; String times = sdr . format ( new Date ( i * 1000L ) ) ; return times ;
unlock: private void unlock ( Client client , PlayerData playerData , String payload ) { if ( ! ( client instanceof PlayerClient ) ) return ; if ( ! safe . isLocked ( ) ) { return ; } if ( payload . equals ( safe . getCode ( ) ) )
setOrganizationId: public void setOrganizationId ( Long organizationId ) { this . organizationId = organizationId ;
getSoundDistance: public float getSoundDistance ( ) { return soundDistance ;
shouldAccept: default boolean shouldAccept ( final @ NonNull Packet packet ) { return true ;
getBotStartingTask: public Task getBotStartingTask ( TaskStack taskStack , BotClient client ) { return new TaskEnforceFlags ( taskStack , client ) ;
getBarBorderWidth: public float getBarBorderWidth ( ) { return mBarBorderWidth ;
createUserNotification: public Notification createUserNotification ( Notification . NotificationType type , String message , String requiredPrivilege , Long userId , String attachmentURL ) { debug ( "[createUserNotification]" ) ; Notification notification = new Notification ( message , type , requiredPrivilege , userId ) ; notification . setAttachmentURL ( attachmentURL ) ; Notification n = notificationRepository . save ( notification ) ; services . applicationEvent . emitEvent ( ApplicationEvent . NOTIFICATION_CREATED , new NotificationDto ( notification ) ) ; return n ;
tryFix: private void tryFix ( ) { if ( BrainOutClient . ClientController . getUserProfile ( ) . getInt ( Constants . User . GEARS , 0 ) > 0 )
setX: public void setX ( float x ) { this . x = x ;
setImage: private void setImage ( ) { int val = Prefs . getInt ( PreferenceKeys . BACKGROUND_MODE , Background . MODE_OFF ) ; if ( val == Background . MODE_FILE ) {
obtain: public static Event obtain ( String kind , EffectSet . EffectAttacher effectAttacher ) { LaunchAttachedEffectEvent e = obtain ( LaunchAttachedEffectEvent . class ) ; if ( e == null ) return null ; return e . init ( kind , effectAttacher ) ;
testAnonymizeAddress: public void testAnonymizeAddress ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . customers ( ) . anonymizeAddress ( "acme" , "acme" , Identifier . fromId ( 1 ) , Identifier . fromId ( 1 ) , options ) ;
update: public void update ( float dt ) { super . update ( dt ) ; switch ( state )
getLightEntity: public LightEntity getLightEntity ( ) { return lightEntity ;
getCurrentItem: protected Mode getCurrentItem ( ) { if ( settings . getMode ( ) . isDefined ( ) ) return items . get ( settings . getMode ( ) . getValue ( ) ) ; return any ;
getFromPubKeyFromLocal: public static String getFromPubKeyFromLocal ( Context context ) { return getString ( SETTINGS , context , KEY_FROM_PUBKEY ) ;
getId: public static long getId ( Object o ) { if ( o instanceof com . discord . models . user . User ) {
getInfo: public Single < lnrpc . LightningOuterClass . GetInfoResponse > getInfo ( lnrpc . LightningOuterClass . GetInfoRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . oBGetInfo ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
done: No method body
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { json . writeArrayStart ( "weapons" ) ; for ( String weapon : weapons ) { json . writeValue ( weapon ) ; } json . writeArrayEnd ( ) ; super . write ( json , componentWriter , owner ) ;
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductUpdateRequest.json" ) ; Product requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Product . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Product responseEntity = this . api . products ( ) . update ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductUpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
hasRender: public boolean hasRender ( ) { return false ;
isAuthenticated: public static boolean isAuthenticated ( ) { Optional < SecurityContext > context = Optional . ofNullable ( SecurityContextHolder . getContext ( ) ) ; return context . map ( a -> a . getAuthentication ( ) ) . map ( a -> a . isAuthenticated ( ) ) . orElse ( false ) ;
setBytes: public int setBytes ( long pos , byte [ ] bytes , int offset , int len ) throws SQLException { return 0 ;
getID: public ID getID ( ) { return ID . reconnect ;
idOffset: public int idOffset ( ) { return 1000 ; }
getConsumerParameterClassName: public String getConsumerParameterClassName ( ) { return consumerParameterClassName ;
list: public CommonResult < CommonPage < White > > list ( @ RequestBody @ Valid WhitePageListParam param ) { List < White > listPage = whiteService . getWhiteListPage ( param . getPageNum ( ) , param . getPageSize ( ) , param . getQueryKey ( ) ) ; return CommonResult . success ( CommonPage . restPage ( listPage ) ) ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < ShopCountryPriceRounding > responseEntity = this . api . shopCountryPriceRoundings ( ) . all ( "acme" , "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCountryPriceRoundingAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( ShopCountryPriceRounding entity : responseEntity . getEntities ( ) ) {
shouldParseNegativeCodedoseCords_withPositiveLang: public void shouldParseNegativeCodedoseCords_withPositiveLang ( ) { String point = "POINT (51.1083 -17.0352)" ; Geometry geometry = MapService . parsePoint ( point ) ; assertEquals ( "Point" , geometry . getGeometryType ( ) ) ; assertEquals ( geometry . toText ( ) , point ) ;
addParams: public HttpUtils addParams ( String key , Object value ) { mParams . put ( key , value ) ; return this ;
setMix: public void setMix ( float mix ) { this . mix = mix ;
compile: private static byte [ ] compile ( boolean staticMethod , String owner , String desc , String body ) throws CompileException , IOException { String template = getTemplate ( ) ; Type [ ] paramTypes = Type . getArgumentTypes ( desc ) ; Type returnType = Type . getReturnType ( desc ) ; List < String > paramClassNames = Arrays . stream ( paramTypes ) . map ( Type :: getClassName ) . collect ( Collectors . toList ( ) ) ; StringBuilder fields_placeholder = new StringBuilder ( ) ; StringBuilder args_placeholder = new StringBuilder ( ) ; if ( ! staticMethod ) { args_placeholder . append ( owner . replace ( "/" , "." ) ) . append ( " $0," ) ; } for ( int i = 0 ; i < paramClassNames . size ( ) ; i ++ ) { String paramClassName = paramClassNames . get ( i ) ; args_placeholder . append ( String . format ( "%s $%d," , paramClassName , i + 1 ) ) ; } if ( returnType == Type . VOID_TYPE ) { args_placeholder . append ( "Object $_" ) ; } else { args_placeholder . append ( returnType . getClassName ( ) ) . append ( " $_\n" ) ; } if ( ! args_placeholder . toString ( ) . isEmpty ( ) && args_placeholder . toString ( ) . endsWith ( "," ) ) { args_placeholder . delete ( args_placeholder . length ( ) - 1 , args_placeholder . length ( ) ) ; } String sourceCode = template . replace ( "{{fields_placeholder}}" , fields_placeholder ) . replace ( "{{args_placeholder}}" , args_placeholder ) . replace ( "{{body_placeholder}}" , body ) . replace ( "{{package_placeholder}}" , "package w;" ) . replace ( "{{return_type}}" , returnType . getClassName ( ) ) ; byte [ ] res = WCompiler . compileWholeClass ( sourceCode ) ; return res ;
getWeight: No method body
setDirty: public void setDirty ( boolean sendProfile ) { this . dirty = true ; this . sendProfile = sendProfile ;
run: public void run ( ) { RandomGenerator rnd = RandomGenerator . getDefault ( ) ; while ( ! interrupted ( ) ) {
loadContent: public Component < ? , ? > loadContent ( ) { Vertical ly = vertical ( ) . childGap ( true ) . padding ( true ) ; ly . add ( text ( "Hello World!" ) ) ; return ly ;
getVerticesCount: void getVerticesCount ( ) { assertEquals ( 4 , square . getVerticesCount ( ) ) ; assertEquals ( 3 , triangle . getVerticesCount ( ) ) ; assertEquals ( 20 , oddlyPoly . getVerticesCount ( ) ) ;
getItemData: public ActiveData getItemData ( ) { return itemData ;
getDecimalDigits: public int getDecimalDigits ( ) { return mDecimalDigits ;
addGroups: public Customer addGroups ( String shopKey , String countryCode , Identifier customerId , CustomerGroup model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Customer > responseModel = ( Class < Customer > ) ( Class < ? > ) Customer . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/customer-groups" , shopKey , countryCode , customerId ) , query , null , responseModel , model ) ;
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Person person = ( Person ) o ; return Objects . equals ( name , person . name ) && Objects . equals ( lastname , person . lastname ) && Objects . equals ( phone , person . phone ) ;
setDelayTime: public void setDelayTime ( int mDelayTime ) { this . mDelayTime = mDelayTime ;
getHighlightColor: public Integer getHighlightColor ( ) { return mHighlightColor ;
arrayAdd: public static < T > T [ ] arrayAdd ( T [ ] src , T ... specific ) { Class < ? > type = src . getClass ( ) . getComponentType ( ) ; T [ ] temp = ( T [ ] ) Array . newInstance ( type , src . length + specific . length ) ; System . arraycopy ( src , 0 , temp , 0 , src . length ) ; System . arraycopy ( specific , 0 , temp , temp . length - 1 , specific . length ) ; return temp ;
eGroupRequest: private boolean eGroupRequest ( SocialMessages . ClientMessage e , boolean notify ) { Clan myClan = BrainOutClient . SocialController . getMyClan ( ) ; LoginService loginService = LoginService . Get ( ) ; if ( myClan != null && loginService != null ) { Clan . ClanMember me = myClan . getMembers ( ) . get ( BrainOutClient . ClientController . getMyAccount ( ) ) ; if ( me != null && ( me == myClan . getOwner ( ) || me . hasPermission ( "request_approval" ) ) ) { String author = e . payload . optString ( "name" , "unknown" ) ; String credential = e . payload . optString ( "credential" , null ) ; String key = e . payload . optString ( "key" , null ) ; if ( key == null ) return true ; ActionMessage msg = new ActionMessage ( L . get ( "MENU_CLAN_EVENT_JOIN_REQUEST" , author ) , e . messageId ) ; msg . addAction ( L . get ( "MENU_CONNECT_ACCOUNT" ) , ( button ) -> { GameState top = BrainOutClient . getInstance ( ) . topState ( ) ; if ( ! ( top . topMenu ( ) instanceof RemoteAccountMenu ) ) { top . pushMenu ( new RemoteAccountMenu ( e . sender , credential ) ) ; } } ) ; msg . addIconAction ( "button-approve" , ( button ) -> { JSONObject args = new JSONObject ( ) ; args . put ( "message_id" , e . messageId ) ; args . put ( "account_id" , e . sender ) ; args . put ( "key" , key ) ; args . put ( "player_name" , author ) ; args . put ( "method" , "approve" ) ; button . setDisabled ( true ) ; BrainOutClient . SocialController . sendRequest ( "respond_clan_request" , args , new SocialController . RequestCallback ( ) { @ Override public void success ( JSONObject response ) { button . setDisabled ( false ) ; } @ Override public void error ( String reason ) { button . setDisabled ( false ) ; } } ) ; } ) ; msg . addIconAction ( "button-reject" , ( button ) -> { JSONObject args = new JSONObject ( ) ; args . put ( "message_id" , e . messageId ) ; args . put ( "account_id" , e . sender ) ; args . put ( "key" , key ) ; args . put ( "method" , "reject" ) ; button . setDisabled ( true ) ; BrainOutClient . SocialController . sendRequest ( "respond_clan_request" , args , new SocialController . RequestCallback ( ) { @ Override public void success ( JSONObject response ) { button . setDisabled ( false ) ; } @ Override public void error ( String reason ) { button . setDisabled ( false ) ; } } ) ; } ) ; addChatMessage ( "clan" , msg , notify ) ; } } return true ;
getLayer: public int getLayer ( ) { return 0 ;
release: public void release ( ) { if ( fbo != null ) { fbo . dispose ( ) ; fbo = null ; } if ( targetFbo != null ) { targetFbo . dispose ( ) ; targetFbo = null ; } inited = false ; disabled = false ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesOpen3ActionPerformed ( evt ) ;
render: No method body
onSuccess: public void onSuccess ( final Context context , final byte [ ] result ) { isClickable = true ; if ( result != null ) {
setupBeforeAll: static void setupBeforeAll ( ) throws URISyntaxException { pdfDirectory = Paths . get ( ReadDocumentsFromPdfChainTest . class . getResource ( "/pdf/qa" ) . toURI ( ) ) ;
evaluateServerJs: public < T > T evaluateServerJs ( ServerJs serverJs , Map < String , Object > externalModel , List < String > externalArguments , Class < T > resultType ) { return evaluateServerJsScript ( serverJs , externalModel , externalArguments , resultType ) ;
failed: public void failed ( ) { Gdx . app . postRunnable ( ( ) ->
setPushUrl: public void setPushUrl ( String pushUrl ) { BarkConfiguration . pushUrl = pushUrl ;
getHitShake: public float getHitShake ( ) { return hitShake ;
resolveDeferred: No method body
getSeedString: public static String getSeedString ( Context context ) { return getString ( SETTINGS , context , SEED_STRING ) ;
getSteamMass: public double getSteamMass ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
refreshContent: No method body
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { tgValvesClose18ItemStateChanged ( evt ) ;
writePdfToByteArray: public byte [ ] writePdfToByteArray ( String templateName , Map < String , Object > ... models ) { return pdfConstructor . writeDocumentToByteArray ( templateName , models ) ;
attachWarehouse: public void attachWarehouse ( Identifier merchantIdentifier , Identifier warehouseIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "post" , this . resolvePath ( "/merchants/%s/warehouses/%s" , merchantIdentifier , warehouseIdentifier ) , null , null , null ) ;
acquireSpawn: public SpawnMode acquireSpawn ( Client client , Team team ) { return SpawnMode . allowed ;
deletePrivilege: No method body
getID: public ID getID ( ) { return ID . getBlogUpdates ;
getItems: public ObjectMap < String , ObjectAtLocation > getItems ( ) { if ( items == null ) { items = new ObjectMap < > ( ) ; } return items ;
getDescription: public String getDescription ( ) { return description ;
unwrapOutputReadyResult: static < T > Output < T > unwrapOutputReadyResult ( Result < T > res ) { if ( ! res . isSuccess ( ) ) { throw res . getFailure ( ) ; } if ( res . isEmpty ( ) ) { return Output . notReady ( ) ; } return Output . ready ( res . getValue ( ) ) ;
getHeight: public float getHeight ( ) { return maxY - minY ;
getXDist: private static float getXDist ( MotionEvent e ) { float x = Math . abs ( e . getX ( 0 ) - e . getX ( 1 ) ) ; return x ;
parse: No method body
update: public void update ( float dt ) { counter += dt ; if ( flagData . getState ( ) == FlagData . State . taking )
color: public PaintHolder color ( int color ) { this . paint . setColor ( color ) ; return this ;
sendSMS: public void sendSMS ( @ NonNull String message ) { rabbitTemplate . convertAndSend ( AMQPConstant . SMS_QUEUE , message ) ;
getStyleEven: protected String getStyleEven ( ) { return "button-row-dark-blue" ;
render: public void render ( Batch batch , RenderContext context ) { super . render ( batch , context ) ; placeSprite . draw ( batch ) ;
testGetCustomData: public void testGetCustomData ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . products ( ) . getCustomData ( Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductGetCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
all: public ApiCollection < Brand > all ( ) throws ApiErrorException , ConnectionException { Class < Brand > responseModel = ( Class < Brand > ) ( Class < ? > ) Brand . class ; return this . requestCollection ( "get" , this . resolvePath ( "/brands" ) , null , null , responseModel ) ;
isPinchZoomEnabled: public boolean isPinchZoomEnabled ( ) { return mPinchZoomEnabled ;
component1: public final long component1 ( ) { return this . channelId ;
getDimension: public String getDimension ( ) { return follow . getDimension ( ) ;
copyTo: void copyTo ( VertexAttachment attachment ) { if ( bones != null ) { attachment . bones = new int [ bones . length ] ; arraycopy ( bones , 0 , attachment . bones , 0 , bones . length ) ; } else attachment . bones = null ; if ( vertices != null ) { attachment . vertices = new float [ vertices . length ] ; arraycopy ( vertices , 0 , attachment . vertices , 0 , vertices . length ) ; } else attachment . vertices = null ; attachment . worldVerticesLength = worldVerticesLength ; attachment . deformAttachment = deformAttachment ;
buttonStyleNo: public String buttonStyleNo ( ) { return "button-small" ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { regen2ItemStateChanged ( evt ) ;
charIsLowerCases: private static boolean charIsLowerCases ( char c ) { return 'a' <= c && 'z' >= c ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
all: public ApiCollection < WebhookEvent > all ( ApiOptions options ) throws ApiErrorException , ConnectionException { Class < WebhookEvent > responseModel = ( Class < WebhookEvent > ) ( Class < ? > ) WebhookEvent . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/webhooks/events" ) , query , null , responseModel ) ;
onClick: public void onClick ( View v ) { mContext . startActivity ( ShareUtil . getTwitterIntent ( mContext , message ) ) ; shareFailedLayout . setVisibility ( View . GONE ) ;
onStopLoad: No method body
hashCode: public int hashCode ( ) { return Objects . hash ( name , lastname , phone ) ;
deleteChannel: public Observable < Channel > deleteChannel ( long channelId ) { return null ;
setClient: public void setClient ( Client client ) { this . clientId = client . getId ( ) ;
registerEventListener: No method body
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Campaign responseEntity = this . api . campaigns ( ) . get ( "acme" , 1 , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CampaignGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
serviceProtocolContentTypeHeader: public static String serviceProtocolContentTypeHeader ( ) { return ServiceProtocol . serviceProtocolVersionToHeaderValue ( Protocol . ServiceProtocolVersion . V1 ) ;
onClick: public void onClick ( View v ) { System . out . println ( shareLayout . toString ( ) ) ; shareLayout . setVisibility ( View . VISIBLE ) ;
render: public void render ( Batch batch , RenderContext context ) { if ( enabled )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionIncrement2ActionPerformed ( evt ) ;
loadPackages: public void loadPackages ( Runnable runnable ) { Gdx . app . postRunnable ( ( ) -> BrainOut . PackageMgr . loadPackages ( runnable ) ) ;
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/CompanyCreateRequest.json" ) ; Company requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Company . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Company responseEntity = this . api . companies ( ) . create ( requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CompanyCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
createSpinner: public static SimpleSpinner createSpinner ( final Context context , SpinnerMap choices , String defaultChoice , @ Nullable ISelectionCallback callback ) { Spinner spinner = new Spinner ( context ) ; spinner . setLayoutParams ( new ViewGroup . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; spinner . setTop ( 20 ) ; spinner . setBottom ( 20 ) ; spinner . setPadding ( 10 , 10 , 10 , 10 ) ; spinner . setPopupBackgroundDrawable ( new ColorDrawable ( Colors . getThemeBackground ( ) ) ) ; List < String > keys = new ArrayList < > ( choices . keySet ( ) ) ; ArrayAdapter < String > adapter = new ArrayAdapter < > ( context , Constants . SPINNER_LAYOUT , keys ) ; adapter . setDropDownViewResource ( Constants . SPINNER_DROP_DOWN_LAYOUT ) ; spinner . setAdapter ( adapter ) ; SimpleSpinner simpleSpinner = new SimpleSpinner ( spinner , defaultChoice ) ; spinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { @ Override public void onItemSelected ( AdapterView < ? > parent , View view , int position , long id ) { String key = ( String ) parent . getItemAtPosition ( position ) ; simpleSpinner . setSelectedKey ( key ) ; LogUtils . log ( TAG , "newValue = " + key ) ; if ( callback != null ) { callback . onItemSelected ( key ) ; } else { Prefs . setString ( DEFAULT_TRANSLATE_FROM_KEY , key ) ; } } @ Override public void onNothingSelected ( AdapterView < ? > parent ) { } } ) ; LogUtils . log ( TAG , "selection index = " + keys . indexOf ( defaultChoice ) ) ; spinner . setSelection ( StringUtils . isEmpty ( defaultChoice ) || ! keys . contains ( defaultChoice ) ? 0 : keys . indexOf ( defaultChoice ) ) ; return simpleSpinner ;
setSalesforceUser: public void setSalesforceUser ( SalesforceUser salesforceUser ) { this . salesforceUser = salesforceUser ;
setAccessLevel: public void setAccessLevel ( FrontendResource . AccessLevel accessLevel ) { this . accessLevel = accessLevel ;
call: private void call ( Client client , PlayerData playerData ) { ServerElevatorComponentData elevator = getElevator ( ) ; if ( elevator == null ) return ; ActiveData button = ( ( ActiveData ) getComponentObject ( ) ) ; if ( button != null ) { BrainOutServer . Controller . getClients ( ) . sendTCP ( new LaunchEffectMsg ( button . getDimension ( ) , button . getX ( ) , button . getY ( ) , getContentComponent ( ) . getPushEffect ( ) ) ) ; } if ( elevator . call ( this ) )
hasUpdate: public boolean hasUpdate ( ) { return false ;
setHighlightFullBarEnabled: public void setHighlightFullBarEnabled ( boolean enabled ) { mHighlightFullBarEnabled = enabled ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case activeAction : { switch ( ( ( ActiveActionEvent ) event ) . action ) { case updated : { updateSound ( ) ; break ; } } break ; } } return false ;
received: public boolean received ( Object from , ModeMessage o ) { this . messageClient = ( ( PlayerClient ) from ) ; return super . received ( from , o ) ;
scrollY: protected void scrollY ( float pixelsY ) { super . scrollY ( pixelsY ) ; scrollY = pixelsY ; updateHoveredRow ( ) ;
isInvoicePayed: public boolean isInvoicePayed ( LightningOuterClass . Invoice invoice ) { boolean payed ; if ( invoice . getValueMsat ( ) == 0 ) { payed = invoice . getAmtPaidMsat ( ) != 0 ; } else { payed = invoice . getValueMsat ( ) <= invoice . getAmtPaidMsat ( ) ; } return payed ;
isEnemies: public boolean isEnemies ( Team a , Team b ) { return true ;
pause: public void pause ( ) { pauseLock . lock ( ) ; try
clearCache: public void clearCache ( ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "已清空类源码变动缓存." ) ; } changedClassNames . clear ( ) ;
initRoleResourceMap: void initRoleResourceMap ( ) throws Exception { MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . get ( "/resource/init" ) . contentType ( MediaType . APPLICATION_JSON ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "资源角色规则接口测试成功:{}" , map . get ( "data" ) ) ;
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "tag" , tag ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
handleException: public CommonResult < ? > handleException ( Exception ex ) { log . error ( "全局异常信息.[异常原因={}]" , ex . getMessage ( ) , ex ) ; return CommonResult . failed ( HttpStatus . ERROR , "系统异常，请联系管理员！" , null , "traceId=" + TraceContext . traceId ( ) ) ;
zoom: public void zoom ( float scaleX , float scaleY , float xValue , float yValue , AxisDependency axis ) { Runnable job = ZoomJob . getInstance ( mViewPortHandler , scaleX , scaleY , xValue , yValue , getTransformer ( axis ) , axis , this ) ; addViewportJob ( job ) ;
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof RequestOptions ) ) return false ; RequestOptions that = ( RequestOptions ) o ; return Objects . equals ( additionalHeaders , that . additionalHeaders ) ;
getError: public static Throwable getError ( @ NonNull Intent result ) { return ( Throwable ) result . getSerializableExtra ( EXTRA_ERROR ) ;
isInverted: public boolean isInverted ( ) { return mInverted ;
getCurrentAccuracy: public float getCurrentAccuracy ( ) { return currentAccuracy ;
setState: public void setState ( State state ) { this . state = state ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoSteamPressure3OffActionPerformed ( evt ) ;
getContent: public String getContent ( ) { return content ;
removeFriend: public void removeFriend ( int id ) { friends . remove ( id ) ;
isVisible: No method body
addDepart: No method body
run: public Stream < Map < String , String > > run ( final String input ) { final Query query = queryCreator . apply ( input ) ; final TopDocs topDocs ; try { topDocs = indexSearcher . search ( query , this . getMaxDocumentCount ( ) ) ; } catch ( final IOException ioException ) { throw new IllegalStateException ( "error processing search for query " + query , ioException ) ; } return Arrays . stream ( topDocs . scoreDocs ) . map ( hit -> {
overrideTheme: public static int overrideTheme ( int current ) { if ( ! isEnabled ( ) ) return current ; switch ( current ) {
setDrawCenterText: public void setDrawCenterText ( boolean enabled ) { this . mDrawCenterText = enabled ;
getBackground: protected TextureRegion getBackground ( ) { return BrainOutClient . getRegion ( "bg-ingame" ) ;
getInstance: public static GlobalConfiguration getInstance ( ) { return GlobalConfigurationHolder . globalConfiguration ;
getSearchableRepositoryEntityClass: public static Class < SearchableEntity > getSearchableRepositoryEntityClass ( String entityKey ) { SearchableRepositoryMetadata gsa = searchableRepositoryMetadataByEntityKey . get ( entityKey ) ; if ( gsa == null ) { return null ; } return ( Class < SearchableEntity > ) gsa . entityClass ( ) ;
isEmbeddable: public boolean isEmbeddable ( ) { return embeddable ;
setOrgIdAndExpose: private void setOrgIdAndExpose ( String formName , CRUDControllerConfiguration conf ) { Form form = formRepository . findByName ( formName ) ; conf . setOrganizationId ( form != null ? form . getOrganizationId ( ) : null ) ; exposed . put ( conf . getKey ( ) , conf ) ;
getByIndex: public ConsumableRecord getByIndex ( int index ) { return data . get ( data . orderedKeys ( ) . get ( index ) ) ;
getIssueDate: public LocalDateTime getIssueDate ( ) { return createdOn ;
notificationMessage: public String notificationMessage ( ) { return "" ;
received: public boolean received ( final SimpleInstrumentActionMsg action ) { BrainOutServer . PostRunnable ( ( ) -> { if ( playerData != null && playerController != null ) { Map map = playerData . getMap ( ) ; if ( map == null ) return ; ChunkData chunk = map . getChunkAt ( ( int ) playerData . getX ( ) , ( int ) playerData . getY ( ) ) ; if ( chunk != null && chunk . hasFlag ( ChunkData . ChunkFlag . shootingDisabled ) ) return ; boolean syncToOthers = chunk == null || ! chunk . hasFlag ( ChunkData . ChunkFlag . hideOthers ) ; final PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; final ServerPlayerControllerComponentData sp = playerData . getComponentWithSubclass ( ServerPlayerControllerComponentData . class ) ; if ( poc != null && sp != null ) { ConsumableRecord record = poc . getConsumableContainer ( ) . get ( action . recordId ) ; if ( record != null ) { InstrumentData instrumentData = poc . getInstrument ( record . getId ( ) ) ; if ( instrumentData instanceof GrenadeData ) { ServerGrenadeComponentData tc = instrumentData . getComponent ( ServerGrenadeComponentData . class ) ; ThrowableActive throwActive = ( ( GrenadeData ) instrumentData ) . getThrowActive ( ) ; if ( throwActive != null && tc != null ) { TimeToLiveComponent ttl = throwActive . getComponent ( TimeToLiveComponent . class ) ; if ( ttl != null ) { tc . cook ( ttl . getTime ( ) ) ; } } } if ( syncToOthers ) { sendUDPExcept ( sp . generateInstrumentActionMessage ( instrumentData , action . action ) ) ; } } } } } ) ; return true ;
onDestroy: protected void onDestroy ( ) { EventBus . getDefault ( ) . unregister ( this ) ; super . onDestroy ( ) ;
received: public boolean received ( OtherPlayerStateMsg msg ) { Gdx . app . postRunnable ( ( ) -> { ClientMap map = Map . Get ( msg . d , ClientMap . class ) ; if ( map == null ) return ; ActiveData activeData = map . getActiveData ( msg . object ) ; if ( activeData instanceof PlayerData ) { PlayerData playerData = ( ( PlayerData ) activeData ) ; ClientPlayerComponent cmp = playerData . getComponent ( ClientPlayerComponent . class ) ; if ( cmp != null ) { cmp . setState ( msg . state ) ; } } } ) ; return true ;
getDimensionAsPx: private static int getDimensionAsPx ( Context context , int rid ) { return ( int ) ( context . getResources ( ) . getDimension ( rid ) + .5f ) ;
show: public void show ( View view , String address ) { if ( mFundPopupWindow == null ) {
obtain: public static Event obtain ( String kind , String payload ) { AnimationActionEvent e = obtain ( AnimationActionEvent . class ) ; if ( e == null ) return null ; return e . init ( kind , payload ) ;
run: public void run ( ) { updateInvoiceList ( ) ; EventBus . getDefault ( ) . post ( new PayInvoiceSuccessEvent ( ) ) ; mLoadingDialog . dismiss ( ) ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_two ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_three ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . layout_cancel ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . layout_close ) . setVisibility ( View . VISIBLE ) ; showStepSuccess ( ) ;
init: public void init ( ) { RoomSettings roomSettings = new RoomSettings ( ) ; roomSettings . setRegion ( BrainOutClient . ClientController . getMyRegion ( ) ) ; roomSettings . init ( BrainOutClient . ClientController . getUserProfile ( ) , false ) ; loadingMenu = new WaitLoadingMenu ( "" ) ; BrainOutClient . getInstance ( ) . topState ( ) . pushMenu ( loadingMenu ) ; Matchmaking . FindGame ( "duel" , roomSettings , new Matchmaking . FindGameResult ( )
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { con1StartItemStateChanged ( evt ) ;
getRandomSecondaryWeapon: public InstrumentSlotItem getRandomSecondaryWeapon ( ) { return getRandomItem ( secondaryWeaponsPool ) ;
setImportSuggestions: public void setImportSuggestions ( String [ ] importSuggestions ) { this . importSuggestions = importSuggestions ;
getColorOf: public Color getColorOf ( RemoteClient remoteClient ) { return null ;
testCreateOrUpdateCustomData: public void testCreateOrUpdateCustomData ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/CampaignCreateOrUpdateCustomDataRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . campaigns ( ) . createOrUpdateCustomData ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CampaignCreateOrUpdateCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
onExcept: public Callback < T > onExcept ( final @ NonNull Consumer < Throwable > onExcept ) { this . onExceptConsumer = onExcept ; return this ;
reset: public void reset ( ) { action = null ;
handleResponse: private void handleResponse ( final MessageContext < TResponse > context ) { responseConsumer . accept ( request , context ) ; this . processedResponses . add ( context ) ;
getY: public int getY ( ) { return y ;
getY: public float getY ( ) { return playerData . getY ( ) + getMouseOffsetY ( ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; width = jsonData . getInt ( "width" , width ) ; height = jsonData . getInt ( "height" , height ) ; generate ( ) ;
getHomeKeyAction: public int getHomeKeyAction ( ) { return homeKeyAction ;
initKeyCodes: private void initKeyCodes ( ) { keyUp = new KeycodeProperty ( "up" , "MENU_CONTROL_UP" , ClientConstants . Keys . KEY_MOVE_UP , controls , KeyProperties . Keys . up ) ; keyDown = new KeycodeProperty ( "down" , "MENU_CONTROL_DOWN" , ClientConstants . Keys . KEY_MOVE_DOWN , controls , KeyProperties . Keys . down ) ; keyLeft = new KeycodeProperty ( "left" , "MENU_CONTROL_LEFT" , ClientConstants . Keys . KEY_MOVE_LEFT , controls , KeyProperties . Keys . left ) ; keyRight = new KeycodeProperty ( "right" , "MENU_CONTROL_RIGHT" , ClientConstants . Keys . KEY_MOVE_RIGHT , controls , KeyProperties . Keys . right ) ; new KeycodeProperty ( "slot-1" , "MENU_CONTROL_SLOT_1" , Input . Keys . NUM_1 , controls , KeyProperties . Keys . slotPrimary ) ; new KeycodeProperty ( "slot-2" , "MENU_CONTROL_SLOT_2" , Input . Keys . NUM_2 , controls , KeyProperties . Keys . slotSecondary ) ; new KeycodeProperty ( "slot-3" , "MENU_CONTROL_SLOT_3" , Input . Keys . NUM_3 , controls , KeyProperties . Keys . slotSpecial ) ; new KeycodeProperty ( "slot-4" , "MENU_CONTROL_SLOT_4" , Input . Keys . NUM_4 , controls , KeyProperties . Keys . slotKnife ) ; new KeycodeProperty ( "slot-5" , "ITEM_BINOCULARS" , Input . Keys . B , controls , KeyProperties . Keys . slotBinoculars ) ; new KeycodeProperty ( "slot-6" , "ITEM_FLASHLIGHT" , Input . Keys . L , controls , KeyProperties . Keys . slotFlashlight ) ; new KeycodeProperty ( "last-switch" , "MENU_CONTROL_SLOT_LAST" , Input . Keys . Q , controls , KeyProperties . Keys . previousSlot ) ; new KeycodeProperty ( "activate" , "MENU_ACTIVATE" , Input . Keys . E , controls , KeyProperties . Keys . activate ) ; new KeycodeProperty ( "sit-2" , "MENU_CONTROL_SIT" , Input . Keys . CONTROL_LEFT , controls , KeyProperties . Keys . sit ) ; new KeycodeProperty ( "run" , "MENU_CONTROL_RUN" , Input . Keys . SHIFT_LEFT , controls , KeyProperties . Keys . run ) ; new KeycodeProperty ( "reload" , "MENU_CONTROL_RELOAD" , Input . Keys . R , controls , KeyProperties . Keys . reload ) ; new KeycodeProperty ( "player-list" , "MENU_CONTROL_PLAYER_LIST" , Input . Keys . TAB , controls , KeyProperties . Keys . playerList ) ; new KeycodeProperty ( "drop-weapon" , "MENU_CONTROL_DROP" , Input . Keys . G , controls , KeyProperties . Keys . dropWeapon ) ; new KeycodeProperty ( "drop-ammo-2" , "MENU_CONTROL_DROP_AMMO" , Input . Keys . F , controls , KeyProperties . Keys . dropAmmo ) ; new KeycodeProperty ( "team" , "MENU_CONTROL_CHANGE_TEAM" , Input . Keys . N , controls , KeyProperties . Keys . changeTeam ) ; new KeycodeProperty ( "shoot-mode" , "MENU_CONTROL_SHOOT_MODE" , Input . Keys . V , controls , KeyProperties . Keys . shootMode ) ; new KeycodeProperty ( "unload-weapon" , "MENU_CONTROL_UNLOAD_WEAPON" , Input . Keys . T , controls , KeyProperties . Keys . unloadWeapon ) ; new KeycodeProperty ( "zoom" , "MENU_CONTROL_ZOOM" , Input . Keys . C , controls , KeyProperties . Keys . zoom ) ; new KeycodeProperty ( "chat" , "MENU_CONTROL_CHAT" , ClientConstants . Keys . KEY_CHAT , controls , KeyProperties . Keys . chat ) ; new KeycodeProperty ( "team-chat" , "MENU_CONTROL_TEAM_CHAT" , ClientConstants . Keys . KEY_TEAM_CHAT , controls , KeyProperties . Keys . teamChat ) ; new KeycodeProperty ( "console" , "MENU_CONTROL_CONSOLE" , ClientConstants . Keys . KEY_DEBUG , controls , KeyProperties . Keys . console ) ; new KeycodeProperty ( "voice-chat" , "MENU_CONTROL_VOICE_CHAT" , Input . Keys . X , controls , KeyProperties . Keys . voiceChat ) ; new KeycodeProperty ( "hide-interface" , "MENU_CONTROL_HIDE_INTERFACE" , Input . Keys . MINUS , controls , KeyProperties . Keys . hideInterface ) ; new KeycodeProperty ( "sit-3" , "MENU_CONTROL_SQUAT" , Input . Keys . Z , controls , KeyProperties . Keys . squat ) ; new KeycodeProperty ( "friendly" , "MENU_CONTROL_FRIENDS_FP" , Input . Keys . F1 , controls , KeyProperties . Keys . freePlayFriends ) ; controls . update ( ) ;
getName: public String getName ( ) { return name ;
reloadEventListener: public boolean reloadEventListener ( long eventListenerId ) { debug ( "[reloadEventListener] {}" , eventListenerId ) ; if ( isCluster ( ) ) { getHazelcastInstance ( ) . getTopic ( CLUSTER_EVENT_TOPIC ) . publish ( new ClusterEvent ( EVENT_LISTENER_RELOAD , eventListenerId ) ) ; return true ; } return false ;
reverse: public static void reverse ( List < String > sentence ) { Deque < String > stack = new LinkedList < > ( ) ; while ( ! sentence . isEmpty ( ) ) { stack . push ( sentence . removeFirst ( ) ) ; } while ( ! stack . isEmpty ( ) ) {
getRequestServletPath: String getRequestServletPath ( HttpServletRequest request ) { return request . getServletPath ( ) ;
toString: public String toString ( ) { return String . valueOf ( uid ) ;
notifyDataSetChanged: public void notifyDataSetChanged ( ) { mPageAdapter . notifyDataSetChanged ( ) ;
search: No method body
isStacked: public boolean isStacked ( ) { return mStackSize > 1 ? true : false ;
write: public void write ( Json json ) { json . writeValue ( "a" , alive ) ; json . writeValue ( "d" , dead ) ;
close: private void close ( ) { onTop = false ; pop ( ) ;
checkBlock: private ActiveData checkBlock ( Map map , Vector2 position ) { ActiveData activeData = checkBlock ( map , position , Constants . Layers . BLOCK_LAYER_FOREGROUND ) ; if ( activeData != null ) { return activeData ; } return checkBlock ( map , position , Constants . Layers . BLOCK_LAYER_BACKGROUND ) ;
setPhaseY: public void setPhaseY ( float phase ) { if ( phase > 1f ) { phase = 1f ; } else if ( phase < 0f ) { phase = 0f ; } mPhaseY = phase ;
copy: protected void copy ( PieDataSet pieDataSet ) { super . copy ( pieDataSet ) ;
getBarBounds: public void getBarBounds ( BarEntry e , RectF outputRect ) { RectF bounds = outputRect ; IBarDataSet set = mData . getDataSetForEntry ( e ) ; if ( set == null ) { outputRect . set ( Float . MIN_VALUE , Float . MIN_VALUE , Float . MIN_VALUE , Float . MIN_VALUE ) ; return ; } float y = e . getY ( ) ; float x = e . getX ( ) ; float barWidth = mData . getBarWidth ( ) ; float top = x - barWidth / 2f ; float bottom = x + barWidth / 2f ; float left = y >= 0 ? y : 0 ; float right = y <= 0 ? y : 0 ; bounds . set ( left , top , right , bottom ) ; getTransformer ( set . getAxisDependency ( ) ) . rectValueToPixel ( bounds ) ;
initChars: public void initChars ( ) { super . initChars ( ) ; RecipeComponent recipeComponent = record . getItem ( ) . getContent ( ) . getComponent ( RecipeComponent . class ) ; if ( recipeComponent != null )
stayOnTop: public boolean stayOnTop ( ) { return onTop ;
init: public void init ( ) { generatePhysics ( ) ;
onClick: public void onClick ( View v ) { amountInput = amountEdit . getText ( ) . toString ( ) ; timeInput = amountTimeEdit . getText ( ) . toString ( ) ; timeType = timeButton . getText ( ) . toString ( ) ; if ( StringUtils . isEmpty ( amountInput ) ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . create_invoice_amount ) ) ; return ; } if ( amountInput . equals ( "0" ) ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . amount_greater_than_0 ) ) ; return ; } if ( ( Double . parseDouble ( amountInput ) * 100000000 ) - ( Double . parseDouble ( canReceive ) * 100000000 ) > 0 ) { CreateNewChannelTipDialog mCreateNewChannelTipDialog = new CreateNewChannelTipDialog ( mContext ) ; mCreateNewChannelTipDialog . setCallback ( new CreateNewChannelTipDialog . Callback ( ) { @ Override public void onClick ( ) { mBasePopWindow . dismiss ( ) ; } } ) ; mCreateNewChannelTipDialog . show ( ) ; return ; } if ( StringUtils . isEmpty ( timeInput ) ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . enter_the_time ) ) ; return ; } if ( timeType . equals ( "Minutes" ) ) { expiryTime = String . valueOf ( Integer . parseInt ( timeInput ) * 60 ) ; } else if ( timeType . equals ( "Hours" ) ) { expiryTime = String . valueOf ( Integer . parseInt ( timeInput ) * 3600 ) ; } else if ( timeType . equals ( "Days" ) ) { expiryTime = String . valueOf ( Integer . parseInt ( timeInput ) * 86400 ) ; } mLoadingDialog . show ( ) ; LightningOuterClass . Invoice asyncInvoiceRequest ; if ( mAssetId == 0 ) { asyncInvoiceRequest = LightningOuterClass . Invoice . newBuilder ( ) . setAssetId ( ( int ) mAssetId ) . setValueMsat ( ( long ) ( Double . parseDouble ( amountEdit . getText ( ) . toString ( ) ) * 100000000 * 1000 ) ) . setMemo ( memoEdit . getText ( ) . toString ( ) ) . setExpiry ( Long . parseLong ( expiryTime ) ) . setPrivate ( false ) . build ( ) ; } else { asyncInvoiceRequest = LightningOuterClass . Invoice . newBuilder ( ) . setAssetId ( ( int ) mAssetId ) . setAmount ( ( long ) ( Double . parseDouble ( amountEdit . getText ( ) . toString ( ) ) * 100000000 ) ) . setMemo ( memoEdit . getText ( ) . toString ( ) ) . setExpiry ( Long . parseLong ( expiryTime ) ) . setPrivate ( false ) . build ( ) ; } Obdmobile . oB_AddInvoice ( asyncInvoiceRequest . toByteArray ( ) , new Callback ( ) {
onBeforeLaunch: protected void onBeforeLaunch ( ) { ClientMap map = ( ( ClientMap ) getMap ( ) ) ; if ( map == null ) return ; ActiveData playerData = getData ( ) . getOwner ( ) ; ClientPlayerComponent cpc = playerData . getComponent ( ClientPlayerComponent . class ) ; ClientWeaponComponentData cwcd = getData ( ) . getComponent ( ClientWeaponComponentData . class ) ; if ( cpc != null )
onScale: public boolean onScale ( ScaleGestureDetector detector ) { float scale = getScale ( ) ; float scaleFactor = detector . getScaleFactor ( ) ; if ( getDrawable ( ) == null ) { return true ; } if ( ( scale < mMaxScale && scaleFactor > 1.0f ) || ( scale > mInitScale && scaleFactor < 1.0f ) ) { if ( scale * scaleFactor > mMaxScale ) { scaleFactor = mMaxScale / scale ; } if ( scale * scaleFactor < mInitScale ) { scaleFactor = mInitScale / scale ; } mMatrix . postScale ( scaleFactor , scaleFactor , detector . getFocusX ( ) , detector . getFocusY ( ) ) ; checkBorderAndCenterWhenScale ( ) ; setImageMatrix ( mMatrix ) ; } return true ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Label title = new Label ( L . get ( "MENU_CLAN_JOIN" ) , BrainOutClient . Skin , "title-yellow" ) ; BorderActor borderActor = new BorderActor ( title , "form-red" ) ; data . add ( borderActor ) . expandX ( ) . fillX ( ) . row ( ) ; } { Table body = new Table ( BrainOutClient . Skin ) ; body . setBackground ( "form-border-red" ) ; renderBody ( body ) ; data . add ( body ) . width ( 530 ) . expand ( ) . fill ( ) . row ( ) ; } { Table buttons = new Table ( ) ; renderButtons ( buttons ) ; data . add ( buttons ) . height ( 64 ) . expandX ( ) . fillX ( ) . row ( ) ; } return data ;
setGridDashedLine: public void setGridDashedLine ( DashPathEffect effect ) { mGridDashPathEffect = effect ;
getCandleData: public CandleData getCandleData ( ) { return mCandleData ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; switchMenu ( ) ;
renderTimeLeft: protected Cell < Table > renderTimeLeft ( Table container ) { Cell < Table > cell = super . renderTimeLeft ( container ) ; RemoteClient fox = getFox ( ) ; if ( fox != null ) { container . row ( ) ; Label currentFox = new Label ( L . get ( "MENU_CURRENT_HUNTER" , fox . getName ( ) ) , BrainOutClient . Skin , "title-yellow" ) ; container . add ( currentFox ) . left ( ) . padLeft ( 8 ) . padTop ( 4 ) ; } return cell ;
rescheduleExistingUnsuccessful: public void rescheduleExistingUnsuccessful ( ) { mockAndAuthenticateUser ( 1l , "test@openkoda.com" , "TEST" , "(canManageBackend)" ) ; Scheduler scheduler = new Scheduler ( SCHEDULER_CRON_EXPRESSION , SCHEDULER_EVENT_DATA , false ) ; long schedulerId = 1L ; scheduler . setId ( schedulerId ) ; ScheduledFuture scheduledFuture = mock ( ScheduledFuture . class ) ; when ( taskScheduler . schedule ( any ( SchedulerService . SchedulerTask . class ) , any ( CronTrigger . class ) ) ) . thenReturn ( scheduledFuture ) ; schedulerService . schedule ( scheduler ) ; when ( scheduledFuture . cancel ( anyBoolean ( ) ) ) . thenReturn ( false ) ; boolean result = schedulerService . reschedule ( schedulerId , scheduler ) ; assertFalse ( result ) ;
onError: public void onError ( Throwable throwable ) { this . completionFuture . completeExceptionally ( throwable ) ;
main: public static void main ( String [ ] argv ) { NSAutoreleasePool pool = new NSAutoreleasePool ( ) ; UIApplication . main ( argv , null , IOSLauncher . class ) ; pool . close ( ) ;
checkPurchaseLimit: public boolean checkPurchaseLimit ( PlayerClient playerClient ) { return true ;
onDisconnect: No method body
init: private Event init ( InstrumentInfo info , int destroyer , float x , float y , float angle , boolean notify ) { this . info = info ; this . destroyer = destroyer ; this . x = x ; this . y = y ; this . angle = angle ; this . notify = notify ; this . ragdoll = true ; return this ;
toLinkedMapWithCustomLabels: private Map < Object , String > toLinkedMapWithCustomLabels ( List < Tuple > allByOrganizationId ) { Map < Object , String > result = new LinkedHashMap < > ( allByOrganizationId . size ( ) ) ; for ( Tuple t : allByOrganizationId ) { String label = messages . get ( t . v ( String . class , 1 ) ) ; result . put ( t . v ( String . class , 0 ) , StringUtils . isNotEmpty ( label ) ? label : t . v ( String . class , 0 ) ) ; } return result ;
px2dip: private static int px2dip ( float pxValue , float scale ) { return ( int ) ( pxValue / scale + 0.5f ) ;
onReceive: public void onReceive ( @ NonNull MessageContext < Request > context ) { context . replyDirectly ( new Response ( ) ) ;
needWayPoints: public boolean needWayPoints ( ) { return true ;
renderPreview: public Actor renderPreview ( boolean full ) { return render ( full ) ;
put: public < T1 , T2 , T3 , T4 , T5 , T6 > Tuple6 < T1 , T2 , T3 , T4 , T5 , T6 > put ( PageAttr < T1 > key1 , PageAttr < T2 > key2 , PageAttr < T3 > key3 , PageAttr < T4 > key4 , PageAttr < T5 > key5 , PageAttr < T6 > key6 , Tuple value ) { return Tuples . of ( this . put ( key1 , ( T1 ) value . getT1 ( ) ) , this . put ( key2 , ( T2 ) value . getT2 ( ) ) , this . put ( key3 , ( T3 ) value . getT3 ( ) ) , this . put ( key4 , ( T4 ) value . getT4 ( ) ) , this . put ( key5 , ( T5 ) value . getT5 ( ) ) , this . put ( key6 , ( T6 ) value . getT6 ( ) ) ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case activeAction : { ActiveActionEvent ev = ( ( ActiveActionEvent ) event ) ; if ( ev . action == ActiveActionEvent . Action . updated ) { updatedActiveData ( ev . activeData ) ; } else if ( ev . action == ActiveActionEvent . Action . removed ) { refresh ( ) ; } else if ( ev . action == ActiveActionEvent . Action . added ) { refresh ( ) ; } break ; } } return false ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; addOne ( ) ;
GetVotes: public static ObjectMap < ID , ClientVote > GetVotes ( ) { return votes ;
isStrictReadAccess: public boolean isStrictReadAccess ( ) { return strictReadAccess ;
getBones: public Array < Bone > getBones ( ) { return bones ;
getNeutrinoDbChecked: public static boolean getNeutrinoDbChecked ( Context context ) { return getBoolean ( SETTINGS , context , KEY_NEUTRINO_DB_CHECKED ) ;
chatWithChoices: No method body
damaged: private void damaged ( DamagedEvent event ) { if ( event . data instanceof ActiveData )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVOpen4ActionPerformed ( evt ) ;
getLabel: No method body
convertPixelsToDp: public static float convertPixelsToDp ( float px ) { if ( mMetrics == null ) { Log . e ( "MPChartLib-Utils" , "Utils NOT INITIALIZED. You need to call Utils.init(...) at least once before" + " calling Utils.convertPixelsToDp(...). Otherwise conversion does not" + " take place." ) ; return px ; } return px / mMetrics . density ;
setEnabled: public void setEnabled ( boolean enabled ) { this . enabled = enabled ;
onClick: public void onClick ( View v ) { mMenuPopWindow . dismiss ( ) ; NodeInfo1PopupWindow mNodeInfoPopupWindow = new NodeInfo1PopupWindow ( mContext ) ; mNodeInfoPopupWindow . show ( view , pubKey ) ;
checkBlock: private ActiveData checkBlock ( Vector2 position ) { ActiveData activeData = checkBlock ( position , Constants . Layers . BLOCK_LAYER_FOREGROUND ) ; if ( activeData != null ) { return activeData ; } return checkBlock ( position , Constants . Layers . BLOCK_LAYER_BACKGROUND ) ;
setTime: public void setTime ( float time ) { this . time = time ;
exchange: No method body
checkIgnoredBlock: private boolean checkIgnoredBlock ( int blockX , int blockY ) { for ( WayPointMap . BlockCoordinates coordinates : new ObjectSet . ObjectSetIterator < > ( followBlocksInWay ) ) { if ( blockX == coordinates . x && blockY == coordinates . y ) { return false ; } } return true ;
getPosition: public MPPointF getPosition ( ) { return mPosition ;
deleteMessage: public DeleteMessageResponse deleteMessage ( final String messageId ) throws IOException , NovuNetworkException { try {
turnOffDebugModeForLoggerClass: public boolean turnOffDebugModeForLoggerClass ( Class c ) { debug ( "[turnOffDebugModeForLoggerClass] {}" , c ) ; return debugLogsDecorator . turnOffDebugModeForLoggerClass ( c ) ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , String datalistId , FieldType type , BiFunction < DtoAndEntity , SecureEntityDictionaryRepository , Object > datalistSupplier , PrivilegeBase requiredReadPrivilege , PrivilegeBase requiredWritePrivilege , String contentType , Function dtoToEntityValueConverter ) { return new FrontendMappingFieldDefinition ( formName , name , type , null , null , requiredReadPrivilege ,
canReadGlobalOrOrgField: default boolean canReadGlobalOrOrgField ( FrontendMappingFieldDefinition field , Long organizationId ) { return hasGlobalOrOrgPrivilege ( field . readPrivilege , organizationId ) ;
getMode: public Mode getMode ( ) { return mode ;
doDisplayPlayerBadge: public boolean doDisplayPlayerBadge ( PlayerData playerData ) { return playerData . getOwnerId ( ) == currentFox ;
getNoButtonText: protected String getNoButtonText ( ) { return L . get ( "MENU_CANCEL" ) ;
isStick: public boolean isStick ( ) { return stick ;
selectAllByQueryKey: No method body
sendUDPExcept: public void sendUDPExcept ( UdpMessage object , Client except , Matching matching ) { for ( ObjectMap . Entry < Integer , Client > entry : this )
setTrayText: public static void setTrayText ( CharSequence text ) { if ( inst != null && inst . mFragment . isVisible ( ) && inst . mediaTrayView != null ) {
coefficients: No method body
getWeight: public int getWeight ( ) { return weight ;
onUpdateDispenser: private void onUpdateDispenser ( ) { if ( BrainOutServer . Controller . isLobby ( ) ) return ; Map map = getMap ( ) ; if ( map == null ) return ; GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode == null ) return ; ActiveData activeData = ( ( ActiveData ) getComponentObject ( ) ) ; float x = activeData . getX ( ) , y = activeData . getY ( ) ; for ( ActiveData other : map . getActivesForTag ( Constants . ActiveTags . RESOURCE_RECEIVER , false ) )
isTerminal: public boolean isTerminal ( ) { return "terminal" . equals ( this . key ) ;
getX: public float getX ( ) { return position . x ;
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "x" , x ) ; json . writeValue ( "y" , y ) ; json . writeValue ( "an" , angle ) ; if ( flipX )
SDCachePath: public static String SDCachePath ( Context context ) { if ( checkSDCardState ( ) && PermissionChecker . checkExternalPermission ( context ) ) {
getYesterdayZeroTime: public static long getYesterdayZeroTime ( ) { return getYesterdayZeroCalendar ( ) . getTimeInMillis ( ) ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fill ;
populateTo: protected Organization populateTo ( Organization entity ) { entity . setName ( getSafeValue ( entity . getName ( ) , NAME_ ) ) ; entity . setPersonalizeDashboard ( getSafeValue ( entity . getPersonalizeDashboard ( ) , PERSONALIZE_DASHBOARD ) ) ; entity . setMainBrandColor ( getSafeValue ( entity . getMainBrandColor ( ) , MAIN_BRAND_COLOR ) ) ; entity . setSecondBrandColor ( getSafeValue ( entity . getSecondBrandColor ( ) , SECOND_BRAND_COLOR ) ) ; entity . setLogoId ( getSafeValue ( entity . getLogoId ( ) , LOGO_ID ) ) ; if ( MultitenancyService . isMultitenancy ( ) ) { entity . setAssignedDatasource ( getSafeValue ( entity . getAssignedDatasource ( ) , ASSIGNED_DATASOURCE_ ) ) ; } return entity ;
spawn: public void spawn ( ) { for ( SpawnEntry entry : entries ) { ObjectMap < String , Array < ActiveData > > d = spawnPool . get ( entry . spawnAtDimension ) ; if ( d == null ) { d = new ObjectMap < > ( ) ; spawnPool . put ( entry . spawnAtDimension , d ) ; } Map map = Map . Get ( entry . spawnAtDimension ) ; if ( map == null ) continue ; Array < ActiveData > s = d . get ( entry . spawnAt ) ; if ( s == null ) { s = new Array < > ( ) ; d . put ( entry . spawnAt , s ) ; map . getActivesForTag ( Constants . ActiveTags . MARKER , s , activeData -> { if ( ! ( activeData instanceof MarkerData ) ) return false ; return ( ( MarkerData ) activeData ) . tag . equals ( entry . spawnAt ) ; } ) ; s . shuffle ( ) ; } } for ( SpawnEntry entry : entries )
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case kill : { KillEvent ev = ( ( KillEvent ) event ) ; if ( ev . killer instanceof PlayerClient && ev . victim != null ) { PlayerClient playerClient = ( ( PlayerClient ) ev . killer ) ; PlayerData killerPlayer = playerClient . getPlayerData ( ) ; PlayerData victimPlayer = ev . victim . getPlayerData ( ) ; if ( killerPlayer != null && victimPlayer != null ) { KarmaComponentData kcd = killerPlayer . getComponent ( KarmaComponentData . class ) ; KarmaComponentData vcd = victimPlayer . getComponent ( KarmaComponentData . class ) ; if ( kcd != null && vcd != null ) { if ( kcd . getKarma ( ) < - 1 && vcd . getKarma ( ) > 1 ) { ServerTask . Trigger ( this , playerClient , 1 ) ; playerClient . addStat ( "karma-kill" , 1 ) ; } else if ( kcd . getKarma ( ) > 1 && vcd . getKarma ( ) < - 1 ) { ServerTask . Trigger ( this , playerClient , 1 ) ; playerClient . addStat ( "karma-kill" , 1 ) ; } } } } } } return false ;
setId: public void setId ( String id ) { this . id = id ;
yes: public void yes ( ) { cancelConflict ( ) ;
getFlowX: public float getFlowX ( ) { return flowX ;
init: No method body
enter: private void enter ( Client client , PlayerData playerData , String payload ) { if ( ! ( client instanceof PlayerClient ) ) return ; PlayerClient playerClient = ( ( PlayerClient ) client ) ; if ( ! ( playerClient . getModePayload ( ) instanceof FreePayload ) ) return ; enterPremises ( playerClient , playerData , payload ) ;
hasClientError: public boolean hasClientError ( ) { ErrorCode [ ] errors = getErrorCodes ( ) ; if ( errors == null ) { return false ; } for ( ErrorCode error : errors ) { switch ( error ) { case InvalidResponse : case MissingResponse : return true ; } } return false ;
all: public ApiCollection < Promotion > all ( ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Promotion > responseModel = ( Class < Promotion > ) ( Class < ? > ) Promotion . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/promotions" ) , query , null , responseModel ) ;
send: default < Req > SendResponse send ( Target target , Serde < Req > reqSerde , Req req , @ Nullable Duration delay , RequestOptions options ) throws IngressException { try {
setWidth: public void setWidth ( int width ) { this . width = width ;
getIndexOfDataSet: public int getIndexOfDataSet ( T dataSet ) { return mDataSets . indexOf ( dataSet ) ;
onError: public void onError ( int code , String message , String data ) { if ( Log . ERROR ) Log . error ( "Party session error: " + code + " " + message + " " + data ) ; Gdx . app . postRunnable ( ( ) -> pushMenu ( new RichAlertPopup ( L . get ( "MENU_ATTENTION" ) , message ) ) ) ;
accept: public void accept ( List < Permission > permissions ) throws Exception { List < String > failurePermissions = new ArrayList < > ( ) ; List < String > askNeverAgainPermissions = new ArrayList < > ( ) ; for ( Permission p : permissions ) { if ( ! p . granted ) { if ( p . shouldShowRequestPermissionRationale ) { failurePermissions . add ( p . name ) ; } else { askNeverAgainPermissions . add ( p . name ) ; } } } if ( failurePermissions . size ( ) > 0 ) { permissionCallback . onRequestPermissionFailure ( failurePermissions ) ; } if ( askNeverAgainPermissions . size ( ) > 0 ) { permissionCallback . onRequestPermissionFailureWithAskNeverAgain ( askNeverAgainPermissions ) ; } if ( failurePermissions . size ( ) == 0 && askNeverAgainPermissions . size ( ) == 0 ) {
count: No method body
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamOutVOpen5ItemStateChanged ( evt ) ;
isEnabled: No method body
onWebViewShouldOverrideUrl: public boolean onWebViewShouldOverrideUrl ( WebView webView , String url ) { return BaseWebViewActivity . this . onWebViewShouldOverrideUrl ( webView , url ) ;
havePaintItem: private boolean havePaintItem ( ) { ConsumableContent paint = BrainOutClient . ContentMgr . get ( "consumable-item-paint" , ConsumableContent . class ) ; return playerInventory . hasConsumable ( paint ) ;
release: public void release ( ) { super . release ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
getEndDate: public LocalDate getEndDate ( ) { return endDate ;
getEntityClass: public Class < E > getEntityClass ( ) { return entityClass ;
dragStart: public DragAndDrop . Payload dragStart ( InputEvent event , float x , float y , int pointer ) { getActor ( ) . setVisible ( false ) ; DragAndDrop . Payload payload = new DragAndDrop . Payload ( ) ; Group offset = new Group ( ) ; Table holder = new Table ( BrainOutClient . Skin ) ; renderContentsItem ( holder , false ) ; offset . addActor ( holder ) ; payload . setDragActor ( offset ) ; payload . setObject ( getRecord ( ) ) ; return payload ;
getPresencePenalty: public Double getPresencePenalty ( ) { return presencePenalty ;
all: public ApiCollection < Voucher > all ( String shopKey , String countryCode ) throws ApiErrorException , ConnectionException { Class < Voucher > responseModel = ( Class < Voucher > ) ( Class < ? > ) Voucher . class ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries/%s/vouchers" , shopKey , countryCode ) , null , null , responseModel ) ;
setRegisterHtmlCrudController: public void setRegisterHtmlCrudController ( boolean registerHtmlCrudController ) { this . registerHtmlCrudController = registerHtmlCrudController ;
setViewShow: public void setViewShow ( List < AssetTrendEntity > result ) { if ( result . size ( ) == 0 || result == null ) { setVisibility ( GONE ) ; return ; } Map < String , Double > maxAndMin = findMaxAndMin ( result ) ; float max = Float . parseFloat ( String . valueOf ( maxAndMin . get ( "max" ) ) ) ; float min = Float . parseFloat ( String . valueOf ( maxAndMin . get ( "min" ) ) ) ; float minY = 0.0f ; if ( min != 0 ) { if ( max - min > min ) { minY = min - ( max - min ) / 2 ; } else if ( max - min < min ) { minY = min - min / 2 ; } else { minY = max / 2 ; } } float maxY = 0.0f ; if ( max - min > min ) { maxY = max + ( max - min ) / 2 ; } else if ( max - min < min ) { maxY = max + min / 2 ; } else { maxY = max + max / 2 ; } if ( max == 0 ) { setVisibility ( GONE ) ; return ; } setVisibility ( VISIBLE ) ; lineChart . getDescription ( ) . setEnabled ( false ) ; lineChart . setTouchEnabled ( false ) ; lineChart . setDragDecelerationFrictionCoef ( 0.9f ) ; lineChart . setDragEnabled ( false ) ; lineChart . setScaleXEnabled ( false ) ; lineChart . setScaleYEnabled ( false ) ; lineChart . setScaleEnabled ( false ) ; lineChart . setDrawGridBackground ( false ) ; lineChart . setHighlightPerDragEnabled ( false ) ; lineChart . setBackgroundColor ( Color . WHITE ) ; lineChart . animateX ( 2000 ) ; XAxis xAxis = lineChart . getXAxis ( ) ; xAxis . setPosition ( XAxis . XAxisPosition . BOTTOM ) ; xAxis . setTextSize ( 10f ) ; xAxis . setTextColor ( Color . parseColor ( "#999999" ) ) ; xAxis . setDrawAxisLine ( true ) ; xAxis . setDrawGridLines ( false ) ; xAxis . setGranularity ( 1f ) ; IndexAxisValueFormatter formatter = new IndexAxisValueFormatter ( ) { @ Override public String getFormattedValue ( float value , AxisBase axis ) { int index = ( int ) value ; if ( index < 0 || index >= result . size ( ) ) { return "" ; } return result . get ( index ) . getTime ( ) ; } } ; xAxis . setValueFormatter ( formatter ) ; YAxis leftAxis = lineChart . getAxisLeft ( ) ; leftAxis . setPosition ( YAxis . YAxisLabelPosition . OUTSIDE_CHART ) ; leftAxis . setDrawGridLines ( true ) ; leftAxis . setGranularityEnabled ( false ) ; leftAxis . setTextColor ( Color . parseColor ( "#999999" ) ) ; leftAxis . setAxisMinimum ( minY ) ; leftAxis . setAxisMaximum ( maxY ) ; YAxis rightAxis = lineChart . getAxisRight ( ) ; rightAxis . setEnabled ( false ) ; Legend legend = lineChart . getLegend ( ) ; legend . setEnabled ( false ) ; setManyDatas ( result ) ;
upload: public ResponseEntity < UploadResponse > upload ( @ PathVariable ( value = ORGANIZATIONID , required = false ) Long organizationId , @ RequestParam ( "qqfile" ) MultipartFile file , @ RequestParam ( "qquuid" ) String uuid , @ RequestParam ( "qqfilename" ) String fileName , @ RequestParam ( value = "qqpartbyteoffset" , required = false , defaultValue = "-1" ) long partByteOffset , @ RequestParam ( value = "qqpartindex" , required = false , defaultValue = "-1" ) int partIndex , @ RequestParam ( value = "qqtotalparts" , required = false , defaultValue = "-1" ) int totalParts , @ RequestParam ( value = "qqtotalfilesize" , required = false , defaultValue = "-1" ) long totalFileSize ) throws SQLException , IOException { debug ( "[upload] upload uuid {}, fileName {}" , uuid , fileName ) ; File f = unsecureFileRepository . findByUploadUuid ( uuid ) ; if ( f == null ) { String originalFilename = file . getOriginalFilename ( ) ; InputStream inputStream = file . getInputStream ( ) ; f = services . file . saveAndPrepareFileEntity ( organizationId , uuid , fileName , totalFileSize , originalFilename , inputStream ) ; unsecureFileRepository . saveAndFlush ( f ) ; } UploadResponse result = new UploadResponse ( null , true , f . getId ( ) , File . toFileDto ( f ) ) ; return ResponseEntity . ok ( ) . body ( result ) ;
isAxisMinCustom: public boolean isAxisMinCustom ( ) { return mCustomAxisMin ;
getDescription: public String getDescription ( ) { return description ;
addUnicodeRangeToSet: private static void addUnicodeRangeToSet ( Set < String > set , int code ) { if ( set == null ) { return ; } filterSet . add ( new String ( new int [ ] { code } , 0 , 1 ) ) ;
reset: public static synchronized void reset ( ) { Set < String > cls = transformers . stream ( ) . map ( BaseClassTransformer :: getClassName ) . collect ( Collectors . toSet ( ) ) ; for ( BaseClassTransformer transformer : transformers ) { instrumentation . removeTransformer ( transformer ) ; } for ( String cl : cls ) { for ( Class < ? > aClass : Global . allLoadedClasses . getOrDefault ( cl , new HashSet < > ( ) ) ) { try { instrumentation . retransformClasses ( aClass ) ; } catch ( Exception e ) { Global . error ( "reset re transform error: " , e ) ; } } } transformers . clear ( ) ; activeTransformers . clear ( ) ; Global . info ( "uninstall all transformer finished" ) ;
init: private Event init ( Client client ) { this . client = client ; return this ;
getTaskActionMatches: public boolean getTaskActionMatches ( String action ) { if ( ! ( action . equals ( getTask ( ) . getAction ( ) ) ) ) { return false ; } if ( BrainOut . getInstance ( ) . getController ( ) . getPlayState ( ) . getID ( ) == PlayState . ID . endgame ) { GameMode . ID ll = ( ( PlayStateEndGame ) BrainOut . getInstance ( ) . getController ( ) . getPlayState ( ) ) . getLastGameMode ( ) ; if ( ll != null ) { return getTask ( ) . getGameModes ( ) . contains ( ll , true ) ; } } return getTask ( ) . getGameModes ( ) . contains ( BrainOut . getInstance ( ) . getController ( ) . getGameMode ( ) . getID ( ) , true ) ;
acquireConsumableItem: public DecayConsumableItem acquireConsumableItem ( ) { return new DecayConsumableItem ( this ) ;
setCompress: public void setCompress ( boolean compress ) { this . compress = compress ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < Product > responseEntity = this . api . products ( ) . all ( options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( Product entity : responseEntity . getEntities ( ) ) {
changeUserOrganizationRole: protected PageModelMap changeUserOrganizationRole ( long organizationId , long userId , String roleName ) { debug ( "[changeUserRole] organizationId {}, userId {}, roleName {}" , organizationId , userId , roleName ) ; return Flow . init ( transactional )
getValidIndex: private int getValidIndex ( int sourceLength , String source ) { if ( TextUtils . isEmpty ( source ) ) { return 0 ; } int length = 0 ; for ( int i = 0 ; i < source . length ( ) ; i ++ ) { if ( source . charAt ( i ) > 255 ) { length += 2 ; } else { length ++ ; } if ( length == sourceLength ) { return i + 1 ; } if ( length > sourceLength ) { return i ; } } return 0 ;
start: private void start ( float time , boolean cancellable , Runnable complete , Runnable cancelled ) { if ( task != null ) { task . cancel ( ) ; } long now = System . currentTimeMillis ( ) ; long timeL = ( long ) ( time * 1000.0f ) ; this . startTime = now ; this . endTime = now + timeL ; this . cancelled = cancelled ; this . cancellable = cancellable ; this . task = new TimerTask ( ) { @ Override public void run ( ) { BrainOut . getInstance ( ) . postRunnable ( ( ) -> { if ( ! ( ( ActiveData ) getComponentObject ( ) ) . isAlive ( ) ) { if ( cancelled != null ) { cancelled . run ( ) ; } return ; } complete . run ( ) ; cleanUp ( ) ; } ) ; } } ; BrainOut . Timer . schedule ( task , timeL ) ; ActiveProgressVisualComponentData visual = getComponentObject ( ) . getComponent ( ActiveProgressVisualComponentData . class ) ; if ( visual != null )
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Table badges = new Table ( ) ; { Label title = new Label ( L . get ( "MENU_SELECT_PROFILE_BADGE" ) , BrainOutClient . Skin , "title-small" ) ; badges . add ( title ) . expandX ( ) . center ( ) . colspan ( 2 ) . pad ( 32 ) . row ( ) ; } ScrollPane pane = new ScrollPane ( badges , BrainOutClient . Skin , "scroll-default" ) ; renderBadges ( badges ) ; data . add ( pane ) . expand ( ) . pad ( 20 ) . fill ( ) ; setScrollFocus ( pane ) ; } return data ;
getWidth: No method body
init: public void init ( ) { BrainOut . Network . connect ( Constants . Connection . TIME_OUT , serverLocation , tcp , udp ,
getSubscriberNotificationsFeed: No method body
applyInterest: public void applyInterest ( ) { amount += amount * interestRate ;
onError: public void onError ( ) { DiscordTools . basicAlert (
init: public void init ( ) { super . init ( ) ; if ( lightData instanceof LightData ) { lightEntity = ( ( LightData ) lightData ) . getLightEntity ( ) ; } else { lightEntity = getContentComponent ( ) . getLightEntity ( ) ; } light = new LightEntityData ( lightEntity , lightData . getDimension ( ) ) { @ Override public float getX ( ) { return lightData . getX ( ) ; } @ Override public float getY ( ) { return lightData . getY ( ) ; } } ; light . init ( ) ; if ( light . getLight ( ) != null ) { light . getLight ( ) . setContactFilter ( SHADOW_FILTER ) ; } BrainOut . EventMgr . subscribe ( Event . ID . physicsUpdated , this ) ;
get: public Object get ( String key ) { return this . options . get ( key ) ;
setMajor: public void setMajor ( Integer major ) { this . major = major ;
handle: No method body
setTakingTeam: public void setTakingTeam ( Team takingTeam ) { this . takingTeam = takingTeam ;
needLocalizationCheck: protected boolean needLocalizationCheck ( ) { return false ;
getSumWeight: public float getSumWeight ( ) { return sumWeight ;
getItemIcon: No method body
resolve: public String resolve ( String define ) { switch ( define ) { case "language" : { return BrainOutClient . ClientSett . getLanguage ( ) . getSelectValue ( ) ; } } return super . resolve ( define ) ;
getOpenCamera: public OpenCamera getOpenCamera ( ) { return camera ;
call: No method body
findAllUserIdsInOrganization: No method body
access$getExperimentOverrides$p: public static HashMap < String , Integer > access$getExperimentOverrides$p ( StoreExperiments experiments ) { return new HashMap < > ( ) ;
scorePosted: private void scorePosted ( float newScore ) { float oldScore = newScore - scoreAdded ; int oldIndex = getCurrentStage ( oldScore ) . completedIndex ; scoreAdded = 0 ; score = newScore ; int newIndex = getCurrentStage ( score ) . completedIndex ; client . log ( "Battle pass score posted, new value: " + newScore ) ; if ( oldIndex != newIndex ) { client . log ( "New battle pass stage: " + newIndex ) ; client . notify ( NotifyAward . none , 0 , NotifyReason . battlePassStageComplete , NotifyMethod . message , new LevelND ( String . valueOf ( newIndex + 1 ) ) ) ; } updated ( ) ;
getConsumableRecord: public ConsumableRecord getConsumableRecord ( ) { return consumableRecord ;
init: private Event init ( RemoteClient killer , RemoteClient victim , Instrument instrument , Skin skin , ActiveData . LastHitKind kind ) { this . killer = killer ; this . victim = victim ; this . instrument = instrument ; this . kind = kind ; this . skin = skin ; return this ;
getLockedIcon: protected String getLockedIcon ( ContentLockTree . LockItem lockItem ) { String unlockFor = lockItem . getUnlockFor ( ) ; if ( Constants . User . TECH_LEVEL . equals ( unlockFor ) ) { Levels levels = BrainOutClient . ClientController . getLevels ( unlockFor ) ; Levels . Level level = levels . getLevel ( lockItem . getParam ( ) ) ; return level . icon ; } return super . getLockedIcon ( lockItem ) ;
zoom: public void zoom ( float scaleX , float scaleY , float x , float y ) { mViewPortHandler . zoom ( scaleX , scaleY , x , - y , mZoomMatrixBuffer ) ; mViewPortHandler . refresh ( mZoomMatrixBuffer , this , false ) ; calculateOffsets ( ) ; postInvalidate ( ) ;
getGameModes: protected GameMode . ID [ ] getGameModes ( ) { return Constants . Matchmaking . APPROVED_MODES ;
readInstrumentSection: protected void readInstrumentSection ( JsonValue instrument ) { this . instrumentContent = ( ( Instrument ) BrainOut . ContentMgr . get ( instrument . getString ( "id" ) ) ) ; if ( this . instrumentContent != null ) { this . instrumentContent . setSlotItem ( this ) ; } if ( instrument . has ( "skin" ) ) { Skin skin = ( Skin ) BrainOut . ContentMgr . get ( instrument . getString ( "skin" ) ) ; defaultSkin = skin ; skins . add ( skin ) ; } else if ( instrument . has ( "skins" ) ) { if ( instrument . get ( "skins" ) . isArray ( ) ) { for ( JsonValue value : instrument . get ( "skins" ) ) { Skin skin = ( Skin ) BrainOut . ContentMgr . get ( value . asString ( ) ) ; skins . add ( skin ) ; } } else { Skin skin = ( Skin ) BrainOut . ContentMgr . get ( instrument . get ( "skins" ) . asString ( ) ) ; skins . add ( skin ) ; } if ( instrument . has ( "defaultSkin" ) ) { defaultSkin = ( Skin ) BrainOut . ContentMgr . get ( instrument . getString ( "defaultSkin" ) ) ; } else { defaultSkin = skins . size > 0 ? skins . get ( 0 ) : null ; } } this . amount = instrument . getInt ( "amount" , this . amount ) ; if ( instrument . has ( "upgrades" ) )
getWatchY: No method body
release: public void release ( ) { if ( mAlertDialog != null ) {
getDiscriminator: public int getDiscriminator ( ) { return 0 ;
calculateDecayMultiplierPerUpdate: public static double calculateDecayMultiplierPerUpdate ( double halfLife ) { return Math . pow ( 0.5 , 1 / ( 72000 * halfLife ) ) ;
renderError: private void renderError ( String errorText ) { clanList . clear ( ) ; Label wait = new Label ( errorText , BrainOutClient . Skin , "title-red" ) ; wait . setAlignment ( Align . center ) ; clanList . add ( wait ) . pad ( 32 ) . expandX ( ) . fillX ( ) . center ( ) . row ( ) ;
onFailure: public void onFailure ( TerminalException t ) { exitFut . completeExceptionally ( t ) ;
isDashedLineEnabled: public boolean isDashedLineEnabled ( ) { return mDashPathEffect == null ? false : true ;
setMinOffset: public void setMinOffset ( float minOffset ) { mMinOffset = minOffset ;
run: public void run ( ) { mAlertDialog . dismiss ( ) ; mLoadingDialog . dismiss ( ) ; deletePaymentProbe ( payment . getPaymentHash ( ) ) ; CreateChannelTipDialog mCreateChannelTipDialog = new CreateChannelTipDialog ( mContext ) ; mCreateChannelTipDialog . show ( ) ;
getShootTime: private float getShootTime ( ) { return ( 60.0f / fireRate . asFloat ( ) ) * Constants . Weapons . SHOOT_SPEED_COEF ;
getSteamDensity: public double getSteamDensity ( ) { return steamDensity ;
act: public void act ( float delta ) { super . act ( delta ) ; Tooltip . update ( this ) ;
onResourceReady: public void onResourceReady ( GlideDrawable resource , GlideAnimation < ? super GlideDrawable > glideAnimation ) { layout . setBackground ( resource . getCurrent ( ) ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; check ( ) ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; if ( texture != null )
setStartYear: public void setStartYear ( int startYear ) { mYearPicker . setStartNumber ( startYear ) ;
testCreateOrUpdateCustomDataForCountry: public void testCreateOrUpdateCustomDataForCountry ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCategoryCreateOrUpdateCustomDataForCountryRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . shopCategories ( ) . createOrUpdateCustomDataForCountry ( "acme" , 1 , "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCategoryCreateOrUpdateCustomDataForCountryResponse.json" ) ; assertThatJson ( expectedResponseJson )
initWebSocket: private void initWebSocket ( ) { if ( mOkHttpClient == null ) { mOkHttpClient = new OkHttpClient . Builder ( ) . retryOnConnectionFailure ( true ) . build ( ) ; } if ( mRequest == null ) { mRequest = new Request . Builder ( ) . url ( wsUrl ) . build ( ) ; } mOkHttpClient . dispatcher ( ) . cancelAll ( ) ; try {
getAddress: public String getAddress ( ) { return address ;
getCurrentBillingStart: public LocalDateTime getCurrentBillingStart ( ) { return currentBillingStart ;
setVolume: public void setVolume ( float volume ) { this . volume = volume ;
isPaused: public static boolean isPaused ( ) { return simPaused ;
getRenderer: public SkeletonRenderer getRenderer ( ) { return renderer ;
request: public void request ( long l ) { handleSubscriptionRequest ( l ) ;
yes: public void yes ( ) { prefs . putBoolean ( id , true ) ; prefs . flush ( ) ; Gdx . app . postRunnable ( ( ) -> {
getComponent: public WeaponAnimationComponentData getComponent ( ComponentObject componentObject ) { return new WeaponAnimationComponentData ( ( WeaponData ) componentObject , this ) ;
getWebView: public WebView getWebView ( ) { return mWebView ;
findBone: private BonePointData findBone ( String name ) { BonePointData bone = instrumentComponent . getBone ( name ) ; if ( bone == null && instrumentData . getOwner ( ) != null ) { PlayerAnimationComponentData pac = instrumentData . getOwner ( ) . getComponent ( PlayerAnimationComponentData . class ) ; if ( pac != null ) { Bone bone_ = pac . getSkeleton ( ) . findBone ( name ) ; if ( bone_ == null ) return null ; return new BonePointData ( bone_ , pac . getLaunchData ( ) ) ; } } return bone ;
stop: protected void stop ( ) { if ( soundId != - 1 )
createOrUpdateGlobalOrgRole: public GlobalOrganizationRole createOrUpdateGlobalOrgRole ( Long id , String name , Set < PrivilegeBase > privileges , boolean removable ) { debug ( "[createOrUpdateGlobalOrgRole] orgName: {}; privilages: {}; removable: {}" , name , privileges , removable ) ; GlobalOrganizationRole role = repositories . unsecure . globalOrganizationRole . findByName ( name ) ; if ( role == null ) { role = new GlobalOrganizationRole ( id , name ) ; } role . setPrivilegesSet ( privileges ) ; role . setRemovable ( removable ) ; repositories . unsecure . globalOrganizationRole . save ( role ) ; role = repositories . unsecure . globalOrganizationRole . findByName ( name ) ; applicationEventPublisher . publishEvent ( new PrivilegeChangeEvent ( this ) ) ; return role ;
updateMemberRole: No method body
getPlayerStats: private String getPlayerStats ( ) { int count = 0 ; for ( ObjectMap . Entry < Integer , RemoteClient > client : BrainOutClient . ClientController . getRemoteClients ( ) ) { RemoteClient remoteClient = client . value ; if ( remoteClient . getInfoBoolean ( "bot" , false ) ) continue ; count ++ ; } return String . valueOf ( count ) + " / " +
getAxis: public YAxis . AxisDependency getAxis ( ) { return axis ;
getPreviewURL: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionDecrement5ActionPerformed ( evt ) ;
filter: public Mono < Void > filter ( ServerWebExchange exchange , WebFilterChain chain ) { String token = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthConstants . JWT_TOKEN_HEADER ) ; log . info ( "请求进来了.[token={}]" , token ) ; if ( StringUtils . isBlank ( token ) ) { return chain . filter ( exchange ) ; } try { String repToken = token . replace ( AuthConstants . JWT_TOKEN_PREFIX , "" ) ; JWSObject jwsObject = JWSObject . parse ( repToken ) ; String user = jwsObject . getPayload ( ) . toString ( ) ; log . info ( "token中获取的[user={}]" , user ) ; ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . header ( AuthConstants . USER_TOKEN_HEADER , user ) . build ( ) ; exchange = exchange . mutate ( ) . request ( request ) . build ( ) ; } catch ( ParseException e ) { log . error ( e . getMessage ( ) ) ; } return chain . filter ( exchange ) ;
init: public void init ( PlayState . InitCallback callback ) { BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ; if ( callback != null )
getGridClippingRect: public RectF getGridClippingRect ( ) { mGridClippingRect . set ( mViewPortHandler . getContentRect ( ) ) ; mGridClippingRect . inset ( - mAxis . getGridLineWidth ( ) , 0.f ) ; return mGridClippingRect ;
getInvocationState: public InvocationState getInvocationState ( ) { return this . invocationState ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVStop4ActionPerformed ( evt ) ;
getAimOffset: public Vector2 getAimOffset ( ) { return aimOffset ;
getHighlightCircleOuterRadius: public float getHighlightCircleOuterRadius ( ) { return mHighlightCircleOuterRadius ;
setBezier: public void setBezier ( int bezier , int frame , int value , float time1 , float value1 , float cx1 , float cy1 , float cx2 , float cy2 , float time2 , float value2 ) { float [ ] curves = this . curves ; int i = getFrameCount ( ) + bezier * BEZIER_SIZE ; if ( value == 0 ) curves [ frame ] = BEZIER + i ; float tmpx = ( time1 - cx1 * 2 + cx2 ) * 0.03f , tmpy = ( value1 - cy1 * 2 + cy2 ) * 0.03f ; float dddx = ( ( cx1 - cx2 ) * 3 - time1 + time2 ) * 0.006f , dddy = ( ( cy1 - cy2 ) * 3 - value1 + value2 ) * 0.006f ; float ddx = tmpx * 2 + dddx , ddy = tmpy * 2 + dddy ; float dx = ( cx1 - time1 ) * 0.3f + tmpx + dddx * 0.16666667f , dy = ( cy1 - value1 ) * 0.3f + tmpy + dddy * 0.16666667f ; float x = time1 + dx , y = value1 + dy ; for ( int n = i + BEZIER_SIZE ; i < n ; i += 2 ) {
delete: public void delete ( Identifier variantIdentifier , String priceKey ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/variants/%s/prices/%s" , variantIdentifier , priceKey ) , null , null , null ) ;
setFilesId: public void setFilesId ( List < Long > filesId ) { this . filesId = filesId ;
lockInput: public boolean lockInput ( ) { return true ;
updated: public void updated ( ) { BrainOut . EventMgr . sendDelayedEvent ( ComponentUpdatedEvent . obtain ( this , activeData ) ) ; if ( Log . INFO ) Log . info ( "Component " + getComponentClass ( ) . getCanonicalName ( ) + " updated!" ) ;
getCustomDataForKey: public Map < String , Object > getCustomDataForKey ( String shopKey , String key , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/custom-data/%s" , shopKey , key ) , query , null , responseModel ) ;
checkMemberStatus: private void checkMemberStatus ( ) { updateMembersStatus ( ) ; addAction ( Actions . repeat ( RepeatAction . FOREVER , Actions . sequence (
disposeNoise: private void disposeNoise ( ) { if ( noise != null )
stayOnTop: public boolean stayOnTop ( ) { return onTop ;
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fill ;
component2: public final long component2 ( ) { return this . lastMessageId ;
searchByNameAndLastname: public Person [ ] searchByNameAndLastname ( String name , String lastname ) { ArrayList < Person > tmp = new ArrayList < > ( ) ; for ( Person p : phoneBook ) { if ( p . getLastname ( ) . equals ( lastname ) && p . getName ( ) . equals ( name ) ) { tmp . add ( p ) ; } } return tmp . toArray ( new Person [ ] { } ) ;
remove: public Object remove ( int index ) { Object removed ; checkBoundaries ( index , size - 1 ) ; if ( index == 0 ) { removed = head . getPayload ( ) ; head = head . getNext ( ) ; } else { Node previous = getNodeByIndex ( index - 1 ) ; removed = previous . getNext ( ) . getPayload ( ) ; previous . setNext ( previous . getNext ( ) . getNext ( ) ) ; } size -- ; return removed ;
setParent: protected void setParent ( Group parent ) { super . setParent ( parent ) ; if ( parent == null && data != null )
getCrashLogName: public static String getCrashLogName ( ) { return "crash_" + DateUtils . formatCurrentDate ( ) + ".log" ;
removeLast: void removeLast ( ) { deque . addFirst ( "nicola" ) ; deque . addFirst ( "marco" ) ; deque . addFirst ( "giovanni" ) ; assertEquals ( "nicola" , deque . removeLast ( ) ) ;
update: public Campaign update ( String shopKey , Integer campaignId , Campaign model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Campaign > responseModel = ( Class < Campaign > ) ( Class < ? > ) Campaign . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/shops/%s/campaigns/%s" , shopKey , campaignId ) , query , null , responseModel , model ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case destroy : { destroy ( ) ; break ; } } return false ;
getInfoFloat: public float getInfoFloat ( String key , float def ) { if ( info == null ) return def ; return info . optFloat ( key , def ) ;
run: public void run ( ) { notify . markAsRead ( ) ; readTasks . remove ( taskKey ) ; BrainOutClient . EventMgr . sendDelayedEvent ( SimpleEvent . obtain ( SimpleEvent . Action . updateSocialMessages ) ) ;
getSteamMass: public double getSteamMass ( ) { return 0 ;
toString: public String toString ( ) { return "" ;
initProperties: protected void initProperties ( Array < Upgrade > upgrades ) { aimDistance = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . AIM_DISTANCE ) , upgrades ) ; damage = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . DAMAGE ) , upgrades ) ; bullet = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . BULLET ) , upgrades ) ; accuracy = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . ACCURACY ) , upgrades ) ; recoil = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . RECOIL ) , upgrades ) ; reloadTime = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . RELOAD_TIME ) , upgrades ) ; fetchTime = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . FETCH_TIME ) , upgrades ) ; reloadBothTime = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . RELOAD_TIME_BOTH ) , upgrades ) ; cockTime = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . COCK_TIME ) , upgrades ) ; fireRate = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . FIRE_RATE ) , upgrades ) ; fireRateB2 = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . FIRE_RATE_B2 ) , upgrades ) ; clipSize = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . CLIP_SIZE ) , upgrades ) ; speedCoef = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . SPEED_COEF ) , upgrades ) ; shootModes = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . SHOOT_MODES ) , upgrades ) ; magazinesCount = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . NUMBER_OF_MAGAZINES ) , upgrades ) ; addMagazineRoundTime = new UpgradableProperty ( weaponProperties . property ( Constants . Properties . MAG_ADD_ROUND_TIME ) , upgrades ) ; UpgradableProperty resistance = weaponProperties . property ( Constants . Properties . WEAR_RESISTANCE ) ; if ( data . getComponent ( WeaponDurabilityComponentData . class ) != null && resistance != null ) { wearResistance = new UpgradableProperty ( resistance , upgrades ) ; } source . init ( this ) ;
getUsersInOrganizationWithRole: No method body
exceptionCaught: public void exceptionCaught ( final ChannelHandlerContext context , final Throwable cause ) { if ( cause instanceof ReadTimeoutException ) { client . getLogger ( ) . warn ( "{}: {}" , cause . getClass ( ) . getSimpleName ( ) , cause . getMessage ( ) ) ; return ; } if ( cause instanceof SocketException ) { client . getLogger ( ) . warn ( "{}: {}" , cause . getClass ( ) . getSimpleName ( ) , cause . getMessage ( ) ) ; return ; } client . getLogger ( ) . warn ( "An Exception has reached the end of pipeline: {}: {}" , cause . getClass ( ) , cause . getMessage ( ) ) ; client . getLogger ( ) . fatal ( cause ) ;
owned: No method body
toPredicate: public Predicate toPredicate ( Root < UserRole > root , CriteriaQuery < ? > query , CriteriaBuilder cb ) { if ( specificOrganizationId != null ) { return cb . equal ( root . get ( "organizationId" ) , specificOrganizationId ) ; } return cb . conjunction ( ) ;
search: public List < T > search ( Specification < T > specification ) { return wrapped . search ( scope , specification ) ;
getConsumableContent: public ConsumableContent getConsumableContent ( ) { return consumableContent ;
onClick: public void onClick ( View v ) { if ( ! isClickable ) { LogUtils . e ( TAG , "重复点击" ) ; return ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M && ! PermissionChecker . checkReadPhoneStatePermission ( mContext ) ) { ( ( BaseActivity ) mContext ) . requestIMEI ( ) ; return ; } LogUtils . e ( TAG , "点击获取图形验证码" ) ; isClickable = false ; mRandomStr = String . valueOf ( System . currentTimeMillis ( ) ) ;
setPasswordHash: public void setPasswordHash ( String shopKey , String countryCode , Identifier customerIdentifier , CustomerPasswordHash model , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/password-hash" , shopKey , countryCode , customerIdentifier ) , query , null , null , model ) ;
render: public void render ( ) { BrainOutClient . drawFade ( getFade ( ) , getBatch ( ) ) ; super . render ( ) ;
render: public void render ( Batch batch , RenderContext context ) { super . render ( batch , context ) ; batch . end ( ) ; Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; ShapeRenderer shapeRenderer = BrainOutClient . ShapeRenderer ; shapeRenderer . setProjectionMatrix ( batch . getProjectionMatrix ( ) ) ; shapeRenderer . setColor ( isCutterEnabled ( ) ? selectedCutterBlockColor : selectedBlockColor ) ; renderCurrentShape ( ) ; batch . begin ( ) ;
getFunctionName: public String getFunctionName ( ) { return null ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; layers = json . readValue ( Array . class , Layer . class , jsonData . get ( "layers" ) ) ;
run: public void run ( ) { mLoadingDialog . dismiss ( ) ; ToastUtils . showToast ( mContext , e . getMessage ( ) ) ;
enablePlayerAimMarker: private void enablePlayerAimMarker ( boolean enable ) { CSGame game = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( game == null ) return ; PlayerData playerData = game . getPlayerData ( ) ; if ( playerData == null ) return ; ClientPlayerComponent pca = playerData . getComponent ( ClientPlayerComponent . class ) ; if ( pca == null ) return ; pca . setForceDisplayAim ( enable ) ; pca . setDisplayAim ( enable ) ;
JoinRoom: public static void JoinRoom ( GameService . Room room ) { WaitLoadingMenu loading = new WaitLoadingMenu ( L . get ( "MENU_QUICK_PLAY" ) , true ) ; pushMenu ( loading ) ; Matchmaking . JoinGame ( room . id , new Matchmaking . JoinGameResult ( )
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Image icon = new Image ( BrainOutClient . Skin , "icon-event-freeplay" ) ; icon . setScaling ( Scaling . none ) ; data . add ( icon ) . padTop ( 48 ) . size ( 64 ) . padBottom ( 16 ) . row ( ) ; } { Label prepare = new Label ( L . get ( "MENU_FREEPLAY_PREPARE" ) , BrainOutClient . Skin , "title-small" ) ; data . add ( prepare ) . row ( ) ; } { Table autoStartRoot = new Table ( ) ; autoStartRoot . add ( new Label ( L . get ( "MENU_FREEPLAY_AUTOSTART" ) , BrainOutClient . Skin , "title-yellow" ) ) . padRight ( 4 ) ; Label autoStart = new Label ( getAutoStartInfo ( ) , BrainOutClient . Skin , "title-small" ) ; autoStart . addAction ( Actions . repeat ( RepeatAction . FOREVER , Actions . sequence ( Actions . delay ( 1.0f ) , Actions . run ( ( ) -> autoStart . setText ( getAutoStartInfo ( ) ) ) ) ) ) ; autoStartRoot . add ( autoStart ) . padLeft ( 4 ) . row ( ) ; data . add ( autoStartRoot ) . padBottom ( 32 ) . row ( ) ; } { Table playersRoot = new Table ( BrainOutClient . Skin ) ; playersRoot . setBackground ( "form-gray" ) ; Label players = new Label ( L . get ( "MENU_PLAYERS" ) , BrainOutClient . Skin , "title-yellow" ) ; playersRoot . add ( players ) . padRight ( 4 ) ; playerCount = new Label ( getPlayerStats ( ) , BrainOutClient . Skin , "title-small" ) ; playersRoot . add ( playerCount ) . padLeft ( 4 ) . row ( ) ; data . add ( playersRoot ) . width ( 400 ) . expandX ( ) . fillY ( ) . center ( ) . row ( ) ; } { Table playerListRoot = new Table ( BrainOutClient . Skin ) ; playerListRoot . setBackground ( "form-default" ) ; playerList = new Table ( ) ; playerList . align ( Align . top | Align . center ) ; ScrollPane pane = new ScrollPane ( playerList , BrainOutClient . Skin , "scroll-default" ) ; pane . setFadeScrollBars ( false ) ; setScrollFocus ( pane ) ; playerListRoot . add ( pane ) . expand ( ) . fill ( ) . row ( ) ; data . add ( playerListRoot ) . expand ( ) . width ( 400 ) . center ( ) . fillY ( ) . row ( ) ; } { readyLabel = new Label ( "" , BrainOutClient . Skin , "title-gray-bg" ) ; readyLabel . setAlignment ( Align . center ) ; data . add ( readyLabel ) . size ( 192 , 32 ) . padTop ( 16 ) . center ( ) . row ( ) ; } { readyButton = new TextButton ( L . get ( "MENU_READY" ) , BrainOutClient . Skin , "button-checkable-green" ) ; readyButton . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; ready ( readyButton . isChecked ( ) ) ; } } ) ; data . add ( readyButton ) . pad ( 0 , 16 , 16 , 16 ) . center ( ) . size ( 192 , 64 ) . row ( ) ; } updateClients ( ) ; return data ;
getCamera: public Camera getCamera ( ) { return camera ;
toString: public String toString ( ) { return name ;
onClick: public void onClick ( View v ) { mSelectTimePopupWindow = new SelectTimePopupWindow ( mContext ) ; mSelectTimePopupWindow . setOnItemClickCallback ( new SelectTimePopupWindow . ItemCleckListener ( ) { @ Override public void onItemClick ( View view ) { switch ( view . getId ( ) ) { case R . id . tv_minutes : timeButton . setText ( R . string . minutes ) ; break ; case R . id . tv_hours : timeButton . setText ( R . string . hours ) ; break ; case R . id . tv_days : timeButton . setText ( R . string . day ) ; break ; } } } ) ; mSelectTimePopupWindow . show ( v ) ;
mav: public Object mav ( HttpServletRequest request , String viewNameForSuccess , String viewNameForValidationError , PageModelFunction < Object > forSuccess , PageModelFunction < Object > forValidationError ) { return mav ( request , ( r ) -> Tuples . of (
getYearDateZero: public static Date getYearDateZero ( ) { Calendar currCal = Calendar . getInstance ( ) ; int currentYear = currCal . get ( Calendar . YEAR ) ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( Calendar . YEAR , currentYear ) ; return cal . getTime ( ) ;
testCreateReturnAddress: public void testCreateReturnAddress ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/MerchantCreateReturnAddressRequest.json" ) ; MerchantReturnAddress requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , MerchantReturnAddress . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; MerchantReturnAddress responseEntity = this . api . merchants ( ) . createReturnAddress ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/MerchantCreateReturnAddressResponse.json" ) ; assertThatJson ( expectedResponseJson )
handle: public void handle ( final @ NonNull JRPCServer server , final @ NonNull ServerMessageContext < T > context ) { handler . accept ( server , context ) ;
getDefaultTitleText: protected String getDefaultTitleText ( int index ) { return null ;
render: public void render ( Batch batch , RenderContext context ) { super . render ( batch , context ) ; if ( ! enabled ) return ; if ( laserSprite == null ) return ; if ( ! playerData . isVisible ( ) ) { return ; } if ( BrainOutClient . ShapeRenderer != null )
isFirstCurrencyPrimary: public static boolean isFirstCurrencyPrimary ( ) { return getPrefs ( ) . getBoolean ( FIRST_CURRENCY_IS_PRIMARY , true ) ;
equals: public boolean equals ( Object other ) { if ( other instanceof WatchTransformer ) { return this . uuid . equals ( ( ( WatchTransformer ) other ) . getUuid ( ) ) ; } return false ;
loadClass: public Class < ? > loadClass ( String name ) throws ClassNotFoundException { if ( name . startsWith ( "org.apache.groovy" ) || name . startsWith ( "org.codehaus.groovy" ) || name . startsWith ( "groovy" ) || name . startsWith ( "w.core.GroovyBundle" ) ) { Class < ? > c = findLoadedClass ( name ) ; if ( c != null ) return c ; return findClass ( name ) ; } return super . loadClass ( name ) ;
setRequestUrl: public void setRequestUrl ( String requestUrl ) { this . requestUrl = requestUrl ;
checkRecoveredStartString: private Boolean checkRecoveredStartString ( String logLine ) { Boolean isMatch = false ; String pattern ; pattern = ".*Seed birthday surpassed, starting recovery of wallet from height=\\d+ hash=\\w+ with recovery-window=\\d.*" ; Pattern r = Pattern . compile ( pattern ) ; Matcher m = r . matcher ( logLine ) ; isMatch = m . matches ( ) ; return isMatch ;
asProperties: private Properties asProperties ( Map < String , String > source ) { Properties properties = new Properties ( ) ; properties . putAll ( source ) ; return properties ;
applyMoveDirection: protected boolean applyMoveDirection ( ) { return false ;
setProducts: public void setProducts ( PaymentProductDto [ ] products ) { this . products = products ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < Voucher > responseEntity = this . api . vouchers ( ) . all ( "acme" , "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/VoucherAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( Voucher entity : responseEntity . getEntities ( ) ) {
generateTransformedValuesLine: public float [ ] generateTransformedValuesLine ( ILineDataSet data , float phaseX , float phaseY , int min , int max ) { final int count = ( ( int ) ( ( max - min ) * phaseX ) + 1 ) * 2 ; if ( valuePointsForGenerateTransformedValuesLine . length != count ) { valuePointsForGenerateTransformedValuesLine = new float [ count ] ; } float [ ] valuePoints = valuePointsForGenerateTransformedValuesLine ; for ( int j = 0 ; j < count ; j += 2 ) { Entry e = data . getEntryForIndex ( j / 2 + min ) ; if ( e != null ) { valuePoints [ j ] = e . getX ( ) ; valuePoints [ j + 1 ] = e . getY ( ) * phaseY ; } else { valuePoints [ j ] = 0 ; valuePoints [ j + 1 ] = 0 ; } } getValueToPixelMatrix ( ) . mapPoints ( valuePoints ) ; return valuePoints ;
getMessageContentReplacement: No method body
init: private Event init ( ) { return this ;
hashCode: public int hashCode ( ) { Map map = Map . Get ( getMenu ( ) . getDimension ( ) ) ; return y * map . getWidth ( ) + x ;
shouldCreatePropertiesBackup_nonWindowsEnv: public void shouldCreatePropertiesBackup_nonWindowsEnv ( ) throws IOException { Set < BackupOption > backupOptions = Set . of ( BACKUP_PROPERTIES ) ; boolean result = testObject . doBackup ( backupOptions ) ; assertFileDoesNotExist ( testObject . getDatabaseBackupFile ( ) ) ; assertFileExists ( testObject . getTarBackupFile ( ) ) ; assertTarContains ( testObject . getApplicationPropertiesFilePath ( ) ) ; Assertions . assertTrue ( result ) ;
getInterpolation: public float getInterpolation ( float input ) { input *= 2f ; if ( input < 1f ) { return 0.5f * ( float ) Math . pow ( input , 4 ) ; } input -= 2f ; return - 0.5f * ( ( float ) Math . pow ( input , 4 ) - 2f ) ;
setBuyerCompanyName: public void setBuyerCompanyName ( String buyerCompanyName ) { this . buyerCompanyName = buyerCompanyName ;
getDateStableRandom: protected int getDateStableRandom ( String account ) { if ( ! BrainOut . OnlineEnabled ( ) ) { return 0 ; } MessageDigest digest ; try { digest = MessageDigest . getInstance ( "SHA-256" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; return 0 ; } String payload = String . valueOf ( getCurrentDay ( ) ) + category + hash ; if ( share > 1 ) { int a ; try { a = Integer . parseInt ( account ) ; } catch ( NumberFormatException igored ) { a = - 1 ; } if ( a > 0 ) { payload += String . valueOf ( a % share ) ; } } byte [ ] hash = digest . digest ( payload . getBytes ( ) ) ; return Math . abs ( new BigInteger ( hash ) . intValue ( ) ) ;
provide: No method body
resetMissionControl: public Single < routerrpc . RouterOuterClass . ResetMissionControlResponse > resetMissionControl ( routerrpc . RouterOuterClass . ResetMissionControlRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . resetMissionControl ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
onDraw: protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; if ( mData == null ) return ; long starttime = System . currentTimeMillis ( ) ; drawGridBackground ( canvas ) ; if ( mAutoScaleMinMaxEnabled ) { autoScale ( ) ; } if ( mAxisLeft . isEnabled ( ) ) mAxisRendererLeft . computeAxis ( mAxisLeft . mAxisMinimum , mAxisLeft . mAxisMaximum , mAxisLeft . isInverted ( ) ) ; if ( mAxisRight . isEnabled ( ) ) mAxisRendererRight . computeAxis ( mAxisRight . mAxisMinimum , mAxisRight . mAxisMaximum , mAxisRight . isInverted ( ) ) ; if ( mXAxis . isEnabled ( ) ) mXAxisRenderer . computeAxis ( mXAxis . mAxisMinimum , mXAxis . mAxisMaximum , false ) ; mXAxisRenderer . renderAxisLine ( canvas ) ; mAxisRendererLeft . renderAxisLine ( canvas ) ; mAxisRendererRight . renderAxisLine ( canvas ) ; if ( mXAxis . isDrawGridLinesBehindDataEnabled ( ) ) mXAxisRenderer . renderGridLines ( canvas ) ; if ( mAxisLeft . isDrawGridLinesBehindDataEnabled ( ) ) mAxisRendererLeft . renderGridLines ( canvas ) ; if ( mAxisRight . isDrawGridLinesBehindDataEnabled ( ) ) mAxisRendererRight . renderGridLines ( canvas ) ; if ( mXAxis . isEnabled ( ) && mXAxis . isDrawLimitLinesBehindDataEnabled ( ) ) mXAxisRenderer . renderLimitLines ( canvas ) ; if ( mAxisLeft . isEnabled ( ) && mAxisLeft . isDrawLimitLinesBehindDataEnabled ( ) ) mAxisRendererLeft . renderLimitLines ( canvas ) ; if ( mAxisRight . isEnabled ( ) && mAxisRight . isDrawLimitLinesBehindDataEnabled ( ) ) mAxisRendererRight . renderLimitLines ( canvas ) ; int clipRestoreCount = canvas . save ( ) ; if ( isClipDataToContentEnabled ( ) ) { canvas . clipRect ( mViewPortHandler . getContentRect ( ) ) ; } mRenderer . drawData ( canvas ) ; if ( ! mXAxis . isDrawGridLinesBehindDataEnabled ( ) ) mXAxisRenderer . renderGridLines ( canvas ) ; if ( ! mAxisLeft . isDrawGridLinesBehindDataEnabled ( ) ) mAxisRendererLeft . renderGridLines ( canvas ) ; if ( ! mAxisRight . isDrawGridLinesBehindDataEnabled ( ) ) mAxisRendererRight . renderGridLines ( canvas ) ; if ( valuesToHighlight ( ) ) mRenderer . drawHighlighted ( canvas , mIndicesToHighlight ) ; canvas . restoreToCount ( clipRestoreCount ) ; mRenderer . drawExtras ( canvas ) ; if ( mXAxis . isEnabled ( ) && ! mXAxis . isDrawLimitLinesBehindDataEnabled ( ) ) mXAxisRenderer . renderLimitLines ( canvas ) ; if ( mAxisLeft . isEnabled ( ) && ! mAxisLeft . isDrawLimitLinesBehindDataEnabled ( ) ) mAxisRendererLeft . renderLimitLines ( canvas ) ; if ( mAxisRight . isEnabled ( ) && ! mAxisRight . isDrawLimitLinesBehindDataEnabled ( ) ) mAxisRendererRight . renderLimitLines ( canvas ) ; mXAxisRenderer . renderAxisLabels ( canvas ) ; mAxisRendererLeft . renderAxisLabels ( canvas ) ; mAxisRendererRight . renderAxisLabels ( canvas ) ; if ( isClipValuesToContentEnabled ( ) ) { clipRestoreCount = canvas . save ( ) ; canvas . clipRect ( mViewPortHandler . getContentRect ( ) ) ; mRenderer . drawValues ( canvas ) ; canvas . restoreToCount ( clipRestoreCount ) ; } else { mRenderer . drawValues ( canvas ) ; } mLegendRenderer . renderLegend ( canvas ) ; drawDescription ( canvas ) ; drawMarkers ( canvas ) ; if ( mLogEnabled ) {
getShortestPath: Queue < WayPoint > getShortestPath ( WayPoint wayPoint ) { WayPointDistanceEntry entry = get ( wayPoint , null ) ; if ( entry == null ) { return null ; } return entry . shortestPath ;
getStreamBuilderAdd: public static Stream < Student > getStreamBuilderAdd ( ) { Stream . Builder < Student > builder = Stream . builder ( ) ; return builder
aabbCompute: private void aabbCompute ( ) { float minX = Integer . MAX_VALUE , minY = Integer . MAX_VALUE , maxX = Integer . MIN_VALUE , maxY = Integer . MIN_VALUE ; Object [ ] polygons = this . polygons . items ; for ( int i = 0 , n = this . polygons . size ; i < n ; i ++ ) { FloatArray polygon = ( FloatArray ) polygons [ i ] ; float [ ] vertices = polygon . items ; for ( int ii = 0 , nn = polygon . size ; ii < nn ; ii += 2 ) { float x = vertices [ ii ] ; float y = vertices [ ii + 1 ] ; minX = Math . min ( minX , x ) ; minY = Math . min ( minY , y ) ; maxX = Math . max ( maxX , x ) ; maxY = Math . max ( maxY , y ) ; } } this . minX = minX ; this . minY = minY ; this . maxX = maxX ; this . maxY = maxY ;
getYDist: private static float getYDist ( MotionEvent e ) { float y = Math . abs ( e . getY ( 0 ) - e . getY ( 1 ) ) ; return y ;
write: public void write ( Json json ) { json . writeObjectStart ( "accounts" ) ; for ( ObjectMap . Entry < String , Account > account : accounts ) { json . writeValue ( account . key , account . value ) ; } json . writeObjectEnd ( ) ;
getOrganizationSettings: protected PageModelMap getOrganizationSettings ( Long organizationId , String userSearch , Pageable userPageable ) { return findOrganizationWithSettingsFlow ( organizationId )
update: public void update ( float dt ) { Watcher watcher = Map . GetWatcher ( ) ; ActiveData activeData = ( ( ActiveData ) getComponentObject ( ) ) ; if ( watcher == null || ! watcher . getDimension ( ) . equals ( activeData . getDimension ( ) ) ) { return ; } updateWindsTimer -= dt ; if ( updateWindsTimer <= 0 ) { updateWindsTimer = WIND_TIMER ; updateActiveWinds ( ) ; } float windWaveDirection = getWindWaveDirection ( ) ; final float ONE_FULL_WIGGLE_TIME = 5.4f ; final int FULL_WIGGLES_IN_CYCLE = 7 ; float oneFullWIggleTime , toDegsCoof , windCycleTime ; oneFullWIggleTime = ONE_FULL_WIGGLE_TIME ; toDegsCoof = oneFullWIggleTime / 360.0f ; windCycleTime = oneFullWIggleTime * FULL_WIGGLES_IN_CYCLE ; time += dt * ( 1 + windWaveDirection * 3 ) ; float angle = ( time % oneFullWIggleTime ) / toDegsCoof + getSkeleton ( ) . getX ( ) * 2 ; float cycle1 = ( time % windCycleTime ) / windCycleTime ; float cycle2 = cycle1 <= 0.5 ? windPowerInterpolation . apply ( cycle1 * 2 ) * 360 : 0 ; float powerSinusoid = 0.75f - MathUtils . cosDeg ( cycle2 ) * 0.25f ; float baseWiggle = powerSinusoid * ( 1 - Math . abs ( windWaveDirection ) ) * 0.2f ; float windWiggle = Math . abs ( windWaveDirection ) * 0.1f ; float windAngle = windWaveDirection * 0.15f ; float off = 0.5f + ( MathUtils . cosDeg ( angle ) * ( baseWiggle + windWiggle ) ) + windAngle ; float c = 3.33333f * MathUtils . clamp ( off , 0.f , 1.0f ) ; track . setTrackTime ( c ) ; super . update ( dt ) ;
isUseValueColorForLineEnabled: No method body
hasUpdate: public boolean hasUpdate ( ) { return true ;
subscribe: public void subscribe ( Flow . Subscriber < ? super ByteBuffer > subscriber ) { this . inputMessagesSubscriber = subscriber ; this . inputMessagesSubscriber . onSubscribe ( new Flow . Subscription ( ) { @ Override public void request ( long l ) { handleSubscriptionRequest ( l ) ; } @ Override public void cancel ( ) { closeRequest ( ) ; } } ) ; this . httpServerRequest . handler ( this :: handleIncomingBuffer ) ; this . httpServerRequest . exceptionHandler ( this :: handleRequestFailure ) ; this . httpServerRequest . endHandler ( this :: handleRequestEnd ) ;
setDesc: public void setDesc ( String desc ) { this . desc = desc ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcOpen5ItemStateChanged ( evt ) ;
webViewReload: public void webViewReload ( ) { mWebView . reload ( ) ;
isRegisterHtmlCrudController: public boolean isRegisterHtmlCrudController ( ) { return registerHtmlCrudController ;
draw: public void draw ( TextureRegion region , float width , float height , Affine2 transform ) { if ( ! drawing ) throw new IllegalStateException ( "begin must be called before draw." ) ; final short [ ] triangles = this . triangles ; final float [ ] vertices = this . vertices ; Texture texture = region . getTexture ( ) ; if ( texture != lastTexture ) switchTexture ( texture ) ; else if ( triangleIndex + 6 > triangles . length || vertexIndex + SPRITE_SIZE > vertices . length ) flush ( ) ; int triangleIndex = this . triangleIndex ; final int startVertex = vertexIndex / VERTEX_SIZE ; triangles [ triangleIndex ++ ] = ( short ) startVertex ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 1 ) ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 2 ) ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 2 ) ; triangles [ triangleIndex ++ ] = ( short ) ( startVertex + 3 ) ; triangles [ triangleIndex ++ ] = ( short ) startVertex ; this . triangleIndex = triangleIndex ; float x1 = transform . m02 ; float y1 = transform . m12 ; float x2 = transform . m01 * height + transform . m02 ; float y2 = transform . m11 * height + transform . m12 ; float x3 = transform . m00 * width + transform . m01 * height + transform . m02 ; float y3 = transform . m10 * width + transform . m11 * height + transform . m12 ; float x4 = transform . m00 * width + transform . m02 ; float y4 = transform . m10 * width + transform . m12 ; final float u = region . getU ( ) ; final float v = region . getV2 ( ) ; final float u2 = region . getU2 ( ) ; final float v2 = region . getV ( ) ; float light = this . lightPacked ; float dark = this . darkPacked ; int idx = vertexIndex ; vertices [ idx ++ ] = x1 ; vertices [ idx ++ ] = y1 ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u ; vertices [ idx ++ ] = v ; vertices [ idx ++ ] = x2 ; vertices [ idx ++ ] = y2 ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u ; vertices [ idx ++ ] = v2 ; vertices [ idx ++ ] = x3 ; vertices [ idx ++ ] = y3 ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u2 ; vertices [ idx ++ ] = v2 ; vertices [ idx ++ ] = x4 ; vertices [ idx ++ ] = y4 ; vertices [ idx ++ ] = light ; vertices [ idx ++ ] = dark ; vertices [ idx ++ ] = u2 ; vertices [ idx ++ ] = v ; vertexIndex = idx ;
render: public Actor render ( boolean full ) { Label textLabel = new Label ( BrainOut . LocalizationMgr . parse ( text ) , BrainOutClient . Skin , style ) ; textLabel . setWrap ( true ) ; Container < Label > labelContainer = new Container < > ( textLabel ) ; labelContainer . prefWidth ( ClientConstants . Menu . Chat . WIDTH - 20 ) . pad ( 4 ) ; return labelContainer ;
deleteAudience: public void deleteAudience ( String audienceId , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/promotions/audiences/%s" , audienceId ) , query , null , null ) ;
getBoneIndex: No method body
interfaceMethod: public String interfaceMethod ( ) { return "R2.interfaceMethod" ;
create: public UI create ( Route route ) throws Exception { return new IOSUI ( route ) ;
isClipValuesToContentEnabled: public boolean isClipValuesToContentEnabled ( ) { return mClipValuesToContent ;
evaluateScript: private < T > T evaluateScript ( String script , Map < String , Object > bindings , Class < T > resultType , Writer log ) { Context c = contextBuilder . build ( ) ; Value b = c . getBindings ( "js" ) ; for ( Map . Entry < String , Object > o : bindings . entrySet ( ) ) { b . putMember ( o . getKey ( ) , o . getValue ( ) ) ; } for ( Map . Entry < String , Object > o : ComponentProvider . resources . entrySet ( ) ) { b . putMember ( o . getKey ( ) , o . getValue ( ) ) ; } b . putMember ( "model" , bindings ) ; b . putMember ( "process" , new ServerJSProcessRunner ( services , log == null ? new NullWriter ( ) : log ) ) ; T result = c . eval ( "js" , script ) . as ( resultType ) ; return result ;
getMaps: protected String [ ] getMaps ( ) { return Constants . Matchmaking . APPROVED_COMPETITIVE_MAPS ;
transformPage: public void transformPage ( View page , float position ) { if ( position <= 0.0f ) { page . setTranslationX ( 0f ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; this . effect = jsonData . getString ( "effect" , null ) ; this . animation = jsonData . getString ( "animation" , null ) ;
testReadPages: void testReadPages ( ) { final List < Map < String , String > > documents = new ReadDocumentsFromInMemoryPdfChain ( PdfReadMode . PAGES ) . run ( inMemoryPdf ) . collect ( Collectors . toList ( ) ) ; assertEquals ( 2 , documents . size ( ) , "incorrect number of read document pages" ) ; final Map < String , String > doc1 = documents . get ( 0 ) ; assertNotNull ( doc1 . get ( PromptConstants . CONTENT ) , "got no content for doc1" ) ; assertEquals ( "my-in-memory.pdf p.1" , doc1 . get ( PromptConstants . SOURCE ) , "got wrong source for doc1" ) ; final Map < String , String > doc2 = documents . get ( 1 ) ; assertNotNull ( doc2 . get ( PromptConstants . CONTENT ) , "got no content for doc2" ) ; assertEquals ( "my-in-memory.pdf p.2" , doc2 . get ( PromptConstants . SOURCE ) , "got wrong source for doc2" ) ;
request: public Request request ( ) { return this . request ;
getWaterMass: public double getWaterMass ( ) { return zeroHeadFlow ;
hasLocalizedName: public boolean hasLocalizedName ( ) { return true ;
screenSizeUpdated: private void screenSizeUpdated ( ) { renderContext . resize ( BrainOutClient . getWidth ( ) , BrainOutClient . getHeight ( ) ) ;
setBASE_PATH: public void setBASE_PATH ( String BASE_PATH ) { this . BASE_PATH = BASE_PATH ;
getTakeFlagPoints: public int getTakeFlagPoints ( ) { return takeFlagPoints ;
getState: public TaskState getState ( ) { return state ;
setListener: private void setListener ( ) { textField . onValueChange ( event -> { String enteredText = textField . getValue ( ) ; if ( enteredText != null && ! enteredText . isEmpty ( ) ) { showSuggestions ( enteredText ) ; } else { entriesPopup . visible ( false ) ; } } ) ; UI . get ( ) . registerJSListener ( "focusout" , textField , e -> entriesPopup . visible ( false ) ) ;
received: public boolean received ( final PlayStateChangedMsg msg ) { Gdx . app . postRunnable ( ( ) -> { setPlayState ( msg . id ) ; Json json = new Json ( ) ; BrainOut . R . tag ( json ) ; getPlayState ( ) . read ( json , new JsonReader ( ) . parse ( msg . data ) ) ; getPlayState ( ) . init ( null ) ; } ) ; return true ;
toString: public String toString ( ) { return name ;
webhookEvents: public WebhookEventService webhookEvents ( ) { WebhookEventService service = this . getService ( "com.scayle.adminapi.service.WebhookEventService" ) ; return service ;
setGitHubRepoName: public void setGitHubRepoName ( String gitHubRepoName ) { this . gitHubRepoName = gitHubRepoName ;
appendEncryptStr: private String appendEncryptStr ( String str , String key , Object value ) { if ( ! StringUtils . isEmpty ( str ) ) { str = str + "&" ; } return str + key + "=" + value ;
getDimension: public String getDimension ( ) { return dimension ;
received: public boolean received ( SetGameSpeedMsg msg ) { setSpeed ( msg . speed ) ; return true ;
done: public boolean done ( ) { if ( particleEffect . getStickTime ( ) == 0 ) { return effect . isComplete ( ) ; } return done ;
updateDialogProgress: private void updateDialogProgress ( int progress ) { TextView showProgressTv = mDownLoadDialog . getViewById ( R . id . tv_dialog_show_progress ) ; showProgressTv . setText ( progress + "%" ) ; ProgressBar progressBar = mDownLoadDialog . getViewById ( R . id . pb_dialog_down_load ) ; progressBar . setProgress ( progress ) ;
setCreateNewTable: public void setCreateNewTable ( boolean createNewTable ) { this . createNewTable = createNewTable ;
hasRender: public boolean hasRender ( ) { return false ;
unserialize: public < T > T unserialize ( String json , Class < T > clazz ) { Gson gson = new Gson ( ) ; return ( T ) ( gson . fromJson ( json , clazz ) ) ;
send: public void send ( ) { trace ( "[send email job]" ) ; Page < Email > emails = emailRepository . findTasksAndSetStateDoing ( ( ) -> emailRepository . findByCanBeStartedTrue ( TaskRepository . OLDEST_10 ) ) ; for ( Email e : emails . getContent ( ) ) {
onCancel: public void onCancel ( @ Nullable Throwable t ) { exitFut . cancel ( true ) ;
setAssignedDatasource: public void setAssignedDatasource ( int assignedDatasource ) { this . assignedDatasource = assignedDatasource ;
applyChanges: public ApplyChangesResponse applyChanges ( final ApplyChangesRequest request ) throws IOException , NovuNetworkException { try {
getRoleId: public Long getRoleId ( ) { return roleId ;
error: void error ( ) { pushMenu ( new RichAlertPopup ( L . get ( "MENU_JOIN_BY_ROOM_ID" ) , L . get ( "MENU_PROMO_ERROR" ) ) ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new BulletEffectsComponentData ( ( BulletData ) componentObject , this ) ;
id: public ByteString id ( ) { return id ;
setIntegrationAsPrimary: public SingleIntegrationResponse setIntegrationAsPrimary ( final String integrationId ) throws NovuNetworkException , IOException { return restHandler . extractResponse ( this . integrationsApi . setIntegrationAsPrimary ( integrationId ) . execute ( ) ) ;
setFullScreenScan: public void setFullScreenScan ( boolean fullScreenScan ) { isFullScreenScan = fullScreenScan ;
getFlipX: public boolean getFlipX ( ) { return false ;
init: public void init ( UserProfile userProfile ) { for ( String slot : upgrades . keys ( ) ) { String key = getKey ( slot ) ; String keys = userProfile . getSelection ( key ) ; if ( keys != null ) { Upgrade upgrade = ( ( Upgrade ) BrainOut . ContentMgr . get ( keys ) ) ; if ( upgrade != null ) { getSelectedUpgrades ( ) . put ( slot , upgrade ) ; } } } String skinSelection = getSkinSelection ( userProfile ) ; if ( skinSelection != null )
getComponent: public MedkitComponentData getComponent ( ComponentObject componentObject ) { return new MedkitComponentData ( ( InstrumentData ) componentObject , this ) ;
execute: public String execute ( String [ ] args , Client client ) { StringBuilder data = new StringBuilder ( ) ; data . append ( "---------- Network statistics ----------\n" ) ; for ( ObjectMap . Entry < Integer , Client > entry : BrainOutServer . Controller . getClients ( ) ) { Client c = entry . value ; if ( c instanceof PlayerClient ) { PlayerClient playerClient = ( ( PlayerClient ) c ) ; PlayerClient . Statistics stats = playerClient . getStatistics ( ) ; stats . setCollectPerClass ( ) ; } } return "OK" ;
getID: public ID getID ( ) { return ID . lobby ;
applySelection: private void applySelection ( PlayerClient playerClient , ShopCart shopCart , PlayerData playerData , Slot slot , SlotItem . Selection selection ) { UserProfile profile = playerClient . getProfile ( ) ; SlotItem item = selection . getItem ( ) ; boolean have = profile == null || item . hasItem ( profile ) ; if ( have )
contentType: public String contentType ( ) { return "application/json" ;
set: private void set ( ) { setTitle ( "Custom Background Mode" ) ; StringBuilder summary = new StringBuilder ( "Allows you to set a custom background\nCurrent setting: " ) ; switch ( Prefs . getInt ( PreferenceKeys . BACKGROUND_MODE , Background . MODE_OFF ) ) {
onClick: public void onClick ( View v ) { mMenuPopWindow . dismiss ( ) ; UnlockDialog mUnlockDialog = new UnlockDialog ( mContext ) ; mUnlockDialog . show ( ) ;
renderIcon: public void renderIcon ( WidgetGroup to ) { if ( icon != null )
getTrans: public MPPointF getTrans ( float x , float y ) { ViewPortHandler vph = mChart . getViewPortHandler ( ) ; float xTrans = x - vph . offsetLeft ( ) ; float yTrans = 0f ; if ( inverted ( ) ) { yTrans = - ( y - vph . offsetTop ( ) ) ; } else { yTrans = - ( mChart . getMeasuredHeight ( ) - y - vph . offsetBottom ( ) ) ; } return MPPointF . getInstance ( xTrans , yTrans ) ;
setValueTextSize: public void setValueTextSize ( float size ) { mValueTextSize = Utils . convertDpToPixel ( size ) ;
copy: public PieEntry copy ( ) { PieEntry e = new PieEntry ( getY ( ) , label , getData ( ) ) ; return e ;
fail: No method body
failed: private void failed ( CaseOpenResultMsg . Result result ) { switch ( result )
setAppType: public void setAppType ( String appType ) { this . appType = appType ;
mapObjectArraysToJsonString: private Object mapObjectArraysToJsonString ( Map < Object , Object [ ] > objArray ) throws JSONException { JSONArray results = new JSONArray ( ) ; JSONObject result ; for ( var entry : objArray . entrySet ( ) ) { result = new JSONObject ( ) ; result . put ( "k" , entry . getKey ( ) ) ; JSONArray values = new JSONArray ( ) ; for ( Object o : entry . getValue ( ) ) { values . put ( o ) ; } result . put ( "v" , values ) ; results . put ( result ) ; } return results . toString ( ) ;
changed: public void changed ( ChangeEvent event , Actor actor ) { InviteMenu . this . filter = filterText . getText ( ) . toLowerCase ( ) ; updateFriends ( ) ;
getTextWidth: public static int getTextWidth ( Paint paint , String str ) { int iRet = 0 ; if ( str != null && str . length ( ) > 0 ) { int len = str . length ( ) ; float [ ] widths = new float [ len ] ; paint . getTextWidths ( str , widths ) ; for ( int j = 0 ; j < len ; j ++ ) { iRet += ( int ) Math . ceil ( widths [ j ] ) ; } } return iRet ;
queryAllByGroup: No method body
checkIBAN: void checkIBAN ( ) { assertThrows ( IllegalArgumentException . class , ( ) -> new BankAccountPro ( "IT001230000000000000000000000000000" , 0.0 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> new BankAccountPro ( "IT00123" , 0.0 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> new BankAccountPro ( "It001234" , 0.0 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> new BankAccountPro ( "It001234" , 0.0 ) ) ; assertThrows ( IllegalArgumentException . class , ( ) -> new BankAccountPro ( "it001234" , 0.0 ) ) ; assertDoesNotThrow ( ( ) -> new BankAccountPro ( "IT001234" , 0.0 ) ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
hasRender: public boolean hasRender ( ) { return false ;
writeOutput: public void writeOutput ( TerminalException throwable , SyscallCallback < Void > callback ) { wrapAndPropagateExceptions (
calculateDistance: protected void calculateDistance ( float v ) { volume = Math . max ( 0 , Math . min ( 1 , - ( float ) Math . log10 ( v ) / 2 ) ) ; volume *= BrainOutClient . ClientSett . getSoundVolume ( ) . getFloatValue ( ) ;
sendReliableUDP: public void sendReliableUDP ( ReliableBody object ) { for ( ObjectMap . Entry < Integer , Client > entry : this )
getDefaultBadge: private ProfileBadge getDefaultBadge ( ) { UserProfile profile = BrainOutClient . ClientController . getUserProfile ( ) ; String badgeName = profile . getSelection ( Constants . User . PROFILE_BADGE ) ; ProfileBadge badge = BrainOutClient . ContentMgr . get ( badgeName , ProfileBadge . class ) ; if ( badge == null ) { badge = BrainOutClient . ContentMgr . get ( Constants . User . PROFILE_BADGE_DEFAULT , ProfileBadge . class ) ; } return badge ;
getOutputType: public PayloadType getOutputType ( ) { return outputType ;
LoadMaps: public static < T extends Map > Array < T > LoadMaps ( InputStream is , Class < T > classType , String key ) { return LoadMaps ( is , classType , key , "default" ) ;
isFriendly: public boolean isFriendly ( ) { return BrainOutClient . ClientController . getMyRemoteClient ( ) . getInfoBoolean ( "friendly" , false ) ;
update: public void update ( float dt ) { timer -= dt ; if ( timer < 0 )
setBalanceValue: public void setBalanceValue ( int balanceValue ) { this . balanceValue = balanceValue ;
setPosition: public void setPosition ( float x , float y ) { this . x = x ; this . y = y ;
getColor: public Color getColor ( ) { return color ;
updateFill: public void updateFill ( MetaObject metaObject ) { this . strictUpdateFill ( metaObject , "updater" , ( ) -> securityUtils . getCurrentAdmin ( ) . getUsername ( ) , String . class ) ; this . strictUpdateFill ( metaObject , "updateTime" , LocalDateTime :: now , LocalDateTime . class ) ;
processSecondarySlot: public void processSecondarySlot ( ) { if ( hasSlot ( Constants . Properties . SLOT_SECONDARY ) ) return ; SecondaryWeaponSlotComponentData secondary = weaponData . getComponent ( SecondaryWeaponSlotComponentData . class ) ; if ( secondary != null )
turnOnDebugModeForLoggerClass: public boolean turnOnDebugModeForLoggerClass ( Class c ) { this . debug ( "[turnOnDebugModeForLoggerClass] {}" , new Object [ ] { c } ) ; return c == null ? false : debugLoggers . add ( c ) ;
createAt: private void createAt ( ItemData createAt , int amount ) { if ( Log . INFO ) Log . info ( "Generated " + amount + " of " + this . item . getID ( ) ) ; ConsumableRecord record = createAt . getRecords ( ) . putConsumable ( amount , this . item . acquireConsumableItem ( ) ) ; if ( record != null && ! "" . equals ( getTag ( ) ) )
init: protected void init ( ) { super . init ( ) ; mYAxis = new YAxis ( AxisDependency . LEFT ) ; mYAxis . setLabelXOffset ( 10f ) ; mWebLineWidth = Utils . convertDpToPixel ( 1.5f ) ; mInnerWebLineWidth = Utils . convertDpToPixel ( 0.75f ) ; mRenderer = new RadarChartRenderer ( this , mAnimator , mViewPortHandler ) ; mYAxisRenderer = new YAxisRendererRadarChart ( mViewPortHandler , mYAxis , this ) ; mXAxisRenderer = new XAxisRendererRadarChart ( mViewPortHandler , mXAxis , this ) ; mHighlighter = new RadarHighlighter ( this ) ;
getStage: public Stage getStage ( ) { return stage ;
removeComponent: public void removeComponent ( Component component ) { removeComponent ( component , true ) ;
getRestoredChannel: public static boolean getRestoredChannel ( Context context ) { return getBoolean ( SETTINGS , context , RESTORED_CHANNEL ) ;
renderBackground: private void renderBackground ( ) { if ( badgeName == null ) badgeName = Constants . User . PROFILE_BADGE_DEFAULT ; ProfileBadge badge = BrainOutClient . ContentMgr . get ( badgeName , ProfileBadge . class ) ; if ( badge == null ) { badge = BrainOutClient . ContentMgr . get ( Constants . User . PROFILE_BADGE_DEFAULT , ProfileBadge . class ) ; if ( badge == null ) { return ; } } AnimationComponent anim = badge . getComponent ( AnimationComponent . class ) ; Actor background ; if ( anim != null ) { background = new ProfileBadgeAnimation ( anim . getAnimation ( ) ) ; } else { IconComponent badgeIcon = badge . getComponent ( IconComponent . class ) ; if ( badgeIcon == null ) return ; Image image = new Image ( BrainOutClient . Skin , badgeIcon . getIconName ( ) ) ; image . setScaling ( Scaling . none ) ; image . setTouchable ( Touchable . disabled ) ; image . setFillParent ( true ) ; background = image ; } addActor ( background ) ;
contentProperties: default Collection < String > contentProperties ( ) { return Collections . emptyList ( ) ; }
isOpen: public synchronized boolean isOpen ( ) { return camera != null ;
getComponent: public InstrumentParticleComponentData getComponent ( ComponentObject componentObject ) { return new InstrumentParticleComponentData ( ( InstrumentData ) componentObject , this ) ;
getSelectValue: public String getSelectValue ( ) { return getValue ( ) ;
setOrganizationId: public void setOrganizationId ( Long organizationId ) { this . organizationId = organizationId ;
acquireCategory: public ObjectMap < Integer , ConsumableRecord > acquireCategory ( String category ) { ObjectMap < Integer , ConsumableRecord > c = categories . get ( category ) ; if ( c == null ) { c = new ObjectMap < > ( ) ; categories . put ( category , c ) ; } return c ;
finish: public void finish ( ) { channel . pipeline ( ) . remove ( "handshake_handler" ) ; channel . pipeline ( ) . remove ( "handshake_encoder" ) ;
setMixRotate: public void setMixRotate ( float mixRotate ) { this . mixRotate = mixRotate ;
exitApplication: public void exitApplication ( Context context ) { User . getInstance ( ) . clear ( ) ;
recycleInstances: public static void recycleInstances ( List < MPPointD > instances ) { pool . recycle ( instances ) ;
addAction: public void addAction ( String title , ActionCallback callback ) { addAction ( title , callback , "button-default" ) ;
toTimestamp: public static long toTimestamp ( long snowflakeId ) { return ( snowflakeId > > 22 ) + EPOCH ;
getData: public ThrowableActiveData getData ( String dimension ) { return new ThrowableActiveData ( this , dimension ) ;
isDistantDelay: public boolean isDistantDelay ( ) { return distantDelay ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoSteamPressure2OnActionPerformed ( evt ) ;
addMenu: void addMenu ( ) { Menu user = Menu . builder ( ) . parentId ( 67L ) . title ( "单元测试" ) . name ( "单元测试" ) . parentTitle ( "单元测试" ) . level ( 5 ) . component ( "单元测试" ) . path ( "路由地址" ) . icon ( "" ) . sort ( 100 ) . build ( ) ; menuService . addMenu ( user ) ; log . info ( "新增菜单方法测试成功！" ) ;
getAdditionalSettings: public ServerSettings . BaseConditions getAdditionalSettings ( ) { return null ;
resetCircleColors: public void resetCircleColors ( ) { if ( mCircleColors == null ) { mCircleColors = new ArrayList < Integer > ( ) ; } mCircleColors . clear ( ) ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . simple , this ) ;
reset: public void reset ( ObjectContext ctx ) { ctx . clearAll ( ) ;
getComponent: public ClientBackgroundEffectComponentData getComponent ( ComponentObject componentObject ) { return new ClientBackgroundEffectComponentData ( componentObject , this ) ;
toastShort: public static void toastShort ( final String text ) { handler . post ( ( ) -> showBasicToast ( text , Toast . LENGTH_SHORT ) ) ;
getCreatedOn: public LocalDateTime getCreatedOn ( ) { return createdOn ;
char_out: void char_out ( byte c , OutputStream outs ) throws IOException { accum [ a_count ++ ] = c ; if ( a_count >= 254 )
onError: public void onError ( Exception e ) { if ( e . getMessage ( ) . equals ( "EOF" ) ) { return ; } LogUtils . e ( TAG , "------------------noRouterOB_SendPaymentV2OnError------------------" + e . getMessage ( ) ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
getID: public ID getID ( ) { return ID . achievementCompleted ;
isExistsFile: public static boolean isExistsFile ( String path , String startFileName ) { File file = new File ( path ) ; if ( file . exists ( ) && file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; for ( File f : files ) { if ( f . isFile ( ) && f . length ( ) > 0 ) { if ( f . getName ( ) . startsWith ( startFileName ) ) { return true ; } } } } else { return false ; } return false ;
emitEventAsync: public boolean emitEventAsync ( String eventName , Object object ) { return services . applicationEvent . emitEventAsync ( ApplicationEvent . getEvent ( eventName ) , object ) ;
get: public CustomDataConfig get ( String entity , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomDataConfig > responseModel = ( Class < CustomDataConfig > ) ( Class < ? > ) CustomDataConfig . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/custom-data-configs/%s" , entity ) , query , null , responseModel ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tg1TripActionPerformed ( evt ) ;
create: public CustomDataConfig create ( String entity , CustomDataConfig model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomDataConfig > responseModel = ( Class < CustomDataConfig > ) ( Class < ? > ) CustomDataConfig . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/custom-data-configs/%s" , entity ) , query , null , responseModel , model ) ;
newInstance: public static CaptureFragment newInstance ( ) { Bundle args = new Bundle ( ) ; CaptureFragment fragment = new CaptureFragment ( ) ; fragment . setArguments ( args ) ; return fragment ;
setStatus: public void setStatus ( PaymentStatus status ) { this . status = status ;
toString: public String toString ( ) { return data . name ;
getSlotWeaponsAmount: private int getSlotWeaponsAmount ( String slot , ConsumableContainer inventory ) { return inventory . queryRecordsOfClassAmount (
getSteamMass: public double getSteamMass ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < ShopCategory > responseEntity = this . api . shopCategories ( ) . all ( "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCategoryAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( ShopCategory entity : responseEntity . getEntities ( ) ) {
isAvailablePhone: public static boolean isAvailablePhone ( String phone ) { String regex = "^[1][0-9]{10}$" ; return Pattern . matches ( regex , phone ) ;
main: public static void main ( String [ ] args ) { final JRPCServer server = new JRPCServer ( ) ; try {
getSteamPressureByTemp: public double getSteamPressureByTemp ( double tempC ) { if ( tempC >= 1 && tempC < 373 ) { int lower = ( int ) tempC ; int higher = ( int ) tempC + 1 ; double lowerValue = steamPressureByTempMap . get ( lower ) ; double higherValue = steamPressureByTempMap . get ( higher ) ; double perDegree = higherValue - lowerValue ; return lowerValue + ( ( tempC - lower ) * perDegree ) ; } if ( ! error ) { error = ! error ; NPPSim . endSimulation ( ) ; StackTraceElement [ ] stack = Thread . currentThread ( ) . getStackTrace ( ) ; StringBuilder strBuilder = new StringBuilder ( ) ; for ( StackTraceElement stack1 : stack ) { strBuilder . append ( stack1 . toString ( ) ) ; strBuilder . append ( "\n" ) ; } new ErrorWindow ( "A component has been damaged beyond repair" , strBuilder . toString ( ) , true ) . setVisible ( true ) ; } return 0 ;
zoomIn: public void zoomIn ( float x , float y , Matrix outputMatrix ) { outputMatrix . reset ( ) ; outputMatrix . set ( mMatrixTouch ) ; outputMatrix . postScale ( 1.4f , 1.4f , x , y ) ;
setX: public void setX ( float x ) { this . x = x ;
hasLabel: public boolean hasLabel ( ) { return false ;
emitBackupFileCopied: private void emitBackupFileCopied ( ) { debug ( "[emitBackupFileCopied]" ) ; String scpTargetFile = backupWriter . getScpTargetFile ( ) ; services . applicationEvent . emitEvent ( BACKUP_FILE_COPIED , scpTargetFile ) ;
selectAllByGroup: No method body
renderTopToolbar: private void renderTopToolbar ( Table toolbar ) { { Table panel = new Table ( BrainOutClient . Skin ) ; panel . setBackground ( "buttons-group" ) ; renderSaveButton ( panel ) ; toolbar . add ( panel ) . padRight ( 8 ) ; } { Table panel = new Table ( BrainOutClient . Skin ) ; panel . setBackground ( "buttons-group" ) ; renderModeButtons ( panel ) ; toolbar . add ( panel ) . padRight ( 32 ) ; } { contextPanel = new Table ( BrainOutClient . Skin ) ; toolbar . add ( contextPanel ) . padRight ( 8 ) ; } switch ( lastEditorMode )
getGitHubRepoOwner: public String getGitHubRepoOwner ( ) { return gitHubRepoOwner ;
getContentView: protected int getContentView ( ) { return R . layout . activity_get_block_data ;
readBinaryFile: public static byte [ ] readBinaryFile ( String filename ) throws IOException { Path src = Paths . get ( filename ) ; return Files . readAllBytes ( src ) ;
existsOne: public boolean existsOne ( Object idOrEntity ) { return wrapped . existsOne ( scope , idOrEntity ) ;
init: public void init ( String startURL , boolean isTransparent , boolean isDecorated , int widthPercent , int heightPercent ) throws Exception { NSURL url = new NSURL ( startURL ) ; NSURLRequest request = new NSURLRequest ( url ) ; IOSLauncher . webView . loadRequest ( request ) ; while ( ! IOSLauncher . webView . isLoading ( ) ) Thread . yield ( ) ;
processAction: private void processAction ( InstrumentActionEvent action ) { if ( isPlayingCustomAnimation ( ) ) return ; if ( isWounded ( ) ) return ; if ( action == null || action . action == null ) return ; switch ( action . action )
getXMax: No method body
leaveGuild: public Observable < Void > leaveGuild ( long guildId ) { return null ;
getYChartMin: No method body
testSetSellableWithoutStock: public void testSetSellableWithoutStock ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/SellableWithoutStockSetSellableWithoutStockRequest.json" ) ; SellableWithoutStock requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , SellableWithoutStock . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; SellableWithoutStock responseEntity = this . api . sellableWithoutStocks ( ) . setSellableWithoutStock ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/SellableWithoutStockSetSellableWithoutStockResponse.json" ) ; assertThatJson ( expectedResponseJson )
getData: public BulletData getData ( LaunchData launchData , float damageCoefficient , String dimension ) { BulletData bulletData = bulletPool . obtain ( ) ; bulletData . setup ( launchData , damageCoefficient , dimension ) ; return bulletData ;
getID: public ID getID ( ) { return ID . onZeroHealth ;
setKey: public void setKey ( String key ) { this . key = key ;
getUserRolesForUsers: public static Specification < UserRole > getUserRolesForUsers ( ) { return new Specification < UserRole > ( ) {
setMessage: public PiscesException setMessage ( String message ) { this . message = message ; return this ;
returnAwakeableId: protected TestInvocationBuilder returnAwakeableId ( ) { return testDefinitionForService (
onRefreshing: public void onRefreshing ( ) { mRefreshDesc . setText ( R . string . text_refreshing ) ; mRefreshIcon . startAnimation ( mRefreshAnimation ) ;
obtain: public static Event obtain ( RemoteClient remoteClient , ActiveData playerData ) { VoiceEvent e = obtain ( VoiceEvent . class ) ; if ( e == null ) return null ; return e . init ( remoteClient , playerData ) ;
getListeners: public List < FileChangedListener > getListeners ( ) { return listeners ;
getDimension: public String getDimension ( ) { return getComponentObject ( ) . getDimension ( ) ;
findPlaceholder: private Placeholder findPlaceholder ( Content content ) { for ( ObjectMap . Entry < String , Placeholder > entry : placeholders ) { if ( entry . value . filter != null ) { if ( entry . value . filter . matches ( content ) ) return entry . value ; } if ( entry . value . tagFilter != null ) { ItemComponent itemComponent = content . getComponent ( ItemComponent . class ) ; if ( itemComponent != null && itemComponent . getTags ( content ) != null && itemComponent . getTags ( content ) . contains ( entry . value . tagFilter , false ) ) { return entry . value ; } } } return null ;
awakeableHandle: No method body
getContentRank: protected int getContentRank ( Content c ) { if ( c instanceof SoundEffect ) { return 5 ; } return super . getContentRank ( c ) ;
found: public void found ( Queue < Vector2 > path , String dimension , ObjectSet < WayPointMap . BlockCoordinates > blocksInWay , ActiveData portalOfInterest ) { followPath = path ; followPathDimension = dimension ; followBlocksInWay = blocksInWay ; followPathSearching = false ; followPortalOfInterest = portalOfInterest ;
jwtAccessTokenConverter: public JwtAccessTokenConverter jwtAccessTokenConverter ( ) { JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter ( ) ; jwtAccessTokenConverter . setKeyPair ( keyPair ( ) ) ; return jwtAccessTokenConverter ;
peek: public Output < T > peek ( ) { Deferred < ByteBuffer > deferred = Util . blockOnSyscall ( cb -> syscalls . peekPromise ( key . name ( ) , cb ) ) ; if ( ! deferred . isCompleted ( ) ) { Util . < Void > blockOnSyscall ( cb -> syscalls . resolveDeferred ( deferred , cb ) ) ; } return Util . unwrapOutputReadyResult ( deferred . toResult ( ) )
beginSpawn: private void beginSpawn ( ) { setState ( State . spawningMenu ) ;
getLayer: public int getLayer ( ) { return layer ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem12ActionPerformed ( evt ) ;
setCutterEnabled: private void setCutterEnabled ( boolean enabled ) { cutterEnabled = enabled ;
drop: public void drop ( DragAndDrop . Source source , DragAndDrop . Payload payload , Vector2 position , int pointer ) { Object o = payload . getObject ( ) ; if ( o instanceof SpriteWithBlocksComponent ) { if ( ! ( payload instanceof SpritesWidget . SpritePayload ) ) return ; SpritesWidget . SpritePayload p = ( ( SpritesWidget . SpritePayload ) payload ) ; float x = position . x + p . getOffsetX ( ) / Constants . Graphics . BLOCK_SIZE , y = position . y + p . getOffsetY ( ) / Constants . Graphics . BLOCK_SIZE ; SpriteWithBlocksComponent sp = ( ( SpriteWithBlocksComponent ) o ) ; Map map = Map . Get ( getMenu ( ) . getDimension ( ) ) ; if ( ! sp . validateBlocksForAdding ( map , ( int ) x , ( int ) y ) ) return ; Content content = sp . getContent ( ) ; BrainOutClient . ClientController . sendTCP ( new CreateObjectMsg ( getMenu ( ) . getDimension ( ) , content , ( int ) x , ( int ) y ) ) ; } if ( o instanceof UserSpriteWithBlocksComponent )
getCustomDimensions: private Dimension getCustomDimensions ( ) { return new Dimension ( ( int ) ( getBounds ( ) . width ) , ( int ) ( getBounds ( ) . height ) ) ;
copy: public Attachment copy ( ) { PointAttachment copy = new PointAttachment ( name ) ; copy . x = x ; copy . y = y ; copy . rotation = rotation ; copy . color . set ( color ) ; return copy ;
getSound: protected String getSound ( ) { return "bleat" ;
deletePaymentProbe: public static void deletePaymentProbe ( String paymentHash ) { LightningOuterClass . DeletePaymentRequest deletePaymentRequest = LightningOuterClass . DeletePaymentRequest . newBuilder ( ) . setPaymentHash ( byteStringFromHex ( paymentHash ) ) . setFailedHtlcsOnly ( false ) . build ( ) ; Obdmobile . deletePayment ( deletePaymentRequest . toByteArray ( ) , new Callback ( ) {
updateUser: void updateUser ( ) { Menu user = Menu . builder ( ) . id ( 67L ) . parentId ( 67L ) . title ( "单元测试" ) . name ( "单元测试" ) . parentTitle ( "单元测试" ) . level ( 5 ) . component ( "单元测试" ) . path ( "路由地址" ) . icon ( "" ) . sort ( 100 ) . build ( ) ; menuService . updateMenu ( user ) ; log . info ( "更新菜单方法测试成功！" ) ;
getAccount: public Account getAccount ( ) { return account ;
setWarmup: public void setWarmup ( String warmup ) { this . warmup = warmup ;
update: public void update ( float dt ) { super . update ( dt ) ; if ( stats == null ) return ; if ( ! itemData . hasItems ( ) && ! getContentComponent ( ) . isShowEmpty ( ) ) { dst = 0 ; return ; } dst = getPlayerDistance ( ) ; float a = MathUtils . clamp ( 1.0f - dst / ( DISPLAY_DISTANCE * DISPLAY_DISTANCE ) , 0.f , 1.f ) ; stats . getColor ( ) . a = a ; statsBGDrawable . getColor ( ) . a = a * 0.5f ; updateTimer -= dt ; if ( updateTimer < 0 )
list: void list ( ) throws Exception { assertNotNull ( userPageListParam , "userPageListParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/user/list" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( userPageListParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "用户列表接口（分页）接口测试成功:{}" , map . get ( "data" ) ) ;
write: public void write ( Json json ) { if ( attachments . size > 0 ) { json . writeObjectStart ( "att" ) ; for ( ObjectMap . Entry < String , String > entry : attachments ) { json . writeValue ( entry . key , entry . value ) ; } json . writeObjectEnd ( ) ; } if ( skin != null )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { cavit6ActionPerformed ( evt ) ;
loadYamlFile: private Object loadYamlFile ( String yamlFile ) { InputStream inputStream = loadResource ( yamlFile ) ; if ( inputStream == null ) { inputStream = loadResource ( yamlFile ) ; } if ( inputStream != null ) { debug ( "[YamlLoaderService] Processing file: " + yamlFile ) ; return yamlToEntityConverterFactory . processYamlDto ( new Yaml ( ) . load ( inputStream ) , yamlFile ) ; } return null ;
hasRender: public boolean hasRender ( ) { return false ;
getHighlightCircleStrokeWidth: public float getHighlightCircleStrokeWidth ( ) { return mHighlightCircleStrokeWidth ;
getGlobalRoles: public Set < String > getGlobalRoles ( ) { return globalRoles ;
loadMaps: public Array < ServerMap > loadMaps ( ServerSettings . MapConditions settings , boolean init ) { ServerController C = BrainOutServer . Controller ; Array < ServerMap > maps = new Array < > ( ) ; ServerMap map = C . createMap ( size . getW ( ) , size . getH ( ) , "default" ) ; maps . add ( map ) ; map . setName ( mapName ) ; background . activate ( map ) ; if ( init ) { map . init ( ) ; } renderGround ( map ) ; renderBorders ( map ) ; return maps ;
setSendCallback: public void setSendCallback ( VoiceChatSendCallback sendCallback ) { this . sendCallback = sendCallback ;
getStackLabels: public String [ ] getStackLabels ( ) { return mStackLabels ;
getMarketFeeMinimum: private int getMarketFeeMinimum ( ) { return MarketFeeMinimum ;
debug: default void debug ( String format , Object ... arguments ) { Logger l = getLogger ( ) ; l . debug ( format , arguments ) ; if ( isDebugLogger ( ) ) {
getEntityAttribute: public PageAttr < E > getEntityAttribute ( ) { return ( PageAttr < E > ) entityAttribute ;
setBendDirection: public void setBendDirection ( int bendDirection ) { this . bendDirection = bendDirection ;
getNotification: public Notification getNotification ( ) { return notification ;
buildHighlightedText: private String buildHighlightedText ( String text , String filter ) { int filterIndex = text . toLowerCase ( ) . indexOf ( filter . toLowerCase ( ) ) ; String textBefore = text . substring ( 0 , filterIndex ) ; String textAfter = text . substring ( filterIndex + filter . length ( ) ) ; String textFilter = "<span style='color: orange; font-weight: bold;'>" + text . substring ( filterIndex , filterIndex + filter . length ( ) ) + "</span>" ; return textBefore + textFilter + textAfter ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; this . ticketsForNewPlayer = jsonData . getInt ( "ticketsForNewPlayer" , 0 ) ; int tickets = jsonData . getInt ( "tickets" , 0 ) ; getGameMode ( ) . setInitialTickets ( tickets ) ;
setTitle: public void setTitle ( String title ) { this . title = title ;
attach: default Res attach ( RequestOptions options ) throws IngressException { try {
dispose: public void dispose ( ) { working = false ; try { if ( streamer != null ) streamer . join ( ) ; } catch ( InterruptedException e ) { } BrainOutClient . EventMgr . unsubscribe ( Event . ID . settingsUpdated , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . gameController , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . simple , this ) ; playback . shutdownNow ( ) ; if ( player != null ) player . dispose ( ) ; if ( recorder != null )
getCurrentMap: public ServerSettings . MapConditions getCurrentMap ( ) { return currentMap ;
onInit: public void onInit ( ) { super . onInit ( ) ; MenuHelper . AddCloseButton ( this , this :: close ) ;
putObject: public String putObject ( @ Nullable String bucketName , @ NonNull String objectName , @ NonNull InputStream inputStream , @ NonNull String contentType ) { if ( null == bucketName ) { bucketName = ossProperties . getMinio ( ) . getBucketName ( ) ; } try { PutObjectArgs objectArgs = PutObjectArgs . builder ( ) . bucket ( bucketName ) . object ( ossProperties . getMinio ( ) . getPrefix ( ) + objectName ) . stream ( inputStream , inputStream . available ( ) , - 1 ) . contentType ( contentType ) . build ( ) ; this . minioClient . putObject ( objectArgs ) ; } catch ( Exception e ) { log . error ( "文件上传失败:{}" , e ) ; throw new PiscesException ( "文件上传失败！" ) ; } return getObjectUrl ( bucketName , objectName ) ;
allWarehouses: public ApiCollection < Warehouse > allWarehouses ( Identifier merchantIdentifier ) throws ApiErrorException , ConnectionException { Class < Warehouse > responseModel = ( Class < Warehouse > ) ( Class < ? > ) Warehouse . class ; return this . requestCollection ( "get" , this . resolvePath ( "/merchants/%s/warehouses" , merchantIdentifier ) , null , null , responseModel ) ;
getEffect: public EffectData getEffect ( LaunchData launchData ) { return new StaticSoundEffectData ( this , launchData ) ;
setPersonalizeDashboard: public void setPersonalizeDashboard ( Boolean personalizeDashboard ) { this . personalizeDashboard = personalizeDashboard ;
onComplete: public void onComplete ( ) { this . completionFuture . complete ( null ) ;
insertItem: public void insertItem ( int i , T item ) { insert ( i , item ) ;
drawBar: No method body
getX: public float getX ( ) { return launchData . getX ( ) ;
validateFirstParameterType: private void validateFirstParameterType ( Class < ? > clazz , ExecutableElement element ) { if ( element . getParameters ( ) . isEmpty ( )
readTask: protected void readTask ( JsonValue jsonData ) { super . readTask ( jsonData ) ; categoryName = jsonData . getString ( "categoryName" ) ;
swap: public static < K , V > Pair < V , K > swap ( Pair < K , V > src ) { return new Pair < > ( src . getSecond ( ) , src . getFirst ( ) ) ;
getNinePatch: public static NinePatch getNinePatch ( String region ) { if ( region . equals ( "" ) ) return null ; return Skin . getPatch ( region ) ;
showInSummaryScreen: public boolean showInSummaryScreen ( ) { return true ;
getBodyRange: public float getBodyRange ( ) { return Math . abs ( mOpen - mClose ) ;
show: public void show ( ) { if ( mAlertDialog == null ) { mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme ) . setContentView ( R . layout . layout_popupwindow_create_channel_tip_general ) . setAnimation ( R . style . popup_anim_style ) . fullWidth ( ) . fullHeight ( ) . create ( ) ; } TextView tipTv = mAlertDialog . findViewById ( R . id . tv_tip ) ; mAlertDialog . findViewById ( R . id . layout_back ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_create ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; CreateChannelDialog mCreateChannelDialog = new CreateChannelDialog ( mContext ) ; mCreateChannelDialog . show ( User . getInstance ( ) . getBalanceAmount ( mContext ) , User . getInstance ( ) . getWalletAddress ( mContext ) , "" ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_cancel ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; } } ) ; if ( mAlertDialog . isShowing ( ) ) { mAlertDialog . dismiss ( ) ; } mAlertDialog . show ( ) ;
updateWorkflowOverride: No method body
delete: public void delete ( String shopKey , Integer shopCategoryId , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/shops/%s/categories/%s" , shopKey , shopCategoryId ) , query , null , null ) ;
onVolumeDown: public void onVolumeDown ( ) { float currentVolume = getCurrentVolume ( ) ; this . mVolume = 1 / mMaxVolume * currentVolume ;
getEffect: No method body
getDescription: public String getDescription ( ) { return "" ;
getWear: public float getWear ( ) { return wear ;
startUCrop: private static void startUCrop ( final Activity activity , b . q . a . a ucrop , int requestCode ) { ucrop . a . setClass ( activity , UCropActivity . class ) ; ucrop . a . putExtras ( ucrop . b ) ; activity . startActivityForResult ( ucrop . a , requestCode ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
getEntryByTouchPoint: public Entry getEntryByTouchPoint ( float x , float y ) { Highlight h = getHighlightByTouchPoint ( x , y ) ; if ( h != null ) { return mData . getEntryForHighlight ( h ) ; } return null ;
getTags: public int getTags ( ) { return WithTag . TAG ( Constants . ActiveTags . RADIOACTIVE ) ;
findByCanBeStartedTrueAndRequestUrlLike: No method body
onProgress: protected void onProgress ( Context context , int progress ) { super . onProgress ( context , progress ) ; if ( mUpdateEntity . isForceUpdate ( ) ) {
getLayer: public int getLayer ( ) { return 0 ;
onReceivedSslError: public void onReceivedSslError ( WebView view , SslErrorHandler handler , SslError error ) { handler . cancel ( ) ;
getY: public float getY ( ) { return position . y ;
setup: void setup ( ) { integers = new Integer [ MAX_ELEMENTS ] ; for ( int i = 0 ; i < MAX_ELEMENTS ; i ++ ) {
attach: public boolean attach ( int mag ) { if ( ! isDetached ( ) ) { return false ; } attachedMagazine = magazines . remove ( mag ) ; return true ;
debug: public void debug ( String msg , Throwable t ) { if ( isReleaseVersion ) {
update: public void update ( float dt ) { super . update ( dt ) ; if ( timer > 0 )
getNameId: public String getNameId ( ) { return name ;
update: protected void update ( float dt ) { int action = MathUtils . random ( 1 , 4 ) ; switch ( action )
execute: public String execute ( String [ ] args , Client client ) { boolean enabled = true ; if ( args . length > 1 ) { enabled = args [ 1 ] . equals ( "true" ) ; } BrainOutServer . Controller . getClients ( ) . getAutobalance ( ) . setEnabled ( enabled ) ; return "Done" ;
onThen: public Flow < I , O , CP > onThen ( Consumer < Function > onThen ) { this . onThen = onThen ; return this ;
setLabel: public void setLabel ( String label ) { this . label = label ;
getLastMessageTimestamp: public long getLastMessageTimestamp ( ) { return lastMessageTimestamp ;
release: public void release ( ) { super . release ( ) ; BrainOutServer . EventMgr . unsubscribe ( Event . ID . playerWon , this ) ;
startApp: protected static void startApp ( Class appClass , String [ ] args ) { startApp ( appClass , args , false ) ;
deserializePacket: public static < T > T deserializePacket ( final byte [ ] data ) { try { final Gson gson = CentralGson . PROTOCOL_INSTANCE . getGson ( ) ; final JsonObject json = deserializeJson ( data ) ; final Class < ? extends Packet > packetCls = extractClass ( json ) ; return ( T ) gson . fromJson ( json . toString ( ) , packetCls ) ; } catch ( final Exception exception ) { exception . printStackTrace ( ) ; } return null ;
isMsTeamsIntegrated: public boolean isMsTeamsIntegrated ( Long orgId ) { IntegrationModuleOrganizationConfiguration config = integrationService . getOrganizationConfiguration ( orgId ) ; return StringUtils . isNotBlank ( config . getMsTeamsWebhookUrl ( ) ) ;
setGetNewPrivilege: public CRUDControllerConfiguration < D , E , F > setGetNewPrivilege ( PrivilegeBase getNewPrivilege ) { this . getNewPrivilege = getNewPrivilege ; return this ;
setEnabled: private void setEnabled ( boolean b ) { enabled = b ; updateLight ( ) ;
trace: public void trace ( Marker marker , String msg , Throwable t ) { if ( isReleaseVersion ) {
success: public void success ( JSONObject response ) { InventoryMoveSoundComponent snd = c . getComponent ( InventoryMoveSoundComponent . class ) ; if ( snd != null ) { snd . play ( playerData ) ; } rsPanel . refresh ( ) ;
testCreateCriterion: public void testCreateCriterion ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/VoucherCreateCriterionRequest.json" ) ; VoucherCriterion requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , VoucherCriterion . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; VoucherCriterion responseEntity = this . api . vouchers ( ) . createCriterion ( "acme" , "acme" , 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/VoucherCreateCriterionResponse.json" ) ; assertThatJson ( expectedResponseJson )
validateDatabase: public Object validateDatabase ( ) { debug ( "[validateDatabase]" ) ; return validate ( )
flatMapError: public final Promise < T > flatMapError ( @ NotNull SafeTransform < Throwable , Promise < T > > transform ) { final Promise < T > promise = new Promise < > ( ) ; subscribe ( promise :: resolve , th -> transform . apply ( th ) . deliverTo ( promise ) ) ; return promise ;
toString: public String toString ( ) { return String . format ( "%s (%s)" , getAnswer ( ) , getSources ( ) . stream ( ) . collect ( Collectors . joining ( ", " ) ) ) ;
delete: void delete ( ) throws Exception { Long departId = 6L ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . delete ( "/depart/delete/" + departId ) . contentType ( MediaType . APPLICATION_JSON ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "组织/部门删除接口测试成功！" ) ;
getInterpolation: public float getInterpolation ( float input ) { return ( float ) Math . pow ( input , 4 ) ;
get: public < T > T get ( PageAttr < T > key ) { return ( T ) super . get ( key . name ) ;
requiredArgs: No method body
getEffect: public EffectData getEffect ( LaunchData launchData , EffectSet . EffectAttacher attacher ) { return getEffect ( launchData ) ;
getY: public float getY ( ) { return bone . getWorldY ( ) ;
getOwner: public ClanMember getOwner ( ) { return owner ;
awaitOnAlreadyResolvedAwaitables: protected TestInvocationBuilder awaitOnAlreadyResolvedAwaitables ( ) { return testDefinitionForService (
init: private void init ( Context context , AttributeSet attrs , int defStyleAttr ) { mScaleTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mMaxVelocity = ViewConfiguration . get ( context ) . getScaledMaximumFlingVelocity ( ) ; isSwipeEnable = true ; isIos = true ; isLeftSwipe = true ; TypedArray ta = context . getTheme ( ) . obtainStyledAttributes ( attrs , R . styleable . SwipeMenuLayout , defStyleAttr , 0 ) ; int count = ta . getIndexCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int attr = ta . getIndex ( i ) ; if ( attr == R . styleable . SwipeMenuLayout_swipeEnable ) { isSwipeEnable = ta . getBoolean ( attr , true ) ; } else if ( attr == R . styleable . SwipeMenuLayout_ios ) { isIos = ta . getBoolean ( attr , true ) ; } else if ( attr == R . styleable . SwipeMenuLayout_leftSwipe ) { isLeftSwipe = ta . getBoolean ( attr , true ) ; } } ta . recycle ( ) ;
getCurrentSelectionFileName: private String getCurrentSelectionFileName ( ) { return selectFileEdit . getText ( ) + ".map" ;
getWhiteDict: public CommonResult < List < WhiteDictDto > > getWhiteDict ( ) { List < WhiteDictDto > whiteDict = whiteService . getWhiteDict ( ) ; return CommonResult . success ( whiteDict ) ;
onFinishInflate: protected void onFinishInflate ( ) { super . onFinishInflate ( ) ; if ( mCheckedId != - 1 ) {
setSpawn: private void setSpawn ( Spawnable spawnable ) { this . spawnSelection = spawnable ; spawnAction . selected ( spawnable ) ; if ( spawnSelection != null )
getTenants: public BulkTenantResponse getTenants ( final GetTenantRequest request ) throws IOException , NovuNetworkException { Map < String , Object > params = new HashMap < > ( ) ; if ( request . getPage ( ) != null ) { params . put ( "page" , request . getPage ( ) ) ; } if ( request . getLimit ( ) != null ) { params . put ( "limit" , request . getLimit ( ) ) ; } Response < BulkTenantResponse > response = tenantsApi . getTenants ( params ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
canScrollUp: public boolean canScrollUp ( ) { boolean result ; if ( android . os . Build . VERSION . SDK_INT < 14 ) { result = ViewCompat . canScrollVertically ( this , - 1 ) || this . getScrollY ( ) > 0 ; } else { result = ViewCompat . canScrollVertically ( this , - 1 ) ; } return result ;
populateFromEntity: protected static BasicUser populateFromEntity ( BasicUser dto , User entity ) { dto . firstName = entity . getFirstName ( ) ; dto . lastName = entity . getLastName ( ) ; dto . email = entity . getEmail ( ) ; return dto ;
lockUpdate: public boolean lockUpdate ( ) { return true ;
hasRender: public boolean hasRender ( ) { return false ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; entry = null ;
parseKey: void parseKey ( ) { RestateRequestIdentityVerifier . fromKeys (
isEveryWhere: void isEveryWhere ( ) { assertTrue ( IsEveryWhere . isEveryWhere ( new int [ ] { 1 , 2 , 1 , 3 } , 1 ) ) ; assertFalse ( IsEveryWhere . isEveryWhere ( new int [ ] { 1 , 2 , 1 , 3 } , 2 ) ) ; assertFalse ( IsEveryWhere . isEveryWhere ( new int [ ] { 1 , 2 , 1 , 3 , 4 } , 1 ) ) ;
enlarge: void enlarge ( ) { Object [ ] tmp = new Object [ elements . length * 2 ] ; System . arraycopy ( elements , 0 , tmp , 0 , elements . length ) ; elements = tmp ;
hashCode: public int hashCode ( ) { return Objects . hash ( createdBy , createdById ) ;
onError: public void onError ( Exception e ) { e . printStackTrace ( ) ;
init: public void init ( ) { super . init ( ) ; SimplePhysicsComponentData phy = getComponentObject ( ) . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy == null ) return ; launchData = new LaunchData ( )
NewVote: public static ServerVote NewVote ( ID id , String data ) { switch ( id ) { case endgame : { return new SVEndGame ( data ) ; } } return null ;
setKey: public void setKey ( Object key ) { this . key = key ;
readStreamEntry: No method body
onEvent: public boolean onEvent ( Event event ) { return false ;
getStats: private String getStats ( ) { ClientItemComponentData ci = getComponentObject ( ) . getComponent ( ClientItemComponentData . class ) ; if ( ci != null && ci . isDiscover ( ) ) { return L . get ( itemData . hasItems ( ) ? "MENU_OPEN" : "MENU_WEAPON_UI_EMPTY" ) ; } if ( itemData instanceof RoundLockSafeData && ( ( RoundLockSafeData ) itemData ) . isLocked ( ) ) return L . get ( "MENU_DOOR_LOCKED_UP" ) ; int itemsCount = itemCount ( ) ; if ( itemsCount == 0 ) return L . get ( "MENU_WEAPON_UI_EMPTY" ) ; return L . get ( "MENU_ITEM_STATS" , String . valueOf ( itemsCount ) ) ;
onInterceptTouchEvent: public boolean onInterceptTouchEvent ( MotionEvent ev ) { try {
unexpectedMessage: static ProtocolException unexpectedMessage ( Class < ? extends MessageLite > expected , MessageLite actual ) { return new ProtocolException (
getScore: public float getScore ( String account , float score ) { if ( event . getEvent ( ) . group ) { if ( myClanId != null && myClanId . equals ( account ) ) { return event . getEvent ( ) . score ; } } else { if ( BrainOutClient . ClientController . getMyAccount ( ) . equals ( account ) ) { return event . getEvent ( ) . score ; } } return super . getScore ( account , score ) ;
instantiateItem: public Object instantiateItem ( ViewGroup container , int position ) { if ( mAdapter . getPageCount ( ) != 0 && position >= mAdapter . getPageCount ( ) ) { position = position % mAdapter . getPageCount ( ) ; } View bannerItemView = mAdapter . getView ( position , getConvertView ( ) ) ; container . addView ( bannerItemView ) ; return bannerItemView ;
removeFirstTwoCharsStringBuilder: public void removeFirstTwoCharsStringBuilder ( ) { assertEquals ( "llo World!" , RemoveFirstTwoChars . removeFirstTwoCharsStringBuilder ( "Hello World!" ) ) ; assertEquals ( "" , RemoveFirstTwoChars . removeFirstTwoCharsStringBuilder ( "No" ) ) ; assertEquals ( "" , RemoveFirstTwoChars . removeFirstTwoCharsStringBuilder ( "Y" ) ) ;
getLineWidth: No method body
formatMoney: public static String formatMoney ( long money ) { String text = String . valueOf ( money ) ; try { DecimalFormat df = new DecimalFormat ( "#,###" ) ; text = df . format ( money ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return text ;
show: public static void show ( Actor actor , OwnableContent item , UserProfile userProfile , Stage stage , UnlockTooltipCreator tooltipCreator ) { Tooltip . RegisterToolTip ( actor , tooltipCreator , stage ) ;
getNewbie: public String getNewbie ( ) { return newbie ;
getSteamDensityByPressure: public double getSteamDensityByPressure ( double pressure ) { if ( pressure >= 0.0017 && pressure < 22.064 ) { int lower = ( int ) ( pressure * 10000.0 ) ; int higher = ( int ) ( pressure * 10000.0 + 1 ) ; double lowerValue = steamDensityByPressureMap . get ( lower ) ; double higherValue = steamDensityByPressureMap . get ( higher ) ; double perDensity = higherValue - lowerValue ; return lowerValue + ( ( pressure * 10000.0 - lower ) * perDensity ) ; } if ( ! error ) { error = ! error ; NPPSim . endSimulation ( ) ; StackTraceElement [ ] stack = Thread . currentThread ( ) . getStackTrace ( ) ; StringBuilder strBuilder = new StringBuilder ( ) ; for ( StackTraceElement stack1 : stack ) { strBuilder . append ( stack1 . toString ( ) ) ; strBuilder . append ( "\n" ) ; } new ErrorWindow ( "A component has been damaged beyond repair" , strBuilder . toString ( ) , true ) . setVisible ( true ) ; } return 0 ;
createAudience: public Audience createAudience ( Audience model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Audience > responseModel = ( Class < Audience > ) ( Class < ? > ) Audience . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/promotions/audiences" ) , query , null , responseModel , model ) ;
received: public boolean received ( final PlayMusicMsg msg ) { Gdx . app . postRunnable ( ( ) -> { Music music = BrainOutClient . ContentMgr . get ( msg . music , Music . class ) ; if ( music == null ) return ; music . playInSoundChannel ( ) ; } ) ; return true ;
getReadPrivilege: public PrivilegeBase getReadPrivilege ( ) { if ( this . readPrivilegeStringTimestamp > this . readPrivilegeTimestamp || readPrivilegeTimestamp == 0 ) { this . readPrivilege = PrivilegeHelper . valueOfString ( this . readPrivilegeString ) ; } return readPrivilege ;
triggerEvent: No method body
piscesServerAccessDeniedHandler: public PiscesServerAccessDeniedHandler piscesServerAccessDeniedHandler ( ) { return new PiscesServerAccessDeniedHandler ( ) ;
resolveAsync: No method body
getPassword: public String getPassword ( ) { return password ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; player = ( ( Player ) BrainOut . ContentMgr . get ( jsonData . getString ( "player" ) ) ) ; additionalClip = jsonData . getInt ( "additionalClip" , 0 ) ; if ( jsonData . has ( "clipExcept" ) ) { for ( JsonValue value : jsonData . get ( "clipExcept" ) ) { clipExcept . add ( BrainOut . ContentMgr . get ( value . asString ( ) , Bullet . class ) ) ; } } if ( jsonData . has ( "weaponExcept" ) ) { for ( JsonValue value : jsonData . get ( "weaponExcept" ) ) { weaponExcept . add ( BrainOut . ContentMgr . get ( value . asString ( ) , Weapon . class ) ) ; } } if ( jsonData . has ( "slotFrom" ) )
setPaused: public static void setPaused ( boolean paused ) { simPaused = paused ;
setUp: public static void setUp ( ) throws Exception { Instrumentation instrumentation = ByteBuddyAgent . install ( ) ; Global . instrumentation = instrumentation ; Global . fillLoadedClasses ( ) ; System . setProperty ( "maxHit" , "3" ) ;
hasOrgPrivilege: default boolean hasOrgPrivilege ( PrivilegeBase p , Long orgId , Map < Long , Set < String > > organizationPrivileges ) { if ( p == null || orgId == null ) { return false ; } return organizationPrivileges . containsKey ( orgId ) && organizationPrivileges . get ( orgId ) . contains ( p . name ( ) ) ;
onSuccess: public void onSuccess ( final Context context , String result ) { postMainThread ( new Runnable ( ) { @ Override public void run ( ) { dialogDismiss ( ) ; } } ) ; final Gson gson = GSonUtils . buildGSon ( ) ; try {
update: protected void update ( float dt ) { delayFor -= dt ; if ( delayFor < 0 )
setAttachment: public void setAttachment ( @ Null Attachment attachment ) { if ( this . attachment == attachment ) return ; if ( ! ( attachment instanceof VertexAttachment ) || ! ( this . attachment instanceof VertexAttachment ) || ( ( VertexAttachment ) attachment ) . getDeformAttachment ( ) != ( ( VertexAttachment ) this . attachment ) . getDeformAttachment ( ) ) { deform . clear ( ) ; } this . attachment = attachment ; attachmentTime = bone . skeleton . time ;
length2: public final float length2 ( ) { return ( x * x ) + ( y * y ) + ( z * z ) ;
resolve: No method body
onRelease: public void onRelease ( ) { clear ( ) ; if ( postEffects != null ) { postEffects . dispose ( ) ; } gs = null ;
getLineHeight: public static float getLineHeight ( Paint paint , Paint . FontMetrics fontMetrics ) { paint . getFontMetrics ( fontMetrics ) ; return fontMetrics . descent - fontMetrics . ascent ;
reset: public void reset ( ) { this . speed . set ( 0 , 0 ) ; this . coef . set ( 0 , 0 ) ;
onEvent: public boolean onEvent ( Event event ) { return false ;
isEmbeddable: public boolean isEmbeddable ( ) { return embeddable ;
setPositiveButton: public ColorPickerDialogBuilder setPositiveButton ( CharSequence text , final ColorPickerClickListener onClickListener ) { builder . setPositiveButton ( text , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { positiveButtonOnClick ( dialog , onClickListener ) ; } } ) ; return this ;
supportsParameter: public boolean supportsParameter ( MethodParameter parameter ) { return AbstractOrganizationRelatedEntityForm . class . equals ( parameter . getParameterType ( ) ) ;
generate: public void generate ( ConsumableContainer container , String dimension ) { container . putConsumable ( amount , new PlayerSkinConsumableItem ( item ) ) ;
setUpdatedOn: public void setUpdatedOn ( LocalDateTime updatedOn ) { this . updatedOn = updatedOn ;
cl_block: void cl_block ( OutputStream outs ) throws IOException { cl_hash ( hsize ) ; free_ent = ClearCode + 2 ; clear_flg = true ; output ( ClearCode , outs ) ;
getNextFloor: private ServerElevatorFloorComponentData getNextFloor ( ) { String floor = ( ( ActiveData ) currentFloor . getComponentObject ( ) ) . getNameId ( ) ; if ( floor == null ) return null ; Map map = getMap ( ) ; if ( map == null ) return null ; String nextFloor = floor . equals ( floorA ) ? floorB : floorA ; ActiveData activeData = findActiveData ( nextFloor ) ; if ( activeData == null ) return null ; return activeData . getComponent ( ServerElevatorFloorComponentData . class ) ;
toString: public String toString ( ) { return
setSecondCurrency: private void setSecondCurrency ( String currencyCode , Double rate , String symbol ) { mSecondCurrency = new Currency ( currencyCode , rate , symbol ) ;
getWaterFlowRate1: public double getWaterFlowRate1 ( ) { return waterMass1 * 20 ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------assetsBalanceOnError------------------" + e . getMessage ( ) ) ;
getUserId: public Long getUserId ( ) { return userId ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( Menu . MenuSound . select ) ;
received: public boolean received ( final DropConsumableMsg msg ) { if ( playerController == null ) return false ; if ( getState ( ) == State . spawned && getPlayerData ( ) != null ) { final Map map = getPlayerData ( ) . getMap ( ) ; if ( map == null ) return true ; BrainOutServer . PostRunnable ( ( ) -> { if ( playerData == null ) return ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { playerController . dropConsumable ( msg . id , msg . angle , msg . amount ) ; } } ) ; } return true ;
buildRoute: No method body
getLocation: public LocalizedString getLocation ( ) { return location ;
init: @ PostConstruct void init ( ) { instance = this ;
setOperator: public void setOperator ( String operator ) { this . operator = operator ;
setPassword: public void setPassword ( String password ) { this . password = password ;
hasUpdate: No method body
renderSpawns: private void renderSpawns ( ServerMap map ) { renderSpawnsForTeam ( map , "team-green" , "SPAWN_BASE" ) ; renderSpawnsForTeam ( map , "team-blue" , "SPAWN_BASE" ) ; renderSpawnsForTeam ( map , "team-dm" , "SPAWN_RANDOM" ) ;
lockInput: public boolean lockInput ( ) { return true ;
update: public void update ( ) { double highestPressure = 0 ; double pressureSum = 0 ; for ( int i = 0 ; i < sources . length ; i ++ ) { double sourcePressure = sources [ i ] . getPressure ( ) ; pressureSum += sourcePressure ; highestPressure = sourcePressure > highestPressure ? sourcePressure : highestPressure ; } pressure = highestPressure ; for ( int i = 0 ; i < sources . length ; i ++ ) { Connectable thisSource = sources [ i ] ; double steamMass = 0 ; double sourceOutFlow = thisSource . getPressure ( ) / pressureSum * steamOutflow ; double sourceSteamTemp = thisSource . getSteamTemperature ( ) ; thisSource . updateSteamOutflow ( sourceOutFlow , sourceSteamTemp ) ; Double [ ] inflowData = NPPMath . mixSteam ( steamMass , steamTemperature , sourceOutFlow , sourceSteamTemp ) ; steamMass = inflowData [ 0 ] ; steamTemperature = inflowData [ 1 ] ; steamDensity = Loader . tables . getSteamDensityByPressure ( pressure ) ; } resetFlows ( ) ;
doubleReturnAndArrayParam2: public void doubleReturnAndArrayParam2 ( ) { WatchMessage msg = new WatchMessage ( ) ; msg . setSignature ( "w.core.WatchTarget#doubleMethodWithParams" ) ; msg . setPrintFormat ( 2 ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; target . doubleMethodWithParams ( 0.1 ) ;
buildDirectResponse: public JRPCMessage buildDirectResponse ( final @ NonNull Packet packet , final @ NonNull String target , final @ NonNull ConversationUID uid ) { return JRPCMessageBuilder . builder ( )
alphaSliderOnly: public ColorPickerDialogBuilder alphaSliderOnly ( ) { isLightnessSliderEnabled = false ; isAlphaSliderEnabled = true ; return this ;
getWindowBackground: protected Drawable getWindowBackground ( ) { return ContextCompat . getDrawable ( mContext , R . color . color_white ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; CSMultipleAccounts cs = BrainOutClient . ClientController . getState ( CSMultipleAccounts . class ) ; cs . resolve ( profile . account ) ;
getSender: public String getSender ( ) { return sender ;
findByTokenAndIsValidTrue: No method body
readFile: public static List < String > readFile ( String path ) throws IOException { return Files . readAllLines ( Paths . get ( path ) ) ;
getID: public ID getID ( ) { return ID . setSpeed ;
clicked: public void clicked ( InputEvent event , float x , float y ) { callback . selected ( friend ) ; close ( ) ;
getMaximumSize: public Dimension getMaximumSize ( ) { return getCustomDimensions ( ) ;
fullRecover: public void fullRecover ( ) { setBleeding ( false ) ; setBonesBroken ( false ) ; setSwamp ( false ) ; setTemperature ( getContentComponent ( ) . getTemperatureMax ( ) ) ; refillHunger ( getContentComponent ( ) . getHungerMax ( ) ) ; refillThirst ( getContentComponent ( ) . getThirstMax ( ) ) ; removeRadio ( getContentComponent ( ) . getRadioMax ( ) ) ; sync ( ) ;
newOne: No method body
setPropertyid: public void setPropertyid ( long propertyid ) { this . propertyid = propertyid ;
getSteamDensity: public double getSteamDensity ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getSteamDensity'" ) ;
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { Bone bone = skeleton . bones . get ( boneIndex ) ; if ( ! bone . active ) return ; float [ ] frames = this . frames ; if ( time < frames [ 0 ] ) { switch ( blend ) { case setup : bone . scaleY = bone . data . scaleY ; return ; case first : bone . scaleY += ( bone . data . scaleY - bone . scaleY ) * alpha ; } return ; } float y = getCurveValue ( time ) * bone . data . scaleY ; if ( alpha == 1 ) {
syncCheck: private void syncCheck ( float dt ) { if ( ! isConnected ( ) ) return ; GameMode mode = getGameMode ( ) ; if ( mode == null ) return ; this . dt += dt ; if ( this . dt > Constants . TimeSync . PERIOD )
warmUpComplete: protected void warmUpComplete ( ) { super . warmUpComplete ( ) ; Array < ServerChipSpawnerComponentData > spawners = new Array < > ( ) ; for ( Map map : Map . All ( ) ) { for ( ActiveData chip : map . getActivesForTag ( Constants . ActiveTags . CHIP_SPAWNER , false ) ) { ServerChipSpawnerComponentData spawner = chip . getComponent ( ServerChipSpawnerComponentData . class ) ; if ( spawner != null ) { spawners . add ( spawner ) ; } } } spawners . shuffle ( ) ; int chips = getGameMode ( ) . getChips ( ) ; for ( int i = 0 ; i < chips && i < spawners . size ; i ++ )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionDecrementActionPerformed ( evt ) ;
update: public void update ( Skeleton skeleton , boolean updateAabb ) { if ( skeleton == null ) throw new IllegalArgumentException ( "skeleton cannot be null." ) ; Array < BoundingBoxAttachment > boundingBoxes = this . boundingBoxes ; Array < FloatArray > polygons = this . polygons ; Object [ ] slots = skeleton . slots . items ; int slotCount = skeleton . slots . size ; boundingBoxes . clear ( ) ; polygonPool . freeAll ( polygons ) ; polygons . clear ( ) ; for ( int i = 0 ; i < slotCount ; i ++ ) { Slot slot = ( Slot ) slots [ i ] ; if ( ! slot . bone . active ) continue ; Attachment attachment = slot . attachment ; if ( attachment instanceof BoundingBoxAttachment ) { BoundingBoxAttachment boundingBox = ( BoundingBoxAttachment ) attachment ; boundingBoxes . add ( boundingBox ) ; FloatArray polygon = polygonPool . obtain ( ) ; polygons . add ( polygon ) ; boundingBox . computeWorldVertices ( slot , 0 , boundingBox . getWorldVerticesLength ( ) , polygon . setSize ( boundingBox . getWorldVerticesLength ( ) ) , 0 , 2 ) ; } } if ( updateAabb )
getGenerator: public FreeplayGenerator getGenerator ( ) { return ( ( FreeplayGenerator ) getContent ( ) ) ;
definitions: No method body
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { waterInVOpen2ItemStateChanged ( evt ) ;
onLoadFailed: public void onLoadFailed ( Exception e , Drawable errorDrawable ) { if ( callback != null ) {
handshake: public HandshakeStatusPacket handshake ( final ChannelPipeline pipeline , final JRPCHandshake handshake ) { return tryHandshake ( pipeline , handshake ) ;
isTouchedSinceLastJump: public final boolean isTouchedSinceLastJump ( ) { return this . isTouchedSinceLastJump ;
close: private void close ( ) { pop ( ) ;
getCustom: public Object getCustom ( String key , Object default_ ) { return this . custom . get ( key , default_ ) ;
drop: public void drop ( DragAndDrop . Source source , DragAndDrop . Payload payload , float x , float y , int pointer ) { currentMode . drop ( source , payload , convertMousePosition ( x , dragAndDropTargetActor . getHeight ( ) - y ) , pointer ) ;
alwaysNotifyTimeout: public Conversation < TRequest , TResponse > alwaysNotifyTimeout ( ) { this . alwaysNotifyTimeout = true ; return this ;
onStartup: public void onStartup ( ServletContext servletContext ) throws ServletException { servletContext . getSessionCookieConfig ( ) . setSecure ( secure ) ;
onClick: public void onClick ( View v ) { if ( null != mCallback ) { mCallback . onItemClick ( v ) ; } mBasePopWindow . dismiss ( ) ;
testCreateOrUpdateCustomData: public void testCreateOrUpdateCustomData ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCountryCreateOrUpdateCustomDataRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . shopCountries ( ) . createOrUpdateCustomData ( "acme" , "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCountryCreateOrUpdateCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
write: public void write ( Json json ) { json . writeValue ( getName ( ) , getValue ( ) ) ;
initStats: protected void initStats ( ) { super . initStats ( ) ; CSGame CC = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( CC != null && playerData != CC . getPlayerData ( ) ) { String name = remoteClient . getName ( ) ; if ( name . length ( ) > 20 ) { name = name . substring ( 0 , 20 ) + "..." ; } this . nickName = new Label ( name , BrainOutClient . Skin , "title-ingame-nickname" ) ; nickName . setEllipsis ( true ) ; nickName . setWrap ( false ) ; getUi ( ) . add ( nickName ) . height ( 1.5f ) . expandX ( ) . fillX ( ) . row ( ) ; nickName . setFontScale ( 1.0f / ClientConstants . Graphics . RES_SIZE ) ; nickName . setAlignment ( Align . center ) ; updateTeam ( ) ; } updateTeamIcon ( ) ;
getContentEditable: public String getContentEditable ( ) { return contentEditable ;
getMatrixTouch: public Matrix getMatrixTouch ( ) { return mMatrixTouch ;
updateWaterInFlow1: public void updateWaterInFlow1 ( double flow , double tempC ) { waterInflowTemperature1 = tempC ; waterMass1 = flow ;
toAuditString: public String toAuditString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( Optional . ofNullable ( getUser ( ) ) . map ( a -> a . getEmail ( ) ) . orElse ( "N/A" ) ) ; sb . append ( ":" ) ; sb . append ( getRoleName ( ) ) ; if ( ! isGlobal ( ) ) { sb . append ( "@" ) ; sb . append ( organizationId ) ; } return sb . toString ( ) ;
onHandshakeSuccess: public boolean onHandshakeSuccess ( final JRPCHandshake handshake ) { this . uniqueId = handshake . getUniqueId ( ) ; this . type = handshake . getType ( ) ; this . client = new JRPCClientInstance ( this ) ; final boolean success = ( this . handshaked = handshake . getToken ( ) . equals ( server . getConfig ( ) . getAuthenticationToken ( ) ) ) ; if ( success ) { server . addConnected ( client ) ; } return success ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; RoomSettings settings = new RoomSettings ( ) ; settings . init ( BrainOutClient . ClientController . getUserProfile ( ) , false ) ; pushMenu ( new EngageConflictMenu ( new QuickPlayOptionsMenu . Callback ( )
deleteResource: No method body
translate: void translate ( ) { circle . translate ( - 10 , - 10 ) ; assertEquals ( - 5 , circle . getCenter ( ) . getX ( ) ) ; assertEquals ( - 5 , circle . getCenter ( ) . getY ( ) ) ;
getFlipX: public boolean getFlipX ( ) { return false ;
updateLoadStatus: private void updateLoadStatus ( int distanceY ) { if ( mCurrentRefreshStatus == LOAD_STATUS_LOADING ) { return ; } if ( distanceY <= 0 ) { mCurrentLoadStatus = LOAD_STATUS_NORMAL ; } else if ( distanceY < mLoadViewHeight ) { mCurrentLoadStatus = LOAD_STATUS_PULL_DOWN_REFRESH ; } else { mCurrentLoadStatus = LOAD_STATUS_LOOSEN_LOADING ; } if ( mLoadCreator != null ) {
storagePath: public static String storagePath ( Context context ) { if ( PermissionChecker . checkExternalPermission ( context ) && StorageUtils . checkSDCardState ( ) ) {
hasRender: public boolean hasRender ( ) { return false ;
getActiveIntegrations: public BulkIntegrationResponse getActiveIntegrations ( ) throws IOException , NovuNetworkException { try {
onClick: public void onClick ( View v ) { int id = v . getId ( ) ; if ( id == R . id . tv_dialog_update_confirm || id == R . id . tv_dialog_update_force_btn ) {
calculateHash: private byte [ ] calculateHash ( int index , long currentDay , String account , UserProfile userProfile ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( "SHA-256" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; return null ; } String payload = String . valueOf ( index ) + "_" + String . valueOf ( currentDay ) + "_" + account + "_" + BattlePassTask . getNonce ( userProfile ) ; return digest . digest ( payload . getBytes ( ) ) ;
obtainStyledAttrs: private void obtainStyledAttrs ( Context context , AttributeSet attrs , int defStyleAttr ) { TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . RoundImageView , defStyleAttr , 0 ) ; currMode = a . hasValue ( R . styleable . RoundImageView_type ) ? a . getInt ( R . styleable . RoundImageView_type , MODE_NONE ) : MODE_NONE ; currRound = a . hasValue ( R . styleable . RoundImageView_radius ) ? a . getDimensionPixelSize ( R . styleable . RoundImageView_radius , currRound ) : currRound ; a . recycle ( ) ;
setMenuOpen: public void setMenuOpen ( boolean state ) { mRightIv . setSelected ( state ) ;
resize: No method body
isComplete: No method body
deleteWhite: void deleteWhite ( ) { Long whiteId = 100L ; whiteService . deleteWhite ( whiteId ) ; log . info ( "删除白名单方法测试成功！" ) ;
getTime: public float getTime ( ) { return time ;
addDict: void addDict ( ) { Dict dict = new Dict ( ) ; dict . setGroupName ( "UNIT_TEST" ) ; dict . setKey ( "UNIT_KEY" ) ; dict . setValue ( "UNIT_VALUE" ) ; dict . setRemark ( "这是一条单元测试新增的数据！" ) ; dictService . addDict ( dict ) ; log . info ( "新增字典方法测试成功！" ) ;
interceptMethod2: private Response interceptMethod2 ( Chain chain ) throws IOException { Request request = chain . request ( ) ; long startTime = System . currentTimeMillis ( ) ; Response response = chain . proceed ( chain . request ( ) ) ; long endTime = System . currentTimeMillis ( ) ; long duration = endTime - startTime ; LogUtils . e ( TAG , "\n" ) ; LogUtils . e ( TAG , "*\n" ) ; LogUtils . e ( TAG , "-------------------------------------------------Start---------------------" + "--------------------------------------------------------" ) ; logRequest ( request ) ; Response resp = logResponse ( response ) ; LogUtils . e ( TAG , "-----------------------------------------------End:" + duration + "毫秒--" + "--------------------------------------------------------------------" ) ; LogUtils . e ( TAG , "*\n" ) ; LogUtils . e ( TAG , "\n" ) ; return resp ;
run: public void run ( ) { setPos ( ) ;
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; final ConversationUID that = ( ConversationUID ) o ; return uid == that . uid ;
formatDateWithFullMonthName: public static String formatDateWithFullMonthName ( LocalDateTime date , String languageTag ) { DateTimeFormatter dateFormat = DateTimeFormatter . ofPattern ( "dd MMMM yyyy" , Locale . forLanguageTag ( languageTag ) ) ; return date . format ( dateFormat ) ;
getObject: No method body
init: private void init ( ) { Image image = new Image ( BrainOutClient . getRegion ( "icon-gears" ) ) ; image . setFillParent ( true ) ; image . setTouchable ( Touchable . disabled ) ; image . setScaling ( Scaling . none ) ; addActor ( image ) ; addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { tryFix ( ) ; } } ) ; DurabilityComponent dc = instrument . getComponentFrom ( DurabilityComponent . class ) ; if ( dc != null )
setEmail: public void setEmail ( String email ) { this . email = email != null ? email . toLowerCase ( ) : null ;
requiredArgs: public int requiredArgs ( ) { return 2 ;
containsOnlyExactErrorMessage: public static Consumer < List < MessageLite > > containsOnlyExactErrorMessage ( Throwable e ) { return containsOnly ( exactErrorMessage ( e ) ) ;
headerBorderStyle: protected String headerBorderStyle ( ) { return "form-red" ;
setOnRootViewClickListener: void setOnRootViewClickListener ( @ NonNull ChannelListItem item , int type ) { mRootView . setOnClickListener ( new OnSingleClickListener ( ) {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jToggleButton3ActionPerformed ( evt ) ;
any: static DeferredInternal < Integer > any ( List < DeferredInternal < ? > > any ) { return new AnyDeferred ( any ) ;
deleteByModule: No method body
execute: public String execute ( String [ ] args , Client client ) { if ( ! ( client instanceof PlayerClient ) ) return "Not a player" ; PlayerClient playerClient = ( ( PlayerClient ) client ) ; PlayerData playerData = playerClient . getPlayerData ( ) ; if ( playerData == null ) return "Player not spawned" ; if ( ! playerData . getDimension ( ) . startsWith ( "intro" ) ) return "not in intro" ; PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( playState . getID ( ) != PlayState . ID . game ) return "Not in game" ; GameMode mode = ( ( ServerPSGame ) playState ) . getMode ( ) ; if ( mode . getID ( ) != GameMode . ID . free ) return "Not in freeplay" ; ServerFreeRealization free = ( ( ServerFreeRealization ) mode . getRealization ( ) ) ; free . playerEnter ( playerData , playerClient ) ; return "Done" ;
canTake: protected boolean canTake ( PlayerData playerData ) { PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return false ; for ( ConsumableRecord record : itemData . getRecords ( ) . getData ( ) . values ( ) ) { if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; Content content = ici . getInstrumentData ( ) . getContent ( ) ; if ( content instanceof Instrument ) { Slot slot = ( ( Instrument ) content ) . getSlot ( ) ; if ( poc . getInstrumentForSlot ( slot ) != null ) { return false ; } } } } return true ;
getRecords: public ConsumableContainer getRecords ( ) { return itemData . getRecords ( ) ;
getBirthByIdCard: public static String getBirthByIdCard ( String idCard ) { Integer len = idCard . length ( ) ; if ( len < CHINA_ID_MIN_LENGTH ) { return null ; } else if ( len == CHINA_ID_MIN_LENGTH ) { idCard = convert15CardTo18 ( idCard ) ; } return idCard . substring ( 6 , 14 ) ;
getID: public ID getID ( ) { return ID . playStateUpdated ;
getDataFolder: public String getDataFolder ( ) { return dataFolder ;
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/CustomerUpdateRequest.json" ) ; Customer requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Customer . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Customer responseEntity = this . api . customers ( ) . update ( "acme" , "acme" , Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CustomerUpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
decodeURI: public String decodeURI ( String uri ) { try {
validateConfig: private void validateConfig ( ApiConfiguration apiConfiguration ) throws InvalidArgumentException { String url = apiConfiguration . getUrl ( ) ; String accessToken = apiConfiguration . getAccessToken ( ) ; if ( url == null || url . isEmpty ( ) ) { throw new InvalidArgumentException ( "A valid API Url has to bet set" ) ; } if ( accessToken == null || accessToken . isEmpty ( ) ) {
close: private void close ( ) { onTop = false ; pop ( ) ;
init: void init ( ) { services . applicationEvent . registerEventListener ( ApplicationEvent . USER_CREATED , this :: createConfigurationsForUser ) ; services . applicationEvent . registerEventListener ( ApplicationEvent . USER_DELETED , this :: deleteConfigurationsForUser ) ; services . applicationEvent . registerEventListener ( ApplicationEvent . ORGANIZATION_CREATED , this :: createConfigurationsForOrganization ) ; services . applicationEvent . registerEventListener ( ApplicationEvent . ORGANIZATION_DELETED , this :: deleteConfigurationsForOrganization ) ; services . applicationEvent . registerEventListener ( ApplicationEvent . USER_ROLE_CREATED , this :: createConfigurationsForOrganizationUser ) ; services . applicationEvent . registerEventListener ( ApplicationEvent . USER_ROLE_DELETED ,
hashCode: public int hashCode ( ) { return Float . floatToIntBits ( width ) ^ Float . floatToIntBits ( height ) ;
single: static < T > DeferredInternal < T > single ( int entryIndex ) { return new ResolvableSingleDeferred < > ( null , entryIndex ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; fuel = jsonData . getFloat ( "fuel" , fuel ) ; working = jsonData . getFloat ( "wkn" , working ) ; requiredItem = jsonData . getString ( "rq" , requiredItem ) ; failCounter = 1 ;
isEditorSelectable: public boolean isEditorSelectable ( ) { return editor ;
getFormLineWidth: No method body
onMessage: No method body
parseServiceProtocolVersion: static Protocol . ServiceProtocolVersion parseServiceProtocolVersion ( String version ) { version = version . trim ( ) ; if ( version . equals ( "application/vnd.restate.invocation.v1" ) ) { return Protocol . ServiceProtocolVersion . V1 ; } if ( version . equals ( "application/vnd.restate.invocation.v2" ) ) { return Protocol . ServiceProtocolVersion . V2 ; } return Protocol . ServiceProtocolVersion . SERVICE_PROTOCOL_VERSION_UNSPECIFIED ;
setOnItemClickListener: public void setOnItemClickListener ( View . OnClickListener listener ) { mItemView . setOnClickListener ( listener ) ;
returnItems: public ReturnItemService returnItems ( ) { ReturnItemService service = this . getService ( "com.scayle.adminapi.service.ReturnItemService" ) ; return service ;
colorWithAlpha: public static int colorWithAlpha ( int color , int alpha ) { return ( color & 0xffffff ) | ( ( alpha & 0xff ) << 24 ) ;
main: public static void main ( String [ ] args ) { RandomGenerator rnd = RandomGenerator . getDefault ( ) ; System . out . println ( rnd . nextInt ( ) ) ; System . out . println ( rnd . nextLong ( ) ) ; System . out . println ( rnd . nextInt ( 100 ) ) ; System . out . println ( rnd . nextLong ( 100 ) ) ; System . out . println ( rnd . nextInt ( 50 , 60 ) ) ; System . out . println ( rnd . nextLong ( 50 , 60 ) ) ; System . out . println ( rnd . nextFloat ( ) ) ; System . out . println ( rnd . nextDouble ( ) ) ; System . out . println ( rnd . nextFloat ( 100.0F ) ) ; System . out . println ( rnd . nextDouble ( 100.0 ) ) ; System . out . println ( rnd . nextFloat ( 0.1F , 0.4F ) ) ; System . out . println ( rnd . nextDouble ( 0.1 , 0.4 ) ) ; System . out . println ( rnd . nextBoolean ( ) ) ;
setId: public void setId ( Long id ) { this . id = id ;
getUpgrade: public Upgrade getUpgrade ( UserProfile profile ) { int level = getUpgradeLevel ( profile ) ; if ( level == 0 ) { return null ; } return upgrades . get ( level - 1 ) ;
getIndexString: public String getIndexString ( ) { return indexString ;
getID: public Event . ID getID ( ) { return Event . ID . voice ;
initWith: No method body
Hide: public static void Hide ( ) { if ( Last != null )
setScaleX: public void setScaleX ( float scaleX ) { this . scaleX = scaleX ;
getScreenMetrics: public static Point getScreenMetrics ( Context context ) { WindowManager manager = ( WindowManager ) context . getSystemService ( Context . WINDOW_SERVICE ) ; Point point = new Point ( ) ; manager . getDefaultDisplay ( ) . getSize ( point ) ; return point ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights ) { case admin : case mod : return true ; } return false ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcClose1ItemStateChanged ( evt ) ;
scanBaseClass: public static Set < Class < ? > > scanBaseClass ( String basePackage , Class < ? > ... baseClasses ) { List < TypeFilter > includeFilters = new ArrayList < > ( 16 ) ; for ( Class < ? > baseClass : baseClasses ) { includeFilters . add ( new AssignableTypeFilter ( baseClass ) ) ; } return scanPackageClass ( basePackage , includeFilters , null ) ;
onChanged: protected void onChanged ( int newValue ) { SendResourcesToClanMemberMenu . this . amount = newValue ;
setTarget: public void setTarget ( Slot target ) { if ( target == null ) throw new IllegalArgumentException ( "target cannot be null." ) ; this . target = target ;
isDone: public boolean isDone ( ) { return done ;
run: public void run ( ) { ps . popAllUntil ( ActionPhaseMenu . class ) ; ps . pushMenu ( new DeathCameraMenu ( map ,
hoverOneItem: private void hoverOneItem ( ActiveData activeData ) { clearHoveredItems ( ) ; hoveredItems . add ( activeData ) ;
setUp: void setUp ( ) { l = new MyArrayList ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( reason . getText ( ) . length ( ) == 0 || reason . getText ( ) . length ( ) > 200 ) { Menu . playSound ( MenuSound . denied ) ; return ; } Date p ; try { p = Utils . DATE_FORMAT . parse ( expires . getText ( ) ) ; } catch ( ParseException e ) { Menu . playSound ( MenuSound . denied ) ; return ; } ban ( reason . getText ( ) , p ) ;
NearFire: private static boolean NearFire ( PlayerData playerData ) { ActiveData fire = playerData . getMap ( ) . getClosestActiveForTag ( 16 , playerData . getX ( ) , playerData . getY ( ) , ActiveData . class , Constants . ActiveTags . CAMP_FIRE , activeData -> true ) ; if ( fire == null ) return false ; ServerCampFireComponentData camp = fire . getComponent ( ServerCampFireComponentData . class ) ; if ( camp != null ) { return camp . getDuration ( ) > 30 ; } return true ;
multiply: public final void multiply ( Vector3 other ) { x *= other . x ; y *= other . y ; z *= other . z ;
testDeleteCustomDataForKey: public void testDeleteCustomDataForKey ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . productVariants ( ) . deleteCustomDataForKey ( Identifier . fromId ( 1 ) , "acme" , options ) ;
persistenceUnitPostProcessor: public PersistenceUnitPostProcessor persistenceUnitPostProcessor ( ) { return pui -> {
onLoadRound: protected void onLoadRound ( int magazine ) { BrainOutClient . ClientController . sendTCP ( new WeaponMagazineActionMsg ( getRecord ( ) , WeaponMagazineActionMsg . Action . loadOne , getSlot ( ) , magazine ) ) ; BrainOut . EventMgr . sendDelayedEvent ( getData ( ) . getOwner ( ) ,
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { steamOutVStop5ActionPerformed ( evt ) ;
getSubscriberPreferences: public SubscriberPreferenceResponse getSubscriberPreferences ( final String subscriberId ) throws IOException , NovuNetworkException { try {
onClick: public void onClick ( View v ) { mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_one ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_error ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . layout_cancel ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . layout_close ) . setVisibility ( View . GONE ) ;
create: public ProductVariantPrice create ( Identifier variantIdentifier , ProductVariantPrice model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ProductVariantPrice > responseModel = ( Class < ProductVariantPrice > ) ( Class < ? > ) ProductVariantPrice . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/variants/%s/prices" , variantIdentifier ) , query , null , responseModel , model ) ;
getRawType: public Type getRawType ( ) { return rawClass ;
onSuccessLogin: protected void onSuccessLogin ( ) { if ( ! StringUtils . isEmpty ( mPageClass ) ) { Class < ? > pageClazz = null ; try { pageClazz = Class . forName ( mPageClass ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } if ( pageClazz != null ) { if ( mClosePage ) { ActivityUtils . getInstance ( ) . finishActivity ( mPageClass ) ; } switchActivityFinish ( pageClazz , mBundle ) ; } return ; } if ( mJustCloseLoginPage ) {
installUpgrade: private void installUpgrade ( String key , Upgrade upgrade , Runnable success , Runnable failed ) { JSONObject args = new JSONObject ( ) ; args . put ( "object" , record . getId ( ) ) ; args . put ( "key" , key ) ; args . put ( "upgrade" , upgrade . getID ( ) ) ; WaitLoadingMenu loading = new WaitLoadingMenu ( "" ) ; pushMenu ( loading ) ; BrainOutClient . SocialController . sendRequest ( "freeplay_weapon_upgrade" , args ,
setAttachmentURL: public void setAttachmentURL ( String attachmentURL ) { this . attachmentURL = attachmentURL ;
getData: public FreeplayGeneratorData getData ( String dimension ) { return new FreeplayGeneratorData ( this , dimension ) ;
getOrganizationIds: public Long [ ] getOrganizationIds ( ) { return organizationIds ;
doInspect: No method body
toString: public String toString ( ) { return queue . toString ( ) ;
release: public void release ( ) { super . release ( ) ; releaseEffect ( ) ;
release: public void release ( ) { BrainOut . EventMgr . unsubscribe ( Event . ID . physicsUpdated , this ) ; super . release ( ) ; if ( light != null )
getZIndex: public int getZIndex ( ) { return 100 ;
setExtra: public void setExtra ( List < LegendEntry > entries ) { mExtraEntries = entries . toArray ( new LegendEntry [ entries . size ( ) ] ) ;
not: default boolean not ( boolean b ) { return ! b ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , FrontendMappingFieldDefinition f , BiFunction < OrganizationUser , LongIdEntity , Boolean > canReadCheck , BiFunction < OrganizationUser , LongIdEntity , Boolean > canWriteCheck ) { return new FrontendMappingFieldDefinition ( formName , f . name , f . type , canReadCheck , canWriteCheck , f . readPrivilege , f . writePrivilege , f . valueSupplier , f . datalistSupplier , true , f . fieldTypeFunction , f . datalistId , f . additionalCss , f . allowNull , f . url , f . htmlFragmentName , f . contentType , f . dtoToEntityValueConverter , f . entityToDtoValueConverter , f . actionPrivilege , f . actionUrl , f . actionLabelKey , f . sqlFormula , f . referencedEntityKey , f . nonDto , f . searchEnabled ) ;
setOnColorSelectedListener: public ColorPickerDialogBuilder setOnColorSelectedListener ( OnColorSelectedListener onColorSelectedListener ) { colorPickerView . addOnColorSelectedListener ( onColorSelectedListener ) ; return this ;
getProgress: public int getProgress ( ) { return uncommittedProgress + committedProgress ;
retryWhiteTask: No method body
write: public JSONObject write ( ) { JSONObject o = new JSONObject ( ) ; o . put ( "i" , item . getID ( ) ) ; if ( container != null ) { JSONObject w = container . write ( ) ; if ( w . length ( ) > 0 ) { o . put ( "c" , w ) ; } } return o ;
getDimension: public String getDimension ( ) { return dimension ;
deleteGitHubConfig: public Object deleteGitHubConfig ( @ PathVariable ( ORGANIZATIONID ) Long orgId ) { debug ( "[deleteGitHubConfig] OrgId: {}" , orgId ) ; integrationService . cleanOrgConfig ( _GITHUB , orgId ) ; String configUrl = services . url . moduleSettings ( INTEGRATION , null , orgId ) ; return "generic-forms::go-to(url='" + configUrl + "')" ;
getAddress: public String getAddress ( ) { return address ;
success: public void success ( JSONObject response ) { InventoryMoveSoundComponent snd = record . getItem ( ) . getContent ( ) . getComponent ( InventoryMoveSoundComponent . class ) ; if ( snd != null ) { snd . play ( playerData ) ; } market . refresh ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( marketRU == 0 ) { marketButton . setChecked ( true ) ; Menu . playSound ( MenuSound . denied ) ; return ; } Menu . playSound ( MenuSound . select ) ; max = marketRU ; refreshSlider ( ) ; arrow . setDrawable ( BrainOutClient . Skin , "icon-exchange-left" ) ; title . setText ( L . get ( "MENU_MARKET_TRANSFER_RU_FROM_MARKET" ) ) ; in = false ;
getObjectUrl: public String getObjectUrl ( @ NonNull String bucketName , @ NonNull String objectName ) { try {
saveSynced: public static void saveSynced ( Context context , Boolean value ) { putBoolean ( SETTINGS , context , SYNCED , value ) ;
searchResults: private Array < ResultObject > searchResults ( String text ) { Array < ConsumableContent > items = BrainOutClient . ContentMgr . queryContent ( ConsumableContent . class ) ; Array < ResultObject > results = new Array < > ( ) ; text = text . toLowerCase ( ) . replaceAll ( " " , "" ) . replaceAll ( "-" , "" ) ; for ( ConsumableContent item : items ) { if ( item instanceof Block || item instanceof ConsumableToOwnableContent ) continue ; if ( item . getComponent ( HideFromMarketComponent . class ) != null ) continue ; if ( item . getComponent ( AutoConvertConsumable . class ) != null ) continue ; int index = - 1 ; String title = "Noname" ; if ( item . getID ( ) != null ) { title = item . getID ( ) ; index = item . getID ( ) . toLowerCase ( ) . indexOf ( text ) ; } if ( item . getTitle ( ) != null && item . getTitle ( ) . get ( ) != null ) { title = item . getTitle ( ) . get ( ) ; int newIndex = title . toLowerCase ( ) . replaceAll ( " " , "" ) . replaceAll ( "-" , "" ) . indexOf ( text ) ; if ( index < 0 || ( newIndex >= 0 && newIndex < index ) ) index = newIndex ; } if ( index < 0 && item . getDescription ( ) != null && item . getDescription ( ) . get ( ) != null ) { index = item . getDescription ( ) . get ( ) . toLowerCase ( ) . indexOf ( text ) ; if ( index >= 0 ) index += 1000 ; } if ( index >= 0 ) { ConsumableItem consumbleItem ; if ( item instanceof Instrument ) { Instrument instrument = ( ( Instrument ) item ) ; InstrumentData instrumentData = instrument . getData ( "default" ) ; instrumentData . setSkin ( instrument . getDefaultSkin ( ) ) ; consumbleItem = new InstrumentConsumableItem ( instrumentData , "default" ) ; } else consumbleItem = item . acquireConsumableItem ( ) ; ConsumableRecord record = new ConsumableRecord ( consumbleItem , 1 , 0 ) ; MarketService . MarketItemEntry entry = MarketUtils . ConsumableRecordToMarketEntry ( record ) ; if ( entry != null ) results . add ( new ResultObject ( index , entry , item . getID ( ) , title ) ) ; } } return results ;
allAttributes: public ApiCollection < Attribute > allAttributes ( Identifier productIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Attribute > responseModel = ( Class < Attribute > ) ( Class < ? > ) Attribute . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/products/%s/attributes" , productIdentifier ) , query , null , responseModel ) ;
reset: public void reset ( ) { Global . reset ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesStop12ActionPerformed ( evt ) ;
downLoadPath: public static String downLoadPath ( Context context ) { return StorageUtils . SDCardPath ( ) + File . separator + context . getPackageName ( ) ;
fromString: public static Operator fromString ( String text ) { for ( Operator operator : Operator . values ( ) ) { if ( operator . label . equalsIgnoreCase ( text ) ) { return operator ; } } return null ;
mailSender: JavaMailSenderImpl mailSender ( MailProperties properties ) { EmailConfigJavaMailSender sender = new EmailConfigJavaMailSender ( ) ; applyProperties ( properties , sender ) ; return sender ;
prepareAdditionalForms: private List < Tuple5 < ProfileSettingsRepository , Function , PageAttr , String , String > > prepareAdditionalForms ( ResultAndModel a , Long userId ) { for ( Tuple4 < ProfileSettingsRepository , Function , PageAttr , String > t : customisationService . additionalSettingsForms ) { Object entity = t . getT1 ( ) . findOneForUserId ( userId ) ; Object form = t . getT2 ( ) . apply ( entity ) ; a . model . put ( t . getT3 ( ) , form ) ; } return customisationService . additionalSettingsForms ;
hideBgPage: protected void hideBgPage ( ) { isShowBgView = false ; webView . setVisibility ( View . VISIBLE ) ; LinearLayout webParentView = ( LinearLayout ) webView . getParent ( ) ; while ( webParentView . getChildCount ( ) > 1 ) {
createSubscriber: public CreateSubscriberResponse createSubscriber ( final SubscriberRequest request ) throws IOException , NovuNetworkException { try {
stop: public void stop ( ) { server . stop ( 0 ) ;
setEmbeddable: public void setEmbeddable ( boolean embeddable ) { this . embeddable = embeddable ;
countPlayersAlive: private int countPlayersAlive ( ) { return playersAlive . size ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoWaterLevel1OnItemStateChanged ( evt ) ;
getChambered: public int getChambered ( ) { if ( weaponProperties . isUnlimited ( ) ) return weaponProperties . getChambers ( ) ; return chambered ;
obtain: public static Event obtain ( String messageId ) { SocialMessageDeletedEvent e = obtain ( SocialMessageDeletedEvent . class ) ; if ( e == null ) return null ; return e . init ( messageId ) ;
getModuleView: default String getModuleView ( String viewName ) { return String . format ( "module/%s/%s" , getName ( ) , viewName ) ;
getPremiumItems: public final List < MGRecyclerDataPayload > getPremiumItems ( ) { return this . premiumItems ;
getChanInfo: public Single < lnrpc . LightningOuterClass . ChannelEdge > getChanInfo ( lnrpc . LightningOuterClass . ChanInfoRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . getChanInfo ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
populateToEntity: final public E populateToEntity ( E entity ) { prepareFieldsReadWritePrivileges ( entity ) ; return populateTo ( entity ) ;
drawHighlightLines: protected void drawHighlightLines ( Canvas c , float x , float y , ILineScatterCandleRadarDataSet set ) { mHighlightPaint . setColor ( set . getHighLightColor ( ) ) ; mHighlightPaint . setStrokeWidth ( set . getHighlightLineWidth ( ) ) ; mHighlightPaint . setPathEffect ( set . getDashPathEffectHighlight ( ) ) ; if ( set . isVerticalHighlightIndicatorEnabled ( ) ) { mHighlightLinePath . reset ( ) ; mHighlightLinePath . moveTo ( x , mViewPortHandler . contentTop ( ) ) ; mHighlightLinePath . lineTo ( x , mViewPortHandler . contentBottom ( ) ) ; c . drawPath ( mHighlightLinePath , mHighlightPaint ) ; } if ( set . isHorizontalHighlightIndicatorEnabled ( ) ) {
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { waterInVStop1ItemStateChanged ( evt ) ;
sendMany: public Single < lnrpc . LightningOuterClass . SendManyResponse > sendMany ( lnrpc . LightningOuterClass . SendManyRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . sendMany ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
calculateSound: protected void calculateSound ( ) { ClientMap map = ( ( ClientMap ) getMap ( ) ) ; if ( map == null ) return ; this . pan = 0 ; this . volume = 1 ; Watcher watcher = Map . GetWatcher ( ) ; if ( watcher != null && watcher . getDimension ( ) . equals ( getDimension ( ) ) )
getType: public String getType ( ) { return type ;
setColorPicker: public void setColorPicker ( ColorPickerView colorPicker ) { this . colorPicker = colorPicker ;
matches: public int matches ( ItemData itemData , ConsumableRecord record ) { if ( record . getItem ( ) . getContent ( ) . hasComponent ( CampFireStarterComponent . class ) ) { return 1 ; } return 0 ;
getUsers: public static StoreUser getUsers ( ) { return new StoreUser ( ) ; }
cancelled: No method body
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
success: public void success ( JSONObject response ) { waitLoadingMenu . pop ( ) ; pop ( ) ; reactivated . run ( ) ;
C: public void C ( ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " C()" ) ;
getHistoryFor: public HistoryRecord getHistoryFor ( PlayerClient client ) { if ( client . getAccount ( ) == null ) return null ; return history . get ( client . getAccount ( ) ) ;
free: private void free ( ) { if ( generated )
getId: public long getId ( ) { return id ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem1ActionPerformed ( evt ) ;
create: public Redirect create ( String shopKey , Redirect model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Redirect > responseModel = ( Class < Redirect > ) ( Class < ? > ) Redirect . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/shops/%s/redirects" , shopKey ) , query , null , responseModel , model ) ;
blockOnSyscall: static < T > T blockOnSyscall ( Consumer < SyscallCallback < T > > syscallExecutor ) { CompletableFuture < T > fut = new CompletableFuture < > ( ) ; syscallExecutor . accept ( SyscallCallback . completingFuture ( fut ) ) ; return Util . awaitCompletableFuture ( fut ) ;
readJsonEntry: public JsonValue readJsonEntry ( String name ) { InputStream entryStream = readStreamEntry ( name ) ; if ( entryStream == null ) { return null ; } return new JsonReader ( ) . parse ( entryStream ) ;
getFile: public PackageFileHandle getFile ( String fileName ) { return new ZipPackageFileHandle ( fileName ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { start1AActionPerformed ( evt ) ;
getTableView: public String getTableView ( ) { return tableView ;
getFlags: public int getFlags ( ) { return 0 ;
setFiles: public void setFiles ( List < File > files ) { this . files = files ;
getCenterCircleBox: public MPPointF getCenterCircleBox ( ) { return MPPointF . getInstance ( mCircleBox . centerX ( ) , mCircleBox . centerY ( ) ) ;
refresh: public void refresh ( ) { final float oldScrollY = getScrollPane ( ) . getScrollY ( ) ; BrainOutClient . getInstance ( ) . postRunnable ( ( ) ->
test_deleteMessage: public void test_deleteMessage ( ) throws IOException , NovuNetworkException , InterruptedException { DeleteMessageResponse deleteMessageResponse = new DeleteMessageResponse ( ) ; deleteMessageResponse . setAcknowledged ( true ) ; deleteMessageResponse . setStatus ( "done" ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( deleteMessageResponse ) ) ) ; DeleteMessageResponse response = messageHandler . deleteMessage ( "id" ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/messages/id" , request . getPath ( ) ) ; assertEquals ( "DELETE" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( deleteMessageResponse ) , gson . toJson ( response ) ) ;
newDragAndDropInventory: protected DragAndDropInventory newDragAndDropInventory ( ) { return new DragAndDropInventory ( pane , this :: updateBackgroundPanel ) ;
convertAndSave: public Form convertAndSave ( FormConversionDto dto , String filePath , Map < String , String > resources ) { debug ( "[convertAndSave]" ) ; Form form = getForm ( dto , resources . get ( dto . getCode ( ) ) ) ; services . dynamicEntity . createDynamicTableIfNotExists ( form . getTableName ( ) ) ; form = repositories . secure . form . saveOne ( form ) ; return form ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case itemAction : { ItemActionEvent ev = ( ( ItemActionEvent ) event ) ; action ( ev . action ) ; break ; } } return false ;
GetMaxMarketWeightForPlayer: public static float GetMaxMarketWeightForPlayer ( Active marketContainer , UserProfile userProfile , String category ) { float maxWeight = 0 ; switch ( category ) { case "default" : { if ( marketContainer != null ) { MaxWeightComponent mx = marketContainer . getComponent ( MaxWeightComponent . class ) ; if ( mx != null ) { maxWeight += mx . getMaxWeight ( ) ; } } break ; } case "rs" : { maxWeight += 500 ; break ; } } int addWeight = 0 ; if ( userProfile != null ) { OrderedMap < ExtendedStorage , Integer > extStorages = userProfile . getItemsOf ( ExtendedStorage . class ) ; for ( ExtendedStorage extStorage : extStorages . keys ( ) ) { if ( ! category . equals ( extStorage . getCategory ( ) ) ) continue ; if ( addWeight < extStorage . getExtraWeight ( ) ) addWeight = extStorage . getExtraWeight ( ) ; } } maxWeight += addWeight ; return maxWeight ;
beforeAll: static void beforeAll ( ) throws IOException , URISyntaxException { tempIndexPath = Files . createTempDirectory ( "lucene" ) ; final Chain < Path , Directory > createLuceneIndexChain = new ReadDocumentsFromPdfChain ( ) . chain ( new SplitDocumentsChain ( new JtokkitTextSplitter ( Encodings . newDefaultEncodingRegistry ( ) . getEncoding ( EncodingType . CL100K_BASE ) , 1000 ) ) ) . chain ( new WriteDocumentsToLuceneDirectoryChain ( tempIndexPath ) ) ; final Path pdfDirectoryPath = Paths . get ( RetrievalQaTest . class . getResource ( "/pdf/qa" ) . toURI ( ) ) ; directory = createLuceneIndexChain . run ( pdfDirectoryPath ) ;
promotionV1s: public PromotionV1Service promotionV1s ( ) { PromotionV1Service service = this . getService ( "com.scayle.adminapi.service.PromotionV1Service" ) ; return service ;
close: protected void close ( ) { onTop = false ; pop ( ) ;
sync: public void sync ( ) { updated ( ( ( PlayerData ) getComponentObject ( ) ) , this ) ;
toAuditString: public String toAuditString ( ) { return null ;
resolveAwakeable: public void resolveAwakeable ( String serializedId , ByteBuffer payload , SyscallCallback < Void > callback ) { wrapAndPropagateExceptions (
getReturnAddress: public MerchantReturnAddress getReturnAddress ( Identifier merchantIdentifier , Integer merchantReturnAddressId , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < MerchantReturnAddress > responseModel = ( Class < MerchantReturnAddress > ) ( Class < ? > ) MerchantReturnAddress . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/merchants/%s/return-addresses/%s" , merchantIdentifier , merchantReturnAddressId ) , query , null , responseModel ) ;
readNumber: public Number readNumber ( JsonReader in ) throws IOException , JsonParseException { String value = in . nextString ( ) ; try {
has: public < T > boolean has ( PageAttr < T > key ) { return super . containsKey ( key . name ) ;
post: No method body
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { stop2AItemStateChanged ( evt ) ;
getVertexEffect: public @ Null VertexEffect getVertexEffect ( ) { return vertexEffect ;
createUI: public Table createUI ( ) { Table data = super . createUI ( ) ; Label title = new Label ( L . get ( "MENU_CHOOSE_ACCOUNT_TITLE" ) , BrainOutClient . Skin , "title-yellow" ) ; title . setAlignment ( Align . center ) ; data . add ( title ) . pad ( 16 ) . expandX ( ) . row ( ) ; Label description = new Label ( L . get ( "MENU_CHOOSE_ACCOUNT_DESC" ) , BrainOutClient . Skin , "title-small" ) ; description . setAlignment ( Align . center ) ; data . add ( description ) . pad ( 16 ) . expandX ( ) . row ( ) ; Table accountsData = new Table ( ) ; for ( CSMultipleAccounts . Profile profile : accounts . getProfiles ( ) ) { renderAccount ( profile , accountsData ) ; } data . add ( accountsData ) . row ( ) ; return data ;
getRolesInfo: public Collection < ? > getRolesInfo ( ) { return Arrays . asList ( globalRoles , organizationRoles ) ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { return rights == PlayerRights . admin ;
getStretch: public boolean getStretch ( ) { return stretch ;
getFieldTooltip: public String getFieldTooltip ( String code , String fieldName ) { String result = accessor . getMessage ( code , NO_MESSAGE ) ; if ( NO_MESSAGE . equals ( result ) ) { result = StringUtils . EMPTY ; } return result ;
isFastMobileNetwork: private static boolean isFastMobileNetwork ( Context context ) { TelephonyManager telephonyManager = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; if ( telephonyManager == null ) { return false ; } switch ( telephonyManager . getNetworkType ( ) ) {
saveMacaroonString: public static void saveMacaroonString ( Context context , String value ) { putString ( SETTINGS , context , MACAROON_STRING , value ) ;
write: public void write ( Json json , Data . ComponentWriter componentWriter , int owner ) { super . write ( json , componentWriter , owner ) ; if ( mode != null )
yes: public void yes ( ) { leaveConflict ( ) ;
setManualCameraId: public synchronized void setManualCameraId ( int cameraId ) { requestedCameraId = cameraId ;
setRightVisibility: public void setRightVisibility ( int visibility ) { setVisibility ( R . id . rl_right , visibility ) ;
getFlipX: public boolean getFlipX ( ) { return false ;
setBeanReloader: public void setBeanReloader ( BeanReloader < ? > beanReloader ) { this . beanReloader = beanReloader ;
getForUser: public static String getForUser ( User user ) { return null ;
getContent: public ConsumableContent getContent ( ) { return armor ;
setSellerCompanyAddressLine1: public void setSellerCompanyAddressLine1 ( String sellerCompanyAddressLine1 ) { this . sellerCompanyAddressLine1 = sellerCompanyAddressLine1 ;
getCount: public int getCount ( ) { if ( mData == null ) { return 0 ; } if ( mData . size ( ) > 1 ) { return Integer . MAX_VALUE ; } return mData . size ( ) ;
bytes: public static StateKey < byte [ ] > bytes ( String name ) { return new StateKey < > ( name , Serde . RAW ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; for ( JsonValue value : jsonData . get ( "sounds" ) ) { fileNames . add ( value . asString ( ) ) ; } loop = jsonData . getBoolean ( "loop" , false ) ; soundDistance = jsonData . getFloat ( "distance" , 1.0f ) ; minimumDistance = jsonData . getFloat ( "minimumDistance" , 0f ) ; if ( jsonData . has ( "pitch" ) ) { if ( jsonData . get ( "pitch" ) . isNumber ( ) ) { float f = jsonData . getFloat ( "pitch" ) ; this . pitch = new RandomValue ( f , f ) ; } else { this . pitch = new RandomValue ( 1.0f , 1.0f ) ; pitch . read ( json , jsonData . get ( "pitch" ) ) ; } } distantDelay = jsonData . getBoolean ( "distantDelay" , false ) ;
getHeadersMap: public Map < String , String > getHeadersMap ( ) { if ( headersMap == null ) { headersMap = JsonHelper . from ( StringUtils . defaultString ( headersJson , "{}" ) , Map . class ) ; } return headersMap ;
testRun: void testRun ( ) throws IOException { try ( final RestClient restClient = restClientBuilder . build ( ) ;
getFlipX: public boolean getFlipX ( ) { return false ;
renderShape: No method body
received: public boolean received ( Object from , ModeMessage modeMessage ) { this . messageClient = ( ( PlayerClient ) from ) ; return receiver . received ( modeMessage , this ) ;
isServer: public boolean isServer ( ) { return false ;
presencePenalty: public OpenAiChatCompletionsParameters presencePenalty ( final Double presencePenalty ) { this . setPresencePenalty ( presencePenalty ) ; return this ;
timedOut: public boolean timedOut ( PlayStateEndGame . GameResult gameResult ) { OrderedMap < Team , Integer > points = new OrderedMap < > ( ) ; for ( Team team : BrainOutServer . Controller . getTeams ( ) ) { points . put ( team , getGameMode ( ) . getPoints ( team ) ) ; } if ( points . size == 2 && Objects . equals ( points . get ( points . orderedKeys ( ) . get ( 0 ) , 0 ) , points . get ( points . orderedKeys ( ) . get ( 1 ) , 0 ) ) ) { return timedOutDraw ( gameResult ) ; } points . orderedKeys ( ) . sort ( ( o1 , o2 ) -> points . get ( o2 , 0 ) - points . get ( o1 , 0 ) ) ; gameResult . setTeamWon ( points . orderedKeys ( ) . get ( 0 ) ) ; return true ;
obtain: public static Event obtain ( int x , int y , int layer , Map map ) { SetDirtyEvent e = obtain ( SetDirtyEvent . class ) ; if ( e == null ) return null ; return e . init ( x , y , layer ) ;
getFollowTarget: public ActiveData getFollowTarget ( ) { return followTarget ;
getInterpolation: public float getInterpolation ( float input ) { return - 0.5f * ( ( float ) Math . cos ( Math . PI * input ) - 1f ) ;
setOrganizationId: public void setOrganizationId ( String organizationId ) { this . organizationId = organizationId ;
sendRemotePlayers: public void sendRemotePlayers ( final Client sendWho ) { BrainOutServer . PostRunnable ( ( ) ->
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case instrumentActivate : { ActivateInstrumentEvent activate = ( ( ActivateInstrumentEvent ) event ) ; activate ( activate . record ) ; return true ; } } return false ;
received: public boolean received ( final TeamLandingMsg msg ) { Gdx . app . postRunnable ( ( ) -> { RemoteClient friend = BrainOutClient . ClientController . getRemoteClients ( ) . get ( msg . clientId ) ; if ( friend == null ) return ; int teamLandingTimer = ( int ) ( msg . time / 1000 - BrainOutClient . ClientController . getServerTime ( ) + Constants . Other . TEAM_LANDING_TIMER ) ; BrainOutClient . EventMgr . sendDelayedEvent ( OnScreenMessagesEvent . obtain ( "You have %d seconds to spawn near your teammate " + friend . getName ( ) , teamLandingTimer , false , Align . top , "title-yellow" , Constants . Other . TEAM_LANDING_ACTION_NAME , true ) ) ; } ) ; return true ;
Get: public static < T extends Map > T Get ( String dimension , Class < T > tClass ) { if ( dimension == null ) return null ; return ( T ) Dimensions . get ( dimension ) ;
sendUDPExcept: public void sendUDPExcept ( UdpMessage object , int except , Matching matching ) { for ( ObjectMap . Entry < Integer , Client > entry : this )
moveViewTo: public void moveViewTo ( float xValue , float yValue , AxisDependency axis ) { float yInView = getAxisRange ( axis ) / mViewPortHandler . getScaleY ( ) ; Runnable job = MoveViewJob . getInstance ( mViewPortHandler , xValue , yValue + yInView / 2f , getTransformer ( axis ) , this ) ; addViewportJob ( job ) ;
toString: public String toString ( ) { return "Highlight, x: " + mX + ", y: " + mY + ", dataSetIndex: " + mDataSetIndex
getTasks: public Queue < Task > getTasks ( ) { return tasks ;
recycleInstance: public static void recycleInstance ( AnimatedMoveViewJob instance ) { pool . recycle ( instance ) ;
getContentView: protected int getContentView ( ) { return R . layout . activity_unlock ;
render: public void render ( Batch batch , RenderContext context ) { super . render ( batch , context ) ; ui . setPosition ( activeData . getX ( ) - ui . getWidth ( ) / ( 2.0f / SCALE ) , activeData . getY ( ) + 6f ) ; ui . draw ( batch , 1 ) ;
update: public ProductVariant update ( Identifier productIdentifier , Identifier variantIdentifier , ProductVariant model ) throws ApiErrorException , ConnectionException { Class < ProductVariant > responseModel = ( Class < ProductVariant > ) ( Class < ? > ) ProductVariant . class ; return this . request ( "put" , this . resolvePath ( "/products/%s/variants/%s" , productIdentifier , variantIdentifier ) , null , null , responseModel , model ) ;
getSteamDensity: public double getSteamDensity ( ) { return 0 ;
lockInput: public boolean lockInput ( ) { return true ;
stop: protected void stop ( ) { if ( soundId != - 1 )
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
init: public void init ( ) { ( ( ClientMap ) getMap ( ) ) . setLightsEnabled ( false ) ; camera = new OrthographicCamera ( BrainOutClient . getWidth ( ) , BrainOutClient . getHeight ( ) ) ; camera . position . x = BrainOutClient . getWidth ( ) / 2 ; camera . position . y = BrainOutClient . getHeight ( ) / 2 ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; musicList = jsonData . getString ( "music-list" ) ; parallax = jsonData . getString ( "parallax" ) ;
hasCache: public boolean hasCache ( ) { return true ;
init: public void init ( ) { autobalance . init ( ) ;
canSeePlayerList: public boolean canSeePlayerList ( ) { return true ;
removeScheduledUnsuccessful: public void removeScheduledUnsuccessful ( ) { mockAndAuthenticateUser ( 1l , "test@openkoda.com" , "TEST" , "(canManageBackend)" ) ; Scheduler scheduler = new Scheduler ( SCHEDULER_CRON_EXPRESSION , SCHEDULER_EVENT_DATA , false ) ; long schedulerId = 1L ; scheduler . setId ( schedulerId ) ; ScheduledFuture scheduledFuture = mock ( ScheduledFuture . class ) ; when ( taskScheduler . schedule ( any ( SchedulerService . SchedulerTask . class ) , any ( CronTrigger . class ) ) ) . thenReturn ( scheduledFuture ) ; schedulerService . schedule ( scheduler ) ; when ( scheduledFuture . cancel ( anyBoolean ( ) ) ) . thenReturn ( false ) ; boolean result = schedulerService . remove ( schedulerId ) ; assertFalse ( result ) ;
addTask: public void addTask ( Task task ) { tasks . add ( task ) ; if ( task . getProject ( ) != this ) {
getStaticData3: public String getStaticData3 ( ) { return staticData3 ;
setWeekOfYear: public void setWeekOfYear ( Integer weekOfYear ) { this . weekOfYear = weekOfYear ;
newAccount: public Account newAccount ( ) { return new AnonymousAccount ( generate ( 24 ) , generate ( 32 ) , "" ) ;
testChainedRun: void testChainedRun ( ) { final OpenAiChatCompletionsParameters parameters = new OpenAiChatCompletionsParameters ( ) ; final Chain < Map < String , String > , String > chain = new AzureOpenAiChatCompletionsChain ( "my-azure-resource-name" , "gpt-35-turbo" , "2023-05-15" , "Hello, this is ${name}. What was my name again?" , parameters , System . getenv ( "AZURE_OPENAI_API_KEY" ) ) . chain ( prev -> Collections . singletonMap ( "result" , prev ) ) . chain ( new AzureOpenAiChatCompletionsChain ( "my-azure-resource-name" , "gpt-35-turbo" , "2023-05-15" , "What was the question for the following answer: ${result}" , parameters , System . getenv ( "AZURE_OPENAI_API_KEY" ) ) ) ; final String result = chain . run ( Collections . singletonMap ( "name" , "Manuel" ) ) ; LOGGER . info ( result ) ; assertNotNull ( result , "got no result from chain" ) ;
getOrganizationId: public Long getOrganizationId ( ) { return organizationId ;
getInstance: public static AssetsDB getInstance ( Context context ) { if ( mInstance == null ) { synchronized ( AssetsDB . class ) { if ( mInstance == null ) { mInstance = new AssetsDB ( context , "asset_db" , null , 1 ) ; } } } return mInstance ;
getRecoveryInfo: No method body
update: public void update ( float dt ) { speed . y -= mass * Constants . Core . GRAVITY * dt ; addPosition ( speed . x * dt , speed . y * dt ) ;
setCategory: public void setCategory ( String category ) { this . category = category ;
getPrefs: public static SharedPreferences getPrefs ( ) { return PreferenceManager . getDefaultSharedPreferences ( AppApplication . getAppContext ( ) ) ;
randomInsideSideEffect: No method body
updateWorkflowGroup: No method body
getCustomData: public Map < String , Object > getCustomData ( String shopKey , Integer shopCategoryId , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/categories/%s/custom-data" , shopKey , shopCategoryId ) , query , null , responseModel ) ;
list: void list ( ) throws Exception { assertNotNull ( menuPageListParam , "menuPageListParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/menu/list" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( menuPageListParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "菜单列表接口（分页）接口测试成功:{}" , map . get ( "data" ) ) ;
isEMUI: public static boolean isEMUI ( ) { try {
hasPermission: public boolean hasPermission ( String action ) { return isOwner ( ) || permissions . contains ( action ) ;
onHandleDecode: No method body
nextRespawnIn: public void nextRespawnIn ( float time ) { sendTCP ( new RespawnTimeMsg ( time ) ) ;
campaigns: public CampaignService campaigns ( ) { CampaignService service = this . getService ( "com.scayle.adminapi.service.CampaignService" ) ; return service ;
calculateDistance: protected void calculateDistance ( float v ) { volume = Math . max ( 0 , Math . min ( 1 , - ( float ) Math . log10 ( v ) / 2 ) ) ; volume *= BrainOutClient . ClientSett . getSoundVolume ( ) . getFloatValue ( ) ;
onLoginFail: public void onLoginFail ( Context context , String code , String msg ) { onFailLogin ( code , msg ) ;
polymod: private static int polymod ( byte [ ] values ) { final int [ ] GENERATORS = { 0x3b6a57b2 , 0x26508e6d , 0x1ea119fa , 0x3d4233dd , 0x2a1462b3 } ; int chk = 1 ; for ( byte b : values ) { byte top = ( byte ) ( chk > > 0x19 ) ; chk = b ^ ( ( chk & 0x1ffffff ) << 5 ) ; for ( int i = 0 ; i < 5 ; i ++ ) { chk ^= ( ( top > > i ) & 1 ) == 1 ? GENERATORS [ i ] : 0 ; } } return chk ;
getInfo: public Single < watchtowerrpc . WatchtowerOuterClass . GetInfoResponse > getInfo ( watchtowerrpc . WatchtowerOuterClass . GetInfoRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . getInfo ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
unregisterCRUDController: public void unregisterCRUDController ( String key ) { this . remove ( key ) ;
onClick: public void onClick ( View v ) { mSelectChannelBalancePopupWindow = new SelectChannelBalancePopupWindow ( mContext ) ; mSelectChannelBalancePopupWindow . setOnItemClickCallback ( new SelectChannelBalancePopupWindow . ItemCleckListener ( ) { @ Override public void onItemClick ( View view , ListAssetItemEntity item ) { if ( item . getPropertyid ( ) == 0 ) { assetTypeIv . setImageResource ( R . mipmap . icon_btc_logo_small ) ; assetTypeTv . setText ( "BTC" ) ; amountUnitTv . setText ( "BTC" ) ; amountEdit . setText ( "0" ) ; } else { assetTypeIv . setImageResource ( R . mipmap . icon_usdt_logo_small ) ; assetTypeTv . setText ( "dollar" ) ; amountUnitTv . setText ( "dollar" ) ; amountEdit . setText ( "0" ) ; } mAssetId = item . getPropertyid ( ) ; getChannelBalance ( mAssetId ) ; } } ) ; mSelectChannelBalancePopupWindow . show ( v ) ;
updateRole: public AjaxResult updateRole ( @ RequestBody @ Valid UpdateRoleByUserParam param ) { userService . updateRole ( param . getUserId ( ) , param . getRoleIds ( ) ) ; return AjaxResult . success ( "更新用户角色成功！" ) ;
getLabel: public String getLabel ( ) { return label ;
getFlipX: public boolean getFlipX ( ) { return false ;
onPull: public void onPull ( int currentDragHeight , int refreshViewHeight , int currentRefreshStatus ) { if ( currentDragHeight > 0 ) { mLoadText . setVisibility ( View . GONE ) ; mLoadIcon . setVisibility ( View . VISIBLE ) ; } float rotate = ( ( float ) currentDragHeight ) / refreshViewHeight ; mLoadIcon . setRotation ( rotate * 360 ) ;
sendMessage: No method body
isSystemUser: public boolean isSystemUser ( ) { return false ;
addParams: public HttpUtils addParams ( Map < String , Object > values ) { if ( values != null ) { mParams . putAll ( values ) ; } return this ;
interruptThread: public static boolean interruptThread ( long threadId ) { Optional < Thread > t = serverJsThreads . keySet ( ) . stream ( ) . filter ( a -> a . getId ( ) == threadId ) . findFirst ( ) ; if ( t . isPresent ( ) ) { t . get ( ) . interrupt ( ) ; } return true ;
publicWebSecurityFilterChain: public SecurityFilterChain publicWebSecurityFilterChain ( HttpSecurity http ) throws Exception { return publicWebHttpSecurity ( http ) . build ( ) ;
render: public void render ( Batch batch , RenderContext context ) { Component it = fistComponent ; while ( it != null )
toFileDto: public FileDto toFileDto ( ) { return toFileDto ( this ) ;
getAvatar: public String getAvatar ( ) { return null ;
saveAll: No method body
scanPackageClass: public static Set < Class < ? > > scanPackageClass ( String basePackage , List < TypeFilter > includeFileters , List < TypeFilter > excludeFilters ) { ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver ( ) ; MetadataReaderFactory metadataReaderFactory = new CachingMetadataReaderFactory ( resourcePatternResolver ) ; Set < Class < ? > > result = new HashSet < > ( 128 ) ; try { String base = SystemPropertyUtils . resolvePlaceholders ( basePackage ) ; String searchPath = CLASSPATH_ALL_URL_PREFIX + convertClassNameToResourcePath ( base ) + "*.class" ; Resource [ ] resources = resourcePatternResolver . getResources ( searchPath ) ; for ( Resource resource : resources ) { if ( resource . isReadable ( ) ) { MetadataReader metadataReader = metadataReaderFactory . getMetadataReader ( resource ) ; boolean flag = false ; if ( includeFileters != null && ! includeFileters . isEmpty ( ) ) { for ( TypeFilter filter : includeFileters ) { if ( filter . match ( metadataReader , metadataReaderFactory ) ) { flag = true ; break ; } } } if ( excludeFilters != null && ! excludeFilters . isEmpty ( ) ) { for ( TypeFilter filter : excludeFilters ) { if ( filter . match ( metadataReader , metadataReaderFactory ) ) { flag = false ; break ; } } } if ( flag ) { result . add ( Class . forName ( metadataReader . getClassMetadata ( ) . getClassName ( ) ) ) ; } } } } catch ( IOException | ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } return result ;
selectPrevSpawn: private void selectPrevSpawn ( ) { TextButton checked = spawnButtons . getChecked ( ) ; if ( checked != null )
getClassNameFromClass: public static String getClassNameFromClass ( File classFile ) throws IOException { ClassReader classReader = new ClassReader ( Files . newInputStream ( classFile . toPath ( ) ) ) ; return classReader . getClassName ( ) . replace ( SLASH , DOT ) ;
getData: public Object getData ( ) { return data ;
setOnDismissListener: public SafeDialogBuilder setOnDismissListener ( DialogInterface . OnDismissListener onDismissListener ) { super . setOnDismissListener ( onDismissListener ) ; return this ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; DuelCompleteMenu . this . exit ( ) ;
success: public void success ( ) { connected ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem5ActionPerformed ( evt ) ;
get: public Long get ( SharedObjectContext ctx ) { return ctx . get ( TOTAL ) . orElse ( 0L ) ;
saveWalletAddressToLocal: public static void saveWalletAddressToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_WALLET_ADDRESS , value ) ;
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; HandlerSpecification < ? , ? > that = ( HandlerSpecification < ? , ? > ) o ; return Objects . equals ( name , that . name )
ok: public void ok ( ) { BrainOutClient . Env . gameCompleted ( ) ; BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ;
setMwidth: public void setMwidth ( int mwidth ) { this . mwidth = mwidth ;
getGlobalSearchableRepositoryAnnotation: public static SearchableRepositoryMetadata getGlobalSearchableRepositoryAnnotation ( ScopedSecureRepository r ) { return r . getSearchableRepositoryMetadata ( ) ;
removeUpdateItem: public void removeUpdateItem ( T item ) { if ( updateList != null )
notifyInsertItem: public void notifyInsertItem ( int position ) { notifyItemInserted ( position ) ; if ( position != mData . size ( ) ) {
testDetachCarrier: public void testDetachCarrier ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . merchants ( ) . detachCarrier ( Identifier . fromId ( 1 ) , Identifier . fromId ( 1 ) , "acme" , options ) ;
loadUserByUsername: void loadUserByUsername ( ) throws JsonProcessingException { String username = "admin" ; UserDto userDto = userService . loadUserByUsername ( username ) ; assertNotNull ( userDto , "根据用户名查询用户信息失败！" ) ; LOGGER . info ( "用户信息:{}" , objectMapper . writeValueAsString ( userDto ) ) ;
readTask: protected void readTask ( JsonValue jsonData ) { if ( jsonData . has ( "item" ) )
obtain: public static Event obtain ( Action action , String string ) { GameControllerEvent e = obtain ( GameControllerEvent . class ) ; if ( e == null ) return null ; return e . init ( action , string ) ;
getTimeAfter: public float getTimeAfter ( ) { return timeAfter ;
getObjectMap: public ObjectMap < String , String > getObjectMap ( ) { return objectMap ;
initBackground: protected void initBackground ( ) { loading = new Table ( ) ; add ( loading ) . expandX ( ) . fillX ( ) . row ( ) ; super . initBackground ( ) ;
setDate: public void setDate ( long date ) { this . date = date ;
getCurrency: public String getCurrency ( ) { return currency ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ;
getColor: public Color getColor ( ) { return color ;
getEventData: public String getEventData ( ) { return eventData ;
setDrawFilled: public void setDrawFilled ( boolean filled ) { mDrawFilled = filled ;
newOrderResult: private void newOrderResult ( boolean success , String reason ) { GameState gs = getGameState ( ) ; pop ( ) ; if ( ! success )
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
setSkeleton: public void setSkeleton ( Skeleton skeleton ) { this . skeleton = skeleton ;
getID: public ID getID ( ) { return ID . foxhunt ;
draw: public void draw ( Batch batch , float parentAlpha ) { int blendSrc = batch . getBlendSrcFunc ( ) , blendDst = batch . getBlendDstFunc ( ) ; int blendSrcAlpha = batch . getBlendSrcFuncAlpha ( ) , blendDstAlpha = batch . getBlendDstFuncAlpha ( ) ; Color color = skeleton . getColor ( ) ; float oldAlpha = color . a ; skeleton . getColor ( ) . a *= parentAlpha ; skeleton . setPosition ( getX ( ) , getY ( ) ) ; skeleton . updateWorldTransform ( ) ; renderer . draw ( batch , skeleton ) ; if ( resetBlendFunction ) batch . setBlendFunctionSeparate ( blendSrc , blendDst , blendSrcAlpha , blendDstAlpha ) ; color . a = oldAlpha ;
isEnabled: public boolean isEnabled ( ) { return enabled ;
getTenantedResourceWhenEntityKey: public void getTenantedResourceWhenEntityKey ( ) { Mockito . when ( request . getServletPath ( ) ) . thenReturn ( "/html/shoe/123/action" ) ; Mockito . when ( request . getRequestURI ( ) ) . thenReturn ( "/html/shoe/123/action" ) ; TenantResolver . TenantedResource t = urlHelper . getTenantedResource ( request ) ; Assertions . assertNull ( t . organizationId ) ; assertEquals ( "shoe" , t . entityKey ) ;
canChildScrollUp: public boolean canChildScrollUp ( ) { if ( android . os . Build . VERSION . SDK_INT < 14 ) {
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; this . effect = jsonData . getString ( "effect" , null ) ; this . animation = jsonData . getString ( "animation" , null ) ;
findAll: No method body
test_getWorkflows: public void test_getWorkflows ( ) throws IOException , NovuNetworkException , InterruptedException { BulkWorkflowResponse workflowResponse = new BulkWorkflowResponse ( ) ; workflowResponse . setPage ( 2L ) ; workflowResponse . setPageSize ( 20L ) ; workflowResponse . setTotalCount ( 200L ) ; workflowResponse . setData ( Collections . singletonList ( new WorkflowResponse ( ) ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( workflowResponse ) ) ) ; BulkWorkflowResponse response = workflowHandler . getWorkflows ( 12 , 13 ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/workflows?limit=13&page=12" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertNotNull ( response ) ; assertEquals ( gson . toJson ( workflowResponse ) , gson . toJson ( response ) ) ;
getTitle: void getTitle ( ) { assertEquals ( "Soffocare" , book . getTitle ( ) ) ;
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "exitTime" , exitTime ) ; json . writeValue ( "location" , location ) ;
t5: public Tuple5 t5 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
getColorCircleList: public List < ColorCircle > getColorCircleList ( ) { return colorCircleList ;
getSpanSize: public int getSpanSize ( int position ) { boolean isHeaderOrFooter = isHeaderPosition ( position ) || isFooterPosition ( position ) ; return isHeaderOrFooter ? layoutManager . getSpanCount ( ) : lookup . getSpanSize ( position ) ;
getDimension: public String getDimension ( ) { return playerData . getDimension ( ) ;
getWeight: public float getWeight ( ) { return weight ;
validate: public IntegrationJiraForm validate ( BindingResult br ) { return this ;
syncGet: No method body
getBytes: public byte [ ] getBytes ( ) throws IOException { return this . content ;
renderBottomToolbar: private void renderBottomToolbar ( Table toolbar ) { { toolbar . add ( modePanel ) . expandX ( ) . center ( ) ; } {
clickStart: public void clickStart ( ) { Log . d ( TAG , "click start" ) ; Log . d ( TAG , "clickStart: " + initWalletType ) ; if ( newCreatedAddress . isEmpty ( ) ) {
invert: public void invert ( ) { this . remove ( chartPanel ) ; plot = new DialPlot ( data ) ; plot . setDialFrame ( frame ) ; scale = new StandardDialScale ( 0 , 7.3 , - 90 , 290 , 1 , 10 ) ; scale . setTickLabelFormatter ( decimalFormat ) ; scale . setTickLabelFont ( font ) ; scale . setTickRadius ( 0.85 ) ; scale . setTickLabelOffset ( 0.2 ) ; scale . setMajorTickIncrement ( 1 ) ; scale . setTickLabelPaint ( LABELGREY ) ; plot . addScale ( 0 , scale ) ; plot . addLayer ( pointer ) ; plot . addLayer ( innerFrame ) ; plot . addLayer ( centerFrame ) ; plot . setBackground ( backgroundLayer ) ; chart . setBackgroundPaint ( LT_GRAY ) ; chart = new JFreeChart ( plot ) ; chartPanel = new ChartPanel ( chart ) { @ Override public Dimension getMaximumSize ( ) { return getCustomDimensions ( ) ; } @ Override public Dimension getMinimumSize ( ) { return getCustomDimensions ( ) ; } @ Override public Dimension getPreferredSize ( ) { return getCustomDimensions ( ) ; } } ; this . add ( chartPanel ) ;
getCandleData: public CandleData getCandleData ( ) { if ( mData == null ) return null ; return mData . getCandleData ( ) ;
execute: No method body
givenObject_whenGetsFieldNamesAtRuntime_thenCorrect: public void givenObject_whenGetsFieldNamesAtRuntime_thenCorrect ( ) { final Object person = new Person ( ) ; final Field [ ] fields = person . getClass ( ) . getDeclaredFields ( ) ; final List < String > actualFieldNames = getFieldNames ( fields ) ; assertTrue ( Arrays . asList ( "name" , "age" ) . containsAll ( actualFieldNames ) ) ;
getTotalBlock: public long getTotalBlock ( Context context ) { totalBlock = PreferencesUtils . getTotalBlock ( context ) ; if ( totalBlock == - 1 ) { totalBlock = 0 ; } return totalBlock ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; hideSortingButton = false ; giveItemFilterTitle = null ; giveItemFilter = null ; giveItemPayloadFilter = null ; refresh ( true ) ;
getNamingStrategy: public HandlerMethodMappingNamingStrategy < T > getNamingStrategy ( ) { return this . namingStrategy ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new GeigerComponentData ( ( ActiveData ) componentObject , this ) ;
dismiss: public void dismiss ( ) { if ( mAlertDialog != null && mAlertDialog . isShowing ( ) ) {
setup: void setup ( ) { project = new Project ( "Archangel 12" , LocalDate . of ( 1962 , 3 , 4 ) , LocalDate . of ( 1964 , 7 , 4 ) ) ; task = new Task ( "Titanium alloy testing" , 2000 ) ; employee = new Employee ( "John" , "Doe" , "ABC-12345-XX" ) ;
onTouchEvent: public boolean onTouchEvent ( MotionEvent event ) { mCaptureHelper . onTouchEvent ( event ) ; return super . onTouchEvent ( event ) ;
getPosition: public float getPosition ( ) { return position ;
refresh: public void refresh ( ) { renderObjects ( ) ;
pageList: public CommonResult < CommonPage < Dict > > pageList ( @ Valid @ RequestBody DictPageListParam param ) { List < Dict > dictList = dictService . pageList ( param . getPageNum ( ) , param . getPageSize ( ) , param . getQueryKey ( ) ) ; return CommonResult . success ( CommonPage . restPage ( dictList ) ) ;
getName: public String getName ( ) { return name ;
isValidEmail: public static boolean isValidEmail ( String mail ) { Pattern pattern = Pattern . compile ( "^[A-Za-z0-9][\\w\\._]*[a-zA-Z0-9]+@[A-Za-z0-9-_]+\\.([A-Za-z]{2,4})" ) ; Matcher mc = pattern . matcher ( mail ) ; return mc . matches ( ) ;
getYesButtonText: protected String getYesButtonText ( ) { return L . get ( "MENU_JOIN" ) ;
getAdditionalSettings: public ServerSettings . BaseConditions getAdditionalSettings ( ) { return baseConditions ;
getRequiredReadPrivilege: public String getRequiredReadPrivilege ( ) { return requiredReadPrivilege ;
getLong: public static long getLong ( String key , long defValue ) { return getPreferences ( ) . getLong ( key , defValue ) ;
hasTimeline: public boolean hasTimeline ( String [ ] propertyIds ) { for ( String id : propertyIds ) if ( timelineIds . contains ( id ) ) return true ; return false ;
onEvent: public boolean onEvent ( Event event ) { if ( event . getID ( ) == Event . ID . teamWon ) { teamWon ( ( ( TeamWonEvent ) event ) . team ) ; } return false ;
release: public void release ( ) { super . release ( ) ; if ( currentInstrument != null ) { currentInstrument . setOwner ( null ) ; } if ( hookedInstrument != null )
contains: public boolean contains ( T e ) { for ( int i = 0 ; i < getEntryCount ( ) ; i ++ ) { if ( getEntryForIndex ( i ) . equals ( e ) ) return true ; } return false ;
e: public static void e ( String tag , String msg ) { if ( Constants . isShowLog ) {
removeImageExtension: public void removeImageExtension ( String name ) { Map defaultMap = Map . GetDefault ( ) ; if ( defaultMap == null ) return ; byte [ ] ext = defaultMap . getExtension ( name ) ; if ( ext == null ) return ; Queue < ActiveData > removeList = new Queue < > ( ) ; for ( Map map : Map . All ( ) ) { for ( ActiveData activeData : map . getActivesForTag ( Constants . ActiveTags . USER_IMAGE , false ) ) { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us == null ) continue ; if ( ! us . getSprite ( ) . equals ( name ) ) continue ; removeList . addLast ( activeData ) ; } for ( ActiveData activeData : removeList ) { UserSpriteWithBlocksComponentData us = activeData . getComponent ( UserSpriteWithBlocksComponentData . class ) ; if ( us != null ) { int w = us . getWidth ( ) , h = us . getHeight ( ) , x = ( int ) activeData . getX ( ) , y = ( int ) activeData . getY ( ) ; for ( int j = 0 ; j < h ; j ++ ) { for ( int i = 0 ; i < w ; i ++ ) { int x_ = x + i , y_ = y + j ; BlockData blockData = map . getBlock ( x_ , y_ , us . getContentComponent ( ) . getBlocksLayer ( ) ) ; if ( blockData != null ) { SpriteBlockComponentData b = blockData . getComponent ( SpriteBlockComponentData . class ) ; if ( b != null && b . getSprite ( map ) == activeData ) { map . getBlocks ( ) . set ( x_ , y_ , null , us . getContentComponent ( ) . getBlocksLayer ( ) , false ) ; } } } } } map . removeActive ( activeData , false , true , false ) ; } removeList . clear ( ) ; } defaultMap . removeExtension ( name ) ; BrainOutServer . Controller . playStateChanged ( ) ;
getLength: No method body
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( buttons . getAllChecked ( ) . size == 0 )
received: public boolean received ( final VoiceChatMsg msg ) { GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode == null ) return true ; BrainOutServer . PostRunnable ( ( ) -> ( ( ServerRealization ) gameMode . getRealization ( ) ) . voiceChat ( this , msg . data , msg . volume ) , 30 ) ; return true ;
removeEntry: public boolean removeEntry ( T e ) { if ( e == null ) return false ; if ( mEntries == null ) return false ; boolean removed = mEntries . remove ( e ) ; if ( removed ) { calcMinMax ( ) ; } return removed ;
onEvent: public boolean onEvent ( Event event ) { return false ;
isSuitable: public boolean isSuitable ( File file ) { return true ;
setMixTime: public void setMixTime ( float mixTime ) { this . mixTime = mixTime ;
fillUp: public void fillUp ( ContentManager contentManager ) { if ( contentToIndex != null && indexToContent != null ) { return ; } contentToIndex = new Array < > ( ) ; indexToContent = new ObjectMap < > ( ) ; int id = 1 ; for ( ObjectMap . Entry < String , Content > entry : contentManager . getItems ( ) )
getResponse: public FormAutocompleteResponse getResponse ( ) { FormAutocompleteResponse response = new FormAutocompleteResponse ( ) ; response . setBuilderStart ( getBuilderStart ( ) ) ; response . setBuilder ( getBuilder ( ) ) ; return response ;
findAnimation: public @ Null Animation findAnimation ( String animationName ) { if ( animationName == null ) throw new IllegalArgumentException ( "animationName cannot be null." ) ; Object [ ] animations = this . animations . items ; for ( int i = 0 , n = this . animations . size ; i < n ; i ++ ) { Animation animation = ( Animation ) animations [ i ] ; if ( animation . name . equals ( animationName ) ) return animation ; } return null ;
list: void list ( ) throws Exception { assertNotNull ( whitePageListParam , "whitePageListParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/white/list" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( whitePageListParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "白名单列表接口（分页）接口测试成功:{}" , map . get ( "data" ) ) ;
isExpired: void isExpired ( ) { Rent r1 = new Rent ( new Book ( "Effective Java" , 2019 , 1350 ) , new Person ( "Nicola" , "Bicocchi" , "ID1456" ) , LocalDate . of ( 2022 , 3 , 1 ) , LocalDate . of ( 2022 , 7 , 1 ) ) ; Rent r2 = new Rent ( new Book ( "Big Java" , 2019 , 1350 ) , new Person ( "Nicola" , "Bicocchi" , "ID1456" ) , LocalDate . of ( 2023 , 3 , 1 ) , LocalDate . of ( 2023 , 7 , 1 ) ) ; assertTrue ( r1 . isExpired ( LocalDate . of ( 2023 , 4 , 1 ) ) ) ; assertFalse ( r2 . isExpired ( LocalDate . of ( 2023 , 4 , 1 ) ) ) ;
getTransformer: public Transformer getTransformer ( ) { return mTrans ;
getIntegrations: protected PageModelMap getIntegrations ( ) { return findEmailConfigFlow ( )
setCallback: public void setCallback ( LightingItemCallback callback ) { this . mCallback = callback ;
testGetCriteria: public void testGetCriteria ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < VoucherCriterion > responseEntity = this . api . vouchers ( ) . getCriteria ( "acme" , "acme" , 1 , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/VoucherGetCriteriaResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( VoucherCriterion entity : responseEntity . getEntities ( ) ) {
newOrganization: public Object newOrganization ( @ Qualifier ( "user" ) Pageable userPageable ) { debug ( "[newOrganization]" ) ; return getNewOrganizationSettings ( userPageable )
getRoleDict: public List < RoleDictDto > getRoleDict ( ) { List < RoleDictDto > roleDictDtoList = ( List < RoleDictDto > ) redisTemplate . opsForValue ( ) . get ( SystemDictConstants . ROLE ) ; if ( CollectionUtils . isEmpty ( roleDictDtoList ) ) { synchronized ( this ) { roleDictDtoList = ( List < RoleDictDto > ) redisTemplate . opsForValue ( ) . get ( SystemDictConstants . ROLE ) ; if ( CollectionUtils . isEmpty ( roleDictDtoList ) ) { List < Role > roleList = this . list ( ) ; if ( CollectionUtils . isEmpty ( roleList ) ) return roleDictDtoList ; roleDictDtoList = roleList . stream ( ) . map ( role -> { RoleDictDto dto = new RoleDictDto ( ) ; dto . setRoleId ( role . getId ( ) ) ; dto . setRoleName ( role . getRoleName ( ) ) ; dto . setRoleCode ( role . getRoleCode ( ) ) ; return dto ; } ) . collect ( Collectors . toList ( ) ) ; redisTemplate . opsForValue ( ) . set ( SystemDictConstants . ROLE , roleDictDtoList ) ; } } } return roleDictDtoList ;
getErrorString: public static String getErrorString ( Context context , String code ) { int resId = getErrorStringRes ( code ) ; if ( resId != - 1 ) { return context . getResources ( ) . getString ( resId ) ; } return "" ;
test_deleteSubscriberCredentialsSuccess: public void test_deleteSubscriberCredentialsSuccess ( ) throws IOException , InterruptedException , NovuNetworkException { mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( "{}" ) ) ; DeleteCredentialsResponse response = subscribersHandler . deleteSubscriberCredentials ( "sId" , "pId" ) ; assertNotNull ( response ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/subscribers/sId/credentials/pId" , request . getPath ( ) ) ; assertEquals ( "DELETE" , request . getMethod ( ) ) ; assertTrue ( response . getAcknowledged ( ) ) ;
discoverSearchableRepositories: public synchronized static void discoverSearchableRepositories ( ) { if ( discoveryCompleted ) { return ; } ApplicationContext c = ApplicationContextProvider . getContext ( ) ; Map < String , SecureRepository > searchableRepositoryBeans = c . getBeansOfType ( SecureRepository . class ) ; int searchableRepositoriesCount = 0 ; int globalSearchableRepositoriesCount = 0 ; for ( Map . Entry < String , SecureRepository > e : searchableRepositoryBeans . entrySet ( ) ) { if ( "globalSearchRepository" . equals ( e . getKey ( ) ) ) { continue ; } SearchableRepositoryMetadata gsa = getGlobalSearchableRepositoryAnnotation ( e . getValue ( ) ) ; if ( gsa == null ) { String message = String . format ( "Repository %s have to be annotated with SearchableRepositoryMetadata" , e . getValue ( ) . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( message ) ; } searchableRepositoriesCount ++ ; if ( gsa . includeInGlobalSearch ( ) ) { globalSearchableRepositoriesCount ++ ; } } searchableRepositories = new SecureRepository [ searchableRepositoriesCount ] ; searchIndexUpdates = new String [ searchableRepositoriesCount ] ; globalSearchableRepositories = new SecureRepository [ globalSearchableRepositoriesCount ] ; int sk = 0 ; int gsk = 0 ; for ( Map . Entry < String , SecureRepository > e : searchableRepositoryBeans . entrySet ( ) ) { if ( "globalSearchRepository" . equals ( e . getKey ( ) ) ) { continue ; } SearchableRepositoryMetadata gsa = getGlobalSearchableRepositoryAnnotation ( e . getValue ( ) ) ; String tableName = discoverTableName ( gsa . entityClass ( ) ) ; searchIndexUpdates [ sk ] = String . format ( UPDATE_INDEX_QUERY , tableName , INDEX_STRING_COLUMN , gsa . searchIndexFormula ( ) , UPDATED_ON ) ; searchableRepositories [ sk ++ ] = e . getValue ( ) ; if ( gsa . includeInGlobalSearch ( ) ) { globalSearchableRepositories [ gsk ++ ] = e . getValue ( ) ; } searchableRepositoryByEntityKey . put ( gsa . entityKey ( ) , e . getValue ( ) ) ; searchableRepositoryMetadataByEntityKey . put ( gsa . entityKey ( ) , gsa ) ; searchableRepositoryMetadataByEntityClass . put ( gsa . entityClass ( ) , gsa ) ; if ( SearchableOrganizationRelatedEntity . class . isAssignableFrom ( gsa . entityClass ( ) ) ) { searchableOrganizationRelatedRepositoryMetadataByEntityKey . put ( gsa . entityKey ( ) , gsa ) ; searchableOrganizationRelatedRepositoryMetadataByEntityClass . put ( gsa . entityClass ( ) , gsa ) ; } } discoveryCompleted = true ;
sendMessageToSlack: public boolean sendMessageToSlack ( String message , String webHook , String channel , String username ) { debug ( "[sendMessageToSlack] Message to {}" , webHook ) ; String requestJson = String . format ( "{\"text\":\"%s\"%s%s}" , StringUtils . replace ( message , "\"" , "\\\"" ) , StringUtils . defaultIfBlank ( channel != null ? String . format ( ", \"channel\": \"%s\"" , channel ) : null , "" ) , StringUtils . defaultIfBlank ( username != null ? String . format ( ", \"username\": \"%s\"" , username ) : null , "" ) ) ; return sendJSONMessageToSlack ( requestJson , webHook ) ;
getLineData: public LineData getLineData ( ) { return mData ;
update: public void update ( ) { double highestPressure = 0 ; double pressureSum = 0 ; double zeroHeadFlowSum = 0 ; for ( Pump thisSource : sources ) { double sourcePressure = thisSource . getHead ( ) ; pressureSum += sourcePressure ; zeroHeadFlowSum += thisSource . getFlow ( ) ; highestPressure = sourcePressure > highestPressure ? sourcePressure : highestPressure ; } zeroFlowHead = highestPressure ; zeroHeadFlow = zeroHeadFlowSum * 5 ; for ( Pump thisSource : sources ) { double sourceOutflow = thisSource . getHead ( ) / pressureSum * waterOutflow ; if ( pressureSum == 0 ) { sourceOutflow = 0 ; } thisSource . updateFlow ( sourceOutflow ) ; } if ( waterTemperature < 0 || waterTemperature > 300 ) { int e = 0 ; } waterDensity = Loader . tables . getWaterDensityByTemp ( waterTemperature ) ; if ( waterOutflow > zeroHeadFlow ) { waterOutflow = zeroHeadFlow ; } Double calculatedPressure = ( 1 - ( waterOutflow / zeroHeadFlow ) ) * zeroFlowHead + 0.10142 ; if ( calculatedPressure . isNaN ( ) ) { calculatedPressure = 0.10142 ; } pressure = ( pressure * 50 + calculatedPressure ) / 51 ; resetFlows ( ) ; waterMass = 0 ;
getWeight: float getWeight ( ) { return distance ;
setMapSource: public void setMapSource ( MapSource mapSource ) { this . mapSource = mapSource ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { cavit1AActionPerformed ( evt ) ;
get: public < T > Optional < T > get ( StateKey < T > key ) { Deferred < ByteBuffer > deferred = Util . blockOnSyscall ( cb -> syscalls . get ( key . name ( ) , cb ) ) ; if ( ! deferred . isCompleted ( ) ) { Util . < Void > blockOnSyscall ( cb -> syscalls . resolveDeferred ( deferred , cb ) ) ; } return Util . unwrapOptionalReadyResult ( deferred . toResult ( ) )
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/RedirectUpdateRequest.json" ) ; Redirect requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Redirect . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Redirect responseEntity = this . api . redirects ( ) . update ( "acme" , 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/RedirectUpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
onReactContextInitialized: public void onReactContextInitialized ( ReactContext reactContext ) { reactInstanceManager . removeReactInstanceEventListener ( this ) ; reactContext . runOnNativeModulesQueueThread (
delete: public AjaxResult delete ( @ PathVariable ( name = "menuId" ) Long menuId ) { menuService . deleteMenu ( menuId ) ; return AjaxResult . success ( "删除成功！" ) ;
write: public void write ( Json json ) { json . writeValue ( "target" , target . toString ( ) ) ;
getRelative: public boolean getRelative ( ) { return relative ;
getAnimationEnd: public float getAnimationEnd ( ) { return animationEnd ;
getTaskTitle: public String getTaskTitle ( ) { return getTask ( ) . getTitle ( ) . get ( String . valueOf ( getTask ( ) . getTarget ( ) ) ) ;
getID: public ID getID ( ) { return ID . duel ;
updateStats: private void updateStats ( ) { String stats = String . valueOf ( ( int ) mousePosition . x ) + ", " + ( int ) mousePosition . y ; mousePositionLabel . setText ( stats ) ;
getMenuDict: void getMenuDict ( ) throws Exception { MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . get ( "/menu/getMenuDict" ) . contentType ( MediaType . APPLICATION_JSON ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "菜单字典接口测试成功:{}" , map . get ( "data" ) ) ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { super . enter ( event , x , y , pointer , fromActor ) ; im . setColor ( 1 , 1 , 1 , 1 ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new LaserComponentData ( ( WeaponData ) componentObject , this ) ;
setThisService: void setThisService ( ) { if ( thisService == null ) {
onDestroy: No method body
GetStore: public static void GetStore ( String storeName , StoreCallback callback ) { StoreService store = StoreService . Get ( ) ; LoginService login = LoginService . Get ( ) ; if ( store == null || login == null ) { callback . failed ( ) ; return ; } store . getStore ( login . getCurrentAccessToken ( ) , storeName ,
size: void size ( ) { assertEquals ( 3 , m . size ( ) ) ;
getWaterDensity: public double getWaterDensity ( ) { return specificDensityWater ;
deriveNextKey: public Single < signrpc . SignerOuterClass . KeyDescriptor > deriveNextKey ( walletrpc . Walletkit . KeyReq request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . deriveNextKey ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem9ActionPerformed ( evt ) ;
getCurrentChannelId: public static Long getCurrentChannelId ( ) { if ( StoreStream . getChat ( ) . getInteractionState ( ) == null ) return null ; return StoreStream . getChat ( ) . getInteractionState ( ) . getChannelId ( ) ;
await: public final T await ( Duration timeout ) throws TerminalException , TimeoutException { Deferred < Void > sleep = Util . blockOnSyscall ( cb -> this . syscalls . sleep ( timeout , cb ) ) ; Awaitable < Void > sleepAwaitable = single ( this . syscalls , sleep ) ; int index = any ( this , sleepAwaitable ) . awaitIndex ( ) ; if ( index == 1 ) { throw new TimeoutException ( ) ; } return this . await ( ) ;
setEdges: public void setEdges ( short [ ] edges ) { this . edges = edges ;
doFetch: public void doFetch ( ) { if ( ! isEnabled ( false ) ) return ; if ( state == State . fetching || state == State . reloading ) return ; if ( data . getOwner ( ) == null ) return ; if ( isPlayingCustomAnimation ( ) ) return ; boolean fineToFetch = getRounds ( ) > 0 && getChambered ( ) < weaponProperties . getChambers ( ) ; if ( ! fineToFetch ) return ; timer = fetchTime . asFloat ( ) ; onFetch ( null ) ; fetch ( ) ; setState ( State . fetching ) ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------invoiceOnError------------------" + e . getMessage ( ) ) ;
render: public void render ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ; super . render ( ) ;
addSlot: public WeaponSlotComponent addSlot ( Weapon . WeaponProperties properties , String name , String icon ) { WeaponSlotComponent slot = new ClientWeaponSlotComponent ( data , record , properties , name , icon , this :: getSlot ) ; slots . put ( name , slot ) ; slot . init ( ) ; return slot ;
showStepOne: private void showStepOne ( ) { searchEdit = mAlertDialog . findViewById ( R . id . edit_search ) ; recentsAddressTv = mAlertDialog . findViewById ( R . id . tv_recents_address ) ; recentsAddressSecondTv = mAlertDialog . findViewById ( R . id . tv_recents_address_second ) ; if ( mAddressData . size ( ) == 0 ) { recentsAddressTv . setVisibility ( View . GONE ) ; recentsAddressSecondTv . setVisibility ( View . GONE ) ; } else { if ( mAddressData . size ( ) == 1 ) { recentsAddressTv . setVisibility ( View . VISIBLE ) ; recentsAddressSecondTv . setVisibility ( View . GONE ) ; recentsAddressTv . setText ( mAddressData . get ( 0 ) . getAddress ( ) ) ; } else { recentsAddressTv . setVisibility ( View . VISIBLE ) ; recentsAddressSecondTv . setVisibility ( View . VISIBLE ) ; recentsAddressTv . setText ( mAddressData . get ( 0 ) . getAddress ( ) ) ; recentsAddressSecondTv . setText ( mAddressData . get ( 1 ) . getAddress ( ) ) ; } } recentsAddressTv . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { toFriendName = mAddressData . get ( 0 ) . getName ( ) ; selectAddress = recentsAddressTv . getText ( ) . toString ( ) ; mAlertDialog . findViewById ( R . id . lv_step_one_content ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . lv_step_two_content ) . setVisibility ( View . VISIBLE ) ; showStepTwo ( ) ; } } ) ; recentsAddressSecondTv . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { toFriendName = mAddressData . get ( 1 ) . getName ( ) ; selectAddress = recentsAddressSecondTv . getText ( ) . toString ( ) ; mAlertDialog . findViewById ( R . id . lv_step_one_content ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . lv_step_two_content ) . setVisibility ( View . VISIBLE ) ; showStepTwo ( ) ; } } ) ; mRecyclerView = mAlertDialog . findViewById ( R . id . recycler_send_list ) ; LinearLayoutManager layoutManager = new LinearLayoutManager ( mContext ) ; layoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; mRecyclerView . setLayoutManager ( layoutManager ) ; mAdapter = new MyAdapter ( mContext , mAddressData , R . layout . layout_item_send_list ) ; mRecyclerView . setAdapter ( mAdapter ) ; mAdapter . notifyDataSetChanged ( ) ; searchEdit . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable s ) { if ( s . length ( ) > 0 ) { if ( ValidateBitcoinAddress . validateBitcoinAddress ( s . toString ( ) ) ) { new Handler ( ) . postDelayed ( new Runnable ( ) { public void run ( ) { if ( mAddressData . size ( ) == 0 ) { toFriendName = "unname" ; } else { toFriendName = "unname" ; for ( AddressEntity entity : mAddressData ) { if ( entity . getAddress ( ) . equals ( s . toString ( ) ) ) { toFriendName = entity . getName ( ) ; } } } selectAddress = s . toString ( ) ; mAlertDialog . findViewById ( R . id . lv_step_one_content ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . lv_step_two_content ) . setVisibility ( View . VISIBLE ) ; showStepTwo ( ) ; } } , 1000 ) ; } else { ToastUtils . showToast ( mContext , mContext . getString ( R . string . wallet_address_is_invalid ) ) ; } } } } ) ; mAlertDialog . findViewById ( R . id . iv_scan ) . setOnClickListener ( new View . OnClickListener ( ) {
getCurrentWeapon: protected WeaponData getCurrentWeapon ( ) { return getController ( ) . getCurrentWeapon ( ) ;
setTimeScale: public void setTimeScale ( float timeScale ) { this . timeScale = timeScale ;
spectatorsCanSeeEnemies: public boolean spectatorsCanSeeEnemies ( ) { return false ;
setVisibleYRangeMaximum: public void setVisibleYRangeMaximum ( float maxYRange , AxisDependency axis ) { float yScale = getAxisRange ( axis ) / maxYRange ; mViewPortHandler . setMinimumScaleY ( yScale ) ;
getBundleData: protected void getBundleData ( Bundle bundle ) { scanCode = bundle . getInt ( KEY_SCAN_CODE ) ;
getCurvePercent: private float getCurvePercent ( float time , int frame ) { float [ ] curves = this . curves ; int i = ( int ) curves [ frame ] ; switch ( i ) { case LINEAR : float x = frames [ frame ] ; return ( time - x ) / ( frames [ frame + getFrameEntries ( ) ] - x ) ; case STEPPED : return 0 ; } i -= BEZIER ; if ( curves [ i ] > time ) { float x = frames [ frame ] ; return curves [ i + 1 ] * ( time - x ) / ( curves [ i ] - x ) ; } int n = i + BEZIER_SIZE ; for ( i += 2 ; i < n ; i += 2 ) { if ( curves [ i ] >= time ) { float x = curves [ i - 2 ] , y = curves [ i - 1 ] ; return y + ( time - x ) / ( curves [ i ] - x ) * ( curves [ i + 1 ] - y ) ; } } float x = curves [ n - 2 ] , y = curves [ n - 1 ] ; return y + ( 1 - y ) * ( time - x ) / ( frames [ frame + getFrameEntries ( ) ] - x ) ;
write: public void write ( Json json , ActiveData . ComponentWriter componentWriter , int owner ) { write ( json ) ; Component it = getFistComponent ( ) ; if ( it != null && componentWriter != null )
setDuration: void setDuration ( ) { dvd . setLength ( 140 ) ; assertEquals ( 140 , dvd . getLength ( ) ) ;
onDoubleTap: public boolean onDoubleTap ( MotionEvent e ) { mLastGesture = ChartGesture . DOUBLE_TAP ; OnChartGestureListener l = mChart . getOnChartGestureListener ( ) ; if ( l != null ) { l . onChartDoubleTapped ( e ) ; } if ( mChart . isDoubleTapToZoomEnabled ( ) && mChart . getData ( ) . getEntryCount ( ) > 0 ) { MPPointF trans = getTrans ( e . getX ( ) , e . getY ( ) ) ; float scaleX = mChart . isScaleXEnabled ( ) ? 1.4f : 1f ; float scaleY = mChart . isScaleYEnabled ( ) ? 1.4f : 1f ; mChart . zoom ( scaleX , scaleY , trans . x , trans . y ) ; if ( mChart . isLogEnabled ( ) ) Log . i ( "BarlineChartTouch" , "Double-Tap, Zooming In, x: " + trans . x + ", y: " + trans . y ) ; if ( l != null ) { l . onChartScale ( e , scaleX , scaleY ) ; } MPPointF . recycleInstance ( trans ) ; } return super . onDoubleTap ( e ) ;
main: public static void main ( String [ ] args ) { SpelExpressionParser parser = new SpelExpressionParser ( ) ; String ifClause = "name == 'pucio'" ; String ifClause2 = "name =='puciopucio'" ; String thenClause = "category.contains('futerały')" ; String elseClause = "name.contains('xiaomi')" ; String wyrazenieDoZapisaniaWBazie = ifClause + " ? " + thenClause + " : " + elseClause ; SpelExpression exp = parser . parseRaw ( wyrazenieDoZapisaniaWBazie ) ; SpelNode ast = exp . getAST ( ) ; SpelNode ifChild = ast . getChild ( 0 ) ; LoggingComponent . debugLogger . debug ( ifChild . toStringAST ( ) ) ; SpelExpression ifClauseExp = parser . parseRaw ( ifChild . toStringAST ( ) ) ; StandardEvaluationContext ctx = new StandardEvaluationContext ( new SomeEvent ( "pucio" ) ) ; Boolean result = ( Boolean ) ifClauseExp . getValue ( ctx ) ; LoggingComponent . debugLogger . debug ( result . toString ( ) ) ; ctx = new StandardEvaluationContext ( new SomeEvent ( "iphone" ) ) ; result = ( Boolean ) ifClauseExp . getValue ( ctx ) ; LoggingComponent . debugLogger . debug ( result . toString ( ) ) ;
reverse: void reverse ( ) { Reverser r = new ReverserSlow ( ) ; assertEquals ( "!dlroW olleH" , r . reverse ( "Hello World!" ) ) ;
removeEldestEntry: protected boolean removeEldestEntry ( Entry < K , V > eldest ) { return size ( ) >= this . capacity ;
obtain: public static Event obtain ( SocialMessages . ClientMessage message , boolean notify ) { SocialMessageEvent e = obtain ( SocialMessageEvent . class ) ; if ( e == null ) return null ; return e . init ( message , notify ) ;
conversionMap: private static Map < Character , Integer > conversionMap ( ) { return Map . of (
isUnsubscribed: No method body
addSlot: private Slot addSlot ( String name , Weapon . WeaponProperties weaponProperties ) { Slot slot = slots . get ( name ) ; if ( slot != null ) { return slot ; } slot = new Slot ( weaponData , weaponComponent , weaponProperties , name ) ; slots . put ( name , slot ) ; slot . init ( ) ; return slot ;
getServiceName: public String getServiceName ( ) { return serviceName ;
run: public void run ( ) { ToastUtils . showToast ( mContext , e . getMessage ( ) ) ; mLoadingDialog . dismiss ( ) ;
gotShotFrom: public void gotShotFrom ( ActiveData shooter ) { pushTask ( new TaskFollowAndShootTarget ( getStack ( ) , shooter ,
onDoubleTapEvent: public boolean onDoubleTapEvent ( MotionEvent e ) { return false ;
lockInput: public boolean lockInput ( ) { return true ;
onAttachedToWindow: protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; getViewTreeObserver ( ) . addOnGlobalLayoutListener ( this ) ;
getDescription: public String getDescription ( ) { return description ;
clickPayInvoice: public void clickPayInvoice ( ) { mPayInvoiceDialog = new PayInvoiceDialog ( mContext ) ; mPayInvoiceDialog . show ( pubkey , assetId , "" ) ;
desc: public String desc ( ) { return "ReplaceClass_" + getClassName ( ) ;
romanToDecimal: public static int romanToDecimal ( String s ) { Map < Character , Integer > conversionMap = conversionMap ( ) ; int result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( i < s . length ( ) - 1 ) && conversionMap . get ( s . charAt ( i ) ) < conversionMap . get ( s . charAt ( i + 1 ) ) ) { result -= conversionMap . get ( s . charAt ( i ) ) ; } else { result += conversionMap . get ( s . charAt ( i ) ) ; } } return result ;
yes: public void yes ( ) { unload ( ) ;
getCronExpression: public String getCronExpression ( ) { return cronExpression ;
onClick: public void onClick ( View v ) { shareLayout . setVisibility ( View . VISIBLE ) ;
getPostNewPrivilege: public PrivilegeBase getPostNewPrivilege ( ) { return postNewPrivilege != null ? postNewPrivilege : defaultControllerPrivilege ;
objectKey: public String objectKey ( ) { return key ;
userProfileUpdated: protected void userProfileUpdated ( ) { Gdx . app . postRunnable ( this :: updateStats ) ;
getLabel: public String getLabel ( ) { return label ;
validateActive: public boolean validateActive ( Active active ) { if ( active instanceof Flag ) { return false ; } return true ;
animateXY: public void animateXY ( int durationMillisX , int durationMillisY , EasingFunction easing ) { ObjectAnimator xAnimator = xAnimator ( durationMillisX , easing ) ; ObjectAnimator yAnimator = yAnimator ( durationMillisY , easing ) ; if ( durationMillisX > durationMillisY ) { xAnimator . addUpdateListener ( mListener ) ; } else { yAnimator . addUpdateListener ( mListener ) ; } xAnimator . start ( ) ; yAnimator . start ( ) ;
canBeResetByOthers: public boolean canBeResetByOthers ( ) { return true ;
run: public String run ( final Map < String , String > input ) { final I request = createRequest ( input ) ; if ( parameters != null ) { request . copyFrom ( parameters ) ; } return createResponseSpec ( request , webClient , objectMapper ) . bodyToMono ( String . class )
hasRender: public boolean hasRender ( ) { return true ;
draw: No method body
addWrongOrgRolesToUserTest: public void addWrongOrgRolesToUserTest ( ) { reset ( userRepository ) ; User user = mock ( User . class ) ; Tuple2 uRole = new Tuple ( ORG_ROLE_USER , 1L ) . t2 ( ) ; UserRole userRole = mock ( UserRole . class ) ; when ( roleRepository . findByName ( anyString ( ) ) ) . thenReturn ( null ) ; List result = userService . addOrgRoleToUser ( user , uRole ) ; verify ( roleRepository ) . findByName ( anyString ( ) ) ; verify ( userRepository , never ( ) ) . save ( any ( User . class ) ) ; assertEquals ( 0 , result . size ( ) ) ;
validateParticipant: private boolean validateParticipant ( int owner ) { return participants . containsKey ( owner ) ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { return true ;
getUserRolesForOrganizations: public static Specification < UserRole > getUserRolesForOrganizations ( ) { return new Specification < UserRole > ( ) {
setId: public void setId ( Long id ) { this . id = id ;
isValid: public boolean isValid ( ) { return instrument . instrument != null ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; this . vs = jsonData . getString ( "vs" ) ; this . fs = jsonData . getString ( "fs" ) ;
getStackLabels: No method body
run: public Stream < Map < String , String > > run ( final String input ) { final ObjectNode query = queryCreator . apply ( input ) ; final String requestJson = objectMapper . createObjectNode ( ) . put ( "size" , getMaxDocumentCount ( ) ) . set ( "query" , query ) . toString ( ) ; final Request searchRequest = new Request ( "GET" , String . format ( "/%s/_search" , index ) ) ; searchRequest . setJsonEntity ( requestJson ) ; final Response searchResponse ; try { searchResponse = restClient . performRequest ( searchRequest ) ; } catch ( final IOException ioException ) { throw new IllegalStateException ( "error executing search with request " + requestJson , ioException ) ; } final ObjectNode response ; try ( final InputStream responseInputStream = searchResponse . getEntity ( ) . getContent ( ) ) { response = ( ObjectNode ) objectMapper . readTree ( responseInputStream ) ; } catch ( final IOException ioException ) { throw new IllegalStateException ( "error parsing search response" , ioException ) ; } final ArrayNode hits = Optional . of ( response ) . map ( o -> o . get ( "hits" ) ) . map ( ObjectNode . class :: cast ) . map ( o -> o . get ( "hits" ) ) . map ( ArrayNode . class :: cast ) . orElse ( null ) ; if ( hits == null ) { return Stream . empty ( ) ; } return StreamSupport . stream ( Spliterators . spliteratorUnknownSize ( hits . iterator ( ) , Spliterator . ORDERED ) , false )
setPositiveButton: public SafeDialogBuilder setPositiveButton ( CharSequence text , DialogInterface . OnClickListener listener ) { super . setPositiveButton ( text , listener ) ; this . mPositiveListener = listener ; return this ;
updateSteamOutflow: public void updateSteamOutflow ( double flow , double tempC ) { steamOutflow += flow ;
b: public e b ( @ NotNull Request request ) { return null ;
getCard: public CardData getCard ( CaseData caseData , String dimension ) { return new StatCardData ( this , caseData , dimension ) ;
getFormLineWidth: public float getFormLineWidth ( ) { return mFormLineWidth ;
generate: private void generate ( ) { if ( light != null ) return ; ClientMap clientMap = ( ( ClientMap ) getMap ( ) ) ; if ( clientMap == null ) { return ; } if ( clientMap . getLights ( ) == null ) { return ; } light = new PointLight ( clientMap . getLights ( ) , 8 , new Color ( 1 , 0.5f , 0.5f , 0.8f ) , 2 , pointPos . x , pointPos . y ) ; light . setXray ( true ) ; light . setStaticLight ( true ) ; if ( Map . GetWatcher ( ) != null )
getProgress: public int getProgress ( ) { return progress ;
onDataSuccess: No method body
release: public void release ( ) { super . release ( ) ; clear ( ) ;
shouldAccept: public boolean shouldAccept ( @ NonNull Packet packet ) { return packet instanceof Request ;
matches: No method body
setAutoState: public void setAutoState ( int state ) { this . autoState = state ;
getReferenceString: public String getReferenceString ( ) { return referenceString ;
getAndAdd: public CounterUpdateResult getAndAdd ( ObjectContext ctx , Long request ) { LOG . info ( "Invoked get and add with " + request ) ; long currentValue = ctx . get ( TOTAL ) . orElse ( 0L ) ; long newValue = currentValue + request ; ctx . set ( TOTAL , newValue ) ; return new CounterUpdateResult ( newValue , currentValue ) ;
deleteUserRoleById: No method body
getMainViewName: default String getMainViewName ( ) { return "main" ;
shouldParseSimpleRuleToString: public void shouldParseSimpleRuleToString ( ) { RuleDto ruleDto = initSimpleDto ( ) ; String rule = RuleSpelHelper . parseToString ( ruleDto ) ; assertEquals ( "name == 'test' ? category == 'test2' : category.contains('test3')" , rule ) ;
isDirectory: public boolean isDirectory ( ) { return false ;
getWaterLevel: public double getWaterLevel ( ) { return waterLevel ;
onCustomMessage: public void onCustomMessage ( String messageType , JSONObject payload ) { if ( Log . INFO ) Log . info ( "Custom message: " + messageType ) ; Gdx . app . postRunnable ( ( ) -> ClanMenu . this . onCustomConflictMessage ( payload ) ) ;
getScale: public float getScale ( ) { return scale ;
getNewToken: protected String getNewToken ( ) { return null ;
onCloseUselessActivityEvent: public void onCloseUselessActivityEvent ( CloseUselessActivityEvent event ) { finish ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ;
callPhoneNum: private void callPhoneNum ( ) { if ( StringUtils . isEmpty ( mPhoneNumber ) ) { LogUtils . e ( TAG , "电话号码为空" ) ; return ; } if ( ! StringUtils . isEmpty ( mPhoneNumber ) && PermissionChecker . checkCallPhonePermission ( mActivity ) ) {
testDeleteBulk: public void testDeleteBulk ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/RedirectDeleteBulkRequest.json" ) ; List < Redirect > requestEntity = this . jsonSerializer . unserializeList ( expectedRequestJson , Redirect . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . redirects ( ) . deleteBulk ( "acme" , requestEntity , options ) ;
assertNegative: public static void assertNegative ( double n , @ NotNull String message ) { if ( Double . isNaN ( n ) || n >= 0 ) throw new AssertionError ( message ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton3ActionPerformed ( evt ) ;
deposit: public void deposit ( double amount ) { checkPositiveValue ( amount ) ; balance += amount ;
getName: public String getName ( ) { return name ;
onNothingSelected: No method body
hasConsumable: public boolean hasConsumable ( ConsumableContent type ) { return getConsumable ( type ) != null ;
setFrame: public void setFrame ( int frame , float time , float mix , float softness , int bendDirection , boolean compress , boolean stretch ) { frame *= ENTRIES ; frames [ frame ] = time ; frames [ frame + MIX ] = mix ; frames [ frame + SOFTNESS ] = softness ; frames [ frame + BEND_DIRECTION ] = bendDirection ; frames [ frame + COMPRESS ] = compress ? 1 : 0 ; frames [ frame + STRETCH ] = stretch ? 1 : 0 ;
getTeam: public Team getTeam ( ) { return team ;
noYYZ: public static List < String > noYYZ ( List < String > strings ) { return strings . stream ( )
getComponent: public RandomJumpComponentData getComponent ( ComponentObject playerData ) { return new RandomJumpComponentData ( ( ActiveData ) playerData , this ) ;
fillList: public static long fillList ( List < Integer > list , int items ) { RandomGenerator rnd = RandomGenerator . getDefault ( ) ; long start = System . nanoTime ( ) ; for ( int i = 0 ; i < items ; i ++ ) { list . add ( rnd . nextInt ( items ) ) ; } return System . nanoTime ( ) - start ;
SdCardAvailable: public static boolean SdCardAvailable ( ) { return Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ;
isSpecial: public boolean isSpecial ( ) { return getInfoBoolean ( "special" , false ) ;
toSimpleString: public String toSimpleString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "DataSet, label: " + ( getLabel ( ) == null ? "" : getLabel ( ) ) + ", entries: " + mEntries . size ( ) + "\n" ) ; return buffer . toString ( ) ;
pathValuesToPixel: public void pathValuesToPixel ( List < Path > paths ) { for ( int i = 0 ; i < paths . size ( ) ; i ++ ) {
setCircleHoleRadius: public void setCircleHoleRadius ( float holeRadius ) { if ( holeRadius >= 0.5f ) {
onLayout: protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super . onLayout ( changed , left , top , right , bottom ) ; width = getWidth ( ) ; height = getHeight ( ) ;
onClick: public void onClick ( View v ) { mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_two ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_one ) . setVisibility ( View . VISIBLE ) ;
getWorldVerticesLength: public int getWorldVerticesLength ( ) { return worldVerticesLength ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { stop1A2ItemStateChanged ( evt ) ;
getPackageManager: public PackageManager getPackageManager ( int threads ) { return new AndroidPackageManager ( threads ) ;
saveUpdateAPKSizeToLocal: public static void saveUpdateAPKSizeToLocal ( Context context , long value ) { putLong ( SETTINGS , context , KEY_UPDATE_APK_SIZE , value ) ;
isSwamp: public boolean isSwamp ( ) { return swamp ;
main: public static void main ( String [ ] args ) { try { System . setErr ( new PrintStream ( new FileOutputStream ( "error.log" ) ) ) ; } catch ( FileNotFoundException e ) { } CSSteamInit . TryInit ( ) ; System . setProperty ( "java.awt.headless" , "true" ) ; ClientEnvironment environment = new SteamEnvironment ( args ) ; ClientSettings settings ; try { settings = SteamSettings . GetSteamSettings ( environment ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; if ( Log . ERROR ) Log . error ( "Error loading settings: " + e . getMessage ( ) ) ; return ; } Lwjgl3ApplicationConfiguration cfg = new Lwjgl3ApplicationConfiguration ( ) ; cfg . setTitle ( environment . getAppName ( ) ) ; if ( settings . getFullscreen ( ) . getValue ( ) ) { ScreenResolutionProperty dm = settings . getDisplayMode ( ) ; Graphics . DisplayMode selected = null ; for ( Graphics . DisplayMode displayMode : Lwjgl3ApplicationConfiguration . getDisplayModes ( ) ) { if ( dm . getWidth ( ) == displayMode . width && dm . getHeight ( ) == displayMode . height && dm . getHz ( ) == displayMode . refreshRate && dm . getBpp ( ) == displayMode . bitsPerPixel ) { selected = displayMode ; break ; } } if ( selected == null ) { for ( Graphics . DisplayMode displayMode : Lwjgl3ApplicationConfiguration . getDisplayModes ( ) ) { if ( displayMode . width < 1024 ) continue ; if ( displayMode . width >= 2200 ) continue ; if ( displayMode . refreshRate > 60 ) continue ; if ( selected != null && ( selected . width > displayMode . width ) ) continue ; selected = displayMode ; } } if ( selected != null ) { environment . setTargetFullScreenDisplayMode ( selected ) ; } cfg . setWindowedMode ( 1024 , 768 ) ; } else { cfg . setWindowedMode ( settings . getDisplayMode ( ) . getWidth ( ) , settings . getDisplayMode ( ) . getHeight ( ) ) ; } cfg . useVsync ( settings . getvSync ( ) . getValue ( ) ) ; cfg . setAudioConfig ( 64 , 512 , 9 ) ; try { Lwjgl3FileHandle h = new Lwjgl3FileHandle ( new File ( ".prefs" , "test" ) , Files . FileType . External ) ; h . write ( false ) ; } catch ( GdxRuntimeException exception ) { if ( Log . ERROR ) Log . error ( "Cannot write into External folder, using Local instead!" ) ; cfg . setPreferencesConfig ( ".prefs" , Files . FileType . Local ) ; } cfg . setWindowIcon ( Files . FileType . Internal , "icons/icon-128.png" , "icons/icon-64.png" , "icons/icon-32.png" , "icons/icon-16.png" ) ; new Lwjgl3Application ( BrainOutSteam . initSteamInstance ( environment , settings ) , cfg ) ;
onResultCallback: No method body
getItems: protected void getItems ( Array < PresetOption . WrapperPreset > items ) { items . addAll ( presets ) ;
isOwner: public boolean isOwner ( ) { return owner == this ;
setTtsConfig: public void setTtsConfig ( TtsConfig ttsConfig ) { this . tts . setConfig ( ttsConfig ) ;
obtainUsername: protected String obtainUsername ( HttpServletRequest request ) { String login = super . obtainUsername ( request ) ; String username = userRepository . findUsernameLowercaseByLogin ( login ) ; return username != null ? username : login ;
listTransactions: private void listTransactions ( String time ) { mTransactionsAssetData . clear ( ) ; SharedPreferences txidSp = mContext . getSharedPreferences ( "SP_TXID_LIST" , Activity . MODE_PRIVATE ) ; String txidListJson = txidSp . getString ( "txidListKey" , "" ) ; if ( ! StringUtils . isEmpty ( txidListJson ) ) {
setUp: public static void setUp ( ) throws Exception { Instrumentation instrumentation = ByteBuddyAgent . install ( ) ; Global . instrumentation = instrumentation ; Global . fillLoadedClasses ( ) ; System . setProperty ( "maxHit" , "3" ) ;
setBalanceAmount: public void setBalanceAmount ( Context context , long balanceAmount ) { PreferencesUtils . saveBalanceAmount ( context , balanceAmount ) ; this . balanceAmount = balanceAmount ;
received: public boolean received ( TakeRecordFromItemMsg msg ) { if ( getState ( ) == State . spawned && getPlayerData ( ) != null ) { final Map map = playerData . getMap ( ) ; if ( map == null ) return true ; ActiveData item = map . getActiveData ( msg . object ) ; if ( item instanceof ItemData ) { final ItemData itemData = ( ( ItemData ) item ) ; if ( itemData instanceof RoundLockSafeData && ( ( RoundLockSafeData ) itemData ) . isLocked ( ) ) { return true ; } BrainOutServer . PostRunnable ( ( ) -> { if ( playerData == null || playerController == null ) return ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { ConsumableRecord record = itemData . getRecords ( ) . getData ( ) . get ( msg . record ) ; if ( record != null ) { playerController . pickUpRecordItem ( itemData , record , msg . amount ) ; } } } ) ; } else { sendUDP ( new UnknownActiveDataMsg ( msg . object , map . getDimension ( ) ) ) ; } } return true ;
getMagazineStatus: public int getMagazineStatus ( int magazine ) { if ( magazines == null ) return 0 ; Magazine m = magazines . get ( magazine , null ) ; if ( m == null ) { return - 1 ; } return m . rounds ;
getLocalization: public String getLocalization ( ) { return localization ;
computeSize: protected void computeSize ( ) { String longest = mXAxis . getLongestLabel ( ) ; mAxisLabelPaint . setTypeface ( mXAxis . getTypeface ( ) ) ; mAxisLabelPaint . setTextSize ( mXAxis . getTextSize ( ) ) ; final FSize labelSize = Utils . calcTextSize ( mAxisLabelPaint , longest ) ; final float labelWidth = labelSize . width ; final float labelHeight = Utils . calcTextHeight ( mAxisLabelPaint , "Q" ) ; final FSize labelRotatedSize = Utils . getSizeOfRotatedRectangleByDegrees ( labelWidth , labelHeight , mXAxis . getLabelRotationAngle ( ) ) ; mXAxis . mLabelWidth = Math . round ( labelWidth ) ; mXAxis . mLabelHeight = Math . round ( labelHeight ) ; mXAxis . mLabelRotatedWidth = Math . round ( labelRotatedSize . width ) ; mXAxis . mLabelRotatedHeight = Math . round ( labelRotatedSize . height ) ; FSize . recycleInstance ( labelRotatedSize ) ; FSize . recycleInstance ( labelSize ) ;
getPerimeter: void getPerimeter ( ) { assertEquals ( 62.83185307179586 , circle . getPerimeter ( ) , DELTA ) ;
all: public ApiCollection < PackageGroup > all ( String shopKey , String countryCode , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < PackageGroup > responseModel = ( Class < PackageGroup > ) ( Class < ? > ) PackageGroup . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries/%s/package-groups" , shopKey , countryCode ) , query , null , responseModel ) ;
getBeepManager: No method body
act: public void act ( float delta ) { super . act ( delta ) ; timer -= delta ; blinky += delta ; if ( timer <= 0 )
dispose: public void dispose ( ) { if ( shaderProgram != null )
setMessage: public void setMessage ( String message ) { this . message = message ;
discard: public void discard ( ) { this . setVisible ( false ) ;
getLength: public int getLength ( ) { return length ;
checkItems: private boolean checkItems ( PlayerData playerData ) { PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; float w = 0 ; if ( ! canTake ( playerData ) ) { return false ; } return false ;
init: public void init ( ) { instance = this ;
setOnDateChangedListener: public DatePicker setOnDateChangedListener ( OnDateChangedListener listener ) { mOnDateChangedListener = listener ; return this ;
getClassName: public String getClassName ( ) { return className ;
toEntityKey: public static String toEntityKey ( String formName ) { return formName ;
setDeleteUrl: public void setDeleteUrl ( String deleteUrl ) { this . deleteUrl = deleteUrl ;
isActive: public boolean isActive ( ) { return active ;
setEntityPageAttribute: public CRUDControllerConfiguration < D , E , F > setEntityPageAttribute ( PageAttr < Page < E > > entityPageAttribute ) { this . entityPageAttribute = entityPageAttribute ; return this ;
getHighlightCircleStrokeWidth: No method body
addPoints: public void addPoints ( Team team , int pointsValue ) { ObjectMap < Team , Integer > points = getGameMode ( ) . getPoints ( ) ; if ( points . get ( team ) == null )
addPerson: No method body
requiredArgs: public int requiredArgs ( ) { return 0 ;
cancelSpawn: public void cancelSpawn ( Client client ) { ServerSettings ss = BrainOutServer . Settings ; switch ( ss . getRespawnKind ( ) )
onClick: public void onClick ( View v ) { mMenuPopWindow . dismiss ( ) ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < Merchant > responseEntity = this . api . merchants ( ) . all ( options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/MerchantAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( Merchant entity : responseEntity . getEntities ( ) ) {
runTest: public void runTest ( ) { WatchMessage msg = new WatchMessage ( ) ; msg . setSignature ( "w.core.WatchTarget#run" ) ; Assertions . assertTrue ( swapper . swap ( msg ) ) ; target . run ( ) ;
run: public void run ( ) { final Runnable doneF = this :: done ; ps . pushMenu ( new FadeInMenu ( 0.5f , ( ) ->
markNotificationAsRead: public Object markNotificationAsRead ( @ PathVariable ( name = ORGANIZATIONID , required = false ) Long organizationId , @ PathVariable ( USERID ) Long userId , @ RequestParam ( "unreadNotifications" ) String unreadNotifications ) { debug ( "[markNotificationAsRead] UserId: {} OrgId: {}" , userId , organizationId ) ; markAsRead ( unreadNotifications , userId ) ; return ResponseEntity . status ( HttpStatus . OK ) . body ( "Successfully marked notifications as read!" ) ;
getCircleColor: public int getCircleColor ( int index ) { return mCircleColors . get ( index ) ;
beginLaunching: private void beginLaunching ( ) { launching = true ;
testDeleteProperty: public void testDeleteProperty ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shopCategories ( ) . deleteProperty ( "acme" , "acme" , 1 , "acme" , options ) ;
triggerRebirth: public static void triggerRebirth ( Context context , Intent ... nextIntents ) { if ( nextIntents . length < 1 ) { throw new IllegalArgumentException ( "intents cannot be empty" ) ; } nextIntents [ 0 ] . addFlags ( FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK ) ; Intent intent = new Intent ( context , ProcessPhoenix . class ) ; intent . addFlags ( FLAG_ACTIVITY_NEW_TASK ) ; intent . putParcelableArrayListExtra ( KEY_RESTART_INTENTS , new ArrayList < > ( Arrays . asList ( nextIntents ) ) ) ; intent . putExtra ( KEY_MAIN_PROCESS_PID , Process . myPid ( ) ) ; context . startActivity ( intent ) ;
refreshResources: private void refreshResources ( List < MarketService . MarketItemEntry > entries ) { resourcesAvailable . clearChildren ( ) ; ObjectMap < Resource , Integer > amounts = new ObjectMap < > ( ) ; for ( MarketService . MarketItemEntry entry : entries ) { ConsumableRecord r = MarketUtils . MarketObjectToConsumableRecord ( entry . name , entry . payload , entry . amount ) ; if ( r == null ) continue ; if ( ! ( r . getItem ( ) . getContent ( ) instanceof Resource ) ) continue ; Resource rr = ( ( Resource ) r . getItem ( ) . getContent ( ) ) ; amounts . put ( rr , amounts . get ( rr , 0 ) + r . getAmount ( ) ) ; } itemsToCraft . clearChildren ( ) ; renderItemsToCraft ( itemsToCraft , amounts ) ; for ( ObjectMap . Entry < Resource , Integer > amount : amounts )
authorized: private void authorized ( LoginService loginService , LoginService . AccessToken token , String account , String credential , LoginService . Scopes scopes ) { loginService . setCurrentAccessToken ( token ) ; final GameUser user = BrainOutClient . Env . getGameUser ( ) ; GameUser . Account account_ = user . getAccounts ( ) . getAccount ( ) ; if ( account_ == null ) { complete ( Request . Result . failed , "no account" ) ; return ; } if ( StoreAccessToken ( ) ) { account_ . setAccessToken ( token . get ( ) ) ; user . write ( ) ; } BrainOutClient . ClientController . setMyAccount ( account ) ; complete ( Request . Result . success , "" ) ;
buildRoute: public Single < routerrpc . RouterOuterClass . BuildRouteResponse > buildRoute ( routerrpc . RouterOuterClass . BuildRouteRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . buildRoute ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
act: public void act ( float delta ) { super . act ( delta ) ; actionList . processActions ( delta ) ;
release: public void release ( ) { super . release ( ) ; free ( ) ;
getCreated: public static Boolean getCreated ( Context context ) { return getBoolean ( SETTINGS , context , CREATED ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { trip2BActionPerformed ( evt ) ;
sendToUserChannel: public boolean sendToUserChannel ( Long userId , String channelName , Object payload , Map < String , Object > headers ) { checkChannelName ( channelName ) ; String userEmail = userRepository . findUserEmailByUserId ( userId ) ; sendToUserChannel ( userEmail , channelName , payload , headers ) ; return true ;
saveFirstLoginToLocal: public static void saveFirstLoginToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_FIRST_LOGIN , value ) ;
getWeapon: public Instrument getWeapon ( ) { return weapon ;
createNew: No method body
setFormLineWidth: public void setFormLineWidth ( float formLineWidth ) { mFormLineWidth = formLineWidth ;
openFileFromSDCard: private void openFileFromSDCard ( String fileDir , String fileName , String mimeType ) { if ( StringUtils . isEmpty ( mimeType ) ) { mimeType = "application/vnd.android.package-archive" ; } File file = new File ( fileDir , fileName ) ; Intent intent = new Intent ( ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setDataAndType ( Uri . fromFile ( file ) , mimeType ) ; mContext . startActivity ( intent ) ;
release: public void release ( ) { if ( inited )
update: No method body
resetSkin: public void resetSkin ( ) { clearToOriginalArrachments ( ) ; data . setSkin ( info . skin ) ; data . updateSkin ( ) ; updateOriginalAttachments ( ) ; resetAnimation ( ) ;
update: public void update ( float dt ) { super . update ( dt ) ; check -= dt ; if ( check > 0 ) return ; check = 0.05f ; Map watcher = Map . GetWatcherMap ( Map . class ) ; if ( watcher == null ) return ; if ( getMap ( ) == watcher )
setVisible: No method body
deleteById: No method body
getRelatedItems: public Array < String > getRelatedItems ( ) { return relatedItems ;
onCommand: public boolean onCommand ( final CommandSender sender , final Command command , final String label , final String [ ] args ) { if ( args . length < 1 ) { sender . sendMessage ( String . format ( "%sNot enough arguments provided" , ChatColor . RED ) ) ; return true ; } final String target = args [ 0 ] ; sender . sendMessage ( String . format ( "%sFetching player list for server '%s'..." , ChatColor . GRAY , target ) ) ; service . publish ( new FetchPlayerListConversation . Request ( target ) , FetchPlayerListConversation . Response . class , new MessageTarget ( Message . TargetType . DIRECT , target ) ) . onResponse ( ( request , context ) -> { final FetchPlayerListConversation . Response response = context . getResponse ( ) ; final List < PlayerDTO > players = response . players ; sender . sendMessage ( String . format ( "%s Players online on %s: %s" , ChatColor . GREEN , response . request . server , Arrays . toString ( players . toArray ( ) ) ) ) ; } ) . onExcept ( ( throwable , errorInformationHolder ) -> { sender . sendMessage ( String . format ( "%sAn error occurred whilst fetching player list for %s: %s" , ChatColor . RED , target , errorInformationHolder . getErrorDescription ( ) ) ) ; } ) . onTimeout ( ( request , messageContexts ) -> { sender . sendMessage ( String . format ( "%sTarget server did not respond." , ChatColor . RED ) ) ; } ) . waitFor ( 1000 , TimeUnit . MILLISECONDS ) . overrideHandlers ( ) ; return true ;
onClickConfirm: public void onClickConfirm ( String verifyCode , String random ) { if ( StringUtils . isEmpty ( verifyCode ) ) { LogUtils . e ( TAG , "没有输入图形验证码" ) ; return ; } if ( mHelper != null ) {
search: default Page < T > search ( int page , int size , String sortField , String sortDirection ) { return SearchableFunctionalRepositoryWithLongId . super . search ( DEFAULT_SCOPE , page , size , sortField , sortDirection ) ;
setMenuItem: public CRUDControllerConfiguration < D , E , F > setMenuItem ( String menuItem ) { this . menuItem = menuItem ; return this ;
runCommandToByteArray: public byte [ ] runCommandToByteArray ( String command ) { return commandToByteArray ( command ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
position: public long position ( Blob pattern , long start ) throws SQLException { return 0 ;
getOffsetRotation: public float getOffsetRotation ( ) { return offsetRotation ;
onDetachedFromWindow: protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; getViewTreeObserver ( ) . removeGlobalOnLayoutListener ( this ) ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < Promotion > responseEntity = this . api . promotions ( ) . all ( options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/PromotionAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( Promotion entity : responseEntity . getEntities ( ) ) {
with: public static HttpUtils with ( Context context ) { return new HttpUtils ( context ) ;
error: public void error ( String reason ) { button . setDisabled ( false ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; spriteName = jsonData . getString ( "sname" , ( ( Sprite ) getContent ( ) ) . getSpriteName ( ) ) ; scale = jsonData . getFloat ( "sscale" , ( ( Sprite ) getContent ( ) ) . getScale ( ) ) ; flipX = jsonData . getBoolean ( "flipX" , false ) ; flipY = jsonData . getBoolean ( "flipY" , false ) ; cache = jsonData . getBoolean ( "cache" , true ) ;
acquireSpawn: public SpawnMode acquireSpawn ( Client client , Team team ) { return SpawnMode . allowed ;
getMax: No method body
touchUp: public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { pop ( ) ;
runQueries: public boolean runQueries ( String ... queries ) { return runQueries ( false , false , queries ) ;
isExternal: boolean isExternal ( WayPointMap map ) { WayPoint wayPoint = map . getWayPointById ( wayPointId ) ; if ( wayPoint == null ) return true ; int myChunkX = ( int ) x / Constants . Core . CHUNK_SIZE , myChunkY = ( int ) y / Constants . Core . CHUNK_SIZE ; int neighborChunkX = ( int ) wayPoint . x / Constants . Core . CHUNK_SIZE , neighborChunkY = ( int ) wayPoint . y / Constants . Core . CHUNK_SIZE ; return myChunkX != neighborChunkX || myChunkY != neighborChunkY ;
getCircleRadius: public float getCircleRadius ( ) { return mCircleRadius ;
isCutterEnabled: public boolean isCutterEnabled ( ) { return cutterEnabled ;
squareFive: void squareFive ( ) { assertEquals ( 3 , SquareFive . squareFive ( List . of ( 3 , 1 , 4 ) ) ) ; assertEquals ( 1 , SquareFive . squareFive ( List . of ( 1 ) ) ) ; assertEquals ( 0 , SquareFive . squareFive ( List . of ( 5 ) ) ) ;
isLaunching: public boolean isLaunching ( ) { return launching ;
deleteBulk: public void deleteBulk ( String shopKey , List < Redirect > model ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/redirects/bulk" , shopKey ) , null , null , null , model ) ;
updateWorkflowGroup: public WorkflowGroupResponse updateWorkflowGroup ( final String id , final WorkflowGroupRequest request ) throws NovuNetworkException , IOException { return restHandler . extractResponse ( this . workflowGroupApi . updateWorkflowGroup ( id , request ) . execute ( ) ) ;
received: public boolean received ( final LoadMapMsg msg ) { if ( ! validateMod ( ) ) return true ; if ( ! msg . map . matches ( "^[A-Za-z0-9_-]+\\.map$" ) ) return true ; BrainOutServer . PostRunnable ( ( ) -> { BrainOutServer . Controller . setMapSource ( new SingleMapSource ( "maps/" + msg . map , GameMode . ID . editor ) ) ; BrainOutServer . PackageMgr . unloadPackages ( true ) ; BrainOutServer . Controller . next ( null ) ; } ) ; return true ;
setContentView: public View setContentView ( int layoutId ) { View rootView = LayoutInflater . from ( mContext ) . inflate ( layoutId , null , false ) ; setContentView ( rootView ) ; return rootView ;
getContact: public ContactData getContact ( Contact contact ) { return contacts [ contact . ordinal ( ) ] ;
read: public void read ( Json json , JsonValue jsonData ) { this . width = jsonData . getFloat ( "_w" ) ; this . height = jsonData . getFloat ( "_h" ) ;
conversationId: public ConversationUID conversationId ( ) { return conversationUID ;
stayOnTop: public boolean stayOnTop ( ) { return onTop ;
expectedName: void expectedName ( ) { assertThat ( CodegenTestServiceGreeterDefinitions . SERVICE_NAME ) . isEqualTo ( "CodegenTestServiceGreeter" ) ; assertThat ( GreeterWithoutExplicitNameDefinitions . SERVICE_NAME ) . isEqualTo ( "GreeterWithoutExplicitName" ) ; assertThat ( MyExplicitNameDefinitions . SERVICE_NAME ) . isEqualTo ( "MyExplicitName" ) ;
toString: public String toString ( ) { return name != null ? name : super . toString ( ) ;
lockUpdate: public boolean lockUpdate ( ) { return true ;
buttonStyleYes: public String buttonStyleYes ( ) { return "button-green" ;
isSelected: public boolean isSelected ( ) { return selected ;
update: public void update ( float dt ) { super . update ( dt ) ; if ( mode != null )
getUserRolesForOrganization: public List < UserRole > getUserRolesForOrganization ( Long organizationId ) { return repositories . secure . userRole . search ( organizationId , UserRoleSpecification . getUserRolesForOrganizations ( ) ) ;
keyTyped: public void keyTyped ( TextField textField , char c ) { filter = filerField . getText ( ) . toLowerCase ( ) ; updateContent ( ) ;
isBrainPass: public boolean isBrainPass ( ) { return getInfoBoolean ( "bp" , false ) ;
getTriangles: public short [ ] getTriangles ( ) { return triangles ;
sendDelayedEvent: public void sendDelayedEvent ( Event event ) { if ( event == null ) return ; synchronized ( futurePairs )
hasCache: No method body
removeOutgoingInviteRequest: public void removeOutgoingInviteRequest ( String clanId ) { myOutgoingInviteRequests . remove ( clanId ) ;
getChildView: private View getChildView ( int position , SelectEntity entity ) { if ( entity == null ) { return null ; } if ( mChildViewCreator != null ) { return mChildViewCreator . getView ( position , entity ) ; } if ( mChildLayout != 0 ) { View childView = mInflater . inflate ( mChildLayout , null , false ) ; if ( childView instanceof TextView ) { ( ( TextView ) childView ) . setText ( entity . getTitle ( ) ) ; } return childView ; } return null ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesOpen17ActionPerformed ( evt ) ;
definitions: public Stream < TestDefinition > definitions ( ) { String debugId = "my-id" ; return Stream . of (
getGroup: public String getGroup ( ) { return group ;
getView: public View getView ( int position , View convertView , @ NotNull ViewGroup parent ) { View view = super . getView ( position , convertView , parent ) ; TextView text1 = view . findViewById ( android . R . id . text1 ) ; TextView text2 = view . findViewById ( android . R . id . text2 ) ; text1 . setText ( commandsList . get ( position ) ) ; text1 . setTextColor ( themedTextColor ) ; text1 . setTextSize ( 16 ) ; String summary ; if ( position >= size ) { summary = "custom command" ; } else { summary = commandsSummary . get ( position ) ; } text2 . setText ( summary ) ; text2 . setTextColor ( themedTextColor ) ; text2 . setTextSize ( 12 ) ; view . setScrollContainer ( true ) ; view . setScrollbarFadingEnabled ( true ) ; return view ;
end: No method body
getPackagePath: public String getPackagePath ( ) { return BrainOut . Env . getExternalPath ( packageFilename ( ) ) ;
getDimension: public String getDimension ( ) { return data . getDimension ( ) ;
renderItems: private void renderItems ( Table items , List < GameService . Room > rooms , ObjectMap < String , GameUser . WorkshopItem > workshop ) { connectButton . setText ( L . get ( "MENU_CONNECT" ) ) ; connectButton . setDisabled ( false ) ; roomButtons = new ButtonGroup < > ( ) ; roomButtons . setMaxCheckCount ( 1 ) ; roomButtons . setMinCheckCount ( 1 ) ; for ( GameService . Room room : rooms )
renderButton: protected void renderButton ( Table buttons , TextButton btn ) { buttons . add ( btn ) . height ( getButtonHeight ( ) ) . expandX ( ) . fillX ( ) . uniform ( ) ;
getRequestSerde: public Serde < REQ > getRequestSerde ( ) { return requestSerde ;
getYChartMax: public float getYChartMax ( ) { return mYAxis . mAxisMaximum ;
getMapHeight: public int getMapHeight ( ) { try
deserialize: public T deserialize ( ByteBuffer byteBuffer ) { try {
getHeight: public float getHeight ( ) { return height ;
getFormatSize: public static String getFormatSize ( double size ) { double kiloByte = size / 1024 ; if ( kiloByte < 1 ) { return size + "B" ; } double megaByte = kiloByte / 1024 ; if ( megaByte < 1 ) { BigDecimal result1 = new BigDecimal ( Double . toString ( kiloByte ) ) ; return result1 . setScale ( 2 , BigDecimal . ROUND_HALF_UP ) . toPlainString ( ) + "KB" ; } double gigaByte = megaByte / 1024 ; if ( gigaByte < 1 ) { BigDecimal result2 = new BigDecimal ( Double . toString ( megaByte ) ) ; return result2 . setScale ( 2 , BigDecimal . ROUND_HALF_UP ) . toPlainString ( ) + "MB" ; } double teraBytes = gigaByte / 1024 ; if ( teraBytes < 1 ) { BigDecimal result3 = new BigDecimal ( Double . toString ( gigaByte ) ) ; return result3 . setScale ( 2 , BigDecimal . ROUND_HALF_UP ) . toPlainString ( ) + "GB" ; } BigDecimal result4 = new BigDecimal ( teraBytes ) ; return result4 . setScale ( 2 , BigDecimal . ROUND_HALF_UP ) . toPlainString ( )
drawForm: protected void drawForm ( Canvas c , float x , float y , LegendEntry entry , Legend legend ) { if ( entry . formColor == ColorTemplate . COLOR_SKIP || entry . formColor == ColorTemplate . COLOR_NONE || entry . formColor == 0 ) return ; int restoreCount = c . save ( ) ; Legend . LegendForm form = entry . form ; if ( form == Legend . LegendForm . DEFAULT ) form = legend . getForm ( ) ; mLegendFormPaint . setColor ( entry . formColor ) ; final float formSize = Utils . convertDpToPixel ( Float . isNaN ( entry . formSize ) ? legend . getFormSize ( ) : entry . formSize ) ; final float half = formSize / 2f ; switch ( form ) { case NONE : break ; case EMPTY : break ; case DEFAULT : case CIRCLE : mLegendFormPaint . setStyle ( Paint . Style . FILL ) ; c . drawCircle ( x + half , y , half , mLegendFormPaint ) ; break ; case SQUARE : mLegendFormPaint . setStyle ( Paint . Style . FILL ) ; c . drawRect ( x , y - half , x + formSize , y + half , mLegendFormPaint ) ; break ; case LINE : { final float formLineWidth = Utils . convertDpToPixel ( Float . isNaN ( entry . formLineWidth ) ? legend . getFormLineWidth ( ) : entry . formLineWidth ) ; final DashPathEffect formLineDashEffect = entry . formLineDashEffect == null ? legend . getFormLineDashEffect ( ) : entry . formLineDashEffect ; mLegendFormPaint . setStyle ( Paint . Style . STROKE ) ; mLegendFormPaint . setStrokeWidth ( formLineWidth ) ; mLegendFormPaint . setPathEffect ( formLineDashEffect ) ; mLineFormPath . reset ( ) ; mLineFormPath . moveTo ( x , y ) ; mLineFormPath . lineTo ( x + formSize , y ) ; c . drawPath ( mLineFormPath , mLegendFormPaint ) ; } break ; } c . restoreToCount ( restoreCount ) ;
setNewAccountForEnvironment: public void setNewAccountForEnvironment ( ) { removeAccount ( ) ; setAccount ( getCurrentEnvironment ( ) , newAccount ( ) ) ;
addPermission: private void addPermission ( Table data , String id , String title ) { CheckBox option = new CheckBox ( L . get ( title ) , BrainOutClient . Skin , "checkbox-default" ) ; data . add ( option ) . expandX ( ) . left ( ) . pad ( 4 , 16 , 4 , 16 ) . row ( ) ; if ( this . permissions . contains ( id ) ) { option . setChecked ( true ) ; } option . addListener ( new ClickOverListener ( )
isGlobal: default boolean isGlobal ( ) { return getOrganizationId ( ) == null ;
getCurrentDay: private long getCurrentDay ( ) { return getCurrentTime ( ) / ( ( DailyQuest ) getQuest ( ) ) . getCycle ( ) ;
autoOpenShopOnSpawn: public boolean autoOpenShopOnSpawn ( ) { return true ;
getPlayerInstruments: public ObjectMap < Integer , InstrumentInfo > getPlayerInstruments ( ) { return playerInstruments ;
setEntityKey: public void setEntityKey ( String entityKey ) { this . entityKey = entityKey ;
addLabel: private void addLabel ( Table line , String text , XmlReader . Element item , Skin skin , String defaultStyle ) { String style = item . getAttribute ( "style" , defaultStyle ) ; Label label ; try { label = new Label ( text , skin , style ) ; } catch ( GdxRuntimeException ignored ) { label = new Label ( text , skin , defaultStyle ) ; } addItem ( line , label , item ) ; if ( item . getBooleanAttribute ( "expand" , false ) ) { label . setWrap ( true ) ; } String align = item . getAttribute ( "align" , null ) ; if ( align != null )
showWaitText: public void showWaitText ( ) { setEnabled ( false ) ; setText ( mWaitingText ) ;
getContent: public String getContent ( ) { return null ; }
fetchWeapon: public void fetchWeapon ( ) { PlayerData playerData = getPlayerData ( ) ; if ( playerData == null ) return ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return ; ConsumableRecord record = poc . getCurrentInstrumentRecord ( ) ; if ( record == null ) return ; if ( ! ( record . getItem ( ) instanceof InstrumentConsumableItem ) ) return ; InstrumentData instrumentData = ( ( InstrumentConsumableItem ) record . getItem ( ) ) . getInstrumentData ( ) ; if ( ! ( instrumentData instanceof WeaponData ) ) return ; WeaponData weaponData = ( ( WeaponData ) instrumentData ) ; ServerBotWeaponComponent sw = instrumentData . getComponent ( ServerBotWeaponComponent . class ) ; if ( sw == null ) { sw = new ServerBotWeaponComponent ( weaponData , record ) ; sw . init ( ) ; instrumentData . addComponent ( sw ) ; } WeaponSlotComponent slot = sw . getSlot ( Constants . Properties . SLOT_PRIMARY ) ; if ( slot == null ) return ; slot . doFetch ( ) ;
emails: public EmailService emails ( ) { EmailService service = this . getService ( "com.scayle.adminapi.service.EmailService" ) ; return service ;
removeFirstTwoCharsIfStringBuilder: public void removeFirstTwoCharsIfStringBuilder ( ) { assertEquals ( "Hello World!" , RemoveFirstTwoCharsIf . removeFirstTwoCharsIfStringBuilder ( "Hello World!" ) ) ; assertEquals ( "od World!" , RemoveFirstTwoCharsIf . removeFirstTwoCharsIfStringBuilder ( "Good World!" ) ) ; assertEquals ( "H" , RemoveFirstTwoCharsIf . removeFirstTwoCharsIfStringBuilder ( "Ho" ) ) ; assertEquals ( "e" , RemoveFirstTwoCharsIf . removeFirstTwoCharsIfStringBuilder ( "Ne" ) ) ; assertEquals ( "" , RemoveFirstTwoCharsIf . removeFirstTwoCharsIfStringBuilder ( "Y" ) ) ; assertEquals ( "H" , RemoveFirstTwoCharsIf . removeFirstTwoCharsIfStringBuilder ( "H" ) ) ; assertEquals ( "" , RemoveFirstTwoCharsIf . removeFirstTwoCharsIfStringBuilder ( "" ) ) ;
deleteOne: No method body
emitEvent: public < T > boolean emitEvent ( AbstractApplicationEvent < T > event , T object ) { debug ( "[emitEvent] event: {}" , event ) ; listeners . getOrDefault ( event , empty ) . forEach ( a -> { if ( a . getT2 ( ) == null ) { a . getT1 ( ) . accept ( object , null ) ; } else if ( a . getT3 ( ) == null ) { a . getT1 ( ) . accept ( object , a . getT2 ( ) ) ; } else if ( a . getT4 ( ) == null ) { a . getT1 ( ) . accept ( object , a . getT2 ( ) , a . getT3 ( ) ) ; } else if ( a . getT5 ( ) == null ) { a . getT1 ( ) . accept ( object , a . getT2 ( ) , a . getT3 ( ) , a . getT4 ( ) ) ; } else { a . getT1 ( ) . accept ( object , a . getT2 ( ) , a . getT3 ( ) , a . getT4 ( ) , a . getT5 ( ) ) ; } } ) ; return true ;
getUserId: public Long getUserId ( ) { return UserProvider . getFromContext ( ) . map ( OrganizationUser :: getUser ) . map ( User :: getId ) . orElse ( - 1L ) ;
test: public void test ( ) { LargeValueFormatter formatter = new LargeValueFormatter ( ) ; String result = formatter . getFormattedValue ( 5f , null ) ; assertEquals ( "5" , result ) ; result = formatter . getFormattedValue ( 5.5f , null ) ; assertEquals ( "5.5" , result ) ; result = formatter . getFormattedValue ( 50f , null ) ; assertEquals ( "50" , result ) ; result = formatter . getFormattedValue ( 50.5f , null ) ; assertEquals ( "50.5" , result ) ; result = formatter . getFormattedValue ( 500f , null ) ; assertEquals ( "500" , result ) ; result = formatter . getFormattedValue ( 1100f , null ) ; assertEquals ( "1.1k" , result ) ; result = formatter . getFormattedValue ( 10000f , null ) ; assertEquals ( "10k" , result ) ; result = formatter . getFormattedValue ( 10500f , null ) ; assertEquals ( "10.5k" , result ) ; result = formatter . getFormattedValue ( 100000f , null ) ; assertEquals ( "100k" , result ) ; result = formatter . getFormattedValue ( 1000000f , null ) ; assertEquals ( "1m" , result ) ; result = formatter . getFormattedValue ( 1500000f , null ) ; assertEquals ( "1.5m" , result ) ; result = formatter . getFormattedValue ( 9500000f , null ) ; assertEquals ( "9.5m" , result ) ; result = formatter . getFormattedValue ( 22200000f , null ) ; assertEquals ( "22.2m" , result ) ; result = formatter . getFormattedValue ( 222000000f , null ) ; assertEquals ( "222m" , result ) ; result = formatter . getFormattedValue ( 1000000000f , null ) ; assertEquals ( "1b" , result ) ; result = formatter . getFormattedValue ( 9900000000f , null ) ; assertEquals ( "9.9b" , result ) ; result = formatter . getFormattedValue ( 99000000000f , null ) ; assertEquals ( "99b" , result ) ; result = formatter . getFormattedValue ( 99500000000f , null ) ; assertEquals ( "99.5b" , result ) ; result = formatter . getFormattedValue ( 999000000000f , null ) ; assertEquals ( "999b" , result ) ; result = formatter . getFormattedValue ( 1000000000000f , null ) ; assertEquals ( "1t" , result ) ; formatter . setSuffix ( new String [ ] { "" , "k" , "m" , "b" , "t" , "q" } ) ; result = formatter . getFormattedValue ( 1000000000000000f , null ) ; assertEquals ( "1q" , result ) ; result = formatter . getFormattedValue ( 1100000000000000f , null ) ; assertEquals ( "1.1q" , result ) ; result = formatter . getFormattedValue ( 10000000000000000f , null ) ; assertEquals ( "10q" , result ) ; result = formatter . getFormattedValue ( 13300000000000000f , null ) ; assertEquals ( "13.3q" , result ) ; result = formatter . getFormattedValue ( 100000000000000000f , null ) ; assertEquals ( "100q" , result ) ;
generate: private boolean generate ( InstrumentAnimationComponentData iac ) { Map map = getMap ( ) ; if ( map == null ) return false ; World world = map . getPhysicWorld ( ) ; if ( world == null ) return false ; BoundingBoxAttachment bb = ( ( BoundingBoxAttachment ) animationSlot . getAttachment ( ) ) ; if ( animationSlot . getBone ( ) . getWorldScaleX ( ) == 0 || animationSlot . getBone ( ) . getWorldScaleY ( ) == 0 ) { return false ; } Bone bone = animationSlot . getBone ( ) ; float v [ ] = new float [ bb . getVertices ( ) . length ] ; Physics . ComputeVertices ( animationSlot , bb , v ) ; BodyDef def = new BodyDef ( ) ; def . type = BodyDef . BodyType . StaticBody ; angleOffset = bone . getWorldRotation ( ) ; flipX = bone . getWorldFlipX ( ) ; physicsBody = world . createBody ( def ) ; physicsBody . setTransform ( ( bone . getWorldX ( ) ) * Constants . Physics . SCALE , ( bone . getWorldY ( ) ) * Constants . Physics . SCALE , 0 ) ; physicsBody . setLinearVelocity ( 0 , 0 ) ; physicsBody . setGravityScale ( 0 ) ; physicsBody . setUserData ( this ) ; physicsBody . setFixedRotation ( true ) ; generatedDimension = map . getDimension ( ) ; PolygonShape poly = new PolygonShape ( ) ; poly . set ( v ) ; Fixture physicsBodyFixture = physicsBody . createFixture ( poly , 0.25f ) ; physicsBodyFixture . setUserData ( this ) ; physicsBodyFixture . setFilterData ( SHIELD_FILTER ) ; return true ;
updateWhite: void updateWhite ( ) { White white = White . builder ( ) . id ( 100L ) . title ( "unitTest" ) . path ( "/unit" ) . remark ( "这时一条单元测试更新的数据" ) . build ( ) ; whiteService . updateWhite ( white ) ; log . info ( "更新白名单方法测试成功！" ) ;
addActivity: public void addActivity ( Activity activity ) { if ( activityStack == null ) { activityStack = new Stack < > ( ) ; } activityStack . add ( activity ) ;
getLogger: default Logger getLogger ( ) { return getLogger ( true ) ;
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "sname" , sound ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesStop5ActionPerformed ( evt ) ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; Avatars . Reset ( ) ;
received: public boolean received ( final PlaceCardOnTableFromHand msg ) { notifyCardEvent ( msg ) ; return true ;
renderBody: private void renderBody ( Table body ) { { Image image ; if ( avatar == null ) { image = new Image ( BrainOutClient . getRegion ( "default-avatar" ) ) ; } else { image = new Image ( ) ; Avatars . Get ( avatar , ( has , avatar ) -> { if ( ! has ) { image . setDrawable ( BrainOutClient . Skin , "default-avatar" ) ; return ; } image . setDrawable ( new TextureRegionDrawable ( new TextureRegion ( avatar ) ) ) ; } ) ; } image . setBounds ( 4 , 4 , 120 , 120 ) ; image . setTouchable ( Touchable . disabled ) ; body . add ( image ) . pad ( 32 ) . row ( ) ; } {
read: public boolean read ( JSONObject o ) { content = o . optString ( "c" , null ) ; id = o . optString ( "id" , null ) ; location = o . optString ( "l" , null ) ; if ( content == null || id == null || location == null ) { return false ; } JSONObject items = o . optJSONObject ( "i" ) ; if ( items != null ) { if ( this . items == null ) { this . items = new ObjectMap < > ( ) ; } else { this . items . clear ( ) ; } for ( String key : items . keySet ( ) ) { Matcher matcher = KEY_PATTERN . matcher ( key ) ; if ( ! matcher . matches ( ) ) { return false ; } String map = matcher . group ( 1 ) ; int layer ; int x ; int y ; try { layer = Integer . parseInt ( matcher . group ( 2 ) ) ; x = Integer . parseInt ( matcher . group ( 3 ) ) ; y = Integer . parseInt ( matcher . group ( 4 ) ) ; } catch ( NumberFormatException e ) { return false ; } ObjectAtLocation obj = new ObjectAtLocation ( key , masterMap , map , layer , x , y ) ; JSONObject item = items . optJSONObject ( key ) ; if ( item == null ) return false ; if ( ! obj . read ( item ) ) return false ; this . items . put ( key , obj ) ; } } return true ;
isTeamBeingDominated: private boolean isTeamBeingDominated ( Team team ) { s_flagsCount . clear ( ) ; for ( Map map : Map . All ( ) ) { for ( ActiveData active : map . getActivesForTag ( Constants . ActiveTags . FLAG , false ) ) { FlagData flag = ( ( FlagData ) active ) ; if ( flag . getState ( ) == FlagData . State . normal && flag . getTeam ( ) != null ) { s_flagsCount . put ( flag . getTeam ( ) , s_flagsCount . get ( flag . getTeam ( ) , 0 ) + 1 ) ; } } } if ( s_flagsCount . size == 0 ) return false ; if ( ! s_flagsCount . containsKey ( team ) ) return true ; int minValue = 99999 , maxValue = 0 ; Team minTeam = null ; for ( ObjectMap . Entry < Team , Integer > point : s_flagsCount ) { if ( point . value > maxValue ) { maxValue = point . value ; } if ( point . value < minValue ) { minValue = point . value ; minTeam = point . key ; } } return minValue != maxValue && team == minTeam ;
toHex: public static String toHex ( ByteBuffer bytes ) { char [ ] hexChars = new char [ bytes . limit ( ) * 2 ] ; for ( int j = 0 ; j < bytes . limit ( ) ; j ++ ) { int v = bytes . get ( ) & 0xFF ; hexChars [ j * 2 ] = hexArray [ v > > > 4 ] ; hexChars [ j * 2 + 1 ] = hexArray [ v & 0x0F ] ; } return new String ( hexChars ) ;
checkCustomInputAcceptContentType: void checkCustomInputAcceptContentType ( ) { assertThatDiscovery ( new CodegenTest . RawInputOutput ( ) )
execute: public String execute ( String [ ] args , Client client ) { String path = args [ 1 ] ; try { Files . createDirectory ( Paths . get ( path ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "Cannot create directory" ; } Set < String > dimensions = new HashSet < > ( ) ; for ( Map map : Map . SafeAll ( ) ) { dimensions . add ( map . getDimension ( ) ) ; for ( ObjectMap . Entry < String , byte [ ] > entry : map . getExtensions ( ) ) { try { Files . write ( Paths . get ( path + "/" + entry . key ) , entry . value ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "Cannot write file " + entry . key ; } } map . getExtensions ( ) . clear ( ) ; } final ServerController . MapSaveResult result = BrainOutServer . Controller . saveAll ( BrainOutServer . Controller . getSuitableDimensions ( client ) , Data . ComponentWriter . TRUE , true , - 1 , Runnable :: run ) ; if ( result == null ) { return "Map: cannot serialize map" ; } byte [ ] map = result . serialize ( ) ; try { Files . write ( Paths . get ( path + "/extracted.map" ) , map ) ; } catch ( IOException e ) { return "Cannot write map." ; } return "done" ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { autoControlAux1ActionPerformed ( evt ) ;
run: public AnswerWithSources run ( final String input ) { final Matcher matcher = retrieveSourcesPattern . matcher ( input ) ; if ( matcher . find ( ) ) {
setTrelloBoardName: public void setTrelloBoardName ( String trelloBoardName ) { this . trelloBoardName = trelloBoardName ;
bind: public RestateHttpEndpointBuilder bind ( Object service ) { return this . bind ( RestateEndpoint . discoverServiceDefinitionFactory ( service ) . create ( service ) ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
test_renameTopic: public void test_renameTopic ( ) throws IOException , NovuNetworkException , InterruptedException { TopicResponse topicResponse = new TopicResponse ( ) ; TopicResponseData data = new TopicResponseData ( ) ; data . setId ( "id" ) ; data . setEnvironmentId ( "environmentId" ) ; data . setOrganizationId ( "organizationId" ) ; data . setSubscriberId ( "subscribeId" ) ; data . setTopicId ( "topicId" ) ; data . setTopicKey ( "topickey" ) ; data . setExternalSubscriberId ( "extSubscriberId" ) ; data . setKey ( "ky" ) ; data . setName ( "name" ) ; data . setSubscribers ( Collections . singletonList ( new Object ( ) ) ) ; topicResponse . setData ( data ) ; RenameTopicRequest renameTopicRequest = new RenameTopicRequest ( ) ; renameTopicRequest . setName ( "name" ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 201 ) . setBody ( gson . toJson ( topicResponse ) ) ) ; TopicResponse response = topicHandler . renameTopic ( renameTopicRequest , "topicKey" ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/topics/topicKey" , request . getPath ( ) ) ; assertEquals ( "PATCH" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( topicResponse ) , gson . toJson ( response ) ) ;
getId: public Long getId ( ) { return id ;
hasAnimatedTrees: public boolean hasAnimatedTrees ( ) { GameMode gm = BrainOutClient . ClientController . getGameMode ( ) ; if ( gm == null || gm . getID ( ) != GameMode . ID . free ) { return false ; } return graphicsQuality . getValue ( ) == GRAPHICS_HIGH ;
formatMessage: default String formatMessage ( String format , Object ... arguments ) { FormattingTuple ft = MessageFormatter . arrayFormat ( format , arguments ) ; return ft . getMessage ( ) ;
setTextColor: public void setTextColor ( int textColor ) { this . textColor = textColor ;
getInvokedFunctionArn: public String getInvokedFunctionArn ( ) { return null ;
parseFloat: public float parseFloat ( String s ) { return Float . parseFloat ( s ) ;
getChannelId: public long getChannelId ( ) { return 0 ;
getAssignedDatasource: public Integer getAssignedDatasource ( ) { return assignedDatasource ;
release: public void release ( ) { super . release ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . newRemoteClient , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . remoteClientLeft , this ) ;
value: public float value ( ) { return Math . max ( ( float ) ( this . timer - System . currentTimeMillis ( ) ) / 1000.0f , 0.0f ) ;
initView: protected void initView ( View rootView ) { mRecyclerView = getRecyclerView ( ) ; initRecyclerView ( ) ;
path: public String path ( ) { return getName ( ) + ":" + super . path ( ) ;
learn: public void learn ( ) { int i , j , b , g , r ; int radius , rad , alpha , step , delta , samplepixels ; byte [ ] p ; int pix , lim ; if ( lengthcount < minpicturebytes ) samplefac = 1 ; alphadec = 30 + ( ( samplefac - 1 ) / 3 ) ; p = thepicture ; pix = 0 ; lim = lengthcount ; samplepixels = lengthcount / ( 3 * samplefac ) ; delta = samplepixels / ncycles ; alpha = initalpha ; radius = initradius ; rad = radius > > radiusbiasshift ; if ( rad <= 1 ) rad = 0 ; for ( i = 0 ; i < rad ; i ++ ) radpower [ i ] = alpha * ( ( ( rad * rad - i * i ) * radbias ) / ( rad * rad ) ) ; if ( lengthcount < minpicturebytes ) step = 3 ; else if ( ( lengthcount % prime1 ) != 0 ) step = 3 * prime1 ; else { if ( ( lengthcount % prime2 ) != 0 ) step = 3 * prime2 ; else { if ( ( lengthcount % prime3 ) != 0 ) step = 3 * prime3 ; else step = 3 * prime4 ; } } i = 0 ; while ( i < samplepixels ) {
copyPropertiesInclude: public static void copyPropertiesInclude ( Object from , Object to , String [ ] includsArray ) throws Exception { List < String > includesList = null ; if ( includsArray != null && includsArray . length > 0 ) { includesList = Arrays . asList ( includsArray ) ; } else { return ; } Method [ ] fromMethods = from . getClass ( ) . getDeclaredMethods ( ) ; Method [ ] toMethods = to . getClass ( ) . getDeclaredMethods ( ) ; Method fromMethod = null , toMethod = null ; String fromMethodName = null , toMethodName = null ; for ( int i = 0 ; i < fromMethods . length ; i ++ ) {
getLayout: public GetLayoutResponse getLayout ( final String layoutId ) throws IOException , NovuNetworkException { Response < GetLayoutResponse > response = layoutApi . getLayout ( layoutId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
contains: public boolean contains ( T dataSet ) { for ( T set : mDataSets ) { if ( set . equals ( dataSet ) ) return true ; } return false ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem3ActionPerformed ( evt ) ;
setSearchInactive: private void setSearchInactive ( ) { search . clearChildren ( ) ; search . setBackground ( "form-default" ) ; SearchField searchField = new SearchField ( "search-default" , result -> { Menu . playSound ( MenuSound . select ) ; hideSortingButton = false ; giveItemFilterTitle = null ; giveItemFilter = result . name ; giveItemPayloadFilter = stripQuality ( result . payload ) ; refresh ( true , true ) ; return true ; } ) ; search . add ( searchField ) . expand ( ) . fill ( ) ;
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Brand responseEntity = this . api . brands ( ) . get ( 1 , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/BrandGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
setData: public void setData ( CandleData data ) { mCandleData = data ; notifyDataChanged ( ) ;
translate: public void translate ( final float [ ] transformedPts , Matrix outputMatrix ) { outputMatrix . reset ( ) ; outputMatrix . set ( mMatrixTouch ) ; final float x = transformedPts [ 0 ] - offsetLeft ( ) ; final float y = transformedPts [ 1 ] - offsetTop ( ) ; outputMatrix . postTranslate ( - x , - y ) ;
filterTopics: public FilterTopicsResponse filterTopics ( final FilterTopicsRequest request ) throws IOException , NovuNetworkException { try {
setHeight: public void setHeight ( float height ) { this . height = height ;
clicked: public void clicked ( InputEvent event , float x , float y ) { save ( ) ; close ( ) ;
getEditorGrid: public EditorGrid getEditorGrid ( ) { return editorGrid ;
getStaticData3: public String getStaticData3 ( ) { return staticData3 ;
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Employee employee = ( Employee ) o ; return Objects . equals ( name , employee . name ) && Objects . equals ( lastname , employee . lastname ) && Objects . equals ( socialSecurityCode , employee . socialSecurityCode ) ;
applyFloat: public float applyFloat ( float in ) { return Float . valueOf ( apply ( String . valueOf ( in ) ) ) ;
newInstance: public < T > T newInstance ( Class < T > type ) { return StaticMap . get ( type ) ;
getWaterMass: public double getWaterMass ( ) { return waterMass ;
hasBadge: public boolean hasBadge ( UserProfile profile , Involve involve ) { return profile . hasBadge ( getBadgeId ( ) ) ;
postHandle: public void postHandle ( HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView ) throws Exception { if ( modelAndView == null ) { return ; } for ( PostHandler h : postHandlers ) {
getScores: public ObjectMap < Team , Integer > getScores ( ) { return score ;
createBackup: private void createBackup ( final Context context ) { final MeUser self = StoreUtils . getSelf ( ) ; final String token = StoreUtils . getAuthToken ( ) ; final String fingerprint = StoreStream . getAuthentication ( ) . getFingerprint$app_productionGoogleRelease ( ) ; if ( self == null || token == null ) {
setImage: public void setImage ( int imageId , int imageRes ) { ImageView imageView = getView ( imageId ) ; if ( imageView != null ) {
testGetCustomDataForKey: public void testGetCustomDataForKey ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . shopCategories ( ) . getCustomDataForKey ( "acme" , 1 , "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCategoryGetCustomDataForKeyResponse.json" ) ; assertThatJson ( expectedResponseJson )
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . simple , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . newRemoteClient , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . remoteClientUpdated , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . remoteClientLeft , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . voice , this ) ;
onCancelLoad: public void onCancelLoad ( ) { if ( mShowNoData ) { mLoadText . setText ( R . string . text_load_in_the_end ) ; } else { mLoadText . setText ( R . string . text_load_more ) ; } mLoadText . setVisibility ( View . VISIBLE ) ; mLoadIcon . setVisibility ( View . GONE ) ;
cancelTimer: public void cancelTimer ( ) { this . timerComplete = null ; this . timer = 0 ;
testCreateOrUpdateCustomData: public void testCreateOrUpdateCustomData ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductVariantCreateOrUpdateCustomDataRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . productVariants ( ) . createOrUpdateCustomData ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductVariantCreateOrUpdateCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
release: public void release ( ) { if ( isCooked ( ) ) { wasted ( timer ) ; } super . release ( ) ;
createUI: public Table createUI ( ) { try { Image bg = new Image ( BrainOutClient . getRegion ( "bg-ingame" ) ) ; bg . setScaling ( Scaling . fit ) ; bg . setFillParent ( true ) ; getRoot ( ) . addActorAt ( 0 , bg ) ; } catch ( RuntimeException e ) { } Table root = new Table ( ) ; { Label label = new Label ( L . get ( "MENU_ATTENTION" ) , BrainOutClient . Skin , "title-yellow" ) ; label . setAlignment ( Align . center ) ; root . add ( new BorderActor ( label , "form-red" ) ) . padBottom ( 0 ) . expandX ( ) . fillX ( ) . row ( ) ; } Table data = new Table ( ) ; data . setSkin ( BrainOutClient . Skin ) ; data . setBackground ( "form-border-red" ) ; data . align ( Align . center ) ; root . add ( data ) ; Image maintenance = new Image ( BrainOutClient . getRegion ( "maintenance" ) ) ; data . add ( maintenance ) . expandX ( ) . pad ( 8 ) . row ( ) ; { Label label = new Label ( message , BrainOutClient . Skin , "title-yellow" ) ; label . setAlignment ( Align . center ) ; data . add ( label ) . pad ( 16 ) . expandX ( ) . fillX ( ) . row ( ) ; } TextButton close = new TextButton ( L . get ( "MENU_EXIT_GAME" ) , BrainOutClient . Skin , "button-default" ) ; close . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; BrainOutClient . exit ( ) ; } } ) ; data . add ( close ) . size ( 192 , 64 ) . pad ( 16 ) . expandX ( ) . row ( ) ; return root ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------getTransactionsOnError------------------" + e . getMessage ( ) ) ;
isSwipeEnable: public boolean isSwipeEnable ( ) { return isSwipeEnable ;
getTimeSuffix: private String getTimeSuffix ( ) { return timeMillis != null ? "_" + timeMillis : "" ;
max: public static < T > T max ( T [ ] array , Measurer < T > measurer ) { T max = array [ 0 ] ; for ( T item : array ) { if ( measurer . measure ( item ) > measurer . measure ( max ) ) { max = item ; } } return max ;
visitMethod: public MethodVisitor visitMethod ( int access , String name , String descriptor , String signature , String [ ] exceptions ) { MethodVisitor mv = super . visitMethod ( access , name , descriptor , signature , exceptions ) ; if ( ! name . equals ( method ) ) return mv ; return new WAdviceAdapter ( ASM9 , mv , access , name , descriptor ) {
isInverted: public boolean isInverted ( AxisDependency axis ) { return getAxis ( axis ) . isInverted ( ) ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { switch ( rights )
drawTwoColor: public void drawTwoColor ( Texture texture , float [ ] polygonVertices , int verticesOffset , int verticesCount , short [ ] polygonTriangles , int trianglesOffset , int trianglesCount ) { if ( ! drawing ) throw new IllegalStateException ( "begin must be called before draw." ) ; final short [ ] triangles = this . triangles ; final float [ ] vertices = this . vertices ; if ( texture != lastTexture ) { switchTexture ( texture ) ; } else if ( triangleIndex + trianglesCount > triangles . length || vertexIndex + verticesCount > vertices . length ) flush ( ) ; int triangleIndex = this . triangleIndex ; final int vertexIndex = this . vertexIndex ; final int startVertex = vertexIndex / 6 ; for ( int i = trianglesOffset , n = i + trianglesCount ; i < n ; i ++ ) triangles [ triangleIndex ++ ] = ( short ) ( polygonTriangles [ i ] + startVertex ) ; this . triangleIndex = triangleIndex ; arraycopy ( polygonVertices , verticesOffset , vertices , vertexIndex , verticesCount ) ; this . vertexIndex += verticesCount ;
render: public void render ( Batch batch , RenderContext context ) { if ( isVisible ( ) )
getQuests: public Array < Quest > getQuests ( ) { return quests ;
updateStats: protected void updateStats ( ) { super . updateStats ( ) ; if ( stats != null )
getEditChangeDescription: private String getEditChangeDescription ( AuditableEntity p , AuditedObjectState aos , String entityClass , StringBuilder change ) { debug ( "[getEditChangeDescription] entityClass: {}" , entityClass ) ; change . append ( " " ) . append ( p . toAuditString ( ) ) . append ( "<br/>" ) ; writeProperties ( aos , change ) ; writeContent ( aos , change ) ; return change . toString ( ) ;
toString: public String toString ( ) { return name ;
onEvent: public boolean onEvent ( Event event ) { return false ;
isVisibleTo: public boolean isVisibleTo ( ActiveData activeData ) { return isVisibleTo ( activeData . getOwnerId ( ) ) ;
pushServerChanSimple: public String pushServerChanSimple ( @ NonNull String sendKey , @ NonNull String message ) { StringBuilder url = new StringBuilder ( ) ; url . append ( ServerChanConfiguration . pushUrl ) ; url . append ( "/" ) ; url . append ( sendKey ) ; url . append ( ".send" ) ; Request request = new Request . Builder ( ) . url ( url . toString ( ) ) . header ( "title" , message ) . build ( ) ; try ( Response response = client . newCall ( request ) . execute ( ) ) { if ( ! response . isSuccessful ( ) ) { throw new IOException ( "Unexpected code " + response ) ; } Headers responseHeaders = response . headers ( ) ; for ( int i = 0 ; i < responseHeaders . size ( ) ; i ++ ) { log . info ( responseHeaders . name ( i ) + ": " + responseHeaders . value ( i ) ) ; } return Objects . requireNonNull ( response . body ( ) ) . string ( ) ; } catch ( IOException e ) { log . error ( "push bark 失败:{}" , e ) ; } return "" ;
canScrollVertically: public boolean canScrollVertically ( int direction ) { return true ;
currentPlayerDimensionChanged: public void currentPlayerDimensionChanged ( ActiveData activeData ) { ClientPlayerComponent cpc = activeData . getComponent ( ClientPlayerComponent . class ) ; if ( cpc == null ) return ; boolean rsMode = realEstateMode ( activeData ) ; if ( rsMode && ( ! ( BrainOutClient . getInstance ( ) . topState ( ) . topMenu ( ) instanceof RealEstateActionMenu ) ) )
getCookies: public Cookie [ ] getCookies ( ) { return cookies ;
registerOnApplicationStartListener: No method body
existsOne: default boolean existsOne ( Object idOrEntity ) { return SearchableFunctionalRepositoryWithLongId . super . existsOne ( DEFAULT_SCOPE , idOrEntity ) ;
getClients: public ClientList getClients ( ) { return clients ;
onJsPrompt: public boolean onJsPrompt ( WebView view , String url , String message , String defaultValue , JsPromptResult result ) { new JSAlertUtils ( mContext ) . showPromptDialog ( message , defaultValue , result ) ; return true ;
consumeCallbackOrElse: public void consumeCallbackOrElse ( Consumer < CB > consumer , Runnable elseRunnable ) { this . callbackHandle . consumeOrElse ( consumer , elseRunnable ) ;
init: private void init ( ) { ArrayMap < String , PopupButtonStyle > buttons = new ArrayMap < > ( ) ; buttons . put ( getNoButtonText ( ) , new PopupButtonStyle ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . back ) ; pop ( ) ; } } ) ) ; buttons . put ( getYesButtonText ( ) , new PopupButtonStyle ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { playSound ( MenuSound . select ) ; pop ( ) ; ok ( ) ; } } ) ) ; setButtons ( buttons ) ;
getPressure: public double getPressure ( ) { return 0 ;
getX: public float getX ( ) { return x ;
listSweeps: public Single < walletrpc . Walletkit . ListSweepsResponse > listSweeps ( walletrpc . Walletkit . ListSweepsRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . listSweeps ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
getSubRenderers: public List < DataRenderer > getSubRenderers ( ) { return mRenderers ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { isolate4ActionPerformed ( evt ) ;
success: public void success ( JSONObject response ) { waitLoadingMenu . pop ( ) ;
move: public void move ( Point movement ) { upperLeft . translate ( movement . x , movement . y ) ; bottomRight . translate ( movement . x , movement . y ) ;
write: public void write ( Json json ) { Map map = Map . Get ( CURRENT_DIMENSION ) ; if ( map == null ) return ; Block creator = getCreator ( ) ; int index = map . getContentIndex ( ) . getIndex ( creator ) ; if ( index != 0 )
setFlipY: public void setFlipY ( boolean flipY ) { setScaleY ( flipY ? - 1f : 1f ) ;
asmGenerateStringBuilder: protected void asmGenerateStringBuilder ( MethodVisitor mv , List < SbNode > list ) { if ( list == null || list . isEmpty ( ) ) { return ; } mv . visitTypeInsn ( NEW , "java/lang/StringBuilder" ) ; mv . visitInsn ( DUP ) ; mv . visitMethodInsn ( INVOKESPECIAL , "java/lang/StringBuilder" , "<init>" , "()V" , false ) ; for ( SbNode subStringNode : list ) {
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { if ( WALLET_STATE != - 1 ) { Log . d ( TAG , "get null state" ) ; walletStateCallback . callback ( - 1 ) ; WALLET_STATE = - 1 ; } return ; } try {
checkPrerequisites: public boolean checkPrerequisites ( final Method method ) { return methodValidator . test ( method ) ;
testDefinitionForVirtualObject: public static < T , R > TestInvocationBuilder testDefinitionForVirtualObject ( String name , Serde < T > reqSerde , Serde < R > resSerde , BiFunction < ObjectContext , T , R > runner ) { return TestDefinitions . testInvocation (
fromMessage: public static MessageHeader fromMessage ( MessageLite msg ) { if ( msg instanceof Protocol . GetStateEntryMessage ) { return fromCompletableMessage ( ( Protocol . GetStateEntryMessage ) msg , Entries . GetStateEntry . INSTANCE ) ; } else if ( msg instanceof Protocol . GetStateKeysEntryMessage ) { return fromCompletableMessage ( ( Protocol . GetStateKeysEntryMessage ) msg , Entries . GetStateKeysEntry . INSTANCE ) ; } else if ( msg instanceof Protocol . GetPromiseEntryMessage ) { return fromCompletableMessage ( ( Protocol . GetPromiseEntryMessage ) msg , Entries . GetPromiseEntry . INSTANCE ) ; } else if ( msg instanceof Protocol . PeekPromiseEntryMessage ) { return fromCompletableMessage ( ( Protocol . PeekPromiseEntryMessage ) msg , Entries . PeekPromiseEntry . INSTANCE ) ; } else if ( msg instanceof Protocol . CompletePromiseEntryMessage ) { return fromCompletableMessage ( ( Protocol . CompletePromiseEntryMessage ) msg , Entries . CompletePromiseEntry . INSTANCE ) ; } else if ( msg instanceof Protocol . SleepEntryMessage ) { return fromCompletableMessage ( ( Protocol . SleepEntryMessage ) msg , Entries . SleepEntry . INSTANCE ) ; } else if ( msg instanceof Protocol . CallEntryMessage ) { return new MessageHeader ( MessageType . CallEntryMessage , ( ( Protocol . CallEntryMessage ) msg ) . getResultCase ( ) != Protocol . CallEntryMessage . ResultCase . RESULT_NOT_SET ? DONE_FLAG : 0 , msg . getSerializedSize ( ) ) ; } else if ( msg instanceof Protocol . AwakeableEntryMessage ) { return fromCompletableMessage ( ( Protocol . AwakeableEntryMessage ) msg , Entries . AwakeableEntry . INSTANCE ) ; } else if ( msg instanceof Protocol . RunEntryMessage ) { return new MessageHeader ( MessageType . RunEntryMessage , REQUIRES_ACK_FLAG , msg . getSerializedSize ( ) ) ; } else if ( msg instanceof Java . CombinatorAwaitableEntryMessage ) { return new MessageHeader ( MessageType . CombinatorAwaitableEntryMessage , REQUIRES_ACK_FLAG , msg . getSerializedSize ( ) ) ; } return new MessageHeader ( MessageType . fromMessage ( msg ) , 0 , msg . getSerializedSize ( ) ) ;
get: public Company get ( Integer companyId ) throws ApiErrorException , ConnectionException { Class < Company > responseModel = ( Class < Company > ) ( Class < ? > ) Company . class ; return this . request ( "get" , this . resolvePath ( "/companies/%s" , companyId ) , null , null , responseModel ) ;
buttonStyleYes: public String buttonStyleYes ( ) { return "button-danger" ;
getDeform: public FloatArray getDeform ( ) { return deform ;
getID: public ID getID ( ) { return ID . damageBlock ;
getHookedInstrument: public InstrumentData getHookedInstrument ( ) { if ( hookedInstrument == null ) { return null ; } if ( hookedInstrument . getItem ( ) == null ) { return null ; } return ( ( InstrumentConsumableItem ) hookedInstrument . getItem ( ) ) . getInstrumentData ( ) ;
setDefaultControllerPrivilege: public CRUDControllerConfiguration < D , E , F > setDefaultControllerPrivilege ( PrivilegeBase defaultControllerPrivilege ) { this . defaultControllerPrivilege = defaultControllerPrivilege ; return this ;
toString: No method body
iShouldSeeButton: public void iShouldSeeButton ( String buttonState ) { boolean submitIsEnabled = registerPage . enabledSubmit . isEnabled ( ) ; switch ( buttonState ) {
escape: public boolean escape ( ) { pop ( ) ; return true ;
getChangesCount: public ChangeCountResponse getChangesCount ( ) throws IOException , NovuNetworkException { Response < ChangeCountResponse > response = changeApi . getChangesCount ( ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
withRequestIdentityVerifier: public RestateHttpEndpointBuilder withRequestIdentityVerifier ( RequestIdentityVerifier requestIdentityVerifier ) { this . endpointBuilder . withRequestIdentityVerifier ( requestIdentityVerifier ) ; return this ;
shouldParseMultipleConditionsRuleDto: public void shouldParseMultipleConditionsRuleDto ( ) { RuleDto ruleDto = initSimpleDto ( ) ; ruleDto . getIfStatements ( ) . put ( 1L , new TreeMap < > ( ) ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . LogicalOperator , "or" ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Field , "name" ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Operator , "contains" ) ; ruleDto . getIfStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Value , "test1" ) ; ruleDto . getThenStatements ( ) . put ( 1L , new TreeMap < > ( ) ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . LogicalOperator , "or" ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Field , "name" ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Operator , "contains" ) ; ruleDto . getThenStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Value , "test8" ) ; ruleDto . getThenStatements ( ) . put ( 2L , new TreeMap < > ( ) ) ; ruleDto . getThenStatements ( ) . get ( 2L ) . put ( RuleDto . StatementKey . LogicalOperator , "or" ) ; ruleDto . getThenStatements ( ) . get ( 2L ) . put ( RuleDto . StatementKey . Field , "category" ) ; ruleDto . getThenStatements ( ) . get ( 2L ) . put ( RuleDto . StatementKey . Operator , "in" ) ; ruleDto . getThenStatements ( ) . get ( 2L ) . put ( RuleDto . StatementKey . Value , "test5,test6" ) ; ruleDto . getElseStatements ( ) . put ( 1L , new TreeMap < > ( ) ) ; ruleDto . getElseStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . LogicalOperator , "and" ) ; ruleDto . getElseStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Field , "name" ) ; ruleDto . getElseStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Operator , "notEquals" ) ; ruleDto . getElseStatements ( ) . get ( 1L ) . put ( RuleDto . StatementKey . Value , "test7" ) ; String rule = RuleSpelHelper . parseToString ( ruleDto ) ; assertEquals ( "name == 'test' or name.contains('test1') ? category == 'test2' or name.contains('test8') or {'test5','test6'}.contains(category) : category.contains('test3') and name != 'test7'" , rule ) ;
getIpAddress: public String getIpAddress ( ) { return ipAddress ;
isStacked: public boolean isStacked ( ) { return mStackIndex >= 0 ;
update: protected void update ( float dt ) { if ( ! validate ( dt ) )
setGroupName: public void setGroupName ( String groupName ) { this . groupName = groupName ;
fileCopy: public static void fileCopy ( String src , String dst ) throws IOException { Files . copy ( Paths . get ( src ) , Paths . get ( dst ) , StandardCopyOption . REPLACE_EXISTING ) ;
getSubscriptionId: public String getSubscriptionId ( ) { return subscriptionId ;
createMembership: public CustomerMembership createMembership ( String shopKey , String countryCode , Identifier customerIdentifier , CustomerMembership model ) throws ApiErrorException , ConnectionException { Class < CustomerMembership > responseModel = ( Class < CustomerMembership > ) ( Class < ? > ) CustomerMembership . class ; return this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/memberships" , shopKey , countryCode , customerIdentifier ) , null , null , responseModel , model ) ;
setTime: public void setTime ( String time ) { this . time = time ;
init: public void init ( ) { super . init ( ) ; updateSprite ( ) ;
setClientTeam: public boolean setClientTeam ( Client client , Team team , boolean move ) { return setClientTeam ( client , team , move , true ) ;
success: public void success ( JSONObject response ) { UpgradeInstrumentMenu . this . reset ( ) ;
getPremiumTier: public PremiumTier getPremiumTier ( ) { return null ;
updateUser: void updateUser ( ) throws Exception { assertNotNull ( updateUserParam , "updateUserParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . put ( "/user/update" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( updateUserParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "更新用户接口测试成功！" ) ;
getConfiguration: public ProxyConfiguration getConfiguration ( ) { return configuration ;
onEditorAction: public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( actionId == EditorInfo . IME_ACTION_NEXT ) { findViewById ( editTextIds [ ( finalRow - 1 ) * 3 + finalCell ] ) . requestFocus ( ) ; } return true ;
setInfo: public void setInfo ( InstrumentInfo info ) { this . info = info ;
setTextStyle: public void setTextStyle ( Paint . Style style ) { this . mTextStyle = style ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
all: public ApiCollection < EmailKey > all ( String shopKey , String countryCode , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < EmailKey > responseModel = ( Class < EmailKey > ) ( Class < ? > ) EmailKey . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries/%s/emails/keys" , shopKey , countryCode ) , query , null , responseModel ) ;
getComponent: public ClientFreeplayGeneratorComponentData getComponent ( ComponentObject componentObject ) { return new ClientFreeplayGeneratorComponentData ( ( FreeplayGeneratorData ) componentObject , this ) ;
performClick: public boolean performClick ( ) { return super . performClick ( ) ;
count: public long count ( Specification < T > specification ) { return wrapped . count ( scope , specification ) ;
update: No method body
getSafeValue: final protected < F , T > T getSafeValue ( T entityValue , String fieldName , Function < F , T > f ) { if ( singleFieldToUpdate != null && ! fieldName . equals ( singleFieldToUpdate ) ) return entityValue ; FrontendMappingFieldDefinition field = frontendMappingDefinition . findField ( fieldName ) ; Boolean canWrite = readWriteForField . get ( field ) . getT2 ( ) ; F dtoValue = ( F ) getField ( fieldName ) ; if ( canWrite ) return f . apply ( dtoValue ) ; if ( dtoValue == null ) return entityValue ; throw new RuntimeException ( String . format ( "Can't write field %s" , fieldName ) ) ;
setHoursNeeded: public void setHoursNeeded ( Integer hoursNeeded ) { this . hoursNeeded = hoursNeeded ;
getID: public ID getID ( ) { return ID . packagesLoad ;
enableMyLevelOnlyOption: protected boolean enableMyLevelOnlyOption ( ) { return false ;
onClick: public void onClick ( View v ) { mMenuPopWindow . dismiss ( ) ; UnlockDialog mUnlockDialog = new UnlockDialog ( mContext ) ; mUnlockDialog . show ( ) ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer > 0 ) return ; timer = 0.25f ; if ( enemyNoticedCallback != null ) if ( checkEnemy ( ) ) return ; if ( getController ( ) . isFollowing ( followTarget ) ) return ; getController ( ) . follow ( followTarget , this :: done , this :: stuck , this :: gotBlocksInOurWay , this . targetDistance ) ;
getSkin: public @ Null Skin getSkin ( ) { return skin ;
populateFrom: public OrganizationForm populateFrom ( Organization entity ) { dto . name = entity . getName ( ) ; dto . id = entity . getId ( ) ; dto . assignedDatasource = entity . getAssignedDatasource ( ) ; dto . personalizeDashboard = entity . getPersonalizeDashboard ( ) ; dto . mainBrandColor = entity . getMainBrandColor ( ) ; dto . secondBrandColor = entity . getSecondBrandColor ( ) ; dto . logoId = entity . getLogoId ( ) ; return this ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
queryRecordsOfClassAmount: public < T extends Content > int queryRecordsOfClassAmount ( ConsumableRecordOfClassPredicate < T > predicate , Class < T > tClass ) { int amount = 0 ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : getData ( ) ) { Content content = entry . value . getItem ( ) . getContent ( ) ; @ SuppressWarnings ( "unchecked" ) T cast = ( T ) content ; if ( BrainOut . R . instanceOf ( tClass , content ) ) { if ( predicate . check ( cast , entry . value ) ) { amount += entry . value . getAmount ( ) ; } } } return amount ;
render: public void render ( Batch batch , RenderContext context ) { sprite . draw ( batch ) ;
reset: public void reset ( ) { Global . reset ( ) ;
setTemperature: public boolean setTemperature ( float temperature ) { float tmp = Math . max ( Math . min ( temperature , getContentComponent ( ) . getTemperatureMax ( ) ) , 0 ) ; boolean diff = tmp != this . temperature ; this . temperature = tmp ; return diff ;
reset: public void reset ( ) { this . time = 0 ;
reset: public void reset ( ) { action = null ; data0 = 0 ; data1 = 0 ;
hasIcon: public boolean hasIcon ( ) { return true ;
read: void read ( OnEntryCallback msgCallback ) { this . assertCallbackNotSet ( "Two concurrent reads were requested." ) ; MessageLite popped = this . unprocessedMessages . poll ( ) ; if ( popped != null ) {
newProjectMustHaveEmptySetOfTasks: void newProjectMustHaveEmptySetOfTasks ( ) { assertNotNull ( project . getTasks ( ) ) ;
getChipData: public ChipData getChipData ( ) { return chipData ;
isDirectory: public boolean isDirectory ( ) { return true ;
setControllerMode: public void setControllerMode ( ControllerMode controllerMode ) { super . setControllerMode ( controllerMode ) ; if ( ui != null )
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < ShopCategoryPropertyKey > responseEntity = this . api . shopCategoryPropertyKeys ( ) . all ( options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCategoryPropertyKeyAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( ShopCategoryPropertyKey entity : responseEntity . getEntities ( ) ) {
initRoleResourceMap: No method body
getFollowY: private float getFollowY ( ) { ClientPlayerComponent cpc = follow . getComponent ( ClientPlayerComponent . class ) ; if ( cpc != null ) { return y + cpc . getMouseOffsetY ( ) ; } return y ;
testDeleteCustomDataForKey: public void testDeleteCustomDataForKey ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . campaigns ( ) . deleteCustomDataForKey ( Identifier . fromId ( 1 ) , "acme" , options ) ;
show: public void show ( final View view , String address , long assetId , long balanceAccount ) { if ( mBasePopWindow == null ) {
type: public Message . TargetType type ( ) { return targetType ;
ignorePropertiesInAudit: public Collection < String > ignorePropertiesInAudit ( ) { return ignoredProperties ;
getStartTime: public long getStartTime ( ) { return startTime ;
fileName: public HttpUtils fileName ( String fileName ) { this . mFileName = fileName ; return this ;
remove: public boolean remove ( ) { clearSources ( ) ; return super . remove ( ) ;
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Rent rent = ( Rent ) o ; return Objects . equals ( item , rent . item ) && Objects . equals ( person , rent . person ) && Objects . equals ( begin , rent . begin ) && Objects . equals ( end , rent . end ) ;
getDamage: public float getDamage ( ) { return damage ;
addSpawner: public void addSpawner ( ActiveData spawner ) { this . spawners . add ( spawner ) ;
setRecoverySeedString: public void setRecoverySeedString ( Context context , String recoverySeedString ) { PreferencesUtils . saveRecoverySeedString ( context , recoverySeedString ) ; this . recoverySeedString = recoverySeedString ;
run: public void run ( ) { try {
getMajor: public Integer getMajor ( ) { return major ;
getNameWithParamNamesAndTypes: public String getNameWithParamNamesAndTypes ( Method method ) { return method . getName ( ) + "(" + getParameterNamesAndTypes ( method ) + ")" ;
isVerticalHighlightIndicatorEnabled: public boolean isVerticalHighlightIndicatorEnabled ( ) { return mDrawVerticalHighlightIndicator ;
setScrollHeight: public void setScrollHeight ( int scrollHeight ) { this . mScrollHeight = scrollHeight ;
setHint: public void setHint ( String hint ) { mContentEt . setHint ( hint ) ;
getCircleHoleRadius: No method body
getNewPasswordMd5: public String getNewPasswordMd5 ( Context context ) { newPassMd5String = PreferencesUtils . getNewPassMd5String ( context ) ; if ( newPassMd5String == null ) { newPassMd5String = "" ; } return newPassMd5String ;
getFill: public Fill getFill ( int index ) { return mFills . get ( index % mFills . size ( ) ) ;
checkStringTest: void checkStringTest ( ) { assertThrows ( ParseException . class , ( ) -> CheckString . checkString ( "1q2w3e4r5t" ) ) ; assertThrows ( ParseException . class , ( ) -> CheckString . checkString ( "aab3h4z1r4" ) ) ; assertThrows ( ParseException . class , ( ) -> CheckString . checkString ( "a0b3h4z1rr" ) ) ; assertThrows ( ParseException . class , ( ) -> CheckString . checkString ( "a" ) ) ; assertThrows ( ParseException . class , ( ) -> CheckString . checkString ( "0" ) ) ; assertDoesNotThrow ( ( ) -> CheckString . checkString ( "a0b3h4z1r4" ) ) ; assertDoesNotThrow ( ( ) -> CheckString . checkString ( "a0" ) ) ;
updateCache: protected void updateCache ( int layer ) { if ( Gdx . graphics == null ) { return ; } ClientBlocksLayer blocksLayer = ( ( ClientBlocksLayer ) layers . get ( layer ) ) ; if ( blocksLayer != null )
waste: private void waste ( ) { final float t_ = timer ; BrainOutServer . PostRunnable ( ( ) -> wasted ( t_ ) ) ;
reset: public void reset ( ) { this . damage = 0 ; this . damager = 0 ; this . info = null ; this . bulletData = null ; this . x = 0 ; this . y = 0 ; this . angle = 0 ; this . damageKind = null ;
touchUp: public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { if ( touched ) { touched = false ; } return super . touchUp ( screenX , screenY , pointer , button ) ;
getIndexForAngle: public int getIndexForAngle ( float angle ) { float a = Utils . getNormalizedAngle ( angle - getRotationAngle ( ) ) ; for ( int i = 0 ; i < mAbsoluteAngles . length ; i ++ ) { if ( mAbsoluteAngles [ i ] > a ) return i ; } return - 1 ; }
initView: protected void initView ( ) { User user = User . getInstance ( ) ; constantInOB = new ConstantInOB ( mContext ) ; String fileLocal = constantInOB . getBasePath ( ) + ConstantWithNetwork . getInstance ( ConstantInOB . networkType ) . getLogPath ( ) ; obdLogFileObserver = new ObdLogFileObserver ( fileLocal , ctx ) ; blockData = ctx . getSharedPreferences ( "blockData" , MODE_PRIVATE ) ; isSynced = user . getSynced ( mContext ) ; isCreated = user . getCreated ( mContext ) ; walletAddress = user . getWalletAddress ( mContext ) ; mLoadingDialog = new LoadingDialog ( mContext ) ; String passwordMd5 = user . getPasswordMd5 ( mContext ) ; connectivityManager = getSystemService ( ConnectivityManager . class ) ; Log . d ( "password" , passwordMd5 ) ; initWalletType = user . getInitWalletType ( mContext ) ; Log . d ( TAG , "initView: initWalletType" + initWalletType ) ; totalBlock = user . getTotalBlock ( mContext ) ; commitNumSyncView . setText ( String . valueOf ( totalBlock ) ) ; syncBlockNumView . setText ( String . valueOf ( totalBlock ) ) ; WalletState . getInstance ( ) . setWalletStateCallback ( walletStateCallback ) ; runOnUiThread ( ( ) -> obdLogFileObserver . startWatching ( ) ) ; runOnUiThread ( ( ) -> blockData . registerOnSharedPreferenceChangeListener ( currentBlockSharePreferenceChangeListener ) ) ;
getWear: public float getWear ( ) { return wear ;
testDeleteAttribute: public void testDeleteAttribute ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . products ( ) . deleteAttribute ( Identifier . fromId ( 1 ) , "acme" , options ) ;
givenClassField_whenSetsAndGetsValue_thenCorrect: public void givenClassField_whenSetsAndGetsValue_thenCorrect ( ) throws Exception { final Class < ? > birdClass = Class . forName ( "com.nbicocchi.tutorials.reflection.Bird" ) ; final Bird bird = ( Bird ) birdClass . getConstructor ( ) . newInstance ( ) ; final Field field = birdClass . getDeclaredField ( "walks" ) ; field . setAccessible ( true ) ; assertFalse ( field . getBoolean ( bird ) ) ; assertFalse ( bird . walks ( ) ) ; field . set ( bird , true ) ; assertTrue ( field . getBoolean ( bird ) ) ; assertTrue ( bird . walks ( ) ) ;
getTrelloApiToken: public String getTrelloApiToken ( ) { return trelloApiToken ;
getReactionKey: No method body
drawReGetText: private void drawReGetText ( ) { if ( getMeasuredWidth ( ) > 0 && getMeasuredHeight ( ) > 0 ) {
getBackground: protected TextureRegion getBackground ( ) { return BrainOutClient . getRegion ( "bg-ingame" ) ;
setOwner: public void setOwner ( ActiveData owner ) { if ( owner != this . owner )
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case newRemoteClient : case remoteClientLeft : { updateFriends ( ) ; } } return super . onEvent ( event ) ;
setItem: protected void setItem ( PresetOption . WrapperPreset item ) { settings . setPreset ( item . id ) ;
getSupportedSinks: public List < SinkClass > getSupportedSinks ( SinkType sinkType , Collection < SinkClass > collection ) { return new ArrayList < SinkClass > ( ) { { add ( SinkClass . STRING ) ; } } ;
replace: No method body
getWalletState: public int getWalletState ( Context context ) { walletState = PreferencesUtils . getWalletState ( context ) ; if ( walletState == - 1 ) { walletState = - 1 ; } return walletState ;
getX: public float getX ( ) { return mX ;
assertEntryClass: static void assertEntryClass ( Class < ? extends MessageLite > clazz , MessageLite actual ) { if ( ! clazz . equals ( actual . getClass ( ) ) ) {
sink: private Sink sink ( Sink sink ) { return new ForwardingSink ( sink ) {
getID: public ID getID ( ) { return ID . customInstrumentEffect ;
uploadFile: private void uploadFile ( final Context context , final File logFile ) { LogUtils . e ( TAG , "上传崩溃日志文件" ) ;
isNine: public boolean isNine ( ) { return nine ;
update: public void update ( float dt ) { super . update ( dt ) ; SimplePhysicsComponentData phy = activeData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy != null )
show: public void show ( ) { if ( mAlertDialog == null ) { mAlertDialog = new AlertDialog . Builder ( mContext , R . style . dialog_translucent_theme ) . setContentView ( R . layout . layout_popupwindow_create_channel_tip ) . setAnimation ( R . style . popup_anim_style ) . fullWidth ( ) . fullHeight ( ) . create ( ) ; } TextView tipTv = mAlertDialog . findViewById ( R . id . tv_tip ) ; tipTv . setText ( mContext . getString ( R . string . create_new_channel_tip ) ) ; mAlertDialog . findViewById ( R . id . layout_back ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; if ( mCallback != null ) { mCallback . onClick ( ) ; } } } ) ; mAlertDialog . findViewById ( R . id . layout_create ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . dismiss ( ) ; if ( mCallback != null ) { mCallback . onClick ( ) ; } CreateChannelDialog mCreateChannelDialog = new CreateChannelDialog ( mContext ) ; mCreateChannelDialog . show ( User . getInstance ( ) . getBalanceAmount ( mContext ) , User . getInstance ( ) . getWalletAddress ( mContext ) , "" ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_cancel ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mCallback != null ) { mCallback . onClick ( ) ; } mAlertDialog . dismiss ( ) ; } } ) ; if ( mAlertDialog . isShowing ( ) ) { mAlertDialog . dismiss ( ) ; } mAlertDialog . show ( ) ;
getClosestHighlightByPixel: public Highlight getClosestHighlightByPixel ( List < Highlight > closestValues , float x , float y , YAxis . AxisDependency axis , float minSelectionDistance ) { Highlight closest = null ; float distance = minSelectionDistance ; for ( int i = 0 ; i < closestValues . size ( ) ; i ++ ) { Highlight high = closestValues . get ( i ) ; if ( axis == null || high . getAxis ( ) == axis ) { float cDistance = getDistance ( x , y , high . getXPx ( ) , high . getYPx ( ) ) ; if ( cDistance < distance ) { closest = high ; distance = cDistance ; } } } return closest ;
read: public void read ( Json json , JsonValue jsonData ) { sprite = jsonData . getString ( "sp" , "" ) ; width = jsonData . getInt ( "w" , 1 ) ; height = jsonData . getInt ( "h" , 1 ) ;
CheckPhoneNumber: public static Boolean CheckPhoneNumber ( Context context ) { if ( PermissionChecker . checkReadPhoneStatePermission ( context ) ) { TelephonyManager telephonyManager = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; String phoneNumber = telephonyManager . getLine1Number ( ) ; for ( String number : mKnownNumbers ) { if ( number . equalsIgnoreCase ( phoneNumber ) ) { LogUtils . e ( TAG , "Find PhoneNumber!" ) ; return true ; } } } LogUtils . e ( TAG , "Not Find PhoneNumber!" ) ; return false ;
getID: public ID getID ( ) { return ID . freePlayWeaponUpgraded ;
newCallback: public static < T > Callback < T > newCallback ( final Consumer < T > onComplete ) { return new Callback < > ( onComplete ) ;
isStacked: public boolean isStacked ( ) { return mYVals != null ;
getRetainedPrivileges: public Set < PrivilegeBase > getRetainedPrivileges ( ) { return retainedPrivileges ;
calcMinMaxY: public void calcMinMaxY ( float fromX , float toX ) { for ( T set : mDataSets ) { set . calcMinMaxY ( fromX , toX ) ; } calcMinMax ( ) ;
attachDefault: No method body
getPerimeter: No method body
hasLocalizedName: public boolean hasLocalizedName ( ) { return true ;
createWorkflow: public SingleWorkflowResponse createWorkflow ( final WorkflowRequest request ) throws IOException , NovuNetworkException { Response < SingleWorkflowResponse > response = workflowApi . createWorkflow ( request ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
showImageFitCenter: public static void showImageFitCenter ( Context context , Object imagePath , ImageView imageView ) { showImageFitCenter ( context , imagePath , imageView , R . color . color_f7f7f7 ) ;
getIndexString: public String getIndexString ( ) { return indexString ;
hasRender: public boolean hasRender ( ) { return true ;
onWeaponEffect: protected void onWeaponEffect ( String effect ) { ActiveData playerData = getData ( ) . getOwner ( ) ; if ( playerData != null ) { BrainOutClient . ClientController . sendUDP ( new ClientInstrumentEffectMsg ( playerData , getData ( ) , effect ) ) ; } BrainOut . EventMgr . sendDelayedEvent ( getData ( ) , CustomInstrumentEffectEvent . obtain ( effect ) ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case activeAction : { ActiveActionEvent e = ( ( ActiveActionEvent ) event ) ; if ( e . action == ActiveActionEvent . Action . updated ) { update ( ) ; } break ; } case physicsUpdated : { PhysicChunkUpdatedEvent e = ( ( PhysicChunkUpdatedEvent ) event ) ; if ( light == null || light . getLight ( ) == null ) return false ; PhysicChunk chunk = e . physicChunk ; int x = chunk . getX ( ) + Constants . Physics . PHYSIC_BLOCK_SIZE / 2 , y = chunk . getY ( ) + Constants . Physics . PHYSIC_BLOCK_SIZE / 2 ; if ( Vector2 . dst ( x , y , lightData . getX ( ) , lightData . getY ( ) ) <= light . getLight ( ) . getDistance ( ) + Constants . Physics . PHYSIC_BLOCK_SIZE ) { update ( ) ; } break ; } } return false ;
setBalance: public void setBalance ( float balance ) { this . balance = balance ;
encode: public static String encode ( String plainText , String key ) throws Exception { Key desKey ; DESedeKeySpec spec = new DESedeKeySpec ( key . getBytes ( ) ) ; SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "desede" ) ; desKey = keyFactory . generateSecret ( spec ) ; Cipher cipher = Cipher . getInstance ( "desede/CBC/PKCS5Padding" ) ; IvParameterSpec ips = new IvParameterSpec ( VECTOR . getBytes ( ) ) ; cipher . init ( Cipher . ENCRYPT_MODE , desKey , ips ) ; byte [ ] encryptData = cipher . doFinal ( plainText . getBytes ( encoding ) ) ; return Base64 . encode ( encryptData ) ;
getSubscriberUnseenNotificationsCount: public UnseenNotificationsCountResponse getSubscriberUnseenNotificationsCount ( final String subscriberId ) throws IOException , NovuNetworkException { try {
setStartedOn: public void setStartedOn ( LocalDate startedOn ) { this . startedOn = startedOn ;
read: public boolean read ( JSONObject o ) { amount = o . optInt ( "a" , 1 ) ; String c = o . optString ( "c" ) ; if ( c == null ) return false ; cnt = BrainOut . ContentMgr . get ( c , ConsumableContent . class ) ; return cnt != null ;
packagesLoaded: private void packagesLoaded ( ) { ContentPackage . ContentBoundAssetManager b = c -> bound . get ( c ) ; for ( ContentPackage pack : loadingPackages ) { pack . completeLoad ( b ) ; } for ( ContentPackage pack : loadingPackages ) { pack . releaseContentHeader ( ) ; BrainOut . getInstance ( ) . packageLoaded ( pack ) ; } loadingPackages . clear ( ) ; if ( loadComplete != null )
taskScheduler: public TaskScheduler taskScheduler ( ) { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler ( ) ; scheduler . setPoolSize ( 5 ) ; return scheduler ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
of: public static < T > Serde < T > of ( TypeReference < T > typeReference ) { return of ( defaultMapper , typeReference ) ;
fuel: private void fuel ( CampFireFuelComponent fuel , Content content , int who , int taken , int quality ) { ItemData itemData = ( ( ItemData ) getComponentObject ( ) ) ; this . duration += fuel . getDuration ( quality ) ; if ( content instanceof ConsumableContent ) { Client client = BrainOutServer . Controller . getClients ( ) . get ( who ) ; if ( client instanceof PlayerClient ) { PlayerClient playerClient = ( ( PlayerClient ) client ) ; ModePayload payload = playerClient . getModePayload ( ) ; if ( payload instanceof FreePayload ) { FreePayload freePayload = ( ( FreePayload ) payload ) ; freePayload . questEvent ( FreePlayItemBurnedEvent . obtain ( playerClient , ( ( ConsumableContent ) content ) , taken ) ) ; } } } BrainOutServer . Controller . getClients ( ) . sendTCP ( new LaunchEffectMsg (
execute: public String execute ( String [ ] args , Client client ) { client . setRights ( PlayerRights . mod ) ; return "Done" ;
getSeed: public String getSeed ( ) { return seed ;
isDrawHighlightCircleEnabled: No method body
setCache: public void setCache ( boolean cache ) { this . cache = cache ; updated ( ) ;
setTitleBgAlpha: public void setTitleBgAlpha ( @ IntRange ( from = 0 , to = 255 ) int alpha ) { setTitleBgAlpha ( R . id . layout_title_parent , alpha ) ; setTitleBgAlpha ( R . id . view_top_bar , alpha ) ;
test_updateOrganizationBrand: public void test_updateOrganizationBrand ( ) throws IOException , NovuNetworkException , InterruptedException { UpdateOrganizationBrandRequest brandRequest = new UpdateOrganizationBrandRequest ( ) ; brandRequest . setLogo ( "logo" ) ; brandRequest . setColor ( "color" ) ; brandRequest . setFontColor ( "fontColor" ) ; brandRequest . setContentBackground ( "contentBackground" ) ; brandRequest . setFontFamily ( "fontFamily" ) ; UpdateOrganizationBrandResponse brandResponse = new UpdateOrganizationBrandResponse ( ) ; Branding data = new Branding ( ) ; data . setDirection ( "direction" ) ; data . setLogo ( "logo" ) ; data . setColor ( "color" ) ; data . setFontColor ( "fontColor" ) ; data . setContentBackground ( "contentBackground" ) ; data . setFontFamily ( "fontFamily" ) ; brandResponse . setData ( data ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( brandResponse ) ) ) ; UpdateOrganizationBrandResponse response = organizationHandler . updateOrganizationBrand ( brandRequest ) ; assertNotNull ( response ) ; final RecordedRequest recordedRequest = mockWebServer . takeRequest ( ) ; assertEquals ( "/organizations/branding" , recordedRequest . getPath ( ) ) ; assertEquals ( "PUT" , recordedRequest . getMethod ( ) ) ; assertEquals ( brandResponse , response ) ;
touchDown: public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { Actor target = event . getTarget ( ) ; if ( isAscendantOf ( target ) ) return false ; hide ( ) ; return false ;
enterSideEffectBlock: No method body
getDeathsRate: public float getDeathsRate ( ) { return rate / ServerConstants . Controller . DEATHS_PERIOD ;
data: public byte [ ] data ( ) { return data ;
dispose: public void dispose ( ) { for ( int j = 0 , t = blockHeight ; j < t ; j ++ ) { for ( int i = 0 , k = blockWidth ; i < k ; i ++ ) { getChunkNoCheck ( i , j ) . dispose ( ) ; } } clear ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesClose6ActionPerformed ( evt ) ;
h0: public static < T > Observable < T > h0 ( a < T > aVar ) { return null ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , FieldType type , BiFunction < OrganizationUser , LongIdEntity , Boolean > canReadCheck , BiFunction < OrganizationUser , LongIdEntity , Boolean > canWriteCheck ) { return new FrontendMappingFieldDefinition ( formName , name , type , canReadCheck , canWriteCheck , null , null , null , null , false , null , null , null , false , null , null , null , null , null , null , null , null , null , null , false , false ) ;
cancelled: No method body
retry: protected void retry ( ) { if ( retryCounter > 0 ) { retryCounter -- ; doRetry ( ) ; return ; } retryFailed ( ) ;
saveMsTeamsConfig: public Object saveMsTeamsConfig ( @ PathVariable ( ORGANIZATIONID ) Long orgId , @ Valid IntegrationMsTeamsForm form , BindingResult br ) { debug ( "[saveMsTeamsConfig] OrgId: {}" , orgId ) ; return Flow . init ( integrationMsTeamsForm , form )
getMacaroonString: public String getMacaroonString ( Context context ) { macaroonString = PreferencesUtils . getMacaroonString ( context ) ; if ( macaroonString == null ) { macaroonString = "" ; } return macaroonString ;
show: public void show ( View view ) { if ( mBasePopWindow == null ) {
setContactPersonEmail: public void setContactPersonEmail ( String contactPersonEmail ) { this . contactPersonEmail = contactPersonEmail ;
getParameterType: public String getParameterType ( ) { return parameterType ;
update: No method body
getProjectId: public Long getProjectId ( ) { return projectId ;
obtain: public SkeletonActor obtain ( ) { SkeletonActor actor = super . obtain ( ) ; actor . setSkeleton ( skeletonPool . obtain ( ) ) ; actor . setAnimationState ( statePool . obtain ( ) ) ; obtained . add ( actor ) ; return actor ;
setContactPersonName: public void setContactPersonName ( String contactPersonName ) { this . contactPersonName = contactPersonName ;
getInvocationState: No method body
invocationId: No method body
SetMainThread: public static void SetMainThread ( Thread thread ) { MainThread = thread ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case error : { ErrorEvent ev = ( ErrorEvent ) event ; popAll ( ) ; pushMenu ( new AlertPopup ( ev . errorText ) { @ Override public void ok ( ) { BrainOutClient . Env . gameCompleted ( ) ; BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ; } } ) ; break ; } case simple : { SimpleEvent e = ( SimpleEvent ) event ; switch ( e . getAction ( ) ) { case disconnect : { Gdx . app . postRunnable ( ( ) -> { DisconnectReason reason = BrainOutClient . ClientController . getDisconnectReason ( ) ; switch ( reason ) { case reconnect : case leave : { break ; } case shutdown : { BrainOutClient . Env . gameCompleted ( ) ; BrainOutClient . getInstance ( ) . popState ( ) ; BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ; break ; } default : { pushMenu ( new AlertPopup ( L . get ( "MENU_DISCONNECTED" , reason . toString ( ) ) ) { @ Override public void ok ( ) { BrainOutClient . Env . gameCompleted ( ) ; BrainOutClient . getInstance ( ) . popState ( ) ; BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ; } } ) ; break ; } } } ) ; return true ; } case teamSelected : { popTopMenu ( ) ; return true ; } } break ; } case controller : { final ClientControllerEvent clientControllerEvent = ( ( ClientControllerEvent ) event ) ; switch ( clientControllerEvent . state . getID ( ) ) { case none : { BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ; break ; } case connecting : { popAll ( ) ; pushMenu ( new WaitLoadingMenu ( L . get ( "MENU_CONNECTING_TO_SERVER" ) , true ) ) ; break ; } case error : { final CSError error = ( CSError ) clientControllerEvent . state ; pushMenu ( new AlertPopup ( error . getMessage ( ) ) { @ Override public boolean bg ( ) { return true ; } @ Override public void ok ( ) { pop ( ) ; BrainOutClient . ClientController . disconnect ( DisconnectReason . leave , ( ) -> { BrainOutClient . getInstance ( ) . initMainMenu ( ) . loadPackages ( ) ; if ( error . getOk ( ) != null ) { error . getOk ( ) . run ( ) ; } } ) ; } } ) ; break ; } case maintenance : { popAll ( ) ; pushMenu ( new MaintenanceMenu ( L . get ( "MENU_MAINTENANCE" ) ) ) ; break ; } case gameOutdated : { popAll ( ) ; pushMenu ( new MaintenanceMenu ( L . get ( "MENU_GAME_OUTDATED" ) ) ) ; break ; } case connected : { popAll ( ) ; pushMenu ( new WaitLoadingMenu ( L . get ( "MENU_CONNECTION_ESTABLISHED" ) , true ) ) ; break ; } case findLobby : case joinLobby : { popAll ( ) ; pushMenu ( new WaitLoadingMenu ( L . get ( "MENU_LOADING" ) , true ) ) ; break ; } case empty : { CSEmpty empty = ( CSEmpty ) clientControllerEvent . state ; empty . pushMenu ( this ) ; break ; } case packagesLoad : { popAll ( ) ; pushPackageLoadingMenu ( ) ; break ; } case mapDownload : { popAll ( ) ; pushMenu ( new WaitLoadingMenu ( L . get ( "MENU_DOWNLOADING_MAP" ) , true ) ) ; break ; } case mapLoad : { popAll ( ) ; pushMenu ( new WaitLoadingMenu ( L . get ( "MENU_INITIALIZING_MAP" ) , true ) ) ; break ; } case game : { popAll ( ) ; BrainOutClient . getInstance ( ) . switchState ( new ActionPhaseState ( ) ) ; break ; } } break ; } } return false ;
init: public void init ( ) { super . init ( ) ; this . effect = getContentComponent ( ) . getEffects ( ) ; initEffect ( ) ;
isScaleXEnabled: public boolean isScaleXEnabled ( ) { return mScaleXEnabled ;
apply: public boolean apply ( PlayerClient playerClient ) { boolean weAreGood = false ; for ( ServerRewards reward : rewards ) { weAreGood |= reward . apply ( playerClient ) ; } return weAreGood ;
getEntries: public LegendEntry [ ] getEntries ( ) { return mEntries ;
init: public void init ( ) { super . init ( ) ; InstrumentAnimationComponentData cwp = getComponentObject ( ) . getComponentWithSubclass ( InstrumentAnimationComponentData . class ) ; if ( cwp == null ) return ; laserPoint = new BonePointData (
getUserAgent: @ Override public String getUserAgent ( ) { return "" ;
setBufferSizeField: public void setBufferSizeField ( String bufferSizeField ) { this . bufferSizeField = bufferSizeField ;
applyChanges: public ApplyChangesResponse applyChanges ( final ApplyChangesRequest request ) throws IOException , NovuNetworkException { Response < ApplyChangesResponse > response = changeApi . applyChanges ( request ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
prepareTempAttachmentFile: protected Path prepareTempAttachmentFile ( String attachmentURL ) { debug ( "[prepareTempAttachmentFile] {}" , attachmentURL ) ; if ( StringUtils . isBlank ( attachmentURL ) ) { return null ; } Path tmpFile = null ; try { RestTemplate rTemplate = new RestTemplate ( ) ; ResponseEntity < byte [ ] > tmp = rTemplate . getForEntity ( attachmentURL , byte [ ] . class ) ; String fileName = StringUtils . substringAfterLast ( tmp . getHeaders ( ) . get ( "Content-Disposition" ) . get ( 0 ) , "=" ) ; String extension = "." + StringUtils . substringAfterLast ( fileName , "." ) ; fileName = StringUtils . substringBeforeLast ( fileName , "." ) ; tmpFile = Files . createTempFile ( fileName , extension ) ; Files . write ( tmpFile , tmp . getBody ( ) ) ; } catch ( IOException e ) { error ( e , "Error while creating temporary attachment for email from url({}):" , attachmentURL ) ; } return tmpFile ;
setProgressViewText: private void setProgressViewText ( View view , double total , double current ) { LinearLayout downloadView = view . findViewById ( R . id . download_view ) ; downloadView . findViewById ( R . id . refresh_btn ) . setVisibility ( View . INVISIBLE ) ; RelativeLayout rvProcessInner = downloadView . findViewById ( R . id . process_inner ) ; RelativeLayout rvMyProcessOuter = downloadView . findViewById ( R . id . progress_bar_outer ) ; double percent = ( current / total * 100 ) ; double totalWidth = rvMyProcessOuter . getWidth ( ) ; int innerHeight = rvMyProcessOuter . getHeight ( ) - 2 ; int innerWidth = ( int ) ( totalWidth * percent / 100 ) ; TextView syncPercentView = downloadView . findViewById ( R . id . sync_percent ) ; String percentString = String . format ( "%.2f" , percent ) + "%" ; syncPercentView . setText ( percentString ) ; RelativeLayout . LayoutParams rlInnerParam = new RelativeLayout . LayoutParams ( innerWidth , innerHeight ) ; rvProcessInner . setLayoutParams ( rlInnerParam ) ; TextView syncedBlockNumView = downloadView . findViewById ( R . id . block_num_synced ) ; syncedBlockNumView . setText ( String . format ( "%.2f" , current ) + "MB" ) ;
onNotExecuted: No method body
updateTransform: private void updateTransform ( ) { if ( light != null )
updateOrCreateProductReductions: public void updateOrCreateProductReductions ( String shopKey , Integer campaignId , List < ProductCampaignReduction > model ) throws ApiErrorException , ConnectionException { this . request ( "post" , this . resolvePath ( "/shops/%s/campaigns/%s/reductions/products" , shopKey , campaignId ) , null , null , null , model ) ;
setRightTextSize: public void setRightTextSize ( int textSize ) { TextView textView = ( TextView ) getView ( R . id . tv_right ) ; DisplayUtil . setTextSizeDP ( textView , textSize ) ;
getHeight: No method body
contains: No method body
restSubscribeOn$default: public static Observable < ? > restSubscribeOn$default ( Observable < ? > observable , boolean b , int i , Object obj ) { return observable ;
addSubscriberToTopic: public SubscriberAdditionResponse addSubscriberToTopic ( final SubscriberAdditionRequest request , final String topicKey ) throws IOException , NovuNetworkException { Response < SubscriberAdditionResponse > response = topicApi . addSubscriberToTopic ( topicKey , request ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
isInBoundsX: protected boolean isInBoundsX ( Entry e , IBarLineScatterCandleBubbleDataSet set ) { if ( e == null ) return false ; float entryIndex = set . getEntryIndex ( e ) ; if ( e == null || entryIndex >= set . getEntryCount ( ) * mAnimator . getPhaseX ( ) ) {
onFail: No method body
getDimension: public String getDimension ( ) { return activeData . getDimension ( ) ;
getTags: public int getTags ( ) { return super . getTags ( ) | WithTag . TAG ( Constants . ActiveTags . DETECTABLE ) ;
component5: public final MessageAttachment component5 ( ) { return this . attachment ;
use: public boolean use ( ConsumableContainer container , ConsumableRecord record ) { uses -- ; if ( uses <= 0 ) { container . getConsumable ( 1 , record ) ; return true ; } return false ;
getKeyCode: public int getKeyCode ( Keys keys , int def ) { return this . codes . get ( keys , def ) ;
isPerTaskReward: public boolean isPerTaskReward ( ) { return perTaskReward ;
init: private void init ( ) { setSelected ( false ) ; setImageResource ( R . drawable . selector_icon_password_eye ) ; setOnClickListener ( this ) ;
checkSyncedOver: private Boolean checkSyncedOver ( String logLine ) { Boolean isMatch = false ; String pattern ; pattern = ".*Chain backend is fully synced \\(end_height=\\d+\\)!.*" ; Pattern r = Pattern . compile ( pattern ) ; Matcher m = r . matcher ( logLine ) ; isMatch = m . matches ( ) ; return isMatch ;
transfer: public double transfer ( BankAccount other , double amount ) { String CountryCodeSrc = IBAN . substring ( 0 , 2 ) ; String CountryCodeDst = other . getIBAN ( ) . substring ( 0 , 2 ) ; if ( ! CountryCodeSrc . equals ( CountryCodeDst ) ) { throw new IllegalArgumentException ( "International transfers invalid" ) ; } double allowedAmount = withdraw ( amount ) ; other . deposit ( allowedAmount ) ; return allowedAmount ;
setNext: public void setNext ( Node next ) { this . next = next ;
findOne: default T findOne ( Long id ) { return findById ( id ) . orElse ( null ) ;
hasPrivileges: public boolean hasPrivileges ( ) { return ! privileges . isEmpty ( ) ;
getStreamOf: public static Stream < Student > getStreamOf ( ) { return Stream . of (
readAnimation: private Animation readAnimation ( SkeletonInput input , String name , SkeletonData skeletonData ) throws IOException { Array < Timeline > timelines = new Array ( input . readInt ( true ) ) ; float scale = this . scale ; for ( int i = 0 , n = input . readInt ( true ) ; i < n ; i ++ ) { int slotIndex = input . readInt ( true ) ; for ( int ii = 0 , nn = input . readInt ( true ) ; ii < nn ; ii ++ ) { int timelineType = input . readByte ( ) , frameCount = input . readInt ( true ) , frameLast = frameCount - 1 ; switch ( timelineType ) { case SLOT_ATTACHMENT : { AttachmentTimeline timeline = new AttachmentTimeline ( frameCount , slotIndex ) ; for ( int frame = 0 ; frame < frameCount ; frame ++ ) timeline . setFrame ( frame , input . readFloat ( ) , input . readStringRef ( ) ) ; timelines . add ( timeline ) ; break ; } case SLOT_RGBA : { RGBATimeline timeline = new RGBATimeline ( frameCount , input . readInt ( true ) , slotIndex ) ; float time = input . readFloat ( ) ; float r = input . read ( ) / 255f , g = input . read ( ) / 255f ; float b = input . read ( ) / 255f , a = input . read ( ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b , a ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) ; float r2 = input . read ( ) / 255f , g2 = input . read ( ) / 255f ; float b2 = input . read ( ) / 255f , a2 = input . read ( ) / 255f ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , r , r2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 1 , time , time2 , g , g2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 2 , time , time2 , b , b2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 3 , time , time2 , a , a2 , 1 ) ; } time = time2 ; r = r2 ; g = g2 ; b = b2 ; a = a2 ; } timelines . add ( timeline ) ; break ; } case SLOT_RGB : { RGBTimeline timeline = new RGBTimeline ( frameCount , input . readInt ( true ) , slotIndex ) ; float time = input . readFloat ( ) ; float r = input . read ( ) / 255f , g = input . read ( ) / 255f , b = input . read ( ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) ; float r2 = input . read ( ) / 255f , g2 = input . read ( ) / 255f , b2 = input . read ( ) / 255f ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , r , r2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 1 , time , time2 , g , g2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 2 , time , time2 , b , b2 , 1 ) ; } time = time2 ; r = r2 ; g = g2 ; b = b2 ; } timelines . add ( timeline ) ; break ; } case SLOT_RGBA2 : { RGBA2Timeline timeline = new RGBA2Timeline ( frameCount , input . readInt ( true ) , slotIndex ) ; float time = input . readFloat ( ) ; float r = input . read ( ) / 255f , g = input . read ( ) / 255f ; float b = input . read ( ) / 255f , a = input . read ( ) / 255f ; float r2 = input . read ( ) / 255f , g2 = input . read ( ) / 255f , b2 = input . read ( ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b , a , r2 , g2 , b2 ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) ; float nr = input . read ( ) / 255f , ng = input . read ( ) / 255f ; float nb = input . read ( ) / 255f , na = input . read ( ) / 255f ; float nr2 = input . read ( ) / 255f , ng2 = input . read ( ) / 255f , nb2 = input . read ( ) / 255f ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , r , nr , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 1 , time , time2 , g , ng , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 2 , time , time2 , b , nb , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 3 , time , time2 , a , na , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 4 , time , time2 , r2 , nr2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 5 , time , time2 , g2 , ng2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 6 , time , time2 , b2 , nb2 , 1 ) ; } time = time2 ; r = nr ; g = ng ; b = nb ; a = na ; r2 = nr2 ; g2 = ng2 ; b2 = nb2 ; } timelines . add ( timeline ) ; break ; } case SLOT_RGB2 : { RGB2Timeline timeline = new RGB2Timeline ( frameCount , input . readInt ( true ) , slotIndex ) ; float time = input . readFloat ( ) ; float r = input . read ( ) / 255f , g = input . read ( ) / 255f , b = input . read ( ) / 255f ; float r2 = input . read ( ) / 255f , g2 = input . read ( ) / 255f , b2 = input . read ( ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b , r2 , g2 , b2 ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) ; float nr = input . read ( ) / 255f , ng = input . read ( ) / 255f , nb = input . read ( ) / 255f ; float nr2 = input . read ( ) / 255f , ng2 = input . read ( ) / 255f , nb2 = input . read ( ) / 255f ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , r , nr , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 1 , time , time2 , g , ng , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 2 , time , time2 , b , nb , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 3 , time , time2 , r2 , nr2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 4 , time , time2 , g2 , ng2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 5 , time , time2 , b2 , nb2 , 1 ) ; } time = time2 ; r = nr ; g = ng ; b = nb ; r2 = nr2 ; g2 = ng2 ; b2 = nb2 ; } timelines . add ( timeline ) ; break ; } case SLOT_ALPHA : AlphaTimeline timeline = new AlphaTimeline ( frameCount , input . readInt ( true ) , slotIndex ) ; float time = input . readFloat ( ) , a = input . read ( ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , a ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) ; float a2 = input . read ( ) / 255f ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , a , a2 , 1 ) ; } time = time2 ; a = a2 ; } timelines . add ( timeline ) ; break ; } } } for ( int i = 0 , n = input . readInt ( true ) ; i < n ; i ++ ) { int boneIndex = input . readInt ( true ) ; for ( int ii = 0 , nn = input . readInt ( true ) ; ii < nn ; ii ++ ) { int type = input . readByte ( ) , frameCount = input . readInt ( true ) , bezierCount = input . readInt ( true ) ; switch ( type ) { case BONE_ROTATE : timelines . add ( readTimeline ( input , new RotateTimeline ( frameCount , bezierCount , boneIndex ) , 1 ) ) ; break ; case BONE_TRANSLATE : timelines . add ( readTimeline ( input , new TranslateTimeline ( frameCount , bezierCount , boneIndex ) , scale ) ) ; break ; case BONE_TRANSLATEX : timelines . add ( readTimeline ( input , new TranslateXTimeline ( frameCount , bezierCount , boneIndex ) , scale ) ) ; break ; case BONE_TRANSLATEY : timelines . add ( readTimeline ( input , new TranslateYTimeline ( frameCount , bezierCount , boneIndex ) , scale ) ) ; break ; case BONE_SCALE : timelines . add ( readTimeline ( input , new ScaleTimeline ( frameCount , bezierCount , boneIndex ) , 1 ) ) ; break ; case BONE_SCALEX : timelines . add ( readTimeline ( input , new ScaleXTimeline ( frameCount , bezierCount , boneIndex ) , 1 ) ) ; break ; case BONE_SCALEY : timelines . add ( readTimeline ( input , new ScaleYTimeline ( frameCount , bezierCount , boneIndex ) , 1 ) ) ; break ; case BONE_SHEAR : timelines . add ( readTimeline ( input , new ShearTimeline ( frameCount , bezierCount , boneIndex ) , 1 ) ) ; break ; case BONE_SHEARX : timelines . add ( readTimeline ( input , new ShearXTimeline ( frameCount , bezierCount , boneIndex ) , 1 ) ) ; break ; case BONE_SHEARY : timelines . add ( readTimeline ( input , new ShearYTimeline ( frameCount , bezierCount , boneIndex ) , 1 ) ) ; } } } for ( int i = 0 , n = input . readInt ( true ) ; i < n ; i ++ ) { int index = input . readInt ( true ) , frameCount = input . readInt ( true ) , frameLast = frameCount - 1 ; IkConstraintTimeline timeline = new IkConstraintTimeline ( frameCount , input . readInt ( true ) , index ) ; float time = input . readFloat ( ) , mix = input . readFloat ( ) , softness = input . readFloat ( ) * scale ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , mix , softness , input . readByte ( ) , input . readBoolean ( ) , input . readBoolean ( ) ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) , mix2 = input . readFloat ( ) , softness2 = input . readFloat ( ) * scale ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , mix , mix2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 1 , time , time2 , softness , softness2 , scale ) ; } time = time2 ; mix = mix2 ; softness = softness2 ; } timelines . add ( timeline ) ; } for ( int i = 0 , n = input . readInt ( true ) ; i < n ; i ++ ) { int index = input . readInt ( true ) , frameCount = input . readInt ( true ) , frameLast = frameCount - 1 ; TransformConstraintTimeline timeline = new TransformConstraintTimeline ( frameCount , input . readInt ( true ) , index ) ; float time = input . readFloat ( ) , mixRotate = input . readFloat ( ) , mixX = input . readFloat ( ) , mixY = input . readFloat ( ) , mixScaleX = input . readFloat ( ) , mixScaleY = input . readFloat ( ) , mixShearY = input . readFloat ( ) ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , mixRotate , mixX , mixY , mixScaleX , mixScaleY , mixShearY ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) , mixRotate2 = input . readFloat ( ) , mixX2 = input . readFloat ( ) , mixY2 = input . readFloat ( ) , mixScaleX2 = input . readFloat ( ) , mixScaleY2 = input . readFloat ( ) , mixShearY2 = input . readFloat ( ) ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , mixRotate , mixRotate2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 1 , time , time2 , mixX , mixX2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 2 , time , time2 , mixY , mixY2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 3 , time , time2 , mixScaleX , mixScaleX2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 4 , time , time2 , mixScaleY , mixScaleY2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 5 , time , time2 , mixShearY , mixShearY2 , 1 ) ; } time = time2 ; mixRotate = mixRotate2 ; mixX = mixX2 ; mixY = mixY2 ; mixScaleX = mixScaleX2 ; mixScaleY = mixScaleY2 ; mixShearY = mixShearY2 ; } timelines . add ( timeline ) ; } for ( int i = 0 , n = input . readInt ( true ) ; i < n ; i ++ ) { int index = input . readInt ( true ) ; PathConstraintData data = skeletonData . pathConstraints . get ( index ) ; for ( int ii = 0 , nn = input . readInt ( true ) ; ii < nn ; ii ++ ) { switch ( input . readByte ( ) ) { case PATH_POSITION : timelines . add ( readTimeline ( input , new PathConstraintPositionTimeline ( input . readInt ( true ) , input . readInt ( true ) , index ) , data . positionMode == PositionMode . fixed ? scale : 1 ) ) ; break ; case PATH_SPACING : timelines . add ( readTimeline ( input , new PathConstraintSpacingTimeline ( input . readInt ( true ) , input . readInt ( true ) , index ) , data . spacingMode == SpacingMode . length || data . spacingMode == SpacingMode . fixed ? scale : 1 ) ) ; break ; case PATH_MIX : PathConstraintMixTimeline timeline = new PathConstraintMixTimeline ( input . readInt ( true ) , input . readInt ( true ) , index ) ; float time = input . readFloat ( ) , mixRotate = input . readFloat ( ) , mixX = input . readFloat ( ) , mixY = input . readFloat ( ) ; for ( int frame = 0 , bezier = 0 , frameLast = timeline . getFrameCount ( ) - 1 ; ; frame ++ ) { timeline . setFrame ( frame , time , mixRotate , mixX , mixY ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) , mixRotate2 = input . readFloat ( ) , mixX2 = input . readFloat ( ) , mixY2 = input . readFloat ( ) ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , mixRotate , mixRotate2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 1 , time , time2 , mixX , mixX2 , 1 ) ; setBezier ( input , timeline , bezier ++ , frame , 2 , time , time2 , mixY , mixY2 , 1 ) ; } time = time2 ; mixRotate = mixRotate2 ; mixX = mixX2 ; mixY = mixY2 ; } timelines . add ( timeline ) ; } } } for ( int i = 0 , n = input . readInt ( true ) ; i < n ; i ++ ) { Skin skin = skeletonData . skins . get ( input . readInt ( true ) ) ; for ( int ii = 0 , nn = input . readInt ( true ) ; ii < nn ; ii ++ ) { int slotIndex = input . readInt ( true ) ; for ( int iii = 0 , nnn = input . readInt ( true ) ; iii < nnn ; iii ++ ) { String attachmentName = input . readStringRef ( ) ; VertexAttachment attachment = ( VertexAttachment ) skin . getAttachment ( slotIndex , attachmentName ) ; if ( attachment == null ) throw new SerializationException ( "Vertex attachment not found: " + attachmentName ) ; boolean weighted = attachment . getBones ( ) != null ; float [ ] vertices = attachment . getVertices ( ) ; int deformLength = weighted ? ( vertices . length / 3 ) << 1 : vertices . length ; int frameCount = input . readInt ( true ) , frameLast = frameCount - 1 ; DeformTimeline timeline = new DeformTimeline ( frameCount , input . readInt ( true ) , slotIndex , attachment ) ; float time = input . readFloat ( ) ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { float [ ] deform ; int end = input . readInt ( true ) ; if ( end == 0 ) deform = weighted ? new float [ deformLength ] : vertices ; else { deform = new float [ deformLength ] ; int start = input . readInt ( true ) ; end += start ; if ( scale == 1 ) { for ( int v = start ; v < end ; v ++ ) deform [ v ] = input . readFloat ( ) ; } else { for ( int v = start ; v < end ; v ++ ) deform [ v ] = input . readFloat ( ) * scale ; } if ( ! weighted ) { for ( int v = 0 , vn = deform . length ; v < vn ; v ++ ) deform [ v ] += vertices [ v ] ; } } timeline . setFrame ( frame , time , deform ) ; if ( frame == frameLast ) break ; float time2 = input . readFloat ( ) ; switch ( input . readByte ( ) ) { case CURVE_STEPPED : timeline . setStepped ( frame ) ; break ; case CURVE_BEZIER : setBezier ( input , timeline , bezier ++ , frame , 0 , time , time2 , 0 , 1 , 1 ) ; } time = time2 ; } timelines . add ( timeline ) ; } } } int drawOrderCount = input . readInt ( true ) ; if ( drawOrderCount > 0 ) { DrawOrderTimeline timeline = new DrawOrderTimeline ( drawOrderCount ) ; int slotCount = skeletonData . slots . size ; for ( int i = 0 ; i < drawOrderCount ; i ++ ) { float time = input . readFloat ( ) ; int offsetCount = input . readInt ( true ) ; int [ ] drawOrder = new int [ slotCount ] ; for ( int ii = slotCount - 1 ; ii >= 0 ; ii -- ) drawOrder [ ii ] = - 1 ; int [ ] unchanged = new int [ slotCount - offsetCount ] ; int originalIndex = 0 , unchangedIndex = 0 ; for ( int ii = 0 ; ii < offsetCount ; ii ++ ) { int slotIndex = input . readInt ( true ) ; while ( originalIndex != slotIndex ) unchanged [ unchangedIndex ++ ] = originalIndex ++ ; drawOrder [ originalIndex + input . readInt ( true ) ] = originalIndex ++ ; } while ( originalIndex < slotCount ) unchanged [ unchangedIndex ++ ] = originalIndex ++ ; for ( int ii = slotCount - 1 ; ii >= 0 ; ii -- ) if ( drawOrder [ ii ] == - 1 ) drawOrder [ ii ] = unchanged [ -- unchangedIndex ] ; timeline . setFrame ( i , time , drawOrder ) ; } timelines . add ( timeline ) ; } int eventCount = input . readInt ( true ) ; if ( eventCount > 0 ) { EventTimeline timeline = new EventTimeline ( eventCount ) ; for ( int i = 0 ; i < eventCount ; i ++ ) { float time = input . readFloat ( ) ; EventData eventData = skeletonData . events . get ( input . readInt ( true ) ) ; Event event = new Event ( time , eventData ) ; event . intValue = input . readInt ( false ) ; event . floatValue = input . readFloat ( ) ; event . stringValue = input . readBoolean ( ) ? input . readString ( ) : eventData . stringValue ; if ( event . getData ( ) . audioPath != null ) { event . volume = input . readFloat ( ) ; event . balance = input . readFloat ( ) ; } timeline . setFrame ( i , event ) ; } timelines . add ( timeline ) ; } float duration = 0 ; Object [ ] items = timelines . items ; for ( int i = 0 , n = timelines . size ; i < n ; i ++ ) duration = Math . max ( duration , ( ( Timeline ) items [ i ] ) . getDuration ( ) ) ; return new Animation ( name , timelines , duration ) ;
updateDrawState: public void updateDrawState ( TextPaint ds ) { super . updateDrawState ( ds ) ; ds . setUnderlineText ( false ) ;
obtain: public static Event obtain ( Kind kind , LaunchData launchData , String custom ) { LaunchEffectEvent e = obtain ( LaunchEffectEvent . class ) ; if ( e == null ) return null ; return e . init ( kind , launchData , custom ) ;
setMax: public synchronized void setMax ( int max ) { if ( max < 0 ) { throw new IllegalArgumentException ( "max not less than 0" ) ; } this . max = max ;
setScrollY: public void setScrollY ( float pixels ) { super . scrollY ( pixels ) ;
remove: No method body
getContent: public String getContent ( ) { return content ;
isAccountNonLocked: public boolean isAccountNonLocked ( ) { return true ;
i_should_see_alert: public void i_should_see_alert ( String alertMessage ) { Assert . assertEquals ( alertMessage , page . waitFor ( page . alertMessage ) . getText ( ) . replace ( "\n" , "" ) ) ;
getY: public float getY ( ) { return playerData . getY ( ) ;
append: void append ( ) { List < Integer > a = new ArrayList < > ( List . of ( 1 , 2 , 3 ) ) ; List < Integer > b = new ArrayList < > ( List . of ( 4 , 5 ) ) ; Append . append ( a , b ) ; assertEquals ( List . of ( 1 , 2 , 3 , 4 , 5 ) , a ) ;
getLastName: public String getLastName ( ) { return lastName ;
isPalindrome: public static boolean isPalindrome ( String s ) { if ( s . isEmpty ( ) ) { return true ; } String reversedString = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; return reversedString . equalsIgnoreCase ( s ) ;
isOnUIThread: public static boolean isOnUIThread ( ) { return Looper . myLooper ( ) == Looper . getMainLooper ( ) ;
getValue: public Object getValue ( ) { return value ;
testGetAudience: public void testGetAudience ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Audience responseEntity = this . api . audiences ( ) . getAudience ( "645e0c241a93369ff53f26e0" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/AudienceGetAudienceResponse.json" ) ; assertThatJson ( expectedResponseJson )
parse: public void parse ( EventService . Event event ) { super . parse ( event ) ; stages = new Array < > ( ) ; Stage oldStage = null ; battlePass = event . data . getString ( "battle-pass" ) ; JSONArray stages = event . data . optJSONArray ( "stages" ) ; if ( stages != null )
hashCode: public int hashCode ( ) { return Objects . hash ( title , year , length ) ;
removeBadge: protected void removeBadge ( Actor applied ) { applied . setVisible ( false ) ;
addSubscriberToTopic: public SubscriberAdditionResponse addSubscriberToTopic ( final SubscriberAdditionRequest request , final String topicKey ) throws IOException , NovuNetworkException { try {
calcStackSize: private void calcStackSize ( List < BarEntry > yVals ) { for ( int i = 0 ; i < yVals . size ( ) ; i ++ ) {
checkOrganizationOnlyNotificationNotPushedToMsTeamsNoAttributePresent: public void checkOrganizationOnlyNotificationNotPushedToMsTeamsNoAttributePresent ( ) { long organizationId = 1L ; NotificationDto notificationDto = new NotificationDto ( "message" , Notification . NotificationType . SUCCESS , organizationId , null ) ; notificationDto . propagate = Boolean . TRUE ; IntegrationModuleOrganizationConfiguration organizationConfiguration = prepareIntegrationModuleOrganizationConfiguration ( organizationId ) ; organizationConfiguration . msTeamsWebhookUrl = null ; when ( integrationService . getOrganizationConfiguration ( organizationId ) ) . thenReturn ( organizationConfiguration ) ; pushNotificationService . createMsTeamsPostMessageRequest ( notificationDto ) ; verify ( integrationService , times ( 1 ) ) . getOrganizationConfiguration ( anyLong ( ) ) ; verify ( httpRequestTaskRepository , never ( ) ) . save ( any ( HttpRequestTask . class ) ) ;
onPageStarted: public void onPageStarted ( WebView view , String url , Bitmap favicon ) { if ( mIsLoading && mUrls . size ( ) > 0 ) { mUrls . pop ( ) ; } recordUrl ( url ) ; super . onPageStarted ( view , url , favicon ) ; if ( mCallBack != null ) {
setDrawable: public void setDrawable ( Drawable drawable ) { this . mDrawable = drawable ; invalidate ( ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case activeAction : { ActiveActionEvent ev = ( ( ActiveActionEvent ) event ) ; switch ( ev . action ) { case updated : { if ( ev . activeData instanceof ItemData ) { ItemData itemData = ( ( ItemData ) ev . activeData ) ; if ( good ( itemData ) ) { updated ( itemData ) ; } } break ; } } break ; } } return false ;
validateIDCard: public static boolean validateIDCard ( String idCard ) { String card = idCard . trim ( ) ; if ( validateIdCard18 ( card ) ) { return true ; } if ( validateIdCard15 ( card ) ) { return true ; } String [ ] cardValidate = validateIdCard10 ( card ) ; if ( cardValidate != null ) { if ( ! StringUtils . isEmpty ( cardValidate [ 2 ] ) && cardValidate [ 2 ] . equals ( "true" ) ) { return true ; } } return false ;
fetchAvatar: protected void fetchAvatar ( String avatar , Table avatarInfo ) { Avatars . Get ( avatar , ( has , avatarTexture ) ->
getInstance: public static MPPointD getInstance ( double x , double y ) { MPPointD result = pool . get ( ) ; result . x = x ; result . y = y ; return result ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case animationAction : { InstrumentData currentInstrument = playerData . getCurrentInstrument ( ) ; if ( currentInstrument != null && currentInstrument . onEvent ( event ) ) { return true ; } break ; } case resetInstrument : { detachCurrentInstrument ( ) ; break ; } } return super . onEvent ( event ) ;
getEndColor: public int getEndColor ( ) { return getGradientColors ( ) [ 1 ] ;
delete: public void delete ( String shopKey , Integer redirectId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/redirects/%s" , shopKey , redirectId ) , null , null , null ) ;
getPicture: public String getPicture ( ) { return picture ;
getBones: public Array < Bone > getBones ( ) { return bones ;
update: public AjaxResult update ( @ RequestBody @ Valid UpdateRoleByRoleParam param ) { Role role = RoleConverterMapper . INSTANCE . UpdateParamToRole ( param ) ; roleService . updateRole ( role ) ; return AjaxResult . success ( ) ;
estimateRouteFee: public Single < routerrpc . RouterOuterClass . RouteFeeResponse > estimateRouteFee ( routerrpc . RouterOuterClass . RouteFeeRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . estimateRouteFee ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
delete: public void delete ( String shopKey , String countryCode , Integer priceRoundingId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/price-roundings/%s" , shopKey , countryCode , priceRoundingId ) , null , null , null ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
received: public boolean received ( final SimpleMsg simpleMsg ) { Gdx . app . postRunnable ( ( ) -> { switch ( simpleMsg . code ) { case invalidSpawn : { invalidSpawn ( ) ; break ; } case updateSpawn : { updateSpawn ( ) ; break ; } } } ) ; return true ;
endNodeInternal: public void endNodeInternal ( ) { synchronized ( currentNodes ) {
getTenants: No method body
getOrganization: public Organization getOrganization ( ) { return organization ;
copy: public Attachment copy ( ) { ClippingAttachment copy = new ClippingAttachment ( name ) ; copyTo ( copy ) ; copy . endSlot = endSlot ; copy . color . set ( color ) ; return copy ;
resetGame: public boolean resetGame ( int owner ) { if ( ! validateParticipant ( owner ) ) return false ; for ( IntMap . Entry < Participant > entry : participants ) { entry . value . hand . clear ( ) ; } tableCards . clear ( ) ; discard . clear ( ) ; deck = new Array < > ( getContentComponent ( ) . getDeck ( ) ) ; deck . shuffle ( ) ; notifyTableToAll ( ) ; return true ;
getSortFilter: private MarketService . MarkerEntriesOrder getSortFilter ( ) { if ( forcePriceSort ) { return MarketService . MarkerEntriesOrder . takeAmountAsc ; } if ( giveItemFilterTitle != null ) { return MarketService . MarkerEntriesOrder . none ; } if ( giveItemFilter != null || accountFilter != null || giveItemPayloadFilter != null ) { return MarketService . MarkerEntriesOrder . takeAmountAsc ; } return MarketService . MarkerEntriesOrder . none ;
isContentView: public boolean isContentView ( @ LayoutRes int layoutId ) { return true ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; mSendStepThreePopupWindow = new SendStepThreePopupWindow ( mContext ) ; mSendStepThreePopupWindow . show ( view ) ;
isPropagate: public boolean isPropagate ( ) { return propagate ;
add: public void add ( Object o ) { add ( o , size ) ;
productVariantPrices: public ProductVariantPriceService productVariantPrices ( ) { ProductVariantPriceService service = this . getService ( "com.scayle.adminapi.service.ProductVariantPriceService" ) ; return service ;
received: public boolean received ( PingMsg pingMsg ) { sendUDP ( new PongMsg ( pingMsg , 0 ) ) ; return true ;
updateWaterOutflow: public void updateWaterOutflow ( double flow , double tempC ) { waterOutflow += flow ;
testAnonymize: public void testAnonymize ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . customers ( ) . anonymize ( "acme" , "acme" , Identifier . fromId ( 1 ) , options ) ;
createGlobalRoleTest: public void createGlobalRoleTest ( ) { GlobalRole role = new GlobalRole ( ) ; role . setName ( ROLE_NAME ) ; reset ( globalRoleRepository ) ; Mockito . when ( globalRoleRepository . findByName ( anyString ( ) ) ) . thenReturn ( null ) . thenReturn ( role ) ; GlobalRole result = roleService . createOrUpdateGlobalRole ( ROLE_NAME , ROLE_PRIVILEGES , false ) ; assertEquals ( ROLE_NAME , result . getName ( ) ) ; verify ( globalRoleRepository , times ( 1 ) ) . save ( any ( GlobalRole . class ) ) ;
freePersonalMaps: private void freePersonalMaps ( String exitedFromDimension , PlayerClient playerClient ) { ServerFreeplayMap oldMap = ServerFreeplayMap . Get ( exitedFromDimension , ServerFreeplayMap . class ) ; if ( oldMap == null ) { return ; } RealEstateInfo rsInfo = oldMap . getRealEstateInfo ( ) ; if ( rsInfo == null ) { return ; } Array < ServerFreeplayMap > mapsOfInterest = new Array < > ( ) ; Array < ConsumableRecord > toRemove = new Array < > ( ) ; for ( ServerMap map : Map . All ( ServerMap . class ) ) { if ( ! ( map instanceof ServerFreeplayMap ) ) continue ; ServerFreeplayMap f = ( ( ServerFreeplayMap ) map ) ; if ( f . getRealEstateInfo ( ) != rsInfo ) continue ; mapsOfInterest . add ( f ) ; } for ( ServerFreeplayMap map : mapsOfInterest ) { if ( map . countActivesForTag ( Constants . ActiveTags . PLAYERS ) > 0 ) { return ; } } playerClient . log ( "Disposing real estate dimension " + exitedFromDimension ) ; for ( ServerFreeplayMap map : mapsOfInterest ) { ModePayload p = playerClient . getModePayload ( ) ; if ( p instanceof FreePayload ) { ObjectMap < String , Map > personalMaps = ( ( FreePayload ) p ) . getPersonalMaps ( ) ; if ( personalMaps != null ) { personalMaps . remove ( map . getDimension ( ) ) ; } } for ( ActiveData activeData : map . getActivesForTag ( Constants . ActiveTags . ITEM , false ) ) { if ( ! ( activeData instanceof ItemData ) ) continue ; ConsumableContainer records = ( ( ItemData ) activeData ) . getRecords ( ) ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : records . getData ( ) ) { ConsumableItem item = entry . value . getItem ( ) ; if ( item . getPrivate ( ) == playerClient . getId ( ) ) { toRemove . add ( entry . value ) ; } } if ( toRemove . size > 0 ) { for ( ConsumableRecord item : toRemove ) { records . removeRecord ( item ) ; } toRemove . clear ( ) ; } } } PlayState ps = BrainOutServer . Controller . getPlayState ( ) ; for ( ServerMap map : mapsOfInterest )
onCreate: public void onCreate ( ) { inactivityTimer = new InactivityTimer ( activity ) ; beepManager = new BeepManager ( activity ) ; ambientLightManager = new AmbientLightManager ( activity ) ; cameraManager = new CameraManager ( activity ) ; cameraManager . setFullScreenScan ( isFullScreenScan ) ; callback = new SurfaceHolder . Callback ( ) { @ Override public void surfaceCreated ( SurfaceHolder holder ) { if ( holder == null ) { Log . e ( TAG , "*** WARNING *** surfaceCreated() gave us a null surface!" ) ; } if ( ! hasSurface ) { hasSurface = true ; initCamera ( holder ) ; } } @ Override public void surfaceChanged ( SurfaceHolder holder , int format , int width , int height ) { } @ Override public void surfaceDestroyed ( SurfaceHolder holder ) { hasSurface = false ; } } ; onCaptureListener = new OnCaptureListener ( ) { @ Override public void onHandleDecode ( Result result , Bitmap barcode , float scaleFactor ) { inactivityTimer . onActivity ( ) ; beepManager . playBeepSoundAndVibrate ( ) ; onResult ( result ) ; } @ Override public void onLightChange ( boolean isDark ) { if ( onCaptureCallback != null ) { onCaptureCallback . onLightChange ( isDark ) ; } } } ; beepManager . setPlayBeep ( isPlayBeep ) ; beepManager . setVibrate ( isVibrate ) ;
activate: public boolean activate ( PlayerData playerData ) { if ( ! test ( playerData ) ) return false ; BrainOutClient . ClientController . sendTCP ( new ActivateActiveMsg ( activeData . getId ( ) , "" ) ) ; return true ;
setEnemy: private void setEnemy ( boolean enemy ) { String icon = enemy ? "player-icon-enemy" : "player-icon-friend" ; if ( teamIcon == null )
deleteContact: public void deleteContact ( Identifier merchantIdentifier , Integer merchantContactId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/merchants/%s/contacts/%s" , merchantIdentifier , merchantContactId ) , null , null , null ) ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
getFlipX: public boolean getFlipX ( ) { return false ;
buildPlanarYUVLuminanceSource: private PlanarYUVLuminanceSource buildPlanarYUVLuminanceSource ( byte [ ] data , int width , int height , boolean isRotate ) { PlanarYUVLuminanceSource source ; if ( isRotate ) { byte [ ] rotatedData = new byte [ data . length ] ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) rotatedData [ x * height + height - y - 1 ] = data [ x + y * width ] ; } int tmp = width ; width = height ; height = tmp ; source = cameraManager . buildLuminanceSource ( rotatedData , width , height ) ; } else { source = cameraManager . buildLuminanceSource ( data , width , height ) ; } return source ;
delete: void delete ( ) throws Exception { Long userId = 6L ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . delete ( "/user/delete/" + userId ) . contentType ( MediaType . APPLICATION_JSON ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "删除用户接口测试成功！" ) ;
hasRender: public boolean hasRender ( ) { return false ;
selected: No method body
beforeExecute: protected void beforeExecute ( Thread t , Runnable r ) { super . beforeExecute ( t , r ) ; pauseLock . lock ( ) ; try
clearCacheRefElement: private void clearCacheRefElement ( String namespace ) { try {
delete: public void delete ( Identifier productIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/products/%s" , productIdentifier ) , query , null , null ) ;
getMessages: No method body
getFlipY: public boolean getFlipY ( ) { return getScaleY ( ) < 0 ;
peekPromise: public void peekPromise ( String key , SyscallCallback < Deferred < ByteBuffer > > callback ) { wrapAndPropagateExceptions (
subscribeCustomMessages: public Observable < lnrpc . LightningOuterClass . CustomMessage > subscribeCustomMessages ( lnrpc . LightningOuterClass . SubscribeCustomMessagesRequest request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . subscribeCustomMessages ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
calcMinMax: protected void calcMinMax ( ) { super . calcMinMax ( ) ; mYAxis . calculate ( mData . getYMin ( AxisDependency . LEFT ) , mData . getYMax ( AxisDependency . LEFT ) ) ; mXAxis . calculate ( 0 , mData . getMaxEntryCountSet ( ) . getEntryCount ( ) ) ;
lockInput: public boolean lockInput ( ) { return true ;
getTarget: public Class < T > getTarget ( ) { return target ;
getLastLogin: public LocalDateTime getLastLogin ( ) { return lastLogin ;
setAX: public void setAX ( float ax ) { this . ax = ax ;
onMethodExit: protected void onMethodExit ( int opcode ) { if ( opcode != ATHROW ) {
setMixX: public void setMixX ( float mixX ) { this . mixX = mixX ;
getComponent: public PlayerAnimationComponentData getComponent ( ComponentObject componentObject ) { return new PlayerAnimationComponentData ( ( PlayerData ) componentObject , this ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { tgValvesStopActionPerformed ( evt ) ;
getAttachmentURL: public String getAttachmentURL ( ) { return attachmentURL ;
t3: public Tuple3 t3 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] ) ;
getType: public int getType ( ) { return TYPE_PENDING_FORCE_CLOSING_CHANNEL ;
func: public float func ( float x , float y ) { ActiveData it = ( ( ActiveData ) getComponentObject ( ) ) ; float dist = Math . abs ( it . getX ( ) - x ) ; float max = getContentComponent ( ) . getDistance ( ) ; if ( dist > max ) return 0 ; return ( 1.0f - dist / max ) ;
onClick: public void onClick ( View v ) { amountInput = amountEdit . getText ( ) . toString ( ) ; timeInput = amountTimeEdit . getText ( ) . toString ( ) ; numberInput = numberEdit . getText ( ) . toString ( ) ; timeType = timeButton . getText ( ) . toString ( ) ; if ( StringUtils . isEmpty ( amountInput ) ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . create_invoice_amount ) ) ; return ; } if ( amountInput . equals ( "0" ) ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . amount_greater_than_0 ) ) ; return ; } if ( ( Double . parseDouble ( amountInput ) * 100000000 ) - ( Double . parseDouble ( canSend ) * 100000000 ) > 0 ) { CreateNewChannelTipDialog mCreateNewChannelTipDialog = new CreateNewChannelTipDialog ( mContext ) ; mCreateNewChannelTipDialog . setCallback ( new CreateNewChannelTipDialog . Callback ( ) { @ Override public void onClick ( ) { mBasePopWindow . dismiss ( ) ; } } ) ; mCreateNewChannelTipDialog . show ( ) ; return ; } if ( StringUtils . isEmpty ( numberInput ) ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . enter_the_number ) ) ; return ; } if ( Integer . parseInt ( numberInput ) > 20 ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . num_exceeds ) ) ; return ; } if ( StringUtils . isEmpty ( timeInput ) ) { ToastUtils . showToast ( mContext , mContext . getString ( R . string . enter_the_time ) ) ; return ; } mLoadingDialog . show ( ) ; try {
getAuthors: public ObjectMap < String , String [ ] > getAuthors ( ) { return authors ;
history: public Object history ( @ PathVariable ( ORGANIZATIONID ) Long organizationId , @ Qualifier ( "audit" ) Pageable auditPageable , @ RequestParam ( required = false , defaultValue = "" , name = "audit_search" ) String search , HttpServletRequest request ) { debug ( "[history] orgId {}, " ) ; return getHistory ( organizationId , auditPageable , search )
getFollowPath: public Queue < Vector2 > getFollowPath ( ) { return followPath ;
addInventoryPanel: protected void addInventoryPanel ( Table b ) { b . add ( targetPanel ) . size ( 228 , 392 ) . row ( ) ; targetWeightUpgrades = new Table ( BrainOutClient . Skin ) ; targetWeightRoot = new Table ( BrainOutClient . Skin ) ; targetWeightRoot . setBackground ( "form-gray" ) ; targetWeightRoot . align ( Align . right ) ; targetWeightRoot . add ( targetWeighInfo ) . pad ( 1 ) ; targetWeightRoot . add ( targetWeightUpgrades ) . row ( ) ; b . add ( targetWeightRoot ) . expandX ( ) . fillX ( ) . row ( ) ; targetFill = new ProgressBar ( 0 , playerData . getMaxOverweight ( ) , 0.05f , false , BrainOutClient . Skin , "progress-inventory" ) ; b . add ( targetFill ) . expandX ( ) . fillX ( ) . padTop ( - 2 ) . row ( ) ; targetPanel . setHeight ( targetPanel . getHeight ( ) - targetWeightRoot . getHeight ( ) - targetFill . getHeight ( ) ) ;
setTitleText: public void setTitleText ( CharSequence titleText ) { setText ( R . id . tv_title , String . valueOf ( titleText ) ) ;
showSpawnMenu: public void showSpawnMenu ( ActionPhaseState state , ShopCart shopCart , SpawnMenu . Spawn spawn , Spawnable lastSpawnPoint ) { state . pushMenu ( new SpawnMenu ( shopCart , spawn , lastSpawnPoint ) ) ;
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Shop responseEntity = this . api . shops ( ) . get ( "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
FindGame: public static void FindGame ( RoomSettings roomSettings , FindGameResult callback , boolean trackStarted ) { FindGame ( "main" , roomSettings , callback , trackStarted ) ;
hasRender: public boolean hasRender ( ) { return false ;
instantiate: No method body
notFound: public void notFound ( ) { pushTask ( new TaskHide ( getStack ( ) , null ) ) ;
setHighlightPerTapEnabled: public void setHighlightPerTapEnabled ( boolean enabled ) { mHighLightPerTapEnabled = enabled ;
setToolbarWidgetColor: public void setToolbarWidgetColor ( @ ColorInt int color ) { options . putInt ( EXTRA_UCROP_WIDGET_COLOR_TOOLBAR , color ) ;
addOffsetCallback: public void addOffsetCallback ( UpdateOffsetCallback offsetCallback ) { this . offsetCallbacks . addLast ( offsetCallback ) ;
postApply: public void postApply ( InstrumentData instrumentData ) { if ( getComponents ( ) == null ) return ; for ( ContentComponent contentComponent : getComponents ( ) )
getState: protected TestInvocationBuilder getState ( AtomicInteger nonTerminalExceptionsSeen ) { return testDefinitionForVirtualObject (
addUpgradeButton: private Button addUpgradeButton ( String key , Upgrade upgrade , boolean canBeSelected , Table sideButtons ) { Shop . ShopItem shopItem = upgrade . getShopItem ( ) ; if ( shopItem == null ) return null ; final Button upgradeButton = new Button ( BrainOutClient . Skin , canBeSelected ? "button-upgrade-checkable" : "button-upgrade" ) ; class HoverUpgradeListener extends ClickOverListener { @ Override public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { super . enter ( event , x , y , pointer , fromActor ) ; chars . setHoverUpgrade ( key , upgrade ) ; updateChars ( ) ; } @ Override public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { super . exit ( event , x , y , pointer , toActor ) ; chars . clearHoverUpgrade ( ) ; updateChars ( ) ; } } ConsumableContent junk = BrainOutClient . ContentMgr . get ( "consumable-item-junk" , ConsumableContent . class ) ; if ( info . upgrades . get ( key ) == upgrade ) { if ( canBeSelected ) { upgradeButton . setChecked ( true ) ; } upgradeButton . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { upgradeButton . setChecked ( true ) ; } } ) ; } else { upgradeButton . addListener ( new HoverUpgradeListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { if ( playerInventory . getAmount ( junk ) >= getPrice ( shopItem ) ) { installUpgrade ( key , upgrade , ( ) -> { instrumentIcon . enableUpgrade ( key , upgrade ) ; updateChars ( ) ; renderSideButtons ( ) ; userPanel . refresh ( ) ; } , ( ) -> { upgradeButton . setChecked ( false ) ; playSound ( MenuSound . denied ) ; } ) ; } else { upgradeButton . setChecked ( false ) ; playSound ( MenuSound . denied ) ; } } } ) ; int amount = getPrice ( shopItem ) ; String icon = "icon-junk-small" ; Image currencyIcon = new Image ( BrainOutClient . getRegion ( icon ) ) ; Table price = new Table ( ) ; price . setTouchable ( Touchable . disabled ) ; price . setFillParent ( true ) ; price . align ( Align . right | Align . bottom ) ; price . add ( new Label ( String . valueOf ( amount ) , BrainOutClient . Skin , playerInventory . getAmount ( junk ) >= getPrice ( shopItem ) ? "title-small" : "title-red" ) ) . pad ( 8 ) ; price . add ( currencyIcon ) . pad ( 8 ) . padLeft ( - 8 ) . padBottom ( 4 ) . padRight ( 2 ) . row ( ) ; upgradeButton . addActor ( price ) ; } IconComponent iconComponent = upgrade . getComponent ( IconComponent . class ) ; if ( iconComponent != null ) { TextureRegion region = iconComponent . getIcon ( "big-icon" ) ; Image icon = new Image ( region ) ; icon . setScaling ( Scaling . none ) ; icon . setTouchable ( Touchable . disabled ) ; icon . setScale ( 2.0f ) ; icon . setBounds ( 0 , 0 , 192 , 64 ) ; icon . setOrigin ( Align . center ) ; upgradeButton . addActor ( icon ) ; } sideButtons . add ( upgradeButton ) . size ( 192 , 64 ) . row ( ) ; return upgradeButton ;
drawDescription: protected void drawDescription ( Canvas c ) { if ( mDescription != null && mDescription . isEnabled ( ) ) {
updateMessage: public void updateMessage ( String messageId , String sender , JSONObject payload ) { ClientMessage message = messages . get ( messageId ) ; if ( message != null )
readTextFile: public static List < String > readTextFile ( String filename ) throws IOException { Path src = Paths . get ( filename ) ; return Files . readAllLines ( src ) ;
resetSubscriptions: private void resetSubscriptions ( ClientProfile profile ) { ContentLockTree lockTree = ContentLockTree . getInstance ( ) ; if ( lockTree == null ) return ; if ( profile == null ) return ; Shop shop = Shop . getInstance ( ) ; if ( subscription != null ) { subscription . clear ( ) ; } subscription = lockTree . subscribe ( ) ; for ( ObjectMap . Entry < String , Float > entry : profile . getStats ( ) ) { final String id = entry . key ; subscription . addPublisher ( id , new UnlockSubscription . Publisher ( ) { @ Override public float getProperty ( ) { return profile . getStats ( ) . get ( id , 0.0f ) ; } } ) ; } for ( ObjectMap . Entry < String , Content > entry : BrainOut . ContentMgr . getItems ( ) ) { Content content = entry . value ; if ( content instanceof OwnableContent ) { OwnableContent ownableContent = ( ( OwnableContent ) content ) ; if ( lockTree . hasLock ( ownableContent ) ) { if ( ! profile . hasItem ( ownableContent , false ) ) { ItemDependencyComponent dep = content . getComponent ( ItemDependencyComponent . class ) ; if ( dep != null ) { if ( dep . satisfied ( profile ) ) { gotOwnable ( ownableContent , "dependency" , ClientProfile . OnwAction . owned , 1 ) ; } else { for ( OwnableContent item : dep . getItems ( ) ) { if ( ! item . hasItem ( profile ) ) { subscription . addContentSubscriber ( item , content1 -> { if ( dep . satisfied ( profile ) ) { gotOwnable ( ownableContent , "dependency" , ClientProfile . OnwAction . owned , 1 ) ; sendUserProfile ( ) ; } } ) ; } } } } } if ( shop . isFree ( ownableContent ) ) { if ( ! profile . hasItem ( ownableContent , false ) && canSubscribeOn ( ownableContent , profile ) ) { subscription . addContentSubscriber ( ownableContent , profile :: itemUnlocked ) ; } } else { if ( ! profile . hasItem ( ownableContent , false ) && ownableContent . isLocked ( profile ) ) { subscription . addContentSubscriber ( ownableContent , profile :: itemUnlocked ) ; } } } } if ( content instanceof Contract ) { Contract contract = ( ( Contract ) content ) ; if ( contract . getLockItem ( ) . hasDiffStarted ( profile ) && ! contract . getLockItem ( ) . isUnlocked ( profile ) ) { subscription . addSubscriber ( contract . getLockItem ( ) . getUnlockFor ( ) , new UnlockSubscription . Subscriber ( 0 ) { @ Override public int getTarget ( ) { return contract . getLockItem ( ) . getUnlockDiffValue ( profile , 0 ) + contract . getLockItem ( ) . getParam ( ) ; } @ Override public void complete ( ) { PlayerClient . this . notify ( NotifyAward . ownable , 1 , NotifyReason . gotOwnable , NotifyMethod . message , new ContentND ( contract ) ) ; ContractGroupQueue contracts = ContractGroupQueue . Get ( ) ; ContractGroup group = contract . getGroup ( ) ; if ( group . isComplete ( getProfile ( ) ) ) { int idx = contracts . getQueue ( ) . indexOf ( group , true ) ; if ( idx < contracts . getQueue ( ) . size - 1 ) { ContractGroup nextGroup = contracts . getQueue ( ) . get ( idx + 1 ) ; nextGroup . startFirstGroup ( profile ) ; } } else { int idx = group . getTasks ( ) . indexOf ( contract , true ) ; if ( idx < group . getTasks ( ) . size - 1 ) { Contract nextContract = group . getTasks ( ) . get ( idx + 1 ) ; nextContract . getLockItem ( ) . startDiff ( profile ) ; } } profile . setDirty ( ) ; BrainOutServer . PostRunnable ( ( ) -> resetSubscriptions ( profile ) ) ; } } ) ; } } if ( content instanceof CustomAnimationSlotItem ) { ContentProgressComponent cpc = content . getComponent ( ContentProgressComponent . class ) ; if ( cpc != null ) { float v = profile . getStats ( ) . get ( cpc . getStat ( ) , 0.0f ) ; if ( v < cpc . getValue ( ) ) { subscription . addSubscriber ( cpc . getStat ( ) , new UnlockSubscription . Subscriber ( cpc . getValue ( ) ) { @ Override public void complete ( ) { ServerStoreItemComponent ssi = content . getComponentFrom ( ServerStoreItemComponent . class ) ; if ( ssi != null ) { ssi . purchased ( PlayerClient . this ) ; } } } ) ; } } } if ( content instanceof Weapon ) { Weapon weapon = ( ( Weapon ) content ) ; final String weaponId = weapon . getID ( ) ; String skillStat = weapon . getSkillStat ( ) ; float skillLevel = profile . getStats ( ) . get ( skillStat , 0.0f ) ; int level = 1 ; for ( Weapon . Skill skill : weapon . getSkills ( ) ) { final int nextLevel = level ; if ( skillLevel < level ) { subscription . addSubscriber ( weapon . getKillsStat ( ) , new UnlockSubscription . Subscriber ( skill . getKills ( ) ) { @ Override public void complete ( ) { Weapon w = BrainOutServer . ContentMgr . get ( weaponId , Weapon . class ) ; if ( w == null ) return ; designEvent ( 1 , "weapon-skills" , w . getID ( ) , "level-" + nextLevel ) ; if ( w . getDefaultSkin ( ) != null ) { PlayerClient . this . notify ( NotifyAward . weaponSkills , nextLevel , NotifyReason . newSkillLevel , NotifyMethod . message , new SkillsND ( w . getDefaultSkin ( ) . getID ( ) ) ) ; profile . addBadge ( w . getID ( ) ) ; } profile . setStatTo ( skillStat , nextLevel , true ) ; } } ) ; } level += 1 ; } } } subscribeLevel ( Constants . User . LEVEL , ServerConstants . Online . ProfileFields . SCORE ) ; subscribeLevel ( Constants . User . TECH_LEVEL , ServerConstants . Online . ProfileFields . TECH_SCORE ) ;
isWordWrapEnabled: public boolean isWordWrapEnabled ( ) { return mWordWrapEnabled ;
setCreatedBy: public void setCreatedBy ( String createdBy ) { this . createdBy = createdBy ;
onClick: public void onClick ( View v ) { if ( callBack != null ) {
isRunning: public static boolean isRunning ( ) { return run ;
onRequestPermissionSuccess: No method body
setOrganizationId: public void setOrganizationId ( Long organizationId ) { this . organizationId = organizationId ;
keyDown: public boolean keyDown ( int keyCode ) { return keyPressed ( keyCode ) ;
getData: No method body
deleteUser: void deleteUser ( ) { Long resourceCategoryId = 6L ; resourceCategoryService . deleteResourceCategory ( resourceCategoryId ) ; log . info ( "删除资源类别测试成功！" ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
hasRichLocalization: public boolean hasRichLocalization ( ) { return false ;
h: public final String h ( ) { return null ; }
getConfig: public HikariConfig getConfig ( ) { return config ;
stopMusic: public void stopMusic ( ) { if ( currentMusic != null )
getCacheDirectory: public static File getCacheDirectory ( Context context ) { return getCacheDirectory ( context , true ) ;
objectKey: public String objectKey ( ) { return this . stateMachine . objectKey ( ) ;
getDownloadedFileName: private String getDownloadedFileName ( ) { String fileName = "" ; DownloadManager . Query query = new DownloadManager . Query ( ) ; query . setFilterByStatus ( DownloadManager . STATUS_SUCCESSFUL ) ; Cursor c = mDownloadManager . query ( query ) ; if ( c . moveToFirst ( ) ) { fileName = c . getString ( c . getColumnIndex ( DownloadManager . COLUMN_TITLE ) ) ; } return fileName ;
searchByLastname: public Person [ ] searchByLastname ( String lastname ) { ArrayList < Person > tmp = new ArrayList < > ( ) ; for ( Person p : phoneBook ) { if ( p . getLastname ( ) . equals ( lastname ) ) { tmp . add ( p ) ; } } return tmp . toArray ( new Person [ ] { } ) ;
getMfaEnabled: public final boolean getMfaEnabled ( ) { return false ;
release: public void release ( ) { if ( mBasePopWindow != null ) {
setStop: public void setStop ( final Set < String > stop ) { this . stop = stop ;
starting: public void starting ( ) { invokeCount ++ ;
U: public final Subscription U ( Subscriber < ? super T > subscriber ) { return null ;
onTextChanged: public void onTextChanged ( CharSequence s , int start , int before , int count ) { final int currentCharCount = s . length ( ) ; if ( currentCharCount > 0 && QuickAccessPrefs . isTextCharCountEnabled ( ) ) {
checkAlarms: private void checkAlarms ( ) { if ( tg1 . condenser . getWaterLevel ( ) < - 25 ) { annunciator . trigger ( hw1Low ) ; } else { annunciator . reset ( hw1Low ) ; } if ( tg2 . condenser . getWaterLevel ( ) < - 25 ) { annunciator . trigger ( hw2Low ) ; } else { annunciator . reset ( hw2Low ) ; } if ( tg1 . condenser . getWaterLevel ( ) > 25 ) { annunciator . trigger ( hw1High ) ; } else { annunciator . reset ( hw1High ) ; } if ( tg2 . condenser . getWaterLevel ( ) > 25 ) { annunciator . trigger ( hw2High ) ; } else { annunciator . reset ( hw2High ) ; } if ( tg1 . condenser . getPressure ( ) > 0.023 ) { annunciator . trigger ( lowVacuum1 ) ; } else { annunciator . reset ( lowVacuum1 ) ; } if ( tg2 . condenser . getPressure ( ) > 0.023 ) { annunciator . trigger ( lowVacuum2 ) ; } else { annunciator . reset ( lowVacuum2 ) ; } if ( tg1 . condenser . getPressure ( ) > 0.10142 ) { annunciator . trigger ( relief1 ) ; } else { annunciator . reset ( relief1 ) ; } if ( tg2 . condenser . getPressure ( ) > 0.10142 ) { annunciator . trigger ( relief2 ) ; } else { annunciator . reset ( relief2 ) ; } boolean cavitation1A = false ; for ( Pump pump : condensate1A ) { if ( pump . isCavitating ) { cavitation1A = true ; break ; } } annunciator . setTrigger ( cavitation1A , cavit1A ) ; boolean cavitation2A = false ; for ( Pump pump : condensate2A ) { if ( pump . isCavitating ) { cavitation2A = true ; break ; } } annunciator . setTrigger ( cavitation2A , cavit2A ) ; boolean cavitation1B = false ; for ( Pump pump : condensate1B ) { if ( pump . isCavitating ) { cavitation1B = true ; break ; } } annunciator . setTrigger ( cavitation1B , cavit1B ) ; boolean cavitation2B = false ; for ( Pump pump : condensate2B ) { if ( pump . isCavitating ) { cavitation2B = true ; break ; } } annunciator . setTrigger ( cavitation2B , cavit2B ) ;
initView: protected void initView ( ) { mLoadingDialog = new LoginLoadingDialog ( mContext ) ; PasswordFilter passwordFilter = new PasswordFilter ( ) ; mPwdEdit . setFilters ( new InputFilter [ ] { new InputFilter . LengthFilter ( 16 ) , passwordFilter } ) ; TextView . OnEditorActionListener listener = ( v , actionId , event ) -> { if ( actionId == EditorInfo . IME_ACTION_DONE ) { clickUnlock ( ) ; } return true ; } ; mPwdEdit . setOnEditorActionListener ( listener ) ; LinearLayout pageContent = findViewById ( R . id . pageContent ) ; RelativeLayout mOutView = findViewById ( R . id . form_unlock_content ) ; KeyboardScrollView . controlKeyboardLayout ( pageContent , mOutView ) ;
build: No method body
getContent: public Content getContent ( int index ) { if ( index == 0 ) { return null ; } String id = contentToIndex . get ( index - 1 ) ; if ( id == null ) return null ; return BrainOut . ContentMgr . get ( id ) ;
sendServerInfo: public void sendServerInfo ( ) { log ( "Sending Server Info" ) ; String ownerKey = BrainOutServer . Controller . addOwnerKey ( getId ( ) ) ; Preset currentPreset = BrainOutServer . Controller . getCurrentPreset ( ) ; long now = System . currentTimeMillis ( ) / 1000L ; sendTCP ( new ServerInfo ( getServerController ( ) . getPlayState ( ) , getId ( ) , BrainOutServer . Settings . getLevels ( ) , BrainOutServer . PackageMgr . getDefines ( ) , BrainOutServer . Settings . getPrices ( ) , profile , currentPreset , ownerKey , getPartyId ( ) , BrainOutServer . Controller . getClients ( ) . getMaxPlayers ( ) , now ) ) ; sendTCP ( new UpdateGlobalContentIndex ( BrainOutServer . Controller . getContentIndex ( ) ) ) ;
logPacketDispatch: private < TRequest extends Packet > void logPacketDispatch ( final TRequest packet , final MessageTarget target , final ConversationUID uid , final JRPCMessage message ) { client . getLogger ( ) . debugFiner (
keyDown: public boolean keyDown ( int keyCode ) { switch ( keyCode ) { case Input . Keys . E : { Menu . playSound ( Menu . MenuSound . select ) ; cutterButton . setChecked ( ! cutterButton . isChecked ( ) ) ; setCutterEnabled ( cutterButton . isChecked ( ) ) ; return true ; } } return false ;
flipped: private void flipped ( ) { clearChildren ( ) ; Card card = cardData . getCard ( ) ; CardGroup cardGroup = card . getGroup ( ) ; ClientCardGroupComponent ccg = cardGroup . getComponent ( ClientCardGroupComponent . class ) ; IconComponent cardGroupIcon = cardGroup . getComponent ( IconComponent . class ) ; ClientCardComponent ccc = card . getComponentFrom ( ClientCardComponent . class ) ; TextureRegion shine = cardGroupIcon . getIcon ( "icon-shine" ) ; if ( shine != null ) { Image bg = new Image ( shine ) ; bg . setScaling ( Scaling . none ) ; bg . setFillParent ( true ) ; bg . getColor ( ) . a = 0 ; bg . addAction ( Actions . sequence ( Actions . alpha ( 1 , 0.5f ) , Actions . delay ( 1.0f ) , Actions . alpha ( 0 , 0.5f ) ) ) ; addActor ( bg ) ; } Image bg = new Image ( cardGroupIcon . getIcon ( "icon-bg" ) ) ; bg . setFillParent ( true ) ; addActor ( bg ) ; Table cardContent = new Table ( ) ; cardContent . setFillParent ( true ) ; Label title = new Label ( ccc != null ? ccc . getDescription ( cardData ) : "" , BrainOutClient . Skin , "title-yellow" ) ; title . setAlignment ( Align . center ) ; title . setWrap ( true ) ; cardContent . add ( title ) . pad ( 14 ) . expandX ( ) . fillX ( ) . row ( ) ; if ( ccc != null ) { ccc . drawIcon ( cardContent , cardData ) ; } Label description = new Label ( ccc != null ? ccc . getTitle ( cardData ) : "" , BrainOutClient . Skin , "title-small" ) ; description . setWrap ( true ) ; description . setAlignment ( Align . center ) ; cardContent . add ( description ) . width ( 192 ) . pad ( 4 ) . row ( ) ; Label category = new Label ( ccc . getGroupTitle ( cardData ) , BrainOutClient . Skin , ccg . getTitleStyle ( ) ) ; category . setAlignment ( Align . center ) ; cardContent . add ( category ) . expandX ( ) . fillX ( ) . bottom ( ) . pad ( 8 ) . row ( ) ; addActor ( cardContent ) ;
clear: public void clear ( ) { currentEnvironment = null ; accounts . clear ( ) ;
divide: public static < T extends Number > double divide ( T a , T b ) { return a . doubleValue ( ) / b . doubleValue ( ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem1ActionPerformed ( evt ) ;
turnOffDebugForClasses: public boolean turnOffDebugForClasses ( Collection < Class > classCollection ) { debug ( "[turnOffDebugForClasses]" ) ; boolean r = true ; for ( Class c : classCollection ) { r = turnOffDebugModeForLoggerClass ( c ) && r ; } return r ;
removeFirst: public Object removeFirst ( ) { return remove ( 0 ) ;
setFloat: public void setFloat ( float floatValue ) { this . floatValue = floatValue ;
setCallback: public void setCallback ( ClickCallback callback ) { this . mCallback = callback ;
onOpen: public void onOpen ( ) { if ( Log . INFO ) Log . info ( "Connected to messages!" ) ; if ( playerClient != null )
setSkin: public void setSkin ( Skin skin ) { info . skin = skin ;
turnOnDebugModeForLoggerClassname: public boolean turnOnDebugModeForLoggerClassname ( String classname ) { this . debug ( "[turnOnDebugModeForLoggerClassname] {}" , new Object [ ] { classname } ) ; if ( StringUtils . isBlank ( classname ) ) {
getWeekOfDate: public static String getWeekOfDate ( Date date ) { String [ ] weekDays = { "星期日" , "星期一" , "星期二" , "星期三" , "星期四" , "星期五" , "星期六" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int w = cal . get ( Calendar . DAY_OF_WEEK ) - 1 ; if ( w < 0 ) w = 0 ; return weekDays [ w ] ;
isVisible: public boolean isVisible ( ) { return visible ;
getWaterTemperature: public double getWaterTemperature ( ) { return feedwaterTemperature ;
getSprite: public String getSprite ( ) { return sprite ;
addItem: public Cell < Actor > addItem ( Table data , Actor actor , XmlReader . Element item ) { Cell < Actor > cell = data . add ( actor ) ; if ( item . getBooleanAttribute ( "expand" , false ) ) { cell . expandX ( ) ; } if ( item . getBooleanAttribute ( "fill" , false ) ) { cell . fillX ( ) ; } int height = item . getIntAttribute ( "height" , 0 ) ; if ( height != 0 ) { cell . height ( height ) ; } int width = item . getIntAttribute ( "width" , 0 ) ; if ( width != 0 ) { cell . width ( width ) ; } cell . padLeft ( item . getIntAttribute ( "padLeft" , 0 ) ) . padRight ( item . getIntAttribute ( "padRight" , 0 ) ) . padTop ( item . getIntAttribute ( "padTop" , 0 ) ) . padBottom ( item . getIntAttribute ( "padBottom" , 0 ) ) ; int pad = item . getIntAttribute ( "pad" , 0 ) ; if ( pad != 0 ) { cell . pad ( pad ) ; } return cell ;
setAxisMaxLabels: public void setAxisMaxLabels ( int labels ) { if ( labels > 0 )
fail: public void fail ( Request request , Request . Result status ) { switch ( status )
getEmail: public String getEmail ( ) { return email ;
getWatchX: public float getWatchX ( ) { return blocks . getWidth ( ) / 2.0f ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { tgValvesStopItemStateChanged ( evt ) ;
dictionary: public < T extends SearchableEntity > Map dictionary ( String entityKey , String keyField , String labelField ) { Class < SearchableOrganizationRelatedEntity > entityClass = ( Class < SearchableOrganizationRelatedEntity > ) SearchableRepositories . getSearchableRepositoryMetadata ( entityKey ) . entityClass ( ) ; if ( entityClass == null ) { warn ( "SearchableRepository for entity key {} not found" , entityKey ) ; return Collections . emptyMap ( ) ; } return dictionary ( entityClass , keyField , labelField , labelField ) ;
caculateSlope: private float caculateSlope ( MotionEvent event ) { x1 = event . getX ( 0 ) ; y1 = event . getY ( 0 ) ; x2 = event . getX ( 1 ) ; y2 = event . getY ( 1 ) ; return ( y2 - y1 ) / ( x2 - x1 ) ;
getBalance: void getBalance ( ) { assertEquals ( 1000 , bankAccount . getBalance ( ) ) ; BankAccount emptyBankAccount = new BankAccount ( ) ; assertEquals ( 0 , emptyBankAccount . getBalance ( ) ) ;
isHighlightEnabled: public boolean isHighlightEnabled ( ) { return mHighlightEnabled ;
getRenderer: public SkeletonRenderer getRenderer ( ) { return renderer ;
retryFailed: protected void retryFailed ( ) { switchTo ( new CSMaintenance ( ) ) ;
getRecoveryInfo: public Single < lnrpc . LightningOuterClass . GetRecoveryInfoResponse > getRecoveryInfo ( lnrpc . LightningOuterClass . GetRecoveryInfoRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . getRecoveryInfo ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
setDelayTimeText: private void setDelayTimeText ( int time ) { setText ( String . format ( mDelayText , time ) ) ;
validate: public IntegrationTrelloForm validate ( BindingResult br ) { if ( StringUtils . isBlank ( dto . getTrelloApiKey ( ) ) ) { br . rejectValue ( "dto.trelloApiKey" , "not.empty" ) ; } if ( ! dto . getTrelloApiKey ( ) . matches ( LOWER_CASE_ALPHANUMERIC_REGEX ) ) { br . rejectValue ( "dto.trelloApiKey" , "is.alphanumeric" ) ; } if ( dto . getTrelloApiKey ( ) . length ( ) != 32 ) { br . rejectValue ( "dto.trelloApiKey" , "wrong.size" ) ; } if ( StringUtils . isBlank ( dto . getTrelloApiToken ( ) ) ) { br . rejectValue ( "dto.trelloApiToken" , "not.empty" ) ; } if ( ! dto . getTrelloApiToken ( ) . matches ( LOWER_CASE_ALPHANUMERIC_REGEX ) ) { br . rejectValue ( "dto.trelloApiToken" , "is.alphanumeric" ) ; } if ( dto . getTrelloApiToken ( ) . length ( ) != 64 ) { br . rejectValue ( "dto.trelloApiToken" , "wrong.size" ) ; } if ( StringUtils . isBlank ( dto . getTrelloBoardName ( ) ) ) { br . rejectValue ( "dto.trelloBoardName" , "not.empty" ) ; } if ( StringUtils . isBlank ( dto . getTrelloListName ( ) ) ) { br . rejectValue ( "dto.trelloListName" , "not.empty" ) ; } return this ;
getLength: public float getLength ( ) { return super . getLength ( ) + lengthOffset ;
checkUserAvatar: private void checkUserAvatar ( ) { UserProfile userProfile = BrainOutClient . ClientController . getUserProfile ( ) ; if ( ! userProfile . isParticipatingClan ( ) ) return ; if ( ! userProfile . getClanId ( ) . equals ( clanId ) ) return ; if ( userProfile . getClanAvatar ( ) . equals ( clan . getAvatar ( ) ) ) return ; WaitLoadingMenu waitLoadingMenu = new WaitLoadingMenu ( "" ) ; pushMenu ( waitLoadingMenu ) ; BrainOutClient . SocialController . sendRequest ( "follow_clan_avatar" ,
getGroup: public ContractGroup getGroup ( ) { return group ;
zoomIn: public Matrix zoomIn ( float x , float y ) { Matrix save = new Matrix ( ) ; zoomIn ( x , y , save ) ; return save ;
pullRequired: public void pullRequired ( ) { doFetch ( ) ;
doUpdateVisitedHistory: public void doUpdateVisitedHistory ( WebView view , String url , boolean isReload ) { if ( mCallBack != null ) {
visitLineNumber: public void visitLineNumber ( int line , Label start ) { super . visitLineNumber ( line , start ) ; this . line = line ;
getPressure: public double getPressure ( ) { return pressure ;
transferTo: public void transferTo ( java . io . File dest ) throws IOException , IllegalStateException { FileCopyUtils . copy ( this . content , dest ) ;
getAnimationLast: public float getAnimationLast ( ) { return animationLast ;
uploadImage: private void uploadImage ( ) { final String uploadPath = mUploadList . get ( 0 ) ; if ( mNeedCompress ) {
onError: public void onError ( Throwable throwable ) { subscriber . onError ( throwable ) ;
getMinWidth: public float getMinWidth ( ) { return 16 ;
getY: public float getY ( ) { return 0 ;
validate: public IntegrationSlackForm validate ( BindingResult br ) { if ( StringUtils . isBlank ( dto . getWebhookUrl ( ) ) ) { br . rejectValue ( "dto.webhookUrl" , "not.empty" ) ; } return null ;
onResume: public void onResume ( ) { super . onResume ( ) ;
renderError: private void renderError ( Request . Result status ) { content . clear ( ) ; Label loading = new Label ( L . get ( "MENU_ONLINE_ERROR" , status . toString ( ) ) , BrainOutClient . Skin , "title-messages-red" ) ; loading . setAlignment ( Align . center ) ; content . add ( loading ) . pad ( 8 ) . expand ( ) . fill ( ) . row ( ) ;
makeAndShowDialog: private void makeAndShowDialog ( String text , Activity activity ) { AlertDialog dialog = makeWaitingDialog ( activity ) ; if ( dialog == null ) { LogUtils . d ( TAG , "showLoadingDialog 时 Dialog为null" ) ; return ; } TextView waitingTv = dialog . getViewById ( R . id . tv_dialog_waiting ) ; if ( ! StringUtils . isEmpty ( text ) ) { waitingTv . setText ( text ) ; } if ( dialog . isShowing ( ) ) { LogUtils . d ( TAG , "Dialog Is Showing" ) ; return ; } LogUtils . d ( TAG , "Show Dialog" ) ; dialog . show ( ) ; ObjectAnimator animator = makeRotationAnimator ( activity , dialog ) ; animator . start ( ) ;
getVerifyCodeNoImage: public void getVerifyCodeNoImage ( String phone ) { this . mNeedCountdown = true ; if ( mHelper != null ) {
setDrawAxisLine: public void setDrawAxisLine ( boolean enabled ) { mDrawAxisLine = enabled ;
getInterpolation: public float getInterpolation ( float input ) { return ( float ) Math . pow ( input , 3 ) ;
setPhase: public void setPhase ( Phase phase ) { if ( Log . INFO ) Log . info ( "Updathing phase to: " + ( phase != null ? phase . toString ( ) : "null" ) ) ; this . phase = phase ;
getDrawOrder: public Array < Slot > getDrawOrder ( ) { return drawOrder ;
getHz: public int getHz ( ) { return hz ;
received: public boolean received ( UpdateOrderResultMsg msg ) { orderUpdated ( msg . store , msg . orderId , msg . currency , msg . total , msg . item , msg . success ) ; return true ;
getTotalResults: public final int getTotalResults ( ) { return - 1 ;
forceSave: public void forceSave ( ) { for ( ObjectMap . Entry < Integer , Client > clientEntry : BrainOutServer . Controller . getClients ( ) )
has: public static boolean has ( String id ) { return BrainOut . LocalizationMgr . has ( id ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { forcePriceSort = ! forcePriceSort ; refresh ( false ) ;
run: No method body
newAddress: No method body
getIconName: public String getIconName ( ) { return getIconName ( DEFAULT_ICON , "" ) ;
init: public void init ( ) { super . init ( ) ;
getIdsByRoleId: void getIdsByRoleId ( ) throws JsonProcessingException { Long roleId = 2L ; Set < Long > ids = menuService . getIdsByRoleId ( roleId ) ; assertNotNull ( ids ) ; log . info ( "根据角色 id 获取菜单 id 列表方法测试成功:{}" , objectMapper . writeValueAsString ( ids ) ) ;
canSpawn: No method body
getID: public ID getID ( ) { return ID . physicsUpdated ;
get: public AttributeGroup get ( String attributeGroupName ) throws ApiErrorException , ConnectionException { Class < AttributeGroup > responseModel = ( Class < AttributeGroup > ) ( Class < ? > ) AttributeGroup . class ; return this . request ( "get" , this . resolvePath ( "/attribute-groups/%s" , attributeGroupName ) , null , null , responseModel ) ;
getReflection: public Reflection getReflection ( ) { return new ClientReflection ( )
getTitle: public String getTitle ( ) { return L . get ( L . get ( "MENU_ATTENTION" ) ) ;
getSteamID: protected String getSteamID ( ) { if ( credential == null ) return null ; if ( ! credential . startsWith ( "steam" ) ) return null ; return credential . substring ( 6 ) ;
escape: public boolean escape ( ) { pop ( ) ; return true ;
isItemTaskRelated: public boolean isItemTaskRelated ( ConsumableItem item ) { return false ;
supports: No method body
isShowOnOrganizationDashboard: public boolean isShowOnOrganizationDashboard ( ) { return showOnOrganizationDashboard ;
isDrawCubicEnabled: public boolean isDrawCubicEnabled ( ) { return mMode == Mode . CUBIC_BEZIER ;
recycleInstance: public static void recycleInstance ( FSize instance ) { pool . recycle ( instance ) ;
getCreateWorkflowOverrideRequest: private CreateWorkflowOverrideRequest getCreateWorkflowOverrideRequest ( ) { CreateWorkflowOverrideRequest createWorkflowOverrideRequest = new CreateWorkflowOverrideRequest ( ) ; createWorkflowOverrideRequest . setPreferenceSettings ( getPreferenceSettings ( ) ) ; createWorkflowOverrideRequest . setActive ( true ) ; createWorkflowOverrideRequest . setTenantId ( "8329rufivdsnvs9u334" ) ; createWorkflowOverrideRequest . setWorkflowId ( "wvnq340i2jfwqv392" ) ; return createWorkflowOverrideRequest ;
reset: public void reset ( ) { Component it = getFistComponent ( ) ; while ( it != null )
flipSelection: private void flipSelection ( ActiveData activeData ) { if ( isSelected ( activeData ) )
addItem: public void addItem ( String item , int amount ) { Integer have = items . get ( item ) ; if ( have == null )
fix: private void fix ( ) { BrainOutClient . ClientController . sendTCP ( new ContentActionMsg ( instrument , ContentActionMsg . Action . repair ) ) ;
getNameWithParamNames: public String getNameWithParamNames ( Method method ) { return method . getName ( ) + "(" + getParameterNames ( method ) + ")" ;
done: public boolean done ( ) { return fadeOut < 0 ;
findAllAsTupleWithLabelName: No method body
setAttachment: private void setAttachment ( Skeleton skeleton , Slot slot , String attachmentName ) { slot . setAttachment ( attachmentName == null ? null : skeleton . getAttachment ( slotIndex , attachmentName ) ) ;
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCountryUpdateRequest.json" ) ; ShopCountry requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , ShopCountry . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ShopCountry responseEntity = this . api . shopCountries ( ) . update ( "acme" , "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCountryUpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
setHideInterfaceMode: public void setHideInterfaceMode ( boolean mode ) { this . hideInterfaceMode = mode ;
setAdditionalPredicate: public CRUDControllerConfiguration < D , E , F > setAdditionalPredicate ( Specification < E > additionalPredicate ) { this . additionalPredicate = additionalPredicate ; return this ;
getInnerPortal: public ActiveData getInnerPortal ( ) { return findActiveData ( innerPortal ) ;
setLastname: public void setLastname ( String lastname ) { this . lastname = lastname ;
drop: private void drop ( DropOff off ) { Map map = getMap ( ) ; ItemData itemData = getContentComponent ( ) . getItem ( ) . getData ( getComponentObject ( ) . getDimension ( ) ) ; itemData . setPosition ( activeData . getX ( ) , activeData . getY ( ) ) ; for ( FreeplayDropoff . Generator generator : off . generators ) { generator . generate ( itemData ) ; } map . addActive ( map . generateServerId ( ) , itemData , true ) ;
isFullScreenScan: public boolean isFullScreenScan ( ) { return isFullScreenScan ;
setMode: public GameMode setMode ( GameMode . ID mode ) { if ( this . mode != null ) { this . mode . release ( ) ; } this . mode = BrainOut . getInstance ( ) . newMode ( mode ) ; return this . mode ;
getClippedVertices: public FloatArray getClippedVertices ( ) { return clippedVertices ;
fillRegisterForm: public void fillRegisterForm ( String email , String password ) { this . login . click ( ) ; this . login . clear ( ) ; this . login . sendKeys ( email ) ; this . password . click ( ) ; this . password . clear ( ) ; this . password . sendKeys ( password ) ;
asBoolean: public boolean asBoolean ( ) { return ! ( asInt ( ) == 0 || value . equals ( "false" ) ) ;
delete: public void delete ( Identifier productIdentifier , Identifier imageIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/products/%s/images/%s" , productIdentifier , imageIdentifier ) , null , null , null ) ;
onPreviewFrame: public void onPreviewFrame ( byte [ ] data , Camera camera ) { Point cameraResolution = configManager . getCameraResolution ( ) ; Handler thePreviewHandler = previewHandler ; if ( cameraResolution != null && thePreviewHandler != null ) {
getCode: public int getCode ( ) { return code ;
obtain: public static Event obtain ( ActiveData activeData , int oldId , String oldDimension , String newDimension ) { ActiveChangeDimensionEvent e = obtain ( ActiveChangeDimensionEvent . class ) ; if ( e == null ) return null ; return e . init ( activeData , oldId , oldDimension , newDimension ) ;
pop: public void pop ( ) { onTop = false ; super . pop ( ) ;
received: public boolean received ( final RemoveUserImageMsg msg ) { String name = msg . name ; BrainOutServer . PostRunnable ( ( ) -> { removeImageExtension ( name ) ; } ) ; return true ;
mapExists: public boolean mapExists ( String fileName ) { FileHandle fileHandle = Gdx . files . absolute ( fileName ) ; return fileHandle . exists ( ) ;
findByUserIdAndOrganizationIdAndRoleId: No method body
getUserIdAndTokenBase64String: public String getUserIdAndTokenBase64String ( ) { return Base64 . getEncoder ( ) . encodeToString ( StringUtils . join ( userId , ":" , token ) . getBytes ( ) ) ;
setOnDismissListener: No method body
setShadowEnabled: public void setShadowEnabled ( boolean shadowEnabled ) { this . shadowEnabled = shadowEnabled ;
getProgressRequestBody: public static ProgressRequestBody getProgressRequestBody ( Context context , RequestBody requestBody , EngineCallback callBack ) { return new ProgressRequestBody ( context , requestBody , callBack ) ;
runAsync: public static void runAsync ( Runnable runnable ) { cachedPool . execute ( runnable ) ;
getScaleY: public float getScaleY ( ) { return scaleY ;
getIdsByRoleId: No method body
setTickets: public void setTickets ( int tickets ) { this . tickets = tickets ;
onDisable: public void onDisable ( ) { proxyServer . stop ( ) ;
hashCode: public int hashCode ( ) { return x ^ y ;
getBindingResult: public BindingResult getBindingResult ( ) { return bindingResult ;
nextRound: private void nextRound ( ) { if ( Log . INFO ) Log . info ( "Next round!" ) ; cleanupStuff ( ) ; getGameMode ( ) . setRound ( getGameMode ( ) . getRound ( ) + 1 ) ; if ( ! getGameMode ( ) . isGameFinished ( ) ) { killAll ( ) ; } getGameMode ( ) . setTimer ( timeBeforeRound , this :: validateStart ) ; getGameMode ( ) . setState ( GameModeAssault . State . waiting ) ; updated ( ) ;
getNodeList: public List < Node > getNodeList ( ) { return nodeList ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; maxDistance = jsonData . getFloat ( "maxDistance" ) ;
setName: public void setName ( String name ) { spawnName . set ( name ) ;
anonymizeAddress: public void anonymizeAddress ( String shopKey , String countryCode , Identifier customerIdentifier , Identifier addressIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/addresses/%s/anonymize" , shopKey , countryCode , customerIdentifier , addressIdentifier ) , null , null , null ) ;
onRequestPermissionSuccess: public void onRequestPermissionSuccess ( ) { Bundle bundle = new Bundle ( ) ; bundle . putInt ( ScanActivity . KEY_SCAN_CODE , 2 ) ; switchActivity ( ScanActivity . class , bundle ) ;
setEnabled: public void setEnabled ( boolean enabled ) { this . enabled = enabled ;
getUpdateScript: public String getUpdateScript ( FrontendMappingDefinition frontendMappingDefinition , String tableName , boolean includeOnlyMissingColumns ) { StringBuilder updateDatabaseScript = new StringBuilder ( ) ; Set < FrontendMappingFieldDefinition > fields = Arrays . stream ( frontendMappingDefinition . getDbTypeFields ( ) ) . collect ( toSet ( ) ) ; try { Map < String , String > tableColumns = getTableColumns ( tableName ) ; for ( FrontendMappingFieldDefinition field : fields . stream ( ) . filter ( f -> f . getType ( ) != FieldType . files ) . toList ( ) ) { String columnName = toColumnName ( field . getName ( ) ) ; boolean addColumn = ! includeOnlyMissingColumns || ! tableColumns . containsKey ( columnName ) ; if ( addColumn ) { String dbType = field . getType ( ) . getDbType ( ) . getValue ( ) ; updateDatabaseScript . append ( String . format ( "ALTER TABLE %s ADD COLUMN IF NOT EXISTS %s %s;\r\n" , tableName , columnName , dbType ) ) ; if ( field . getType ( ) . equals ( FieldType . organization_select ) ) { updateDatabaseScript . append ( String . format ( "alter table %s add constraint %s foreign key (%s) references %s(%s);\r\n" , tableName , "fk_" + columnName , columnName , "organization" , "id" ) ) ; } } } } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return updateDatabaseScript . toString ( ) ;
secondsToLocalDateTime: public static LocalDateTime secondsToLocalDateTime ( long seconds ) { return Instant . ofEpochSecond ( seconds ) . atZone ( ZoneId . systemDefault ( ) ) . toLocalDateTime ( ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoWaterLevel4OffItemStateChanged ( evt ) ;
test_deleteIntegration: public void test_deleteIntegration ( ) throws NovuNetworkException , IOException , InterruptedException { BulkIntegrationResponse bulkIntegrationResponse = new BulkIntegrationResponse ( ) ; Integration integration = new Integration ( ) ; integration . setActive ( true ) ; integration . setChannel ( "PUSH" ) ; integration . setId ( "Test" ) ; bulkIntegrationResponse . setData ( Collections . singletonList ( integration ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( bulkIntegrationResponse ) ) ) ; BulkIntegrationResponse response = integrationsHandler . deleteIntegration ( integration . getId ( ) ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/integrations/Test" , request . getPath ( ) ) ; assertEquals ( "DELETE" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( bulkIntegrationResponse ) , gson . toJson ( response ) ) ;
getIcon: public String getIcon ( ) { return icon ;
renderModesPanel: private void renderModesPanel ( Table panel ) { ButtonGroup < ImageButton > group = new ButtonGroup < > ( ) ; group . setMaxCheckCount ( 1 ) ; group . setMinCheckCount ( 1 ) ; {
requestPermission: public static void requestPermission ( Activity activity , final PermissionCallback permissionCallback , String ... permissions ) { if ( permissions == null || permissions . length == 0 ) return ; RxPermissions rxPermissions = new RxPermissions ( activity ) ; List < String > needRequest = new ArrayList < > ( ) ; for ( String permission : permissions ) { if ( ! rxPermissions . isGranted ( permission ) ) { needRequest . add ( permission ) ; } } if ( needRequest . isEmpty ( ) ) { permissionCallback . onRequestPermissionSuccess ( ) ;
equalsHashCode: void equalsHashCode ( ) { Book other = new Book ( "Soffocare" , 2002 , 170 ) ; assertEquals ( book , other ) ; assertEquals ( book . hashCode ( ) , other . hashCode ( ) ) ;
lockRender: public boolean lockRender ( ) { return true ;
sendEmailToAllInOrganization: public boolean sendEmailToAllInOrganization ( OrganizationRelatedObject object , String templateName ) { debug ( "[sendEmailToAllInOrganization] Sends {} to organization {} users" , templateName , object . getOrganizationId ( ) ) ; UserProvider . setConsumerAuthentication ( ) ; repositories . unsecure . userRole . getUsersInOrganization ( object . getOrganizationId ( ) ) . forEach ( user -> sendAndSaveEmail ( user , templateName ) ) ; UserProvider . clearAuthentication ( ) ; return true ;
getContent: public Content getContent ( ) { return content ;
addHealth: public float addHealth ( float health ) { float newValue = health + getHealth ( ) ; float oldValue = this . health ; this . health = newValue ; return newValue - oldValue ;
getVersion: No method body
getColor: public Color getColor ( ) { return color ;
setName: public void setName ( String name ) { this . name = name ;
itemStateChanged: public void itemStateChanged ( ItemEvent e ) { if ( e . getStateChange ( ) == 1 ) {
clickedOnItem: protected void clickedOnItem ( String accountId , String credential ) { GameState gs = getGameState ( ) ; pop ( ) ; if ( event . getEvent ( ) . group )
onClick: public void onClick ( View v ) { mMenuPopWindow . dismiss ( ) ; Bundle bundle = new Bundle ( ) ; bundle . putLong ( ChannelsActivity . KEY_BALANCE_AMOUNT , balanceAmount ) ; bundle . putString ( ChannelsActivity . KEY_WALLET_ADDRESS , walletAddress ) ; bundle . putString ( ChannelsActivity . KEY_PUBKEY , pubKey ) ; Intent intent = new Intent ( mContext , ChannelsActivity . class ) ; mContext . startActivity ( intent , bundle ) ;
allowQuestsButton: protected boolean allowQuestsButton ( ) { return false ;
hasRender: public boolean hasRender ( ) { return false ;
getType: public String getType ( ) { return type ;
launchBullet: public boolean launchBullet ( PlayerData pd , Bullet bullet , Bullet . BulletSlot slot , float x , float y , float [ ] angles , int bulletsAmount , int random ) { boolean ok = super . launchBullet ( pd , bullet , slot , x , y , angles , bulletsAmount , random ) ; if ( ok && getClient ( ) != null ) { FreePayload pay = ( FreePayload ) getClient ( ) . getModePayload ( ) ; if ( pay != null ) { pay . nonFriendAction ( ) ; } } return ok ;
create: public ProductImage create ( Identifier productIdentifier , ProductImage model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ProductImage > responseModel = ( Class < ProductImage > ) ( Class < ? > ) ProductImage . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "post" , this . resolvePath ( "/products/%s/images" , productIdentifier ) , query , null , responseModel , model ) ;
deleteUserRole: No method body
cancel: No method body
loadEntriesFromFile: public static List < Entry > loadEntriesFromFile ( String path ) { File sdcard = Environment . getExternalStorageDirectory ( ) ; File file = new File ( sdcard , path ) ; List < Entry > entries = new ArrayList < Entry > ( ) ; try { @ SuppressWarnings ( "resource" ) BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] split = line . split ( "#" ) ; if ( split . length <= 2 ) { entries . add ( new Entry ( Float . parseFloat ( split [ 0 ] ) , Integer . parseInt ( split [ 1 ] ) ) ) ; } else { float [ ] vals = new float [ split . length - 1 ] ; for ( int i = 0 ; i < vals . length ; i ++ ) { vals [ i ] = Float . parseFloat ( split [ i ] ) ; } entries . add ( new BarEntry ( Integer . parseInt ( split [ split . length - 1 ] ) , vals ) ) ; } } } catch ( IOException e ) { Log . e ( LOG , e . toString ( ) ) ; } return entries ;
tryIOOperation: protected boolean tryIOOperation ( ThrowableRunnable action ) { boolean result = false ; Future < Boolean > future = CompletableFuture . supplyAsync ( ( ) -> { try { action . run ( ) ; return true ; } catch ( IOException iexc ) { error ( "[tryIOOperation] IO Error {}" , iexc . toString ( ) ) ; return false ; } catch ( SQLException | RuntimeException e ) { return false ; } } ) ; try { result = future . get ( 10 , TimeUnit . SECONDS ) ; } catch ( InterruptedException | ExecutionException | TimeoutException e ) { error ( "[tryInputOutput] {}" , e ) ; throw new RuntimeException ( e ) ; } return result ;
setFileName: public void setFileName ( String fileName ) { this . fileName = fileName ;
registerEventClasses: public < T > boolean registerEventClasses ( Class < T > [ ] events ) { debug ( "[registerEventClasses]" ) ; return eventClasses . addAll ( java . util . Arrays . asList ( events ) ) ;
userProfileUpdated: protected void userProfileUpdated ( ) { profileUpdated ( ) ;
getControllerKind: public String getControllerKind ( ) { String name = getDetectedController ( ) . getName ( ) . toLowerCase ( ) ; if ( name . contains ( "sony" ) ) return "sony" ; if ( name . contains ( "ps4" ) ) return "sony" ; if ( name . contains ( "xbox" ) ) return "xbox" ; return "generic" ;
getEntityKey: public String getEntityKey ( ) { return entityKey ;
setMovement: public void setMovement ( float movement ) { this . movement = movement ;
searchByLastname: public Optional < Person > searchByLastname ( String lastname ) { for ( Person p : people ) { if ( p . getLastname ( ) . equals ( lastname ) ) { return Optional . of ( p ) ; } } return Optional . empty ( ) ;
Clear: public static void Clear ( String url ) { Texture texture = Avatars . get ( url ) ; if ( texture != null )
onReset: protected void onReset ( boolean resetHandAnimations ) { Instrument . Action action = Instrument . Action . reset ; BrainOut . EventMgr . sendDelayedEvent ( getData ( ) . getOwner ( ) , InstrumentActionEvent . obtain ( action , getCockTime ( ) . asFloat ( ) , 0 ) ) ; if ( resetHandAnimations )
hasUpdate: public boolean hasUpdate ( ) { return true ;
selectValue: No method body
a: public static LottieComposition a ( b . c . a . a0 . i0 . c BossManJack ) throws IOException { return null ;
getConversionDto: public EventListenerEntryConversionDto getConversionDto ( EventListenerEntry entity ) { EventListenerEntryConversionDto dto = new EventListenerEntryConversionDto ( ) ; dto . setConsumerClassName ( entity . getConsumerClassName ( ) ) ; dto . setEventName ( entity . getEventName ( ) ) ; dto . setConsumerMethodName ( entity . getConsumerMethodName ( ) ) ; dto . setConsumerParameterClassName ( entity . getConsumerParameterClassName ( ) ) ; dto . setEventClassName ( entity . getEventClassName ( ) ) ; dto . setEventObjectType ( entity . getEventObjectType ( ) ) ; dto . setIndexString ( entity . getIndexString ( ) ) ; dto . setStaticData1 ( entity . getStaticData1 ( ) ) ; dto . setStaticData2 ( entity . getStaticData2 ( ) ) ; dto . setStaticData3 ( entity . getStaticData3 ( ) ) ; dto . setStaticData4 ( entity . getStaticData4 ( ) ) ; dto . setModule ( entity . getModuleName ( ) ) ; dto . setOrganizationId ( entity . getOrganizationId ( ) ) ; return dto ;
calculateItem: private void calculateItem ( SlotItem . Selection selection ) { SlotItem item = selection . getItem ( ) ; sumPrice += item . getPrice ( ) ; sumWeight += item . getWeight ( ) ;
getTitle: public String getTitle ( ) { return title ;
openChannelSync: No method body
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case blockHitConfirmation : { BlockHitConfirmationEvent ev = ( ( BlockHitConfirmationEvent ) event ) ; confirmBlockHit ( ev ) ; break ; } } return super . onEvent ( event ) ;
setTeam: public void setTeam ( Team team ) { this . team = team ;
reverseCharAt: public void reverseCharAt ( ) { assertEquals ( "tset gnirtS" , Reverse . reverseCharAt ( "String test" ) ) ; assertEquals ( "eoD nhoJ" , Reverse . reverseCharAt ( "John Doe" ) ) ; assertEquals ( "!dlroW olleH" , Reverse . reverseCharAt ( "Hello World!" ) ) ;
getMyDeaths: public int getMyDeaths ( PlayerClient duelist ) { int count = 0 ; for ( Integer death : deaths ) { if ( duelist . getId ( ) == death ) { count ++ ; } } return count ;
hasNotWoundedPartyMembers: private boolean hasNotWoundedPartyMembers ( ) { int ownerId = playerData . getOwnerId ( ) ; Client myClient = BrainOutServer . Controller . getClients ( ) . get ( ownerId ) ; if ( ! ( myClient instanceof PlayerClient ) ) return false ; PlayerClient myPlayerClient = ( ( PlayerClient ) myClient ) ; String myPartyId = myPlayerClient . getPartyId ( ) ; for ( ObjectMap . Entry < Integer , Client > entry : BrainOutServer . Controller . getClients ( ) ) { Client client = entry . value ; if ( ! ( client instanceof PlayerClient ) ) continue ; PlayerClient playerClient = ( ( PlayerClient ) client ) ; if ( playerClient == myPlayerClient ) continue ; if ( playerClient . getModePayload ( ) == null ) continue ; if ( ! ( ( FreePayload ) playerClient . getModePayload ( ) ) . isFriend ( myClient ) ) { String partyId = playerClient . getPartyId ( ) ; if ( partyId == null || ! partyId . equals ( myPartyId ) ) continue ; } if ( ! playerClient . isAlive ( ) ) continue ; PlayerData playerData = playerClient . getPlayerData ( ) ; if ( playerData == null ) continue ; if ( playerData . isWounded ( ) ) continue ; return true ; } return false ;
getMaxDistance: public float getMaxDistance ( ) { return maxDistance ;
assignPackageGroupToWarehouses: public void assignPackageGroupToWarehouses ( String shopKey , String countryCode , Integer packageGroupId , List < PackageGroupWarehouse > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "post" , this . resolvePath ( "/shops/%s/countries/%s/package-groups/%s" , shopKey , countryCode , packageGroupId ) , query , null , null , model ) ;
drag: public boolean drag ( DragAndDrop . Source source , DragAndDrop . Payload payload , float x , float y , int pointer ) { if ( ! ( source instanceof InventoryItem ) ) return false ; InventoryItem item = ( ( InventoryItem ) source ) ; if ( item . getInventory ( ) == this ) return false ; if ( item . record . getRecord ( ) . getItem ( ) . getContent ( ) instanceof Bullet ) { callback . updateStatus ( UpdateBackgroundPanelStatus . bad ) ; return false ; } callback . updateStatus ( UpdateBackgroundPanelStatus . good ) ; return true ;
received: public boolean received ( final RemoveBlockMsg msg ) { received ( ( PlayerMoveMsg ) msg ) ; BrainOutServer . PostRunnable ( ( ) -> { if ( playerData != null && playerController != null ) { PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; final ConsumableRecord record = poc . getConsumableContainer ( ) . get ( msg . recordId ) ; playerController . removeBlock ( record , msg . layer , msg . placeX , msg . placeY ) ; } } ) ; return true ;
findBone: public @ Null Bone findBone ( String boneName ) { if ( boneName == null ) throw new IllegalArgumentException ( "boneName cannot be null." ) ; Object [ ] bones = this . bones . items ; for ( int i = 0 , n = this . bones . size ; i < n ; i ++ ) { Bone bone = ( Bone ) bones [ i ] ; if ( bone . data . name . equals ( boneName ) ) return bone ; } return null ;
apply: No method body
getMessage: private String getMessage ( Throwable throwable ) { if ( throwable instanceof FlowException ) {
requiredArgs: public int requiredArgs ( ) { return 2 ;
getView: public < T extends View > T getView ( int viewId ) { View view = mViews . get ( viewId ) ; if ( view == null ) { view = itemView . findViewById ( viewId ) ; mViews . put ( viewId , view ) ; } return ( T ) view ;
done: private void done ( ) { done = true ;
trace: public void trace ( Marker marker , String format , Object arg1 , Object arg2 ) { logger . trace ( marker , format , arg1 , arg2 ) ;
getForGuildMemberBanner: public final String getForGuildMemberBanner ( String banner , long guildId , long userId , Integer size , boolean allowAnimated ) { return null ;
updateAssetValueData: void updateAssetValueData ( double value , long date ) { SQLiteDatabase db = mInstance . getWritableDatabase ( ) ; if ( ! db . isOpen ( ) ) { return ; } String sql = "update assets_value_data set value =? where update_date=?" ; db . execSQL ( sql , new Object [ ] { value , date } ) ;
RFpart: private static float RFpart ( float value ) { return 1.0f - FPart ( value ) ;
received: public boolean received ( final PromoCodeResultMsg msg ) { Gdx . app . postRunnable ( ( ) -> { BrainOutClient . EventMgr . sendDelayedEvent ( PromoCodeResultEvent . obtain ( msg . result ) ) ; } ) ; return true ;
getPitch: public RandomValue getPitch ( ) { return pitch ;
received: public boolean received ( FreeDimensionMsg msg ) { String d = msg . d ; Gdx . app . postRunnable ( ( ) -> { Map map = Map . Get ( d ) ; if ( map == null ) { return ; } if ( Log . INFO ) Log . info ( "Disposing remote map " + d ) ; map . dispose ( ) ; Map . UnregisterDimension ( d ) ; } ) ; return true ;
handle: public static void handle ( final Throwable e , OutputStream outputStream ) { if ( Log . ERROR ) { StringWriter result = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( result ) ; printWriter . println ( "Stack trace:" ) ; printWriter . println ( "----------------------------------" ) ; e . printStackTrace ( printWriter ) ; printWriter . println ( "----------------------------------" ) ; Log . error ( "crash:\n" + result . toString ( ) ) ; } if ( outputStream != null ) { PrintStream printStream = new PrintStream ( outputStream ) ; printStream . append ( "Sorry, the exception happened:" ) ; try { e . printStackTrace ( printStream ) ; } catch ( Exception e2 ) { } } BrainOut . StopLoop ( ) ; if ( ! BrainOut . OnlineEnabled ( ) ) return ; reportCrash ( e , "crashreport" , ( ) -> BrainOut . getInstance ( ) . crashed ( e ) ) ;
setGameResult: public void setGameResult ( GameResult gameResult ) { this . gameResult = gameResult ;
onClick: public void onClick ( View v ) { toFriendName = mAddressData . get ( 1 ) . getName ( ) ; selectAddress = recentsAddressSecondTv . getText ( ) . toString ( ) ; mAlertDialog . findViewById ( R . id . lv_step_one_content ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . lv_step_two_content ) . setVisibility ( View . VISIBLE ) ; showStepTwo ( ) ;
generate: public void generate ( ) { final int mapChunkWidth = map . getBlocks ( ) . getBlockWidth ( ) , mapChunkHeight = map . getBlocks ( ) . getBlockHeight ( ) ; for ( int j = 0 ; j < mapChunkHeight ; j ++ )
sendServerChan: No method body
getPool: private Array < ConsumableContent > getPool ( ) { switch ( category )
isProcessRunning: public static boolean isProcessRunning ( Context context ) { ActivityManager activityManager = ( ActivityManager ) context . getSystemService ( Context . ACTIVITY_SERVICE ) ; if ( activityManager == null ) { return false ; } List < ActivityManager . RunningAppProcessInfo > lists = activityManager . getRunningAppProcesses ( ) ; String processName = context . getPackageName ( ) ; for ( ActivityManager . RunningAppProcessInfo info : lists ) { if ( info . processName . equals ( processName ) ) { return true ; } } return false ;
setRunOnInit: public void setRunOnInit ( boolean runOnInit ) { this . runOnInit = runOnInit ;
testCreateOrUpdateCustomData: public void testCreateOrUpdateCustomData ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductCreateOrUpdateCustomDataRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . products ( ) . createOrUpdateCustomData ( Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductCreateOrUpdateCustomDataResponse.json" ) ; assertThatJson ( expectedResponseJson )
update: public void update ( float dt ) { super . update ( dt ) ; Map map = getMap ( ) ; boolean generated = physicsBody != null && animationSlot != null ; if ( generated ) { InstrumentAnimationComponentData iac = instrumentData . getComponentWithSubclass ( InstrumentAnimationComponentData . class ) ; if ( getContentComponent ( ) . getSlot ( ) == null || getContentComponent ( ) . getSlot ( ) . isEmpty ( ) ) return ; if ( flipX != iac . getLaunchPointData ( ) . getFlipX ( ) || ! map . getDimension ( ) . equals ( generatedDimension ) ) { reset ( iac ) ; } else { Bone bone = animationSlot . getBone ( ) ; float a = flipX ? ( angleOffset - bone . getWorldRotation ( ) ) : ( bone . getWorldRotation ( ) - angleOffset ) ; physicsBody . setTransform ( ( bone . getWorldX ( ) ) * Constants . Physics . SCALE , ( bone . getWorldY ( ) ) * Constants . Physics . SCALE , MathUtils . degreesToRadians * a ) ; } } boolean isVisible = instrumentData . getOwner ( ) . isVisible ( ) ; boolean should = active && isVisible ; if ( should != generated )
onChannelClose: public void onChannelClose ( final ChannelHandlerContext context ) { logger . warn ( "Channel has been closed! Communication with the server will no longer be possible." ) ; if ( config . isAutoReconnect ( ) ) {
getVersionNumber: protected int getVersionNumber ( ) { return versionNumber ;
getValue: public T getValue ( ) throws IllegalStateException { if ( ! isReady ) { throw new IllegalStateException ( "Not ready" ) ; } return value ;
shouldNotParseTextWithMisspelledPoint: public void shouldNotParseTextWithMisspelledPoint ( ) { String point = "P0INT (11 -97.0352)" ; String type = point . split ( " " ) [ 0 ] ; Executable parsePointExecutable = ( ) -> MapService . parsePoint ( point ) ; RuntimeException exception = assertThrows ( RuntimeException . class , parsePointExecutable ) ; String expectedMessage = "com.vividsolutions.jts.io.ParseException: Unknown geometry type: " + type + " (line 1)" ; String actualMessage = exception . getMessage ( ) ; assertEquals ( expectedMessage , actualMessage ) ;
roundtrip: private static Stream < Arguments > roundtrip ( ) { var random = new Random ( ) ; return Stream . of (
setClipDataToContent: public void setClipDataToContent ( boolean enabled ) { mClipDataToContent = enabled ;
getID: public ID getID ( ) { return ID . game ;
findSkin: public @ Null Skin findSkin ( String skinName ) { if ( skinName == null ) throw new IllegalArgumentException ( "skinName cannot be null." ) ; for ( Skin skin : skins ) if ( skin . name . equals ( skinName ) ) return skin ; return null ;
setConfig: No method body
getScore: public float getScore ( ) { return score ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { return rights == PlayerRights . admin ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ;
getResult: public String getResult ( ) { return result ;
notFound: public void notFound ( ) { followPathSearching = false ;
execute: public String execute ( String [ ] args , Client client ) { if ( client instanceof PlayerClient ) { PlayerClient playerClient = ( ( PlayerClient ) client ) ; playerClient . getProfile ( ) . reset ( ) ; playerClient . getProfile ( ) . setDirty ( ) ; } else { return "Not a player" ; } return "Done" ;
onDataSuccess: public void onDataSuccess ( int index , List < BaseFilterMenuEntity > data ) { BaseMenuCreator menuCreator = mMenuCreatorList . get ( index ) ; if ( menuCreator != null ) {
notify: private void notify ( NotifyEvent event ) { if ( event . notifyAward == NotifyAward . ownable &&
delete: public void delete ( String shopKey , String countryCode , Integer packageGroupId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/package-groups/%s" , shopKey , countryCode , packageGroupId ) , null , null , null ) ;
addResource: void addResource ( ) { Resource resource = new Resource ( ) ; resource . setCategoryId ( 1L ) ; resource . setName ( "测试资源名称" ) ; resource . setDescription ( "这是一条单元测试创建的资源" ) ; resource . setUrl ( "/unitTest" ) ; resourceService . addResource ( resource ) ; log . info ( "新增资源方法测试成功！" ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionIncrement7ActionPerformed ( evt ) ;
getFile: No method body
success: public void success ( JSONObject response ) { waitLoadingMenu . pop ( ) ;
getChannelId: public final long getChannelId ( ) { return this . channelId ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
getUsers: public final List < Long > getUsers ( ) { return this . users ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { mFW2CloseActionPerformed ( evt ) ;
initData: protected void initData ( ) { EventBus . getDefault ( ) . register ( this ) ; String seedsString = User . getInstance ( ) . getSeedString ( mContext ) ; seedList = seedsString . split ( " " ) ; initEditViewForSeeds ( ) ;
enter: private void enter ( Client client , PlayerData playerData ) { if ( ! ( client instanceof PlayerClient ) ) return ; PlayerClient playerClient = ( ( PlayerClient ) client ) ; ActiveProgressComponentData progress = playerData . getComponent ( ActiveProgressComponentData . class ) ; if ( progress == null ) return ; if ( ! isAllowedToLeave ( playerData ) ) return ; PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( playState . getID ( ) != PlayState . ID . game ) return ; GameMode mode = ( ( ServerPSGame ) playState ) . getMode ( ) ; if ( mode . getID ( ) != GameMode . ID . free ) return ; ServerFreeRealization free = ( ( ServerFreeRealization ) mode . getRealization ( ) ) ; playerClient . enablePlayer ( false ) ; progress . startCancellable ( 1.0f , ( ) ->
free: public void free ( ) { synchronized ( distanceEntryPool ) { for ( WayPointDistanceEntry value : values ( ) ) { distanceEntryPool . free ( value ) ; } } clear ( ) ;
notificationMessage: public String notificationMessage ( ) { return String . format ( "Scheduler: %s. With payload: %s. Executed at: %s" , cronExpression , eventData , scheduledAt ) ;
setAuthenticationManager: public void setAuthenticationManager ( @ Lazy AuthenticationManager authenticationManager ) { super . setAuthenticationManager ( authenticationManager ) ;
openChannel: No method body
changeStatus: void changeStatus ( ) { Long roleId = 2L ; Boolean status = true ; roleService . changeStatus ( roleId , status ) ; log . info ( "更改角色可用状态方法测试成功！" ) ;
sendAndSaveEmail: public Email sendAndSaveEmail ( CanonicalObject object , String templateName , String email ) { debug ( "[sendAndSaveEmail] Sends {} to {}" , templateName , email ) ; return repositories . unsecure . email . save ( services . emailConstructor . prepareEmailWithTitleFromTemplate ( email , templateName , object ) ) ;
validate: public OrganizationForm validate ( BindingResult br ) { if ( StringUtils . isBlank ( dto . name ) ) { br . rejectValue ( "dto.name" , "not.empty" , defaultErrorMessage ) ; } ; return this ;
containsBinary: public static boolean containsBinary ( String [ ] strings , String searched ) { String [ ] copy = Arrays . copyOf ( strings , strings . length ) ; Arrays . sort ( copy ) ; return Arrays . binarySearch ( copy , searched ) >= 0 ;
setStartDate: public void setStartDate ( LocalDate startDate ) { this . startDate = startDate ;
createSimpleInfoAudit: public static boolean createSimpleInfoAudit ( String message ) { return createSimpleInfoAudit ( message , null ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
escape: public boolean escape ( ) { cancel ( ) ; return true ;
getSelectKind: public SelectKind getSelectKind ( ) { return selectKind ;
popMeAndPushMenu: public void popMeAndPushMenu ( Menu menu ) { GameState gs = getGameState ( ) ; if ( gs == null ) return ; gs . popMenu ( this ) ; gs . pushMenu ( menu ) ;
timedOut: public boolean timedOut ( PlayStateEndGame . GameResult gameResult ) { Array < Client > clients = BrainOutServer . Controller . getClients ( ) . values ( ) . toArray ( ) ; clients . sort ( ( o1 , o2 ) -> o1 . getScore ( ) < o2 . getScore ( ) ? 1 : - 1 ) ; if ( clients . size > 0 ) { gameResult . setPlayerWon ( clients . get ( 0 ) . getId ( ) ) ; } if ( gameResult instanceof ServerPSEndGame . ServerGameResult ) { ServerPSEndGame . ServerGameResult serverGameResult = ( ( ServerPSEndGame . ServerGameResult ) gameResult ) ; serverGameResult . getRewardClients ( ) . clear ( ) ; for ( int i = 0 ; i < ( float ) clients . size / 2.0f ; i ++ ) { serverGameResult . getRewardClients ( ) . add ( clients . get ( i ) ) ; } } return true ;
getMainBrandColor: public String getMainBrandColor ( ) { return mainBrandColor ;
updateAssetChannelsAmount: private static void updateAssetChannelsAmount ( Context context , String propertyId , double amount ) { AssetsDataDao assetsDataDao = new AssetsDataDao ( context ) ; assetsDataDao . updateAssetDataChannelAmount ( propertyId , amount ) ;
getInstance: public static AnimatedMoveViewJob getInstance ( ViewPortHandler viewPortHandler , float xValue , float yValue , Transformer trans , View v , float xOrigin , float yOrigin , long duration ) { AnimatedMoveViewJob result = pool . get ( ) ; result . mViewPortHandler = viewPortHandler ; result . xValue = xValue ; result . yValue = yValue ; result . mTrans = trans ; result . view = v ; result . xOrigin = xOrigin ; result . yOrigin = yOrigin ; result . animator . setDuration ( duration ) ; return result ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterInVOpen4ActionPerformed ( evt ) ;
hasProgress: public boolean hasProgress ( ) { return true ;
renamePrivilege: No method body
showImageCenterCropOverride: public static void showImageCenterCropOverride ( Context context , Object imagePath , ImageView imageView , int width , int height , int placeHolder ) { DrawableRequestBuilder builder = getBuilder ( context , imagePath , placeHolder ) ; builder . centerCrop ( ) ; builder . crossFade ( ) ; if ( width > 0 && height > 0 ) { builder . override ( width , height ) ; } builder . into ( imageView ) ;
set: public final void set ( Vector3 other ) { x = other . x ; y = other . y ; z = other . z ;
projectRolesVisibleTo: public List < UserRole > projectRolesVisibleTo ( Optional < OrganizationUser > u ) { if ( ! u . isPresent ( ) ) { return Collections . emptyList ( ) ; } Collection < Long > organizationIds = u . get ( ) . getOrganizationIds ( ) ; boolean returnAll = u . get ( ) . hasGlobalPrivilege ( Privilege . canReadBackend ) ; return roles . stream ( ) . filter ( a -> ! a . isGlobal ( ) && ( returnAll || organizationIds . contains ( a . getOrganizationId ( ) ) ) ) . collect ( Collectors . toList ( ) ) ;
renderDigits: private void renderDigits ( ) { digitsValue . clear ( ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char c = value . charAt ( i ) ; int ord = c - '0' ; if ( ord < 0 || ord > 9 ) continue ; Image img = new Image ( BrainOutClient . Skin , digits . get ( ord ) ) ; img . setTouchable ( Touchable . disabled ) ; img . setScaling ( Scaling . none ) ; digitsValue . add ( img ) ; } for ( int i = 0 , t = codeLength - value . length ( ) ; i < t ; i ++ )
setColorEditTextColor: public ColorPickerDialogBuilder setColorEditTextColor ( int argb ) { colorPickerView . setColorEditTextColor ( argb ) ; return this ;
parseJSON: public JSONObject parseJSON ( String s ) { try {
discoverARecord: public ConsumableRecord discoverARecord ( ) { for ( ConsumableRecord record : itemData . getRecords ( ) . getData ( ) . values ( ) ) { if ( isRecordDiscovered ( record ) ) continue ; if ( discoveredItems == null ) { discoveredItems = new IntSet ( ) ; } discoveredItems . add ( record . getId ( ) ) ; return record ; } return null ;
getRequest: public T getRequest ( ) { return request ;
setValue: public void setValue ( String value ) { this . value = value ;
validateActive: public boolean validateActive ( Active active ) { if ( active instanceof Flag ) { return false ; } return true ;
isSilent: public boolean isSilent ( ) { return silent ;
getHighlightsAtXValue: protected List < Highlight > getHighlightsAtXValue ( float xVal , float x , float y ) { mHighlightBuffer . clear ( ) ; BarLineScatterCandleBubbleData data = getData ( ) ; if ( data == null ) return mHighlightBuffer ; for ( int i = 0 , dataSetCount = data . getDataSetCount ( ) ; i < dataSetCount ; i ++ ) { IDataSet dataSet = data . getDataSetByIndex ( i ) ; if ( ! dataSet . isHighlightEnabled ( ) ) continue ; mHighlightBuffer . addAll ( buildHighlights ( dataSet , i , xVal , DataSet . Rounding . CLOSEST ) ) ; } return mHighlightBuffer ;
updateLight: private void updateLight ( ) { if ( ! canRenderLights ( ) ) { return ; } if ( Map . GetWatcher ( ) == null ) return ; boolean generated = light != null ; if ( generated ) { if ( ! generatedDimension . equals ( Map . GetWatcher ( ) . getDimension ( ) ) ) { free ( ) ; generate ( ) ; } updateTransform ( ) ; } boolean isVisible = weaponData . getOwner ( ) != null && weaponData . getOwner ( ) . isVisible ( ) ; boolean should = got && enabled && isVisible ; if ( should != generated )
setOnCancelListener: public Builder setOnCancelListener ( OnCancelListener onCancelListener ) { P . mOnCancelListener = onCancelListener ; return this ;
addLogo: private static Bitmap addLogo ( Bitmap src , Bitmap logo ) { if ( src == null ) { return null ; } if ( logo == null ) { return src ; } int srcWidth = src . getWidth ( ) ; int srcHeight = src . getHeight ( ) ; int logoWidth = logo . getWidth ( ) ; int logoHeight = logo . getHeight ( ) ; if ( srcWidth == 0 || srcHeight == 0 ) { return null ; } if ( logoWidth == 0 || logoHeight == 0 ) { return src ; } float scaleFactor = srcWidth * 1.0f / 6 / logoWidth ; Bitmap bitmap = Bitmap . createBitmap ( srcWidth , srcHeight , Bitmap . Config . ARGB_8888 ) ; try { Canvas canvas = new Canvas ( bitmap ) ; canvas . drawBitmap ( src , 0 , 0 , null ) ; canvas . scale ( scaleFactor , scaleFactor , srcWidth / 2 , srcHeight / 2 ) ; canvas . drawBitmap ( logo , ( srcWidth - logoWidth ) / 2 , ( srcHeight - logoHeight ) / 2 , null ) ; canvas . save ( ) ; canvas . restore ( ) ; } catch ( Exception e ) { bitmap = null ; e . printStackTrace ( ) ; } return bitmap ;
registerBlockEpochNtfn: No method body
getSpriteName: public String getSpriteName ( ) { return spriteName ;
init: private Event init ( PlayerClient player , Player kind ) { this . player = player ; this . kind = kind ; return this ;
getMode: public GameMode getMode ( ) { return mode ;
failed: public static < T > Promise < T > failed ( @ NotNull Throwable e ) { Promise < T > promise = new Promise < > ( ) ; promise . fail ( e ) ; return promise ;
init: public static < A1 , CP > Flow < A1 , A1 , CP > init ( CP services , PageAttr < A1 > a1 , A1 t ) { return Flow . init ( services , t ) . thenSet ( a1 , a -> a . result ) ;
isLoaded: public boolean isLoaded ( ) { return isLoaded ;
setUp: protected void setUp ( ) { mockWebServer = new MockWebServer ( ) ; NovuConfig novuConfig = new NovuConfig ( "1234" ) ; novuConfig . setBaseUrl ( mockWebServer . url ( "" ) . toString ( ) ) ; RestHandler restHandler = new RestHandler ( novuConfig ) ; environmentHandler = new EnvironmentHandler ( restHandler ) ;
get: public void get ( String name , SyscallCallback < Deferred < ByteBuffer > > callback ) { wrapAndPropagateExceptions (
invertMap: public static Map < String , Integer > invertMap ( Map < Integer , String > src ) { Map < String , Integer > dst = new HashMap < > ( ) ; for ( Map . Entry < Integer , String > entry : src . entrySet ( ) ) { dst . put ( entry . getValue ( ) , entry . getKey ( ) ) ; } return dst ;
dropConsumable: public ItemData dropConsumable ( int recordId , float angle , int amount ) { Client client = getClient ( ) ; if ( client == null ) return null ; if ( isWounded ( ) ) return null ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return null ; ConsumableRecord record = poc . getConsumableContainer ( ) . get ( recordId ) ; if ( record == null || record . getAmount ( ) < amount ) return null ; { Map map = getMap ( ) ; if ( map == null ) return null ; ChunkData chunk = map . getChunkAt ( ( int ) playerData . getX ( ) , ( int ) playerData . getY ( ) ) ; if ( chunk != null && chunk . hasFlag ( ChunkData . ChunkFlag . shootingDisabled ) ) return null ; } ConsumableItem item = record . getItem ( ) ; GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode != null ) { GameModeRealization realization = gameMode . getRealization ( ) ; if ( realization instanceof ServerRealization ) { if ( ! ( ( ServerRealization ) realization ) . canDropConsumable ( ( ( PlayerClient ) client ) , item ) ) return null ; } } boolean currentInstrument = false ; Item dropItem = null ; if ( item . getContent ( ) . hasComponent ( ItemComponent . class ) ) { dropItem = item . getContent ( ) . getComponent ( ItemComponent . class ) . getDropItem ( ) ; } if ( item instanceof InstrumentConsumableItem ) { InstrumentData instrumentData = ( ( InstrumentConsumableItem ) item ) . getInstrumentData ( ) ; currentInstrument = instrumentData == playerData . getCurrentInstrument ( ) ; Instrument instrument = instrumentData . getInstrument ( ) ; ServerWeaponComponentData swc = instrumentData . getComponent ( ServerWeaponComponentData . class ) ; if ( swc != null ) { for ( ServerWeaponComponentData . Slot slot : swc . getSlots ( ) . values ( ) ) { slot . checkCancelReloading ( ) ; } } if ( instrument . hasComponent ( ItemComponent . class ) ) { dropItem = instrument . getComponent ( ItemComponent . class ) . getDropItem ( ) ; } } AutoConvertConsumable auto = item . getContent ( ) . getComponent ( AutoConvertConsumable . class ) ; if ( auto != null ) { item = auto . getConvertTo ( ) . acquireConsumableItem ( ) ; } Array < ConsumableRecord > records = new Array < > ( ) ; ConsumableRecord r = new ConsumableRecord ( item , amount , 0 ) ; r . setQuality ( record . getQuality ( ) ) ; records . add ( r ) ; ItemData itemData = ServerMap . dropItem ( playerData . getDimension ( ) , dropItem , records , playerData . getOwnerId ( ) , playerData . getX ( ) , playerData . getY ( ) , angle ) ; poc . getConsumableContainer ( ) . decConsumable ( record , amount ) ; BrainOutServer . Controller . getClients ( ) . sendTCP ( new InventoryItemMovedMsg ( playerData , item . getContent ( ) ) ) ; if ( currentInstrument ) { selectFirstInstrument ( poc ) ; } updateAttachments ( ) ; consumablesUpdated ( ) ; return itemData ;
canZoomOutMoreY: public boolean canZoomOutMoreY ( ) { return mScaleY > mMinScaleY ;
onDisconnect: public void onDisconnect ( ) { if ( disconnectReason == DisconnectReason . pleaseReconnect ) { doConnect ( - 1 , null ) ; return ; } this . serverConnection = null ; BrainOut . EventMgr . sendDelayedEvent ( SimpleEvent . obtain ( SimpleEvent . Action . disconnect ) ) ;
valueConverters: public < V2 > FormFieldDefinitionBuilder < V2 > valueConverters ( Function < V , V2 > toEntityValue , Function < Object , Object > toDtoValue ) { fields . set ( fields . size ( ) - 1 , lastField = createFormFieldDefinition ( formName , lastField , toEntityValue , toDtoValue ) ) ; return ( FormFieldDefinitionBuilder < V2 > ) this ;
publish: public void publish ( final @ NonNull Packet packet , final MessageTarget target ) { client . publish ( packet , target ) ;
getIdsByRoleId: public Set < Long > getIdsByRoleId ( @ NonNull Long roleId ) { List < Menu > menuList = this . baseMapper . findAllByRoleId ( roleId ) ; if ( CollectionUtils . isEmpty ( menuList ) ) return new HashSet < > ( ) ; return menuList . stream ( )
preHandle: No method body
zoomIn: public void zoomIn ( ) { MPPointF center = mViewPortHandler . getContentCenter ( ) ; mViewPortHandler . zoomIn ( center . x , - center . y , mZoomMatrixBuffer ) ; mViewPortHandler . refresh ( mZoomMatrixBuffer , this , false ) ; MPPointF . recycleInstance ( center ) ; calculateOffsets ( ) ; postInvalidate ( ) ;
createDefault: public static < T > Observable < T > createDefault ( @ NonNull ObservableOnSubscribe < T > observableOnSubscribe ) { return create ( observableOnSubscribe ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) ;
hashCode: public int hashCode ( ) { return Objects . hash ( eventClass , eventName ) ;
set: No method body
hasItem: public boolean hasItem ( UserProfile userProfile ) { return userProfile . hasItem ( this ) ;
requiredArgs: public int requiredArgs ( ) { return 2 ;
renderQuestActionButtons: protected void renderQuestActionButtons ( Table renderTo ) { {
getMapWidth: public int getMapWidth ( ) { try
setImmortalTime: public void setImmortalTime ( float immortalTime ) { this . immortalTime . setValue ( immortalTime ) ;
calculateNeighborMask: public byte calculateNeighborMask ( Map map , int currentX , int currentY , int layer ) { final byte a = ( byte ) ( isMatchNeighbor ( map , currentX , currentY , layer , 0 , 1 ) ? 1 : 0 ) ; final byte b = ( byte ) ( isMatchNeighbor ( map , currentX , currentY , layer , 1 , 0 ) ? 2 : 0 ) ; final byte c = ( byte ) ( isMatchNeighbor ( map , currentX , currentY , layer , 0 , - 1 ) ? 4 : 0 ) ; final byte d = ( byte ) ( isMatchNeighbor ( map , currentX , currentY , layer , - 1 , 0 ) ? 8 : 0 ) ; return ( byte ) ( a + b + c + d ) ;
getTakingDistance: public float getTakingDistance ( ) { return getContentComponent ( ) . getTakeDistance ( ) ;
discard: public void discard ( ) { this . setVisible ( false ) ;
onClick: public void onClick ( View widget ) { super . onClick ( widget ) ;
equalIsNot: public static boolean equalIsNot ( String string ) { if ( string == null || string . isEmpty ( ) ) { return true ; } int indexIs = string . indexOf ( "is" ) ; int indexNot = string . indexOf ( "not" ) ; while ( indexIs != - 1 && indexNot != - 1 ) { indexIs = string . indexOf ( "is" , indexIs + 2 ) ; indexNot = string . indexOf ( "not" , indexNot + 3 ) ; } return indexIs == indexNot ;
getAllRefs: public static LinkedHashMap < Table , List < Column > > getAllRefs ( Database db , Table t ) { LinkedHashMap < Table , List < Column > > allRefs = new LinkedHashMap < > ( ) ; Set < Table > visitedTables = new HashSet < > ( ) ; getAllRefsRecursive ( db , t , allRefs , visitedTables ) ; return allRefs ;
getData: No method body
test_deleteFeed: public void test_deleteFeed ( ) throws IOException , NovuNetworkException , InterruptedException { BulkFeedsResponse bulkFeedsResponse = new BulkFeedsResponse ( ) ; bulkFeedsResponse . setData ( Collections . singletonList ( new FeedResponseData ( ) ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( bulkFeedsResponse ) ) ) ; BulkFeedsResponse response = feedsHandler . deleteFeed ( "id" ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/feeds/id" , request . getPath ( ) ) ; assertEquals ( "DELETE" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( bulkFeedsResponse ) , gson . toJson ( response ) ) ;
setKarma: public void setKarma ( int karma ) { this . karma = karma ;
getColor: public Color getColor ( ) { return color ;
updateDepart: public void updateDepart ( @ NonNull Depart depart ) { eventPublisher . publishEvent ( new ClearCacheEvent ( SystemDictConstants . DEPART ) ) ; Assert . isTrue ( this . baseMapper . updateById ( depart ) > 0 , "更新部门失败！" ) ;
intersection: void intersection ( ) { assertEquals ( Set . of ( ) , Intersection . intersection ( Set . of ( 1 , 2 , 3 ) , Set . of ( 4 , 5 , 6 ) ) ) ; assertEquals ( Set . of ( 3 ) , Intersection . intersection ( Set . of ( 1 , 2 , 3 ) , Set . of ( 3 , 4 , 5 ) ) ) ; assertEquals ( Set . of ( ) , Intersection . intersection ( Set . of ( ) , Set . of ( ) ) ) ; assertEquals ( Set . of ( ) , Intersection . intersection ( Set . of ( 1 , 2 , 3 ) , Set . of ( ) ) ) ; assertEquals ( Set . of ( ) , Intersection . intersection ( Set . of ( ) , Set . of ( 1 , 2 , 3 ) ) ) ;
onDraw: protected void onDraw ( Canvas canvas ) { if ( mData == null ) { boolean hasText = ! TextUtils . isEmpty ( mNoDataText ) ; if ( hasText ) { MPPointF pt = getCenter ( ) ; switch ( mInfoPaint . getTextAlign ( ) ) { case LEFT : pt . x = 0 ; canvas . drawText ( mNoDataText , pt . x , pt . y , mInfoPaint ) ; break ; case RIGHT : pt . x = ( float ) ( pt . x * 2.0 ) ; canvas . drawText ( mNoDataText , pt . x , pt . y , mInfoPaint ) ; break ; default : canvas . drawText ( mNoDataText , pt . x , pt . y , mInfoPaint ) ; break ; } } return ; } if ( ! mOffsetsCalculated ) {
updateOrCreate: public void updateOrCreate ( String attributeGroupName , Map < String , String > model , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "post" , this . resolvePath ( "/attributes/%s/translations" , attributeGroupName ) , query , null , null , model ) ;
getPreferredSize: public Dimension getPreferredSize ( ) { return getCustomDimensions ( ) ;
setStopTime: public static void setStopTime ( long stopTime ) { STOP_TIME = stopTime ;
getWeaponProperties: public Weapon . WeaponProperties getWeaponProperties ( ) { return weaponProperties ;
update: public void update ( float dt ) { cnt -= dt ; if ( cnt > 0 ) return ; cnt = 0.2f ; switch ( kind )
update: public Promotion update ( String promotionId , Promotion model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Promotion > responseModel = ( Class < Promotion > ) ( Class < ? > ) Promotion . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/promotions/%s" , promotionId ) , query , null , responseModel , model ) ;
reduceWithDouglasPeucker: public float [ ] reduceWithDouglasPeucker ( float [ ] points , float tolerance ) { int greatestIndex = 0 ; float greatestDistance = 0f ; Line line = new Line ( points [ 0 ] , points [ 1 ] , points [ points . length - 2 ] , points [ points . length - 1 ] ) ; for ( int i = 2 ; i < points . length - 2 ; i += 2 ) { float distance = line . distance ( points [ i ] , points [ i + 1 ] ) ; if ( distance > greatestDistance ) { greatestDistance = distance ; greatestIndex = i ; } } if ( greatestDistance > tolerance ) {
updateResource: public AjaxResult updateResource ( @ RequestBody @ Valid UpdateResourceByRoleParam param ) { roleService . updateResource ( param . getRoleId ( ) , param . getResourceIds ( ) ) ; return AjaxResult . success ( "更新成功！" ) ;
onInit: public void onInit ( ) { super . onInit ( ) ; MenuHelper . AddCloseButton ( this , this :: pop ) ; { Table waiting = new Table ( ) ; if ( BrainOutClient . Skin . has ( "title-small" , Label . LabelStyle . class ) ) { statusLabel = new Label ( L . get ( "MENU_LOADING" ) , BrainOutClient . Skin , "title-messages-white" ) ; waiting . add ( statusLabel ) ; } waiting . add ( new LoadingBlock ( ) ) . padLeft ( 16 ) ; waiting . setBounds ( getWidth ( ) - 288 , 32 , 224 , 16 ) ; addActor ( waiting ) ; } GameService gameService = GameService . Get ( ) ; LoginService loginService = LoginService . Get ( ) ; if ( gameService != null && loginService != null )
getTag: public String getTag ( ) { return tag ;
createUI: public Table createUI ( ) { return null ;
getDepartListPage: No method body
getAccountAddress: public String getAccountAddress ( ) { return accountAddress ;
getDiscriminator: public String getDiscriminator ( ) { return this . discriminator ;
updated: protected void updated ( ) { super . updated ( ) ; updateStats ( ) ;
onDestroy: protected void onDestroy ( ) { EventBus . getDefault ( ) . unregister ( this ) ; super . onDestroy ( ) ;
downloadPeerFile: public void downloadPeerFile ( View view , DownloadCallback downloadCallback ) { String fileName = PEER_FILE_NAME ; String downloadFileName = fileName ; String downloadUrl = ConstantWithNetwork . getInstance ( ConstantInOB . networkType ) . getDownloadBaseUrl ( ) + downloadFileName ; String filePath = downloadDictionaryPath ; OnDownloadListener onDownloadListener = new OnDownloadListener ( ) { @ Override public void onDownloadComplete ( ) { downloadCallback . callback ( ) ; } @ Override public void onError ( Error error ) { view . findViewById ( R . id . refresh_btn ) . setVisibility ( View . VISIBLE ) ; if ( error . isServerError ( ) ) { ToastUtils . showToast ( mContext , fileName + "server occur error!" ) ; } else if ( error . isConnectionError ( ) ) { ToastUtils . showToast ( mContext , fileName + "connection occur error!" ) ; } else { ToastUtils . showToast ( mContext , fileName + "download occur error:" + error . toString ( ) ) ; } } } ; downloadFile ( view , fileName , filePath , downloadUrl , onDownloadListener ) ;
setAssignments: public void setAssignments ( String assignments ) { this . assignments = assignments ;
setBinaryStream: public OutputStream setBinaryStream ( long pos ) throws SQLException { return null ;
update: public Voucher update ( String shopKey , String countryCode , Integer voucherId , Voucher model ) throws ApiErrorException , ConnectionException { Class < Voucher > responseModel = ( Class < Voucher > ) ( Class < ? > ) Voucher . class ; return this . request ( "patch" , this . resolvePath ( "/shops/%s/countries/%s/vouchers/%s" , shopKey , countryCode , voucherId ) , null , null , responseModel , model ) ;
onClick: public void onClick ( View v ) { mContext . startActivity ( ShareUtil . getTwitterIntent ( mContext , lnInvoice ) ) ; shareLayout . setVisibility ( View . GONE ) ;
testGetCustomDataForKey: public void testGetCustomDataForKey ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . productVariants ( ) . getCustomDataForKey ( Identifier . fromId ( 1 ) , "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductVariantGetCustomDataForKeyResponse.json" ) ; assertThatJson ( expectedResponseJson )
leave: public boolean leave ( int owner ) { if ( ! participants . containsKey ( owner ) ) return false ; Participant participant = participants . remove ( owner ) ; freePlaces . add ( participant . place ) ; return true ;
obtain: public static Event obtain ( float time ) { RespawnTimeEvent e = obtain ( RespawnTimeEvent . class ) ; if ( e == null ) return null ; return e . init ( time ) ;
getSoundDistance: public float getSoundDistance ( ) { return soundDistance ;
addItem: public void addItem ( UserProfile userProfile , int amount ) { userProfile . addItem ( this , amount ) ;
render: public void render ( Batch batch , RenderContext context ) { super . render ( batch , context ) ; if ( BrainOutClient . ClientSett . isBackgroundEffectsEnabled ( ) )
findAllIdsAsStream: No method body
findByUsername: No method body
shouldNotCopyBackup_windowsEnv: public void shouldNotCopyBackup_windowsEnv ( ) throws IOException { Set < BackupOption > backupOptions = Set . of ( SCP_ENABLED ) ; File fileToCopy = getTmpFile ( true ) ; boolean result = testObject . copyBackupFile ( backupOptions , fileToCopy ) ; assertFalse ( result ) ;
enumsToMapWithLabels: public static < E extends Enum < E > > Map < Object , String > enumsToMapWithLabels ( E [ ] enumValues ) { return Arrays . stream ( enumValues ) . collect ( Collectors . toMap ( Function . identity ( ) , e -> ( ( OptionWithLabel ) e ) . getLabel ( ) ) ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { off7ActionPerformed ( evt ) ;
getInfo: public String getInfo ( ) { return info ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer < 0 )
setColor: public void setColor ( int color ) { this . mColor = color ; calculateFinalColor ( ) ;
getAttachTo: public AttachTo getAttachTo ( ) { return attachTo ;
end: public void end ( Batch batch ) { batch . setShader ( null ) ;
getIdListAsString: public String getIdListAsString ( List < Notification > notifications ) { debug ( "[getIdListAsString]" ) ; List < Long > usersUnreadNotificationsIdList = new ArrayList < > ( ) ; for ( Notification n : notifications ) { usersUnreadNotificationsIdList . add ( n . getId ( ) ) ; } String idString = usersUnreadNotificationsIdList . toString ( ) . replace ( "[" , "" ) . replace ( "]" , "" ) . replaceAll ( "\\s+" , "" ) ; return idString ;
privateAnd: private boolean privateAnd ( boolean a , boolean b ) { return a && b ;
drawMultilineText: public static void drawMultilineText ( Canvas c , String text , float x , float y , TextPaint paint , FSize constrainedToSize , MPPointF anchor , float angleDegrees ) { StaticLayout textLayout = new StaticLayout ( text , 0 , text . length ( ) , paint , ( int ) Math . max ( Math . ceil ( constrainedToSize . width ) , 1.f ) , Layout . Alignment . ALIGN_NORMAL , 1.f , 0.f , false ) ; drawMultilineText ( c , textLayout , x , y , paint , anchor , angleDegrees ) ;
getCardAt: private String getCardAt ( int idx ) { if ( this . cards == null ) return null ; return this . cards . get ( idx ) ;
getMap: private FreePlayMap getMap ( ) { CSGame game = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( game == null ) return null ; PlayerData playerData = game . getPlayerData ( ) ; if ( playerData == null ) return null ; FreePlayMap map = playerData . getMap ( FreePlayMap . class ) ; if ( map == null ) return null ; return map ;
getWeaponData: public WeaponData getWeaponData ( ) { return weaponData ;
render: public Actor render ( Table data ) { return ContentImage . RenderStatImage ( id , amount , data ) ;
loadFromDb: public boolean loadFromDb ( Long eventListenerEntryId ) { debug ( "[loadFromDb] eventListenerEntryId: {}" , eventListenerEntryId ) ; EventListenerEntry eventListenerEntry = repositories . unsecure . eventListener . findOne ( eventListenerEntryId ) ; return registerListener ( eventListenerEntry ) ;
allValues: public Set < String > allValues ( ) { Set < String > allValues = new HashSet < > ( ) ; allValues . addAll ( splitValues ( ifStatements ) ) ; allValues . addAll ( splitValues ( thenStatements ) ) ; allValues . addAll ( splitValues ( elseStatements ) ) ; return allValues ;
killAll: public void killAll ( ) { for ( PlayerClient duelist : duelists )
pendingSweeps: public Single < walletrpc . Walletkit . PendingSweepsResponse > pendingSweeps ( walletrpc . Walletkit . PendingSweepsRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . pendingSweeps ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
reset: public void reset ( ) { forceX = 0 ; forceY = 0 ;
withIdempotency: public CallRequestOptions withIdempotency ( String idempotencyKey ) { return new CallRequestOptions ( new HashMap < > ( this . additionalHeaders ) , idempotencyKey ) ;
getDrawAngles: public float [ ] getDrawAngles ( ) { return mDrawAngles ;
execute: public void execute ( ) { String str = String . format ( "Elapsed time: %d ms" , executeVirtualThreads ( getRunnable ( ) ) ) ; System . out . println ( str ) ;
getAll: public Object getAll ( @ PathVariable ( value = ORGANIZATIONID , required = false ) Long organizationId , @ Qualifier ( "file" ) Pageable filePageable , @ RequestParam ( required = false , defaultValue = "" , name = "file_search" ) String search ) { debug ( "[getAll]" ) ; return searchFile ( organizationId , search , null , filePageable )
getSpring: public float getSpring ( ) { return spring . getValue ( ) ;
success: public void success ( ) { connected ( ) ;
getName: public String getName ( ) { return name ;
release: public void release ( ) { if ( getMode ( ) == null ) return ; getMode ( ) . getRealization ( ) . release ( ) ;
setInvoiceIdentifier: public void setInvoiceIdentifier ( String invoiceIdentifier ) { this . invoiceIdentifier = invoiceIdentifier ;
getDimension: public String getDimension ( ) { return dimension ;
initializeDialUpdateThread: public void initializeDialUpdateThread ( ) { UI . uiThreads . add ( new Thread ( ( ) -> { try { while ( true ) { annunciator . update ( ) ; if ( this . isVisible ( ) ) { java . awt . EventQueue . invokeLater ( ( ) -> { double [ ] mfwFlows = new double [ ] { 0.0 , 0.0 } ; for ( int i = 0 ; i < 3 ; i ++ ) { mfwFlows [ 0 ] += mainFeederValves . get ( i ) . timestepFlow * 20 ; } for ( int i = 3 ; i < 6 ; i ++ ) { mfwFlows [ 1 ] += mainFeederValves . get ( i ) . timestepFlow * 20 ; } drumLevel1 . setValue ( mcc . drum1 . getWaterLevel ( ) ) ; drumLevel2 . setValue ( mcc . drum2 . getWaterLevel ( ) ) ; mainFWFlow1 . setValue ( mfwFlows [ 0 ] ) ; mainFWFlow2 . setValue ( mfwFlows [ 1 ] ) ; auxFWFlow1 . setValue ( auxFeederValves . get ( 0 ) . timestepFlow * 20 ) ; auxFWFlow2 . setValue ( auxFeederValves . get ( 1 ) . timestepFlow * 20 ) ; fwTemp1 . setValue ( feedwaterMixer1 . getWaterTemperature ( ) ) ; fwTemp2 . setValue ( feedwaterMixer2 . getWaterTemperature ( ) ) ; fwPos1 . setValue ( mainFeederValves . get ( 0 ) . getPosition ( ) * 100 ) ; fwPos2 . setValue ( mainFeederValves . get ( 1 ) . getPosition ( ) * 100 ) ; fwPos3 . setValue ( mainFeederValves . get ( 2 ) . getPosition ( ) * 100 ) ; fwPos4 . setValue ( mainFeederValves . get ( 3 ) . getPosition ( ) * 100 ) ; fwPos5 . setValue ( mainFeederValves . get ( 4 ) . getPosition ( ) * 100 ) ; fwPos6 . setValue ( mainFeederValves . get ( 5 ) . getPosition ( ) * 100 ) ; aFWPos1 . setValue ( auxFeederValves . get ( 0 ) . getPosition ( ) * 100 ) ; aFWPos2 . setValue ( auxFeederValves . get ( 1 ) . getPosition ( ) * 100 ) ; } ) ; } if ( this . isFocused ( ) ) { Thread . sleep ( UI . getUpdateRate ( ) ) ; } else { Thread . sleep ( 200 ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } ) ) ; UI . uiThreads . get ( UI . uiThreads . size ( ) - 1 ) . start ( ) ;
reset: public void reset ( ) { this . killer = null ; this . victim = null ; this . instrument = null ; this . kind = null ; this . skin = null ;
getDisplayModes: No method body
received: public boolean received ( final SetFavoriteMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { Content content = BrainOutServer . ContentMgr . get ( msg . content , Content . class ) ; if ( content == null ) return ; if ( msg . fav ) { profile . addFavorite ( content . getID ( ) ) ; } else { profile . removeFavorite ( content . getID ( ) ) ; } profile . setDirty ( ) ; } ) ; return true ;
updateMembership: public CustomerMembership updateMembership ( String shopKey , String countryCode , Integer membershipId , CustomerMembership model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomerMembership > responseModel = ( Class < CustomerMembership > ) ( Class < ? > ) CustomerMembership . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/customers/memberships/%s" , shopKey , countryCode , membershipId ) , query , null , responseModel , model ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem10ActionPerformed ( evt ) ;
reset: public void reset ( ) { Global . reset ( ) ;
negativeFeeThrowsException: void negativeFeeThrowsException ( ) { assertThrows ( IllegalArgumentException . class , ( ) -> bankAccount . setOperationFee ( - 1.0 ) ) ;
fetch: public void fetch ( ) { if ( getRounds ( ) > 0 && getChambered ( ) < weaponProperties . getChambers ( ) )
getVersion: public @ Null String getVersion ( ) { return version ;
compare: public int compare ( ECar o1 , ECar o2 ) { return o1 . brand . compareTo ( o2 . brand ) ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer > 0 ) return ; timer = 0.1f ; if ( enemyNoticedCallback != null && checkEnemy ( ) ) return ; if ( reachedItem ) { pop ( ) ; return ; } if ( Vector2 . dst2 ( activeData . getX ( ) , activeData . getY ( ) , getPlayerData ( ) . getX ( ) , getPlayerData ( ) . getY ( ) ) < 3.0f * 3.0f ) { pop ( ) ; return ; } followItem ( ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case freePlayEnemyOfKindKilled : { FreePlayEnemyOfKindKilledEvent ev = ( ( FreePlayEnemyOfKindKilledEvent ) event ) ; if ( ev . kind . getID ( ) . equals ( getPlayer ( ) ) ) { ServerTask . Trigger ( this , ev . player , 1 ) ; } } } return false ;
HaveBullets: public static boolean HaveBullets ( PlayerOwnerComponent poc , WeaponData weaponData , Bullet bullet , boolean countLoaded ) { if ( countLoaded ) { ServerWeaponComponentData wp = weaponData . getComponent ( ServerWeaponComponentData . class ) ; if ( wp != null ) { ServerWeaponComponentData . Slot primarySlot = wp . getSlot ( Constants . Properties . SLOT_PRIMARY ) ; if ( primarySlot != null ) { if ( primarySlot . getRounds ( ) > 0 ) { return true ; } } } } for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : poc . getConsumableContainer ( ) . getData ( ) ) { ConsumableRecord record = entry . value ; ConsumableItem item = record . getItem ( ) ; if ( item . getContent ( ) == bullet ) return true ; } return false ;
registerApiCrudController: default CRUDControllerConfiguration registerApiCrudController ( FrontendMappingDefinition definition , ScopedSecureRepository repository , String readPrivilege , String writePrivilege ) { return registerApiCrudController ( definition , repository , PrivilegeHelper . valueOfString ( readPrivilege ) , PrivilegeHelper . valueOfString ( writePrivilege ) ) ;
uploadImages: public void uploadImages ( List < String > list ) { mCurrentUploadIndex = 0 ; if ( mUploadProgressDialog == null ) { mUploadProgressDialog = new UploadProgressDialog ( mContext ) ; } mUploadProgressDialog . show ( ) ; mUploadList . clear ( ) ; mUploadList . addAll ( list ) ; mTotalUploadSize = mUploadList . size ( ) * 100 ; if ( mUploadList . size ( ) > 0 ) {
getAngle: public float getAngle ( ) { return activeData . getAngle ( ) ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; mCreateChannelStepOnePopupWindow = new CreateChannelStepOnePopupWindow ( mContext ) ; mCreateChannelStepOnePopupWindow . show ( view , 0 , "123" , "123" ) ;
deleteCustomData: public void deleteCustomData ( String shopKey , Integer shopCategoryId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/categories/%s/custom-data" , shopKey , shopCategoryId ) , null , null , null ) ;
getPrefHeight: public float getPrefHeight ( ) { return 1.0f ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer > 0 ) return ; timer = 0.1f ; if ( enemyNoticedCallback != null && checkEnemy ( ) ) return ; if ( reachedItem && Vector2 . dst2 ( itemData . getX ( ) , itemData . getY ( ) , getPlayerData ( ) . getX ( ) , getPlayerData ( ) . getY ( ) ) < 3.0f * 3.0f ) { putTheItemIn ( ) ; return ; } followItem ( ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { start2AItemStateChanged ( evt ) ;
write: public void write ( final Packet packet ) { write ( packet , ConversationUID . newUid ( ) ) ;
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { return ; } runOnUiThread ( new Runnable ( ) {
setStartCreate: public void setStartCreate ( Context context , Boolean startCreate ) { PreferencesUtils . saveStartCreate ( context , startCreate ) ; this . startCreate = startCreate ;
id: public String id ( ) { return identifier ;
createTempDirectory: private static File createTempDirectory ( String prefix ) throws IOException { String tempDir = System . getProperty ( "java.io.tmpdir" ) ; File generatedDir = new File ( tempDir , prefix + System . nanoTime ( ) ) ; if ( ! generatedDir . mkdir ( ) ) throw new IOException ( "Failed to create temp directory " + generatedDir . getName ( ) ) ; return generatedDir ;
findActiveData: private ActiveData findActiveData ( String tag ) { for ( Map map : Map . All ( ) ) { ActiveData found = map . getActiveNameIndex ( ) . get ( tag ) ; if ( found != null ) return found ; } return null ;
checkIsNumber: public static boolean checkIsNumber ( String str ) { Pattern pattern = Pattern . compile ( "[0-9]*" ) ; Matcher isNum = pattern . matcher ( str ) ; return isNum . matches ( ) ;
enter: private void enter ( Client client , PlayerData playerData ) { ServerElevatorComponentData elevator = getElevator ( ) ; if ( elevator == null ) return ; elevator . enter ( client , playerData ) ;
updateOrganizationBrand: public UpdateOrganizationBrandResponse updateOrganizationBrand ( final UpdateOrganizationBrandRequest request ) throws IOException , NovuNetworkException { Response < UpdateOrganizationBrandResponse > response = organizationApi . updateOrganizationBrand ( request ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
getTitle: public Label getTitle ( ) { return title ;
addMenu: void addMenu ( ) throws Exception { assertNotNull ( addMenuParam , "addMenuParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/menu/add" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( addMenuParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "新增菜单接口测试成功！" ) ;
detectPromo: private static String detectPromo ( ) { String clip = Gdx . app . getClipboard ( ) . getContents ( ) ; if ( clip != null ) { Matcher matcher = ROOM_ID_PATTERN . matcher ( clip ) ; if ( matcher . matches ( ) ) { return matcher . group ( 1 ) ; } } return "" ;
initializeTorch: private void initializeTorch ( Camera . Parameters parameters , SharedPreferences prefs , boolean safeMode ) { boolean currentSetting = FrontLightMode . readPref ( prefs ) == FrontLightMode . ON ; doSetTorch ( parameters , currentSetting , safeMode ) ;
setString: public static void setString ( String key , String value ) { getPreferences ( ) . edit ( ) . putString ( key , value ) . commit ( ) ;
hasRender: public boolean hasRender ( ) { return true ;
getCurTraceId: public static String getCurTraceId ( ) { return traceIdCtx . get ( ) ;
shopCategoryProductSetUnlinkInstructions: public ShopCategoryProductSetUnlinkInstructionService shopCategoryProductSetUnlinkInstructions ( ) { ShopCategoryProductSetUnlinkInstructionService service = this . getService ( "com.scayle.adminapi.service.ShopCategoryProductSetUnlinkInstructionService" ) ; return service ;
setSliceSpace: public void setSliceSpace ( float spaceDp ) { if ( spaceDp > 20 ) spaceDp = 20f ; if ( spaceDp < 0 ) spaceDp = 0f ; mSliceSpace = Utils . convertDpToPixel ( spaceDp ) ;
getLoadView: public View getLoadView ( Context context , ViewGroup parent ) { mRootView = LayoutInflater . from ( context ) . inflate ( R . layout . view_load_footer , parent , false ) ; mLoadIcon = mRootView . findViewById ( R . id . tv_load_icon ) ; mLoadText = mRootView . findViewById ( R . id . tv_load_text ) ; mLoadingAnimation = new RotateAnimation ( 0 , 359 , Animation . RELATIVE_TO_SELF , 0.5f , Animation . RELATIVE_TO_SELF , 0.5f ) ; mLoadingAnimation . setRepeatCount ( - 1 ) ; mLoadingAnimation . setInterpolator ( new LinearInterpolator ( ) ) ; mLoadingAnimation . setDuration ( 500 ) ; return mRootView ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem1ActionPerformed ( evt ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton9ActionPerformed ( evt ) ;
getDimension: public String getDimension ( ) { return activeData . getDimension ( ) ;
getFlippedAngle: public float getFlippedAngle ( ) { return getAngle ( ) ;
read: public boolean read ( JSONObject data , int multiplyAmount ) { String actionType = data . optString ( "action" ) ; if ( actionType == null ) return false ; Action promoAction ; try { promoAction = newAction ( actionType , data ) ; } catch ( RuntimeException ignored ) { if ( Log . ERROR ) Log . error ( ignored . getMessage ( ) ) ; return false ; } if ( promoAction != null ) { promoAction . setMultiply ( multiplyAmount ) ; this . action = promoAction ; } return true ;
setupBeforeAll: static void setupBeforeAll ( ) throws URISyntaxException , IOException { inMemoryPdf = new InMemoryPdf (
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ProductVariantUpdateRequest.json" ) ; ProductVariant requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , ProductVariant . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ProductVariant responseEntity = this . api . productVariants ( ) . update ( Identifier . fromId ( 1 ) , Identifier . fromId ( 1 ) , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductVariantUpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
onRequestPermissionSuccess: public void onRequestPermissionSuccess ( ) { callPhoneNum ( ) ;
getMinor: public Integer getMinor ( ) { return minor ;
setAverage: public void setAverage ( double average ) { this . average = average ;
success: public void success ( JSONObject response ) { MarketUtils . GetMarketRU ( new MarketUtils . GetRUCallback ( )
getSpeed: public Vector2 getSpeed ( ) { return speed ;
getBones: public @ Null int [ ] getBones ( ) { return bones ;
getCurrentItem: protected ConflictSize getCurrentItem ( ) { for ( ConflictSize size : conflictSizes ) { if ( size . size == conflictSize ) return size ; } return null ;
showImageCenterCrop: public static void showImageCenterCrop ( Context context , Object imagePath , ImageView imageView , int width , int height ) { showImageCenterCrop ( context , imagePath , imageView , R . color . color_f7f7f7 , width , height ) ;
onHideChildren: No method body
ok: public void ok ( ) { done ( ) ;
add: void add ( ) throws Exception { assertNotNull ( addResourceParam , "addResourceParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . post ( "/resource/add" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( addResourceParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "新增资源接口测试成功！" ) ;
defaultDocumentJsonCreator: public static Function < Map < String , String > , String > defaultDocumentJsonCreator ( final ObjectMapper objectMapper ) { return document -> {
init: private Event init ( BlockData blockData ) { this . blockData = blockData ; return this ;
copy: public DataSet < PieEntry > copy ( ) { List < PieEntry > entries = new ArrayList < > ( ) ; for ( int i = 0 ; i < mEntries . size ( ) ; i ++ ) { entries . add ( mEntries . get ( i ) . copy ( ) ) ; } PieDataSet copied = new PieDataSet ( entries , getLabel ( ) ) ; copy ( copied ) ; return copied ;
update: public void update ( ) { sticks . clear ( ) ; buttons . clear ( ) ; for ( Property property : getProperties ( ) )
processWorkWeixin: public void processWorkWeixin ( String message ) { log . info ( "WorkWeixin Receiver:{}" , message ) ;
createUI: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { precisionDecrement1ActionPerformed ( evt ) ;
setProgress: public void setProgress ( int progress ) { this . progress = progress ;
isInfoEnabled: public boolean isInfoEnabled ( Marker marker ) { return logger . isInfoEnabled ( marker ) ;
hasPartner: private boolean hasPartner ( ) { RemoteClient me = BrainOutClient . ClientController . getMyRemoteClient ( ) ; if ( me == null ) return false ; String myPartyId = me . getPartyId ( ) ; for ( ObjectMap . Entry < Integer , RemoteClient > entry : BrainOutClient . ClientController . getRemoteClients ( ) ) { if ( entry . value == me || entry . value == null ) continue ; if ( entry . value . isFriend ( me ) ) return true ; if ( myPartyId != null && myPartyId . equals ( entry . value . getInfoString ( "party" , "" ) ) ) { return true ; } } return false ;
formatNo: static public String formatNo ( int formatLength , int formatNumber ) { String formatedString = "" ; String toUseString = Integer . toString ( formatNumber ) ; int toUseStringLength = toUseString . length ( ) ; if ( toUseStringLength < formatLength ) { String zeroStr = "" ; for ( int i = 0 ; i < formatLength - toUseStringLength ; i ++ ) { zeroStr += "0" ; } formatedString = zeroStr + toUseString ; } else { formatedString = toUseString ; } return formatedString ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { steamOutVClose3ItemStateChanged ( evt ) ;
renderPayload: private void renderPayload ( Table payload ) { if ( MarketFee == - 1 ) { payload . add ( new Label ( L . get ( "MENU_ERROR_TRY_AGAIN" ) , BrainOutClient . Skin , "title-red" ) ) ; return ; } Label priceFor1 = new Label ( pieces == 1 ? L . get ( "MENU_PRICE_FOR_1_PIECE" ) : L . get ( "MENU_PRICE_FOR_N_PIECES" , String . valueOf ( pieces ) ) , BrainOutClient . Skin , "title-yellow" ) ; payload . add ( priceFor1 ) . pad ( 4 ) . expandX ( ) . center ( ) . row ( ) ; { Table item = new Table ( ) ; { Table r1 = new Table ( BrainOutClient . Skin ) ; r1 . setBackground ( "form-default" ) ; if ( marketInventoryRecord . getRecord ( ) . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) marketInventoryRecord . getRecord ( ) . getItem ( ) ) ; if ( ici . getInstrumentData ( ) . getInstrument ( ) . getComponent ( IconComponent . class ) != null ) { ContentImage . RenderImage ( ici . getInstrumentData ( ) . getInstrument ( ) , r1 , 1 ) ; } else { ContentImage . RenderInstrument ( r1 , ici . getInstrumentData ( ) . getInfo ( ) ) ; } } else { ContentImage . RenderImage ( marketInventoryRecord . getRecord ( ) . getItem ( ) . getContent ( ) , r1 , 1 ) ; } item . add ( r1 ) . size ( 192 , 64 ) ; } { Table r2 = new Table ( BrainOutClient . Skin ) ; r2 . setBackground ( "form-default" ) ; TextField num = new TextField ( String . valueOf ( price ) , BrainOutClient . Skin , "edit-empty" ) ; num . setAlignment ( Align . right ) ; Label RU = new Label ( "RU" , BrainOutClient . Skin , "title-small" ) ; setKeyboardFocus ( num ) ; num . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { int a ; try { a = Integer . valueOf ( num . getText ( ) ) ; } catch ( NumberFormatException e ) { a = 0 ; } price = a ; updateFee ( ) ; calculateTotal ( ) ; calculateCreationPrice ( ) ; } } ) ; r2 . add ( num ) . expand ( ) . padRight ( 4 ) . fill ( ) ; r2 . add ( RU ) . padLeft ( 4 ) . padRight ( 8 ) ; item . add ( r2 ) . size ( 192 , 64 ) ; } payload . add ( item ) . expandX ( ) . fillX ( ) . row ( ) ; } if ( min != max ) { LabeledSlider amount_ = new LabeledSlider ( amount , min , max , pieces ) { @ Override protected void onChanged ( int newValue ) { super . onChanged ( newValue ) ; amount = newValue ; updateFee ( ) ; calculateTotal ( ) ; calculateCreationPrice ( ) ; } } ; payload . add ( amount_ ) . expand ( ) . fillX ( ) . pad ( 16 ) . padBottom ( 0 ) . row ( ) ; } { Table total_ = new Table ( ) ; Label t = new Label ( L . get ( "MENU_MARKET_TOTAL" ) , BrainOutClient . Skin , "title-yellow" ) ; total_ . add ( t ) . row ( ) ; total = new Label ( "" , BrainOutClient . Skin , "title-small" ) ; total_ . add ( total ) . row ( ) ; payload . add ( total_ ) . pad ( 16 ) . row ( ) ; } { Label fee = new Label ( L . get ( "MENU_MARKET_FEE" , String . valueOf ( getMarketFee ( ) ) , String . valueOf ( getMarketFeeMinimum ( ) ) ) , BrainOutClient . Skin , "title-red" ) ; payload . add ( fee ) . expandX ( ) . center ( ) . pad ( 16 ) . padTop ( 0 ) . row ( ) ; } calculateTotal ( ) ; updateFee ( ) ;
clearSources: private void clearSources ( ) { for ( DragAndDrop . Source source : sources ) { dropInto . removeSource ( source ) ; } sources . clear ( ) ;
deleteAttribute: public void deleteAttribute ( Identifier productIdentifier , Identifier imageIdentifier , String attributeGroupName ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/products/%s/images/%s/attributes/%s" , productIdentifier , imageIdentifier , attributeGroupName ) , null , null , null ) ;
touchDown: public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { if ( button == Input . Buttons . RIGHT ) { if ( hoveredItem != null ) { CSGame csGame = BrainOutClient . ClientController . getState ( CSGame . class ) ; if ( csGame != null ) { PlayerData playerData = csGame . getPlayerData ( ) ; if ( playerData != null ) { ActiveProgressVisualComponentData progress = playerData . getComponent ( ActiveProgressVisualComponentData . class ) ; if ( progress != null && progress . isActive ( ) ) { return false ; } } } SpriteWithBlocksComponentData spi = hoveredItem . getComponent ( SpriteWithBlocksComponentData . class ) ; if ( spi != null && Map . Get ( hoveredItem . getDimension ( ) , FreePlayMap . class ) != null ) { RealEstateItemContainerComponent rsnic = hoveredItem . getCreator ( ) . getComponent ( RealEstateItemContainerComponent . class ) ; if ( rsnic != null ) { BrainOutClient . getInstance ( ) . topState ( ) . topMenu ( ) . pushMenu ( new RealEstateItemExchangeInventoryMenu ( BrainOutClient . ClientController . getState ( CSGame . class ) . getPlayerData ( ) , hoveredItem ) ) ; } } } } return super . touchDown ( screenX , screenY , pointer , button ) ;
isEnabled: public boolean isEnabled ( ) { return enabled ;
tint: public ScaledTiledDrawable tint ( Color tint ) { ScaledTiledDrawable drawable = new ScaledTiledDrawable ( this ) ; drawable . color . set ( tint ) ; drawable . setLeftWidth ( getLeftWidth ( ) ) ; drawable . setRightWidth ( getRightWidth ( ) ) ; drawable . setTopHeight ( getTopHeight ( ) ) ; drawable . setBottomHeight ( getBottomHeight ( ) ) ; return drawable ;
all: public ApiCollection < ProductVariant > all ( Identifier productIdentifier ) throws ApiErrorException , ConnectionException { Class < ProductVariant > responseModel = ( Class < ProductVariant > ) ( Class < ? > ) ProductVariant . class ; return this . requestCollection ( "get" , this . resolvePath ( "/products/%s/variants" , productIdentifier ) , null , null , responseModel ) ;
isIPLegal: public static boolean isIPLegal ( String ip ) { String regEx = "[\\u4e00-\\u9fa5]" ; Pattern p = Pattern . compile ( regEx ) ; Matcher m = p . matcher ( ip ) ; return m . matches ( ) ;
isRightsValid: public boolean isRightsValid ( Client asker , Client forClient , PlayerRights rights ) { return true ;
requestCollection: protected < T > ApiCollection < T > requestCollection ( String httpMethod , String relativeUrl , Map < String , Object > query , Map < String , Object > headers , Class < T > modelClass ) throws ApiErrorException , ConnectionException { return this . requestCollection ( httpMethod , relativeUrl , query , headers , modelClass , null ) ;
demote: public boolean demote ( ) { if ( rank <= 0 ) return false ; rank -- ; kills = 1 ; return true ;
getArea: public double getArea ( ) { double area = 0.0 ; for ( int i = 0 ; i < vertices . length ; i ++ ) { int next = ( i + 1 ) % vertices . length ; area += ( vertices [ i ] . x * vertices [ next ] . y ) - ( vertices [ i ] . y * vertices [ next ] . x ) ; } return Math . abs ( area / 2.0 ) ;
createIndexRequest: private Request createIndexRequest ( final Map < String , String > document ) { if ( idProvider == null ) {
addProgress: public void addProgress ( int progress ) { uncommittedProgress += progress ;
apply: No method body
received: public boolean received ( final PlayerAimMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { if ( playerController != null ) { playerController . setAim ( msg . aim ) ; } } ) ; return true ;
deleteCustomData: public void deleteCustomData ( String shopKey , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/shops/%s/custom-data" , shopKey ) , query , null , null ) ;
hasBooster: public boolean hasBooster ( String key ) { return this . boosters . containsKey ( key ) ;
getDefines: public ObjectMap < String , String > getDefines ( ) { return defines ;
onResourceReady: public void onResourceReady ( Bitmap resource , GlideAnimation < ? super Bitmap > glideAnimation ) { Drawable drawable ; if ( resource != null ) { drawable = new BitmapDrawable ( context . getResources ( ) , resource ) ; } else { drawable = ContextCompat . getDrawable ( context , placeHolder ) ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) {
setOrganizationId: public void setOrganizationId ( Long organizationId ) { this . organizationId = organizationId ;
setCurrentYear: public void setCurrentYear ( int currentYear ) { mYearPicker . setCurrentNumber ( currentYear ) ;
read: public void read ( Json json , JsonValue jsonData ) { setValue ( jsonData . getInt ( getName ( ) , getValue ( ) ) ) ;
disconnectExternal: public void disconnectExternal ( WayPointMap map ) { toRemove . clear ( ) ; for ( ObjectMap . Entry < Integer , Neighbor > entry : neighbors ) { Neighbor neighbor = entry . value ; if ( ! neighbor . isExternal ( map ) ) continue ; WayPoint wp = neighbor . getWayPoint ( map ) ; if ( wp == null ) continue ; wp . removeNeighbor ( this ) ; toRemove . addLast ( entry . key ) ; } for ( Integer key : toRemove ) { neighbors . remove ( key ) ; } toRemove . clear ( ) ;
apply: public void apply ( PlayerClient playerClient , boolean notify ) { float add = this . amount * multiply ; playerClient . updateEvents ( ( ) ->
init: public void init ( UserProfile userProfile , boolean newbies ) { if ( newbies )
setSoftness: public void setSoftness ( float softness ) { this . softness = softness ;
declareUniform: protected void declareUniform ( ShaderProgram shaderProgram ) { super . declareUniform ( shaderProgram ) ; shaderProgram . setUniformf ( "value" , value ) ;
getApiKey: public String getApiKey ( ) { return apiKey ;
hasRender: public boolean hasRender ( ) { return false ;
configure: public void configure ( ClientDetailsServiceConfigurer clients ) throws Exception { clients . inMemory ( )
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new InstrumentLightComponentData ( ( InstrumentData ) componentObject , this ) ;
getComponent: public ExplosiveComponentData getComponent ( ComponentObject componentObject ) { return new ExplosiveComponentData ( componentObject , this ) ;
data: public MessageBuilder < JRPCMessage > data ( final byte [ ] data ) { this . data = data ; return this ;
getLayout: No method body
onEvent: public boolean onEvent ( Event event ) { return false ;
sync: public void sync ( ) { fp . sync ( ) ; ;
setItem: protected void setItem ( RoomSettings . BooleanOption item ) { if ( item . isDefined ( ) )
v6: public Object v6 ( ) { return list [ 6 ] ; }
hasComponent: public boolean hasComponent ( Class < ? extends ContentComponent > clazz ) { return original . hasComponent ( clazz ) ;
hasRender: public boolean hasRender ( ) { return false ;
goodAtTheBeginning: public void goodAtTheBeginning ( ) { assertTrue ( GoodAtTheBeginning . goodAtTheBeginning ( "good Sweet" ) ) ; assertFalse ( GoodAtTheBeginning . goodAtTheBeginning ( " good Sweet" ) ) ; assertFalse ( GoodAtTheBeginning . goodAtTheBeginning ( "goo" ) ) ;
onNext: public void onNext ( T t ) { try {
write: public void write ( Json json ) { super . write ( json ) ; json . writeArrayStart ( "cards" ) ; for ( CardResult item : cards ) { json . writeValue ( item ) ; } json . writeArrayEnd ( ) ;
subscribe: public void subscribe ( Flow . Subscriber < ? super ByteBuffer > subscriber ) { subscriber . onSubscribe (
getBarBorderColor: public int getBarBorderColor ( ) { return mBarBorderColor ;
hoverOneItem: private void hoverOneItem ( ActiveData activeData ) { clearHoveredItems ( ) ; hoveredItems . add ( activeData ) ;
dismiss: public void dismiss ( ) { super . dismiss ( ) ;
setDebugForClasses: public boolean setDebugForClasses ( Collection < Class > classes ) { debug ( "[setDebugForClasses]" ) ; boolean result = true ; Set < String > classSet = classes . stream ( ) . map ( Class :: getName ) . collect ( Collectors . toSet ( ) ) ; return setDebugForClassNames ( classSet ) ;
getOffsetX: public RandomValue getOffsetX ( ) { return offsetX ;
getTextStyle: public Paint . Style getTextStyle ( ) { return mTextStyle ;
setTextColor: public ViewHolder setTextColor ( int viewId , int color ) { TextView tv = getView ( viewId ) ; tv . setTextColor ( color ) ; return this ;
setTicketId: public void setTicketId ( Long ticketId ) { this . ticketId = ticketId ;
main: public static void main ( String [ ] args ) { new AFKDetector (
calculate: public void calculate ( float dataMin , float dataMax ) { float min = mCustomAxisMin ? mAxisMinimum : ( dataMin - mSpaceMin ) ; float max = mCustomAxisMax ? mAxisMaximum : ( dataMax + mSpaceMax ) ; float range = Math . abs ( max - min ) ; if ( range == 0f ) { max = max + 1f ; min = min - 1f ; } this . mAxisMinimum = min ; this . mAxisMaximum = max ; this . mAxisRange = Math . abs ( max - min ) ;
renderCompletedQuest: private void renderCompletedQuest ( Table data , Quest quest ) { { Label complete = new Label ( L . get ( "MENU_QUEST_COMPLETE" ) , BrainOutClient . Skin , "title-small" ) ; data . add ( complete ) . pad ( 16 ) . row ( ) ; } { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( quest . getTitle ( ) . get ( ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . center ( ) . row ( ) ; data . add ( header ) . width ( 416 ) . row ( ) ; } IconComponent iconComponent = quest . getComponent ( IconComponent . class ) ; if ( iconComponent != null )
onDeath: public void onDeath ( Client killer , PlayerData playerData , InstrumentInfo info ) { super . onDeath ( killer , playerData , info ) ; setEgg ( false ) ;
getLayer: public int getLayer ( ) { return 0 ;
getFrameCount: public int getFrameCount ( ) { return frames . length / getFrameEntries ( ) ;
getContentRect: public RectF getContentRect ( ) { return mContentRect ;
setSetPoint: public void setSetPoint ( float setPoint ) { if ( setPoint > 1.0f ) { rpmSetting = 1.0f ; return ; } else if ( setPoint < 0.0f ) { rpmSetting = 0.0f ; return ; } rpmSetting = setPoint ;
getTransformMode: public TransformMode getTransformMode ( ) { return transformMode ;
popTask: void popTask ( Task task ) { tasks . removeValue ( task , true ) ;
getX: public float getX ( ) { return x ;
getConsumableContainer: public ConsumableContainer getConsumableContainer ( ) { return container ;
getRegionUVs: public float [ ] getRegionUVs ( ) { return regionUVs ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "Exception while deleting payment probe." ) ; LogUtils . e ( TAG , e . getMessage ( ) ) ;
getRendererForShape: public static IShapeRenderer getRendererForShape ( ScatterChart . ScatterShape shape ) { switch ( shape ) { case SQUARE : return new SquareShapeRenderer ( ) ; case CIRCLE : return new CircleShapeRenderer ( ) ; case TRIANGLE : return new TriangleShapeRenderer ( ) ; case CROSS : return new CrossShapeRenderer ( ) ; case X : return new XShapeRenderer ( ) ; case CHEVRON_UP : return new ChevronUpShapeRenderer ( ) ; case CHEVRON_DOWN : return new ChevronDownShapeRenderer ( ) ; } return null ;
transformPage: public void transformPage ( View view , float position ) { if ( position < - 1 ) { view . setRotation ( mMaxRotate * - 1 ) ;
onZeroHealth: protected void onZeroHealth ( DamageEvent e ) { ActiveData playerData = instrumentData . getOwner ( ) ; if ( playerData == null ) return ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; ServerPlayerControllerComponentData pcc = playerData . getComponentWithSubclass ( ServerPlayerControllerComponentData . class ) ; if ( poc != null && pcc != null )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { trip7ActionPerformed ( evt ) ;
getCustomDataForKey: public Map < String , Object > getCustomDataForKey ( Identifier productIdentifier , String key ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "get" , this . resolvePath ( "/products/%s/custom-data/%s" , productIdentifier , key ) , null , null , responseModel ) ;
protocolExceptionErrorMessage: public static Consumer < ? super MessageLite > protocolExceptionErrorMessage ( int code ) { return errorMessage (
updateAttachments: public void updateAttachments ( ) { PlayerAnimationComponentData anim = playerData . getComponent ( PlayerAnimationComponentData . class ) ; if ( anim == null ) return ; ObjectMap < String , String > a = anim . getAttachments ( ) ; tmp . clear ( ) ; tmp . putAll ( a ) ; a . clear ( ) ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : poc . getConsumableContainer ( ) . getData ( ) ) { Content c = entry . value . getItem ( ) . getContent ( ) ; ConsumableItem item = entry . value . getItem ( ) ; if ( item instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) item ) ; if ( ici . getInstrumentData ( ) != playerData . getCurrentInstrument ( ) ) { continue ; } } ReplaceSlotComponent rsc = c . getComponent ( ReplaceSlotComponent . class ) ; if ( rsc != null ) { a . putAll ( rsc . getReplace ( ) ) ; } } } if ( ! tmp . equals ( a ) )
isScaleYEnabled: public boolean isScaleYEnabled ( ) { return mScaleYEnabled ;
createPackage: public ContentPackage createPackage ( String name ) { return new AndroidPackage ( name ) ;
setRemoteAmountAmount: public void setRemoteAmountAmount ( double remoteAmount ) { this . remoteAmount = remoteAmount ; double localAmount = this . getLocalAmount ( ) ; this . totalAmount = localAmount + remoteAmount ;
expire: void expire ( ) { client . getLogger ( ) . debugFinest ( "Conversation timed out after {}ms with {} response(s) [Request: {}] [Expected Response: {}]" , timeout , processedResponses . size ( ) , request . getClass ( ) , expectedResponse ) ; if ( ! parallelResponseHandling ) {
getWaterFlowRate2: public double getWaterFlowRate2 ( ) { return waterMass2 * 20 ;
getInstance: public static Object getInstance ( Class < ? > clazz ) { try {
packagesLoaded: private void packagesLoaded ( InitCallback done ) { done . done ( true ) ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( L . get ( "EDITOR_RESIZE_MAP" ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . expandX ( ) . row ( ) ; data . add ( header ) . expandX ( ) . fillX ( ) . row ( ) ; } Table body = new Table ( BrainOutClient . Skin ) ; body . setBackground ( "form-default" ) ; { Table sizes = new Table ( ) ; Label widthLabel = new Label ( "Width:" , BrainOutClient . Skin , "title-small" ) ; Label heightLabel = new Label ( "Height:" , BrainOutClient . Skin , "title-small" ) ; widthInput = new TextField ( String . valueOf ( map . getBlocks ( ) . getBlockWidth ( ) ) , BrainOutClient . Skin , "edit-default" ) ; heightInput = new TextField ( String . valueOf ( map . getBlocks ( ) . getBlockHeight ( ) ) , BrainOutClient . Skin , "edit-default" ) ; sizes . add ( widthLabel ) . pad ( 8 ) ; sizes . add ( widthInput ) . pad ( 8 ) . row ( ) ; sizes . add ( heightLabel ) . pad ( 8 ) ; sizes . add ( heightInput ) . pad ( 8 ) . row ( ) ; body . add ( sizes ) . row ( ) ; } { Table anchor = new Table ( ) ; ButtonGroup < Button > buttons = new ButtonGroup < > ( ) ; buttons . setMinCheckCount ( 1 ) ; buttons . setMaxCheckCount ( 1 ) ; for ( int j = 1 ; j >= - 1 ; j -- ) { for ( int i = - 1 ; i <= 1 ; i ++ ) { final int _x = i , _y = j ; Button checkBox = new Button ( BrainOutClient . Skin , "button-checkbox" ) ; anchor . add ( checkBox ) . pad ( 2 , - 2 , 2 , - 2 ) ; checkBox . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; anchorX = _x ; anchorY = _y ; } } ) ; buttons . add ( checkBox ) ; if ( i == 0 && j == 0 ) { checkBox . setChecked ( true ) ; } } anchor . row ( ) ; } body . add ( anchor ) . pad ( 16 ) . expandX ( ) . center ( ) . row ( ) ; } { Table buttons = new Table ( ) ; { TextButton resize = new TextButton ( L . get ( "MENU_APPLY" ) , BrainOutClient . Skin , "button-green" ) ; resize . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; doResize ( ) ; } } ) ; buttons . add ( resize ) . size ( 128 , 32 ) . padRight ( 8 ) ; } { TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; canceled ( ) ; } } ) ; buttons . add ( cancel ) . size ( 128 , 32 ) . padLeft ( 8 ) . row ( ) ; } body . add ( buttons ) . expandX ( ) . fillX ( ) . pad ( 8 ) . padTop ( 0 ) . row ( ) ; } data . add ( body ) . expand ( ) . fill ( ) . row ( ) ; return data ;
listenOnlineMessages: private void listenOnlineMessages ( ) { if ( ! BrainOut . OnlineEnabled ( ) ) return ; if ( ! BrainOutServer . Controller . isLobby ( ) && ! BrainOutServer . Controller . isFreePlay ( ) ) return ; if ( messageSession != null ) { if ( messageSession . isOpen ( ) ) { log ( "Already listening for online messages, skipping!" ) ; return ; } } MessageService messageService = MessageService . Get ( ) ; if ( messageService != null && accessToken != null )
shouldNotCopyBackupWithEmptyOptions: public void shouldNotCopyBackupWithEmptyOptions ( ) throws IOException { Set < BackupOption > backupOptions = emptySet ( ) ; File fileToCopy = getTmpFile ( true ) ; boolean result = testObject . copyBackupFile ( backupOptions , fileToCopy ) ; assertFalse ( result ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case physicsContact : { PhysicsContactEvent e = ( ( PhysicsContactEvent ) event ) ; contact ( e ) ; break ; } } return false ;
getCoreData: private ArrayList < List < String > > getCoreData ( ) { ArrayList < List < String > > result = new ArrayList < > ( ) ; try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( ( getClass ( ) . getResourceAsStream ( "/res/coreMap.csv" ) ) ) ) ; ArrayList < String > dataStringArray = new ArrayList < > ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { dataStringArray . add ( line ) ; } for ( int i = 1 ; i < dataStringArray . size ( ) ; i ++ ) { String [ ] dataArray = dataStringArray . get ( i ) . split ( "," ) ; ArrayList < String > data = new ArrayList < > ( Arrays . asList ( dataArray ) ) ; data . remove ( data . size ( ) - 1 ) ; result . add ( data ) ; } if ( result . size ( ) != 56 ) { throw new Exception ( "CorruptedCoreDataException" ) ; } for ( List < String > i : result ) { if ( i . size ( ) != 56 ) { throw new Exception ( "CorruptedCoreDataException" ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return result ;
loadItem: protected JsonValue loadItem ( String path ) { InputStream entryStream ; try { entryStream = readStreamEntry ( path ) ; } catch ( RuntimeException ignored ) { return null ; } if ( entryStream != null ) { try { JsonValue value = READER . parse ( new InputStreamReader ( entryStream ) ) ; postProcess ( value ) ; return value ; } catch ( SerializationException e ) { } } return null ;
activate: private void activate ( Client client , PlayerData playerData ) { if ( ! ( client instanceof PlayerClient ) ) return ; if ( getGenerator ( ) . isEmpty ( ) )
getIcon: public TextureAtlas . AtlasRegion getIcon ( String id , TextureAtlas . AtlasRegion fallback ) { return icons . get ( id , fallback ) ;
setWatcher: private void setWatcher ( ) { for ( Map map : Map . All ( ) )
createdHandle: public void createdHandle ( File file ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "MybatisXmlListener detect file created: {}" , file . getName ( ) ) ; } reloader . updateBean ( file ) ;
isJiraConnected: public boolean isJiraConnected ( Long orgId ) { return StringUtils . isNotEmpty ( integrationService . getOrganizationConfiguration ( orgId ) . getJiraToken ( ) ) ;
read: public void read ( Json json , JsonValue jsonData ) { String id = jsonData . getString ( "id" ) ; Card card = ( ( Card ) BrainOut . ContentMgr . get ( id ) ) ; if ( card != null )
onStarChange: No method body
isContact: public boolean isContact ( ContactPayload payload , float x , float y , Vector2 speed , Vector2 impulse , Vector2 moveForce , float reduce , Map map , int blockX , int blockY ) { return true ;
refillPool: private void refillPool ( float percentage ) { int portionOfCapacity = ( int ) ( desiredCapacity * percentage ) ; if ( portionOfCapacity < 1 ) { portionOfCapacity = 1 ; } else if ( portionOfCapacity > desiredCapacity ) { portionOfCapacity = desiredCapacity ; } for ( int i = 0 ; i < portionOfCapacity ; i ++ ) { this . objects [ i ] = modelObject . instantiate ( ) ; } objectsPointer = portionOfCapacity - 1 ;
getConsole: public Console getConsole ( ) { return console ;
notNull: default void notNull ( Object o ) { Assert . notNull ( o ) ;
createConfigurationsForOrganizationUser: public boolean createConfigurationsForOrganizationUser ( UserRoleDto ur ) { debug ( "[createConfigurationsForOrganizationUser] user role: {}" , ur ) ; if ( ur . isGlobal ( ) ) return true ; return true ;
release: public void release ( ) { super . release ( ) ; activeQuests . clear ( ) ; disposeNoise ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . freePlaySummary , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . activeAction , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . simple , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . gameController , this ) ;
getRewardsCount: public int getRewardsCount ( ) { return rewards . size ;
deleteMsTeamsConfig: public Object deleteMsTeamsConfig ( @ PathVariable ( ORGANIZATIONID ) Long orgId ) { debug ( "[deleteMsTeamsConfig] OrgId: {}" , orgId ) ; integrationService . cleanOrgConfig ( _MSTEAMS , orgId ) ; String configUrl = services . url . moduleSettings ( INTEGRATION , null , orgId ) ; return "generic-forms::go-to(url='" + configUrl + "')" ;
getDropAtOnce: public int getDropAtOnce ( ) { return dropAtOnce ;
contributeFunctions: public void contributeFunctions ( FunctionContributions functionContributions ) { functionContributions . getFunctionRegistry ( ) . register ( "string_agg" , new StandardSQLFunction ( "string_agg" , StandardBasicTypes . STRING ) ) ; functionContributions . getFunctionRegistry ( ) . register ( "arrays_suffix" , new ArraysSuffixFunction ( ) ) ; functionContributions . getFunctionRegistry ( ) . register ( "arrays_overlap" , new StringArraysOverlapFunction ( ) ) ;
audiences: public AudienceService audiences ( ) { AudienceService service = this . getService ( "com.scayle.adminapi.service.AudienceService" ) ; return service ;
deleteMenuByRoleId: No method body
allProperties: public ApiCollection < ShopCategoryProperty > allProperties ( String shopKey , String countryCode , Integer shopCategoryId , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ShopCategoryProperty > responseModel = ( Class < ShopCategoryProperty > ) ( Class < ? > ) ShopCategoryProperty . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries/%s/categories/%s/properties" , shopKey , countryCode , shopCategoryId ) , query , null , responseModel ) ;
hasRender: public boolean hasRender ( ) { return true ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOutClient . ClientSett . getSoundVolume ( ) . setValue ( soundVolume ) ; BrainOutClient . MusicMng . playMusic ( "music-lobby" , true ) ;
d: public static void d ( String tag , boolean msg ) { if ( Constants . isShowLog ) {
createFileFromStream: public File createFileFromStream ( InputStream inputStream , long totalFileSize , String fileName ) { try {
setFirstLogin: public void setFirstLogin ( String firstLogin ) { this . firstLogin = firstLogin ;
getBadgeId: public String getBadgeId ( ) { return "battle-pass-tasks-weekly" ;
isTaskComplete: public boolean isTaskComplete ( UserProfile profile , Task task , int target ) { return profile . getStats ( ) . get ( task . getId ( ) , 0.0f ) >= target ;
toString: public String toString ( ) { return name ;
send: No method body
flatMap: public final < U > Promise < U > flatMap ( @ NotNull PromiseProvider < T , U > provider ) { return PromiseUtils . flatMap ( this , provider ) ;
isDone: public final boolean isDone ( ) { return this . state != State . Incomplete ;
checkGlobalNotificationNotPushedToMsTeams: public void checkGlobalNotificationNotPushedToMsTeams ( ) { NotificationDto notificationDto = new NotificationDto ( "message" , Notification . NotificationType . SUCCESS , null ) ; pushNotificationService . createMsTeamsPostMessageRequest ( notificationDto ) ; verify ( integrationService , never ( ) ) . getOrganizationConfiguration ( anyLong ( ) ) ;
greet: public String greet ( ) { return greet ;
hasLocalizedName: public boolean hasLocalizedName ( ) { return true ;
update: public void update ( ) { double flow1 = 0 , flow2 = 0 ; if ( state != 1 ) { switch ( state ) { case 0 : { if ( position == 0.0 ) { break ; } position -= speed ; if ( position < 0.0 ) { position = 0.0f ; } break ; } case 2 : { if ( position == 1.0 ) { break ; } position += speed ; if ( position > 1.0 ) { position = 1.0f ; } break ; } } } else { switch ( autoState ) { case 0 : { if ( position == 0.0 ) { break ; } position -= speed ; if ( position < 0.0 ) { position = 0.0f ; } break ; } case 2 : { if ( position == 1.0 ) { break ; } position += speed ; if ( position > 1.0 ) { position = 1.0f ; } break ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { double flow = mcc . mcp . get ( i ) . getFlowRate ( ) ; if ( flow > flow1 ) { flow1 = flow ; } } for ( int i = 4 ; i < 8 ; i ++ ) { double flow = mcc . mcp . get ( i ) . getFlowRate ( ) ; if ( flow > flow2 ) { flow2 = flow ; } } timestepFlow = ( flow1 + flow2 ) / 2 / 1750 * 5.55 * position ; source . updateWaterOutflow ( timestepFlow , source . getWaterTemperature ( ) ) ; drain . updateWaterInflow ( timestepFlow , source . getWaterTemperature ( ) ) ;
testDeleteCustomData: public void testDeleteCustomData ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shops ( ) . deleteCustomData ( "acme" , options ) ;
setValueTextSize: public void setValueTextSize ( float size ) { for ( IDataSet set : mDataSets ) {
getButtonHeight: protected float getButtonHeight ( ) { return 32 ;
setY: public void setY ( float y ) { this . y = y ;
generateInstrumentActionMessage: public OtherPlayerInstrumentActionMsg generateInstrumentActionMessage ( InstrumentData weaponData , Instrument . Action action ) { SimplePhysicsComponentData cmp = playerData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( cmp == null ) return null ; PlayerComponentData pcd = playerData . getComponent ( PlayerComponentData . class ) ; Vector2 speed = cmp . getSpeed ( ) ; if ( weaponData == null ) return null ; return new OtherPlayerInstrumentActionMsg (
getFirstLogin: public String getFirstLogin ( Context context ) { firstLogin = PreferencesUtils . getFirstLoginFromLocal ( context ) ; return firstLogin ;
MenuToMenuDtoList: No method body
asmStoreStartTime: protected int asmStoreStartTime ( MethodVisitor mv ) { mv . visitMethodInsn ( INVOKESTATIC , "java/lang/System" , "currentTimeMillis" , "()J" , false ) ; int startTimeVarIndex = newLocal ( Type . LONG_TYPE ) ; mv . visitVarInsn ( LSTORE , startTimeVarIndex ) ; return startTimeVarIndex ;
onItemClick: public void onItemClick ( View view ) { switch ( view . getId ( ) ) {
getSteamVolume: public double getSteamVolume ( ) { return steamVolume ;
stopConnect: public void stopConnect ( ) { isManualClose = true ; if ( mHeartTimer != null ) { mHeartTimer . cancel ( ) ; mHeartTimer = null ; } disconnect ( ) ;
setValue: public void setValue ( int value ) { if ( callChangeListener ( value ) ) {
escape: public boolean escape ( ) { pushMenu ( new ExitMenu ( ) ) ; return true ;
makeWaitingDialog: private AlertDialog makeWaitingDialog ( Activity activity ) { String key = activity . getClass ( ) . getSimpleName ( ) ; AlertDialog dialog = mDialogMap . get ( key ) ; if ( dialog == null ) { dialog = new AlertDialog . Builder ( activity , R . style . dialog_translucent_theme ) . setContentView ( R . layout . layout_dialog_loading ) . setCanceledOnTouchOutside ( false ) . setOnDismissListener ( new MyDismissCallback ( key ) ) . create ( ) ; mDialogMap . put ( key , dialog ) ; } dialog . setCancelable ( mCancelable ) ; return dialog ;
isColorPicker: public boolean isColorPicker ( Form form ) { return getFieldType ( form ) == color_picker ; }
apply: public void apply ( Skeleton skeleton , float lastTime , float time , @ Null Array < Event > events , float alpha , MixBlend blend , MixDirection direction ) { TransformConstraint constraint = skeleton . transformConstraints . get ( transformConstraintIndex ) ; if ( ! constraint . active ) return ; float [ ] frames = this . frames ; if ( time < frames [ 0 ] ) { TransformConstraintData data = constraint . data ; switch ( blend ) { case setup : constraint . mixRotate = data . mixRotate ; constraint . mixX = data . mixX ; constraint . mixY = data . mixY ; constraint . mixScaleX = data . mixScaleX ; constraint . mixScaleY = data . mixScaleY ; constraint . mixShearY = data . mixShearY ; return ; case first : constraint . mixRotate += ( data . mixRotate - constraint . mixRotate ) * alpha ; constraint . mixX += ( data . mixX - constraint . mixX ) * alpha ; constraint . mixY += ( data . mixY - constraint . mixY ) * alpha ; constraint . mixScaleX += ( data . mixScaleX - constraint . mixScaleX ) * alpha ; constraint . mixScaleY += ( data . mixScaleY - constraint . mixScaleY ) * alpha ; constraint . mixShearY += ( data . mixShearY - constraint . mixShearY ) * alpha ; } return ; } float rotate , x , y , scaleX , scaleY , shearY ; int i = search ( frames , time , ENTRIES ) , curveType = ( int ) curves [ i / ENTRIES ] ; switch ( curveType ) { case LINEAR : float before = frames [ i ] ; rotate = frames [ i + ROTATE ] ; x = frames [ i + X ] ; y = frames [ i + Y ] ; scaleX = frames [ i + SCALEX ] ; scaleY = frames [ i + SCALEY ] ; shearY = frames [ i + SHEARY ] ; float t = ( time - before ) / ( frames [ i + ENTRIES ] - before ) ; rotate += ( frames [ i + ENTRIES + ROTATE ] - rotate ) * t ; x += ( frames [ i + ENTRIES + X ] - x ) * t ; y += ( frames [ i + ENTRIES + Y ] - y ) * t ; scaleX += ( frames [ i + ENTRIES + SCALEX ] - scaleX ) * t ; scaleY += ( frames [ i + ENTRIES + SCALEY ] - scaleY ) * t ; shearY += ( frames [ i + ENTRIES + SHEARY ] - shearY ) * t ; break ; case STEPPED : rotate = frames [ i + ROTATE ] ; x = frames [ i + X ] ; y = frames [ i + Y ] ; scaleX = frames [ i + SCALEX ] ; scaleY = frames [ i + SCALEY ] ; shearY = frames [ i + SHEARY ] ; break ; default : rotate = getBezierValue ( time , i , ROTATE , curveType - BEZIER ) ; x = getBezierValue ( time , i , X , curveType + BEZIER_SIZE - BEZIER ) ; y = getBezierValue ( time , i , Y , curveType + BEZIER_SIZE * 2 - BEZIER ) ; scaleX = getBezierValue ( time , i , SCALEX , curveType + BEZIER_SIZE * 3 - BEZIER ) ; scaleY = getBezierValue ( time , i , SCALEY , curveType + BEZIER_SIZE * 4 - BEZIER ) ; shearY = getBezierValue ( time , i , SHEARY , curveType + BEZIER_SIZE * 5 - BEZIER ) ; } if ( blend == setup ) {
greet: No method body
getThermalPower: public double getThermalPower ( ) { return thermalPower ;
isFree: public boolean isFree ( ) { return Shop . getInstance ( ) == null || Shop . getInstance ( ) . isFree ( this ) ;
data: No method body
onAnimationUpdate: public void onAnimationUpdate ( ValueAnimator animation ) { scrollToPosition ( 0 ) ; float currentTopMargin = ( float ) animation . getAnimatedValue ( ) ; mCurrentRefreshStatus = REFRESH_STATUS_PULL_DOWN_REFRESH ; setRefreshViewMarginTop ( ( int ) currentTopMargin ) ; if ( currentTopMargin >= 0 ) {
getAngle: public float getAngle ( ) { return 0 ;
appendStringArrayList: private void appendStringArrayList ( SqlAppender sqlAppender , QueryLiteral arg2 ) { sqlAppender . appendSql ( getAsCommaSeparatedAndSingleQuotedString ( ( ArrayList < String > ) arg2 . getLiteralValue ( ) ) ) ; sqlAppender . appendSql ( "]" ) ; sqlAppender . appendSql ( "::varchar[] && " ) ;
readTask: protected void readTask ( JsonValue jsonData ) { name = new LocalizedString ( jsonData . getString ( "name" ) ) ; location = new LocalizedString ( jsonData . getString ( "location" ) ) ; relatedItems = new Array < > ( ) ; if ( jsonData . has ( "related-items" ) )
installPlugin: public void installPlugin ( Plugin plugin ) { plugins . add ( plugin ) ;
dispatchTouchEvent: public boolean dispatchTouchEvent ( MotionEvent ev ) { if ( isSwipeEnable ) { acquireVelocityTracker ( ev ) ; final VelocityTracker verTracker = mVelocityTracker ; switch ( ev . getAction ( ) ) { case MotionEvent . ACTION_DOWN : isUserSwiped = false ; isUnMoved = true ; iosInterceptFlag = false ; if ( isTouching ) { return false ; } else { isTouching = true ; } mLastP . set ( ev . getRawX ( ) , ev . getRawY ( ) ) ; mFirstP . set ( ev . getRawX ( ) , ev . getRawY ( ) ) ; if ( mViewCache != null ) { if ( mViewCache != this ) { mViewCache . smoothClose ( ) ; iosInterceptFlag = isIos ; } getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mPointerId = ev . getPointerId ( 0 ) ; break ; case MotionEvent . ACTION_MOVE : if ( iosInterceptFlag ) { break ; } float gap = mLastP . x - ev . getRawX ( ) ; if ( Math . abs ( gap ) > 10 || Math . abs ( getScrollX ( ) ) > 10 ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } if ( Math . abs ( gap ) > mScaleTouchSlop ) { isUnMoved = false ; } scrollBy ( ( int ) ( gap ) , 0 ) ; if ( isLeftSwipe ) { if ( getScrollX ( ) < 0 ) { scrollTo ( 0 , 0 ) ; } if ( getScrollX ( ) > mRightMenuWidths ) { scrollTo ( mRightMenuWidths , 0 ) ; } } else { if ( getScrollX ( ) < - mRightMenuWidths ) { scrollTo ( - mRightMenuWidths , 0 ) ; } if ( getScrollX ( ) > 0 ) { scrollTo ( 0 , 0 ) ; } } mLastP . set ( ev . getRawX ( ) , ev . getRawY ( ) ) ; break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : if ( Math . abs ( ev . getRawX ( ) - mFirstP . x ) > mScaleTouchSlop ) { isUserSwiped = true ; } if ( ! iosInterceptFlag ) { verTracker . computeCurrentVelocity ( 1000 , mMaxVelocity ) ; final float velocityX = verTracker . getXVelocity ( mPointerId ) ; if ( Math . abs ( velocityX ) > 1000 ) { if ( velocityX < - 1000 ) { if ( isLeftSwipe ) { smoothExpand ( ) ; } else { smoothClose ( ) ; } } else { if ( isLeftSwipe ) { smoothClose ( ) ; } else { smoothExpand ( ) ; } } } else { if ( Math . abs ( getScrollX ( ) ) > mLimit ) { smoothExpand ( ) ; } else { smoothClose ( ) ; } } } releaseVelocityTracker ( ) ; isTouching = false ; break ; default : break ; } } return super . dispatchTouchEvent ( ev ) ;
update: public void update ( float dt ) { closeSync -= dt ; if ( closeSync <= 0 ) { closeSync = 0.25f ; trigger ( true ) ; } if ( farSync <= 0 )
isDrawCircleHoleEnabled: No method body
createUI: public Table createUI ( ) { data = new Table ( ) ; leftPanel = new Table ( ) ; leftPanel . align ( Align . top ) ; content = new Table ( ) ; content . align ( Align . top ) ; data . add ( ) . height ( 96 ) . colspan ( 2 ) . row ( ) ; data . add ( leftPanel ) . width ( 256 ) . expandY ( ) . fill ( ) . padLeft ( 16 ) . padRight ( 8 ) ; data . add ( content ) . expand ( ) . fill ( ) . padRight ( 16 ) . row ( ) ; renderLeftPanel ( ) ; renderContents ( ) ; data . add ( ) . height ( 16 ) . colspan ( 2 ) . row ( ) ; addListener ( new ClickListener ( ) { @ Override public boolean mouseMoved ( InputEvent event , float x , float y ) { if ( ordersPane == null ) return super . mouseMoved ( event , x , y ) ; updateHoveredRow ( ) ; return super . mouseMoved ( event , x , y ) ; } } ) ; addListener ( new InputListener ( ) { @ Override public boolean keyDown ( InputEvent event , int keycode ) { if ( keycode == Input . Keys . SHIFT_LEFT ) if ( hoveredBuyButton != null ) hoveredBuyButton . setCancelState ( ) ; return super . keyDown ( event , keycode ) ; } @ Override public boolean keyUp ( InputEvent event , int keycode ) { if ( keycode == Input . Keys . SHIFT_LEFT ) if ( hoveredBuyButton != null ) hoveredBuyButton . setBuyState ( ) ; return super . keyUp ( event , keycode ) ; } } ) ; return data ;
registerSpendNtfn: public Observable < chainrpc . Chainnotifier . SpendEvent > registerSpendNtfn ( chainrpc . Chainnotifier . SpendRequest request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . registerSpendNtfn ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
keyUp: public boolean keyUp ( int keycode ) { return keyReleased ( keycode ) ;
show: public void show ( final View view ) { if ( mBasePopWindow == null ) {
run: public void run ( ) { wsStatusListener . onOpen ( response ) ;
calcMinMax: public void calcMinMax ( ) { mYMax = - Float . MAX_VALUE ; mYMin = Float . MAX_VALUE ; mXMax = - Float . MAX_VALUE ; mXMin = Float . MAX_VALUE ; if ( mEntries == null || mEntries . isEmpty ( ) ) return ; for ( T e : mEntries ) {
showStepFailed: private void showStepFailed ( String message ) { TextView fromNodeAddress3Tv = mAlertDialog . findViewById ( R . id . tv_from_node_address_3 ) ; TextView toNodeAddress3Tv = mAlertDialog . findViewById ( R . id . tv_to_node_address_3 ) ; ImageView amountLogo2Tv = mAlertDialog . findViewById ( R . id . iv_amount_logo_2 ) ; TextView amountUnitTv = mAlertDialog . findViewById ( R . id . tv_amount_unit ) ; TextView amountPay2Tv = mAlertDialog . findViewById ( R . id . tv_amount_pay_2 ) ; TextView amountUnit1Tv = mAlertDialog . findViewById ( R . id . tv_amount_unit_1 ) ; TextView payTimeTv = mAlertDialog . findViewById ( R . id . tv_pay_time ) ; TextView payTimeUnitTv = mAlertDialog . findViewById ( R . id . tv_pay_time_unit ) ; TextView failedMessageTv = mAlertDialog . findViewById ( R . id . tv_failed_message ) ; if ( mAssetId == 0 ) { amountLogo2Tv . setImageResource ( R . mipmap . icon_btc_logo_small ) ; amountUnitTv . setText ( "BTC" ) ; amountUnit1Tv . setText ( "BTC" ) ; } else { amountLogo2Tv . setImageResource ( R . mipmap . icon_usdt_logo_small ) ; amountUnitTv . setText ( "dollar" ) ; amountUnit1Tv . setText ( "dollar" ) ; } toNodeAddress3Tv . setText ( toNodeAddress ) ; DecimalFormat df = new DecimalFormat ( "0.00######" ) ; if ( mAssetId == 0 ) { amountPay2Tv . setText ( df . format ( Double . parseDouble ( String . valueOf ( payAmount / 1000 ) ) / 100000000 ) ) ; } else { amountPay2Tv . setText ( df . format ( Double . parseDouble ( String . valueOf ( payAmount ) ) / 100000000 ) ) ; } failedMessageTv . setText ( message ) ; fromNodeAddress3Tv . setText ( mAddress ) ; RelativeLayout shareLayout = mAlertDialog . findViewById ( R . id . layout_share ) ; mAlertDialog . findViewById ( R . id . layout_parent ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { shareLayout . setVisibility ( View . GONE ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_back_to_two ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_two ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . lv_pay_invoice_step_failed ) . setVisibility ( View . GONE ) ; mAlertDialog . findViewById ( R . id . layout_cancel ) . setVisibility ( View . VISIBLE ) ; mAlertDialog . findViewById ( R . id . layout_close ) . setVisibility ( View . GONE ) ; } } ) ; mAlertDialog . findViewById ( R . id . layout_share_to ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { System . out . println ( shareLayout . toString ( ) ) ; shareLayout . setVisibility ( View . VISIBLE ) ; } } ) ; mAlertDialog . findViewById ( R . id . iv_facebook_share ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ToastUtils . showToast ( mContext , "Not yet open, please wait" ) ; shareLayout . setVisibility ( View . GONE ) ; } } ) ; mAlertDialog . findViewById ( R . id . iv_twitter_share ) . setOnClickListener ( new View . OnClickListener ( ) {
getContent: public String getContent ( DynamicPrivilege entity ) { return null ;
renderLightsPanel: private void renderLightsPanel ( Table panel ) { {
renderInstrument: protected void renderInstrument ( Table renderTo , Instrument instrument , Skin skin , CardData cardData ) { Shader blackShader = ( ( Shader ) BrainOut . ContentMgr . get ( "shader-black" ) ) ; InstrumentInfo info = new InstrumentInfo ( ) ; info . instrument = instrument ; info . skin = skin ; float scale ; InstrumentAnimationComponent iac = instrument . getComponentFrom ( InstrumentAnimationComponent . class ) ; if ( iac != null ) { scale = iac . getIconScale ( ) ; } else { scale = 1.0f ; } InstrumentIcon instrumentIcon = new InstrumentIcon ( info , 2.0f * scale , true ) ; instrumentIcon . setBounds ( 0 , 0 , 192 , 64 ) ; instrumentIcon . init ( ) ; ShaderedActor sh = new ShaderedActor ( instrumentIcon , blackShader ) ; WidgetGroup root = new WidgetGroup ( ) ; root . addActor ( sh ) ; InstrumentIcon orig = new InstrumentIcon ( info , 2.0f * scale , true ) ; orig . setBounds ( 0 , 4 , 192 , 64 ) ; orig . init ( ) ; root . addActor ( orig ) ; renderTo . add ( root ) . size ( 196 , 68 ) . expand ( ) . row ( ) ;
listUnspent: public Single < walletrpc . Walletkit . ListUnspentResponse > listUnspent ( walletrpc . Walletkit . ListUnspentRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . listUnspent ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
requiresAckFlag: void requiresAckFlag ( ) { assertThat (
setDeaths: public void setDeaths ( int deaths ) { this . deaths = deaths ;
directionKeyReleased: private void directionKeyReleased ( KeyDirections keyDirections ) { this . keyPressed [ keyDirections . ordinal ( ) ] = false ; updateMoves ( ) ;
setOAuthAuthentication: public static final void setOAuthAuthentication ( ) { Set < String > globalPrivileges = Stream . of ( _readUserData , _manageUserRoles ) . collect ( Collectors . toSet ( ) ) ; UserDetails userDetails = new OrganizationUser ( "_oauth_" , "" , true , true , true , true , Collections . EMPTY_LIST , globalPrivileges , Collections . EMPTY_SET , Collections . EMPTY_MAP , Collections . EMPTY_MAP , null , Collections . EMPTY_MAP ) ; Authentication a = new PreAuthenticatedAuthenticationToken ( userDetails , "N/A" , userDetails . getAuthorities ( ) ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( a ) ;
received: public boolean received ( ClientDisconnect msg ) { setDisconnectReason ( msg . reason ) ; return true ;
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; LoginService loginService = LoginService . Get ( ) ; if ( loginService == null ) throw new RuntimeException ( "No login service!" ) ; RoomSettings partyRoom = new RoomSettings ( ) ; partyRoom . init ( BrainOutClient . ClientController . getUserProfile ( ) , false ) ; partyRoom . setParty ( BrainOutClient . ClientController . getMyAccount ( ) ) ; close ( ) ; BrainOutClient . ClientController . setState ( new CSQuickPlay (
writeWithTries: public static void writeWithTries ( int maxTries ) { int count = 0 ; while ( true ) {
hasRender: public boolean hasRender ( ) { return true ;
getSteamDensity: public double getSteamDensity ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
write: public void write ( JSONObject o ) { o . put ( "c" , instrument . instrument . getID ( ) ) ; ObjectMap < String , Upgrade > u = instrument . upgrades ; if ( u . size > 0 ) { JSONObject upgrades = new JSONObject ( ) ; for ( ObjectMap . Entry < String , Upgrade > entry : u ) { upgrades . put ( entry . key , entry . value . getID ( ) ) ; } o . put ( "u" , upgrades ) ; } Skin skin = instrument . skin ; if ( skin != instrument . instrument . getDefaultSkin ( ) ) { o . put ( "s" , skin . getID ( ) ) ; } if ( rounds != 0 ) { o . put ( "r" , rounds ) ; } if ( chambered != 0 ) { o . put ( "ch" , chambered ) ; } if ( magazines != null )
getOutputAsync: default CompletableFuture < Output < Res > > getOutputAsync ( ) { return getOutputAsync ( RequestOptions . DEFAULT ) ;
onClick: public void onClick ( View v ) { mLoadingDialog . show ( ) ; if ( route != null ) {
setUp: protected void setUp ( ) { mockWebServer = new MockWebServer ( ) ; NovuConfig novuConfig = new NovuConfig ( "1234" ) ; novuConfig . setBaseUrl ( mockWebServer . url ( "" ) . toString ( ) ) ; RestHandler restHandler = new RestHandler ( novuConfig ) ; executiveDetailsHandler = new ExecutiveDetailsHandler ( restHandler ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcStop1ItemStateChanged ( evt ) ;
all: public ApiCollection < ProductVariantPrice > all ( Identifier variantIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < ProductVariantPrice > responseModel = ( Class < ProductVariantPrice > ) ( Class < ? > ) ProductVariantPrice . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/variants/%s/prices" , variantIdentifier ) , query , null , responseModel ) ;
setLevel: public void setLevel ( int level ) { this . level = level ;
getColor: public Color getColor ( ) { return color ;
appendRequestId: default String appendRequestId ( String message ) { return appendRequestId ( message , false ) ;
createWorkflowGroup: public WorkflowGroupResponse createWorkflowGroup ( final WorkflowGroupRequest request ) throws IOException , NovuNetworkException { try {
createCSV: public com . openkoda . model . file . File createCSV ( String filename , List < List < Object > > data , String ... headers ) throws IOException , SQLException { debug ( "[createCSV]" ) ; com . openkoda . model . file . File csvFile = new com . openkoda . model . file . File ( StringUtils . endsWith ( filename , ".csv" ) ? filename : filename + ".csv" , "text/csv" , FileService . StorageType . database ) ; byte [ ] csvByte = createCSVByte ( data , headers ) ; csvFile . setContent ( new SerialBlob ( csvByte ) ) ; csvFile . setSize ( csvByte . length ) ; return csvFile ;
a: public final StickerFormatType a ( int i ) { StickerFormatType stickerFormatType ; StickerFormatType [ ] values = StickerFormatType . values ( ) ; int i2 = 0 ; while ( true ) { if ( i2 >= 4 ) { stickerFormatType = null ; break ; } stickerFormatType = values [ i2 ] ; if ( stickerFormatType . getApiValue ( ) == i ) { break ; } i2 ++ ; } return stickerFormatType != null ? stickerFormatType : StickerFormatType . UNKNOWN ;
formatMinutesInterval: public static String formatMinutesInterval ( final long l ) { final long min = TimeUnit . MILLISECONDS . toMinutes ( l ) ; final long sec = TimeUnit . MILLISECONDS . toSeconds ( l - TimeUnit . MINUTES . toMillis ( min ) ) ; return String . format ( "%02d:%02d" , min , sec ) ;
read: public void read ( ) { preferences = Gdx . app . getPreferences ( Constants . Files . USER_PROFILE_NAME + '-' + BrainOut . Env . getUniqueId ( ) ) ; clear ( ) ; final int profileVersion = preferences . getInteger ( "version" , - 1 ) ; UserLoader loader = processors . get ( profileVersion ) ; if ( loader != null )
setStretch: public void setStretch ( boolean stretch ) { this . stretch = stretch ;
obtain: protected static < T extends Event > T obtain ( Class < T > classOf ) { Pool < T > pool = Pools . get ( classOf , 65535 ) ; if ( pool == null ) return null ; try
copy: protected void copy ( ScatterDataSet scatterDataSet ) { super . copy ( scatterDataSet ) ; scatterDataSet . mShapeSize = mShapeSize ; scatterDataSet . mShapeRenderer = mShapeRenderer ; scatterDataSet . mScatterShapeHoleRadius = mScatterShapeHoleRadius ; scatterDataSet . mScatterShapeHoleColor = mScatterShapeHoleColor ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { trip4ActionPerformed ( evt ) ;
getRoleById: void getRoleById ( ) throws Exception { Long userId = 1L ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . get ( "/role/get/" + userId ) . contentType ( MediaType . APPLICATION_JSON ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "根据用户 id 获取角色信息接口测试成功！" ) ;
findMax: private int findMax ( int [ ] array ) { int max = array [ 0 ] ; for ( int value : array ) { if ( value > max ) { max = value ; } } return max ;
detect: private void detect ( ) { if ( detected ) return ; detected = true ; BrainOut . EventMgr . sendDelayedEvent ( activeData ,
success: public void success ( JSONObject response ) { GameState gs = getGameState ( ) ; if ( gs == null ) return ; loadingMenu . pop ( ) ; pop ( ) ; String clanId = response . optString ( "clan_id" ) ; if ( clanId != null )
isGameActive: public boolean isGameActive ( ) { return getMode ( ) . isGameActive ( ) ;
existsByName: No method body
setHideBottomControls: public void setHideBottomControls ( boolean hide ) { options . putBoolean ( EXTRA_HIDE_BOTTOM_CONTROLS , hide ) ;
getMinScaleY: public float getMinScaleY ( ) { return mMinScaleY ;
createFormFieldDefinition: public static FrontendMappingFieldDefinition createFormFieldDefinition ( String formName , String name , String datalistId , FieldType type , String additionalCss , PrivilegeBase readPrivilege , PrivilegeBase writePrivilege ) { return new FrontendMappingFieldDefinition ( formName , name , type , null , null , readPrivilege , writePrivilege , null , null , false , null , datalistId , additionalCss , false , null , null , null , null , null , null , null , null , null , null , false , false ) ;
started: public void started ( ConfigurableApplicationContext context ) { if ( ! canInvoke ( ) ) { return ; } logger . info ( "{} Started with context {}." , getClass ( ) . getSimpleName ( ) , context . getId ( ) ) ; try {
getUniqueId: public String getUniqueId ( ) { String name = System . getenv ( "DESKTOP_PROFILE_NAME" ) ; if ( name != null ) return name ; return "desktop" ;
forceBottomLine: protected boolean forceBottomLine ( ) { return true ;
setTag: public void setTag ( Class < ? > tag ) { this . mTag = tag ;
getInstance: public static NodeStart getInstance ( ) { if ( mInstance == null ) { synchronized ( WalletState . class ) { if ( mInstance == null ) { mInstance = new NodeStart ( ) ; } } } return mInstance ;
createUI: public Table createUI ( ) { Table data = super . createUI ( ) ; this . content = new Table ( ) ; final TextField filerField = new TextField ( "" , BrainOutClient . Skin , "edit-default" ) ; filerField . setTextFieldListener ( new TextField . TextFieldListener ( ) { @ Override public void keyTyped ( TextField textField , char c ) { filter = filerField . getText ( ) . toLowerCase ( ) ; updateContent ( ) ; } } ) ; setKeyboardFocus ( filerField ) ; data . add ( filerField ) . pad ( 20 ) . expandX ( ) . fillX ( ) . row ( ) ; ScrollPane contentPane = new ScrollPane ( content ) ; contentPane . setFadeScrollBars ( false ) ; updateContent ( ) ; setScrollFocus ( contentPane ) ; data . add ( contentPane ) . pad ( 20 ) . minWidth ( 320 ) . minHeight ( 320 ) . row ( ) ; Table buttons = new Table ( ) ; data . add ( buttons ) . expandX ( ) . row ( ) ; TextButton cancel = new TextButton ( L . get ( "MENU_CANCEL" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { onSelect . cancelled ( ) ; close ( ) ; } } ) ; buttons . add ( cancel ) . width ( 128 ) . pad ( 20 ) . padTop ( 0 ) ; return data ;
setLocked: public void setLocked ( boolean locked ) { this . locked = locked ;
getIcon: public TextureAtlas . AtlasRegion getIcon ( ) { return getIcon ( DEFAULT_ICON ) ;
getAngle: public float getAngle ( ) { return launchData . getAngle ( ) + angleOffset ;
updateWaterInflow: public void updateWaterInflow ( double flow , double tempC ) { throw new UnsupportedOperationException ( "Unimplemented method 'updateWaterInFlow'" ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case freePlayPartnerRevived : { FreePlayPartnerRevivedEvent ev = ( ( FreePlayPartnerRevivedEvent ) event ) ; ServerTask . Trigger ( this , ev . player , 1 ) ; } } return false ;
setLanguage: public void setLanguage ( String language ) { this . language = language ; }
getX: public int getX ( ) { return idX * Constants . Physics . PHYSIC_BLOCK_SIZE ;
init: public void init ( ) { super . init ( ) ; updateSkin ( ) ;
getRequestSessionMetadata: public < T > RequestSessionContextMetadata < T > getRequestSessionMetadata ( ) { RequestAttributes attributes = RequestContextHolder . getRequestAttributes ( ) ; if ( attributes != null ) {
getTimeScale: public float getTimeScale ( ) { return timeScale ;
loadJavaScript: public void loadJavaScript ( String methodName , String ... params ) { loadJavaScript ( methodName , new ValueCallback < String > ( ) {
createEventListenerEntry: public EventListenerEntry createEventListenerEntry ( String eventClassName , String eventName , String eventObjectType , String consumerClassName , String consumerMethodName ) { EventListenerEntry eventListenerEntry = new EventListenerEntry ( eventClassName , eventName , eventObjectType , consumerClassName , consumerMethodName ) ; return repositories . unsecure . eventListener . save ( eventListenerEntry ) ;
getAll: void getAll ( ) throws JsonProcessingException { List < MenuDto > menuDtoList = menuService . getAll ( ) ; assertNotNull ( menuDtoList ) ; log . info ( "获取所有菜单树方法测试成功:{}" , objectMapper . writeValueAsString ( menuDtoList ) ) ;
replaceAll: public void replaceAll ( BiFunction < ? super K , ? super V , ? extends V > function ) { throw new UnsupportedOperationException ( ) ; }
update: public void update ( ) { double [ ] forcedInflowData = NPPMath . mixWater ( waterMass , waterTemperature , waterInflow , waterInflowTemperature ) ; waterMass = forcedInflowData [ 0 ] ; waterTemperature = forcedInflowData [ 1 ] ; waterMass -= waterOutflow ; waterOutflow = initialWaterMass - waterMass ; isolationValveArray . forEach ( valve -> { valve . update ( ) ; totalValvePositions += valve . getPosition ( ) ; } ) ; double highestPressure = 0 ; for ( Connectable source : sources ) { double sourcePressure = source . getPressure ( ) ; highestPressure = sourcePressure > highestPressure ? sourcePressure : highestPressure ; } pressure = highestPressure ; if ( waterOutflow >= 0 ) { for ( int i = 0 ; i < sources . length ; i ++ ) { Connectable thisSource = sources [ i ] ; Double sourceOutFlow = ( double ) ( isolationValveArray . get ( i ) . getPosition ( ) / totalValvePositions ) * waterOutflow ; if ( sourceOutFlow . isNaN ( ) ) { sourceOutFlow = 0.0 ; } double sourceWaterTemp = thisSource . getWaterTemperature ( ) ; thisSource . updateWaterOutflow ( sourceOutFlow , sourceWaterTemp ) ; double [ ] inflowData = NPPMath . mixWater ( waterMass , waterTemperature , sourceOutFlow , sourceWaterTemp ) ; waterMass = inflowData [ 0 ] ; waterTemperature = inflowData [ 1 ] ; waterDensity = Loader . tables . getWaterDensityByTemp ( waterTemperature ) ; } } else { for ( int i = 0 ; i < sources . length ; i ++ ) { Connectable thisSource = sources [ i ] ; Double sourceBackflow = ( double ) ( isolationValveArray . get ( i ) . getPosition ( ) / totalValvePositions ) * ( 0 - waterOutflow ) ; if ( sourceBackflow . isNaN ( ) ) { sourceBackflow = 0.0 ; } thisSource . updateWaterInflow ( sourceBackflow , waterTemperature ) ; } } resetFlows ( ) ; waterMass = initialWaterMass ; totalValvePositions = 0.0f ;
setDescription: public void setDescription ( String description ) { this . description = description ;
validateIdCard18: public static boolean validateIdCard18 ( String idCard ) { boolean bTrue = false ; if ( idCard . length ( ) == CHINA_ID_MAX_LENGTH ) { String code17 = idCard . substring ( 0 , 17 ) ; String code18 = idCard . substring ( 17 , CHINA_ID_MAX_LENGTH ) ; if ( isNum ( code17 ) ) { char [ ] cArr = code17 . toCharArray ( ) ; if ( cArr != null ) { int [ ] iCard = convertCharToInt ( cArr ) ; int iSum17 = getPowerSum ( iCard ) ; String val = getCheckCode18 ( iSum17 ) ; if ( val . length ( ) > 0 ) { if ( val . equalsIgnoreCase ( code18 ) ) { bTrue = true ; } } } } } return bTrue ;
getWarmup: public String getWarmup ( ) { return warmup ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem10ActionPerformed ( evt ) ;
convertControllerEndpoints: private void convertControllerEndpoints ( List < ControllerEndpointConversionDto > controllerEndpointConversionDtos , Long frontendResourceId ) { for ( ControllerEndpointConversionDto controllerEndpointConversionDto : controllerEndpointConversionDtos ) {
getTextSize: public float getTextSize ( ) { return mTextSize ;
createGlobalRole: public Role createGlobalRole ( String name , Set < PrivilegeBase > privileges , boolean removable ) { GlobalRole role = new GlobalRole ( name ) ; role . setPrivilegesSet ( privileges ) ; role . setRemovable ( removable ) ; repositories . unsecure . role . save ( role ) ; return repositories . unsecure . role . findByName ( name ) ;
onResponse: void onResponse ( final MessageContext < TResponse > context ) { this . handlerCalled = true ; if ( ! parallelResponseHandling ) {
selectFirstInstrument: public void selectFirstInstrument ( PlayerOwnerComponent poc ) { if ( isWounded ( ) ) return ; Slot instrumentSlot = null ; ConsumableRecord record = poc . getCurrentInstrumentRecord ( ) ; if ( record != null ) { if ( record . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) record . getItem ( ) ) ; Instrument instrument = ( Instrument ) ici . getInstrumentData ( ) . getContent ( ) ; if ( instrument != null ) { instrumentSlot = instrument . getSlot ( ) ; } } } Array < ConsumableRecord > records = poc . getConsumableContainer ( ) . queryRecords ( r -> r . getItem ( ) instanceof InstrumentConsumableItem ) ; for ( ConsumableRecord r : records ) { if ( r != record && r . getItem ( ) instanceof InstrumentConsumableItem ) { InstrumentConsumableItem ici = ( ( InstrumentConsumableItem ) r . getItem ( ) ) ; if ( ( ( Instrument ) ici . getContent ( ) ) . getSlot ( ) == instrumentSlot ) { poc . setCurrentInstrument ( r ) ; instrumentSelected ( r ) ; changeInstrument ( r . getId ( ) ) ; return ; } } } records . sort ( Comparator . comparingInt ( InstrumentConsumableItem :: SortRecords ) ) ; for ( ConsumableRecord r : records )
twoDigitString: private static String twoDigitString ( int number ) { if ( number == 0 ) { return "00" ; } if ( number / 10 == 0 ) { return "0" + number ; } return String . valueOf ( number ) ;
getCurrentEnvironment: No method body
addToZip: public PrivilegeConversionDto addToZip ( DynamicPrivilege entity , ZipOutputStream zipOut , Set < String > zipEntries ) { return super . addToZip ( entity , zipOut , zipEntries ) ;
calcMinMax: protected void calcMinMax ( T d ) { if ( mYMax < d . getYMax ( ) ) mYMax = d . getYMax ( ) ; if ( mYMin > d . getYMin ( ) ) mYMin = d . getYMin ( ) ; if ( mXMax < d . getXMax ( ) ) mXMax = d . getXMax ( ) ; if ( mXMin > d . getXMin ( ) ) mXMin = d . getXMin ( ) ; if ( d . getAxisDependency ( ) == AxisDependency . LEFT ) {
renderLayer: public void renderLayer ( Batch batch , RenderContext context , int layer ) { visible = isVisible ( context ) ; if ( visible )
getAvailableLoggers: default List < Class > getAvailableLoggers ( ) { return availableLoggers ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { autoSteamPressure4OffItemStateChanged ( evt ) ;
render: public void render ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ; super . render ( ) ;
isWritable: public static boolean isWritable ( String filename ) { return Files . isWritable ( Paths . get ( filename ) ) ;
getEffect: public MixedSoundEffectData getEffect ( LaunchData launchData ) { return new MixedSoundEffectData ( this , launchData ) ;
onBindViewHolder: public void onBindViewHolder ( @ NonNull RecyclerView . ViewHolder holder , int position , @ NonNull List < Object > payloads ) { if ( isHeaderPosition ( position ) || isFooterPosition ( position ) ) { return ; } position = position - mHeaderViews . size ( ) ; mAdapter . onBindViewHolder ( holder , position , payloads ) ;
getPackages: public ObjectMap < String , ContentPackage > getPackages ( ) { return packages ;
getY: public float getY ( ) { return skeleton . getY ( ) ;
looksLikeJsonObject: public static boolean looksLikeJsonObject ( String jsonInput ) throws IOException { if ( StringUtils . isBlank ( jsonInput ) ) { return false ; } String trimmed = jsonInput . trim ( ) ; return trimmed . charAt ( 0 ) == '{' && trimmed . charAt ( trimmed . length ( ) - 1 ) == '}' ;
setWritePrivilege: public void setWritePrivilege ( String writePrivilege ) { this . writePrivilege = writePrivilege ;
isSilent: public boolean isSilent ( ) { return silent . asBoolean ( ) ;
startOBMobile: public void startOBMobile ( ) { String lndDir = getApplicationContext ( ) . getExternalCacheDir ( ) . toString ( ) ; String startParams = ConstantWithNetwork . getInstance ( ConstantInOB . networkType ) . getStartParams ( ) ; Obdmobile . start ( "--lnddir=" + lndDir + startParams + User . getInstance ( ) . getAlias ( mContext ) , new Callback ( ) {
Verify: public static String Verify ( String key , String data ) { if ( sha256_HMAC == null ) return "" ; try
getMaxUploadSizeInBytes: public Long getMaxUploadSizeInBytes ( ) { return maxUploadSizeInBytes ;
getUrl: public String getUrl ( ) { return url ;
saveFromPubKeyToLocal: public static void saveFromPubKeyToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_FROM_PUBKEY , value ) ;
collide: protected ActiveData . LastHitInfo collide ( CollideEvent collideEvent , float damage ) { PlayerOwnerComponent poc = activeData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null ) { ObjectMap < Integer , ConsumableRecord > armor = poc . getConsumableContainer ( ) . getCategory ( "armor" ) ; if ( armor != null ) { for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : armor ) { ConsumableRecord dm = entry . value ; if ( dm != null ) { if ( dm . getItem ( ) instanceof ArmorConsumableItem ) { ArmorConsumableItem hci = ( ( ArmorConsumableItem ) dm . getItem ( ) ) ; if ( validateBullet ( collideEvent . bulletData ) ) { damage = hci . protect ( collideEvent , damage , entry . value . getQuality ( ) ) ; if ( hci . empty ( ) ) { poc . getConsumableContainer ( ) . removeRecord ( dm , true ) ; Client client = BrainOutServer . Controller . getClients ( ) . get ( activeData . getOwnerId ( ) ) ; if ( client instanceof PlayerClient && client . isAlive ( ) ) { ServerPlayerControllerComponentData pc = activeData . getComponentWithSubclass ( ServerPlayerControllerComponentData . class ) ; if ( pc != null ) { pc . updateAttachments ( ) ; } client . sendConsumable ( ) ; } } if ( damage <= 0 ) { BulletData bullet = collideEvent . bulletData ; bullet . setCollided ( true ) ; LaunchData l = bullet . getLaunchData ( ) ; health . damage ( ( DamageEvent ) DamageEvent . obtain ( 0 , coll . getActiveData ( ) . getId ( ) , bullet . getInstrumentInfo ( ) , bullet , l . getX ( ) , l . getY ( ) , l . getAngle ( ) , Constants . Damage . DAMAGE_PROTECT ) ) ; Client client = BrainOutServer . Controller . getClients ( ) . get ( bullet . getOwnerId ( ) ) ; if ( client instanceof PlayerClient ) { ( ( PlayerClient ) client ) . sendUDP ( new HitConfirmMsg ( ) ) ; } return null ; } } } } } } } ActiveData . LastHitInfo lastHitInfo = super . collide ( collideEvent , damage ) ; if ( collideEvent . colliderName . equals ( "head" ) ) { lastHitInfo . kind = ActiveData . LastHitKind . headshot ; } else { lastHitInfo . kind = ActiveData . LastHitKind . normal ; } return lastHitInfo ;
isActive: No method body
upload: public HttpUtils upload ( ) { mType = TYPE_UPLOAD_FILE ; return this ;
f: public < T > T f ( String json , Class < T > cls ) throws JsonSyntaxException { return null ;
approve: public void approve ( int amount ) { ruAvailable = amount ; ruAvailableLabel . setText ( amount ) ; updateFee ( ) ; Menu . playSound ( MenuSound . itemSold ) ;
setId: public void setId ( Long id ) { this . id = id ;
isEmbeddable: public boolean isEmbeddable ( ) { return embeddable ;
getFriends: public IntSet getFriends ( ) { return friends ;
hasUpdate: public boolean hasUpdate ( ) { return false ;
requestError: public boolean requestError ( RequestErrorMsg msg ) { Gdx . app . postRunnable ( ( ) -> { RequestCallback callback = callbackHandlers . remove ( msg . id ) ; if ( callback != null ) { callback . error ( msg . reason ) ; } } ) ; return true ;
debugLevel: No method body
setSpaceBottom: public void setSpaceBottom ( float percent ) { mSpacePercentBottom = percent ;
formatTimeAndDateLong: public static String formatTimeAndDateLong ( long time , Context context ) { DateFormat df = DateFormat . getDateInstance ( DateFormat . LONG , context . getResources ( ) . getConfiguration ( ) . locale ) ; String formattedDate = df . format ( new Date ( time * 1000L ) ) ; DateFormat tf = DateFormat . getTimeInstance ( DateFormat . MEDIUM , context . getResources ( ) . getConfiguration ( ) . locale ) ; String formattedTime = tf . format ( new Date ( time * 1000L ) ) ; return ( formattedDate + ", " + formattedTime ) ;
updateAttachments: public void updateAttachments ( ) { PlayerAnimationComponentData anim = playerData . getComponent ( PlayerAnimationComponentData . class ) ; if ( anim == null || anim . getSkeleton ( ) == null ) return ; for ( ObjectMap . Entry < String , Attachment > entry : originalAttachments ) { Slot slot = anim . getSkeleton ( ) . findSlot ( entry . key ) ; if ( slot == null ) continue ; if ( slot . getAttachment ( ) instanceof SkeletonAttachment ) continue ; slot . setAttachment ( entry . value ) ; } Player player = playerData . getPlayer ( ) ; if ( player . hasComponent ( ReplaceSlotComponent . class ) && playerData . getComponent ( PlayerAnimationComponentData . class ) != null ) { ReplaceSlotComponent rsc = player . getComponent ( ReplaceSlotComponent . class ) ; rsc . upgradeSkeleton ( anim . getSkeleton ( ) ) ; } if ( playerData . getCustomAnimationSlots ( ) != null ) { for ( ObjectMap . Entry < String , String > entry : playerData . getCustomAnimationSlots ( ) ) { ReplaceSlotComponent . UpgradeSkeleton ( anim . getSkeleton ( ) , entry . key , entry . value ) ; } } for ( ObjectMap . Entry < String , String > entry : anim . getAttachments ( ) )
main: public static void main ( String [ ] args ) { waterValve ( 827.85 , 2885 , 1400 , 1001.9 , 0.887 ) ; }
setStepped: public void setStepped ( int frame ) { curves [ frame ] = STEPPED ;
updateResource: void updateResource ( ) throws Exception { assertNotNull ( updateDepartParam , "updateDepartParam is null" ) ; MockHttpServletResponse response = mockMvc . perform ( MockMvcRequestBuilders . put ( "/depart/update" ) . contentType ( MediaType . APPLICATION_JSON ) . content ( objectMapper . writeValueAsString ( updateDepartParam ) ) ) . andDo ( MockMvcResultHandlers . print ( ) ) . andReturn ( ) . getResponse ( ) ; Assertions . assertEquals ( HttpStatus . SUCCESS , response . getStatus ( ) ) ; Map map = objectMapper . readValue ( response . getContentAsString ( ) , Map . class ) ; assertEquals ( HttpStatus . SUCCESS , map . get ( "code" ) ) ; log . info ( "更新组织/部门接口测试成功:{}" , map . get ( "data" ) ) ;
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( L . get ( "MENU_PRIVACY_POLICY" ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . expandX ( ) . row ( ) ; data . add ( header ) . expandX ( ) . fillX ( ) . row ( ) ; } Table body = new Table ( BrainOutClient . Skin ) ; body . setBackground ( "form-default" ) ; { RichLabel contents = new RichLabel ( text , BrainOutClient . Skin , "title-small" ) ; ScrollPane pane = new ScrollPane ( contents , BrainOutClient . Skin , "scroll-default" ) ; pane . setFadeScrollBars ( false ) ; body . add ( pane ) . size ( 600 , 500 ) . pad ( 16 ) . row ( ) ; setScrollFocus ( pane ) ; } if ( accepted == null ) { Table buttons = new Table ( ) ; { TextButton close = new TextButton ( L . get ( "MENU_CLOSE" ) , BrainOutClient . Skin , "button-default" ) ; close . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; pop ( ) ; } } ) ; buttons . add ( close ) . size ( 196 , 64 ) . pad ( 8 ) ; } body . add ( buttons ) . expandX ( ) . fillX ( ) . pad ( 8 ) . row ( ) ; } else { Table buttons = new Table ( ) ; { TextButton cancel = new TextButton ( L . get ( "MENU_EXIT" ) , BrainOutClient . Skin , "button-default" ) ; cancel . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; canceled ( ) ; } } ) ; buttons . add ( cancel ) . size ( 196 , 64 ) . pad ( 8 ) ; } { TextButton accept = new TextButton ( L . get ( "MENU_ACCEPT" ) , BrainOutClient . Skin , "button-green" ) ; accept . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; accepted ( ) ; } } ) ; buttons . add ( accept ) . size ( 196 , 64 ) . pad ( 8 ) ; } body . add ( buttons ) . expandX ( ) . fillX ( ) . pad ( 8 ) . row ( ) ; } data . add ( body ) . expand ( ) . fill ( ) . row ( ) ; return data ;
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ShopCountry responseEntity = this . api . shopCountries ( ) . get ( "acme" , "acme" , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCountryGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
clicked: public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; close ( ) ;
setDrawCircleHole: public void setDrawCircleHole ( boolean enabled ) { mDrawCircleHole = enabled ;
getComponent: public ServerSmokeGeneratorComponentData getComponent ( ComponentObject componentObject ) { return new ServerSmokeGeneratorComponentData ( componentObject , this ) ;
handleSubscriptionRequest: private void handleSubscriptionRequest ( long l ) { if ( l == Long . MAX_VALUE ) { this . subscriberRequest = l ; } else { this . subscriberRequest += l ; if ( this . subscriberRequest < 0 ) { this . subscriberRequest = Long . MAX_VALUE ; } } tryProgress ( ) ;
getExitTime: public float getExitTime ( ) { return exitTime ;
JoinGame: public static void JoinGame ( String roomId , JoinGameResult callback ) { LoginService loginService = LoginService . Get ( ) ; GameService gameService = GameService . Get ( ) ; if ( loginService == null ) throw new RuntimeException ( "No login service!" ) ; if ( gameService == null ) throw new RuntimeException ( "No game service!" ) ; gameService . joinGame ( loginService . getCurrentAccessToken ( ) , roomId ,
sendMessageToGPT: No method body
getLocalizedName: public String getLocalizedName ( ) { if ( getItems ( ) . size == 0 ) return "" ; Content item = getItems ( ) . first ( ) ; if ( item == null ) return "" ; String title = item . getTitle ( ) . get ( ) ; if ( item instanceof Instrument ) { Instrument instrument = ( ( Instrument ) item ) ; if ( instrument . getSlotItem ( ) != null ) { title = instrument . getSlotItem ( ) . getTitle ( ) . get ( ) ; } } return L . get ( "QUEST_TASK_BURN_ITEM" , title , String . valueOf ( getTarget (
setBasecampToDoListId: public void setBasecampToDoListId ( String basecampToDoListId ) { this . basecampToDoListId = basecampToDoListId ;
instantiate: protected Object instantiate ( Class clazz ) { try
fetch: public boolean fetch ( boolean loadTime ) { if ( state == State . reloading ) { if ( reloadTimer >= 0.2f ) { return false ; } } if ( loadTime ) { state = State . fetching ; reloadTimer = getFetchTime ( ) . asFloat ( ) ; } else { state = State . normal ; } fixStuck ( ) ; if ( getChambered ( ) >= weaponProperties . getChambers ( ) ) { return true ; } if ( this . getRounds ( ) > 0 ) { int take = Math . min ( this . getRounds ( ) , weaponProperties . getChambers ( ) ) ; setChambered ( take , getRoundsQuality ( ) ) ; setRounds ( getRounds ( ) - take , getChamberedQuality ( ) ) ; updateWeapon ( true ) ; return true ; } return false ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case animationAction : { AnimationActionEvent actionEvent = ( ( AnimationActionEvent ) event ) ; if ( actionEvent . kind . equals ( "instrument-action" ) ) { getContentComponent ( ) . process ( instrumentData , actionEvent . payload ) ; } return true ; } } return false ;
getXOrigin: public float getXOrigin ( ) { return xOrigin ;
validate: public boolean validate ( ) { return true ;
bindOpenChannelItem: void bindOpenChannelItem ( final OpenChannelItem openChannelItem ) { setState ( openChannelItem . getChannel ( ) . getActive ( ) ) ; if ( openChannelItem . getChannel ( ) . getAssetId ( ) == 0 ) { long availableCapacity = openChannelItem . getChannel ( ) . getBtcCapacity ( ) - openChannelItem . getChannel ( ) . getCommitFee ( ) ; setBalances ( openChannelItem . getChannel ( ) . getLocalBalance ( ) , openChannelItem . getChannel ( ) . getRemoteBalance ( ) , availableCapacity ) ; } else { long availableCapacity = openChannelItem . getChannel ( ) . getAssetCapacity ( ) - openChannelItem . getChannel ( ) . getCommitFee ( ) ; setBalances ( openChannelItem . getChannel ( ) . getLocalAssetBalance ( ) , openChannelItem . getChannel ( ) . getRemoteAssetBalance ( ) , availableCapacity ) ; } setName ( openChannelItem . getChannel ( ) . getRemotePubkey ( ) ) ; setLogo ( openChannelItem . getChannel ( ) . getAssetId ( ) ) ; setOnRootViewClickListener ( openChannelItem , ChannelListItem . TYPE_OPEN_CHANNEL ) ;
logError: private void logError ( Exception e ) { String messageString = getSimpleErrorMessage ( e ) ; StackTraceElement [ ] st = e . getStackTrace ( ) ; String stLine1 = ( st != null && st . length > 0 ) ? "" + st [ 0 ] : "N/A" ; String stLine2 = ( st != null && st . length > 1 ) ? "" + st [ 1 ] : "N/A" ; error ( e , "[execute] {} {} {}" , messageString , stLine1 , stLine2 ) ;
init: public void init ( ) { super . init ( ) ; updatePlayerData ( ) ; BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . damaged , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . hitConfirmed , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . ammoLoaded , this ) ; switchInstrument ( ) ; ClientPlayerComponent cpc = getPlayerData ( ) . getComponent ( ClientPlayerComponent . class ) ; if ( cpc != null ) { hitSpriteBody = new CenterSprite ( BrainOutClient . getRegion ( "hit-marker" ) , cpc . getMouseLaunchData ( ) ) ; hitSpriteHead = new CenterSprite ( BrainOutClient . getRegion ( "hit-marker-head" ) , cpc . getMouseLaunchData ( ) ) ; this . hitSprite = hitSpriteBody ; cpc . setDisplayAim ( true ) ; cpc . setLerpAim ( false ) ; } PlayerOwnerComponent poc = getPlayerData ( ) . getComponent ( PlayerOwnerComponent . class ) ; if ( poc != null )
openURI: public boolean openURI ( String uri ) { getGameUser ( ) . getSteamFriends ( ) . activateGameOverlayToWebPage ( uri , SteamFriends . OverlayToWebPageMode . Modal ) ; return true ;
setPosition: public void setPosition ( float x , float y ) { this . position . set ( x , y ) ;
preHandle: No method body
deleteRole: No method body
update: public void update ( float dt ) { super . update ( dt ) ; timer -= dt ; if ( effects . size == 0 )
exportFrontendResourceToZippedYaml: public byte [ ] exportFrontendResourceToZippedYaml ( @ PathVariable ( ID ) long frontendResourceId ) { debug ( "[exportFrontendResourceToZippedYaml]" ) ; return services . componentExport . exportToZip ( Arrays . asList ( repositories . secure . frontendResource . findOne ( frontendResourceId ) ) ) . toByteArray ( ) ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { if ( mode == Mode . hover )
getCricleColor: public int getCricleColor ( ) { return roundColor ;
getPosition: public static MPPointF getPosition ( MPPointF center , float dist , float angle ) { MPPointF p = MPPointF . getInstance ( 0 , 0 ) ; getPosition ( center , dist , angle , p ) ; return p ;
yAnimator: private ObjectAnimator yAnimator ( int duration , EasingFunction easing ) { ObjectAnimator animatorY = ObjectAnimator . ofFloat ( this , "phaseY" , 0f , 1f ) ; animatorY . setInterpolator ( easing ) ; animatorY . setDuration ( duration ) ; return animatorY ;
onLoginSuccess: public void onLoginSuccess ( Context context ) { super . onLoginSuccess ( context ) ; onSuccessLogin ( ) ;
found: public void found ( Queue < Vector2 > path , String dimension , ObjectSet < BlockCoordinates > blocksInWay , ActiveData portalOfInterest ) { result . found ( path , dimension , blocksInWay , door ) ;
ready: public static < T > Output < T > ready ( T value ) { return new Output < > ( true , value ) ;
setAccountBalance: public void setAccountBalance ( double accountBalance ) { this . accountBalance = accountBalance ;
updateSpawnPointsInfo: private void updateSpawnPointsInfo ( ) { spawnPointsContent . clear ( ) ; Label title = new Label ( L . get ( "MENU_SPAWN_POINT" ) , BrainOutClient . Skin , "title-level" ) ; title . setAlignment ( Align . center ) ; spawnPointsContent . add ( new BorderActor ( title , "form-gray" ) ) . size ( 192 , 64 ) . expandX ( ) . fillX ( ) . row ( ) ; spawnButtons = new ButtonGroup < > ( ) ; GameMode gameMode = BrainOutClient . ClientController . getGameMode ( ) ; if ( spawnSelection != null && gameMode != null && ! gameMode . canSpawn ( spawnSelection , BrainOutClient . ClientController . getTeam ( ) ) ) { spawnSelection = null ; } if ( gameMode != null )
source: public MessageBuilder < JRPCMessage > source ( final @ NonNull DataSource dataSource ) { this . dataSource = dataSource ; return this ;
putObjectCdn: No method body
isInBoundsTop: public boolean isInBoundsTop ( float y ) { return mContentRect . top <= y ;
release: public void release ( ) { super . release ( ) ; ClientMap map = ( ( ClientMap ) getMap ( ) ) ; if ( map == null ) return ; map . removeEffect ( flyEffects ) ;
buildHandshakeResponse: private JRPCMessage buildHandshakeResponse ( final @ NonNull JRPCHandshake handshake , final @ NonNull HandshakeStatusPacket response ) { return JRPCMessageBuilder . builder ( )
testUpdateMembership: public void testUpdateMembership ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/CustomerUpdateMembershipRequest.json" ) ; CustomerMembership requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , CustomerMembership . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; CustomerMembership responseEntity = this . api . customers ( ) . updateMembership ( "acme" , "acme" , 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/CustomerUpdateMembershipResponse.json" ) ; assertThatJson ( expectedResponseJson )
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterTemp12ActionPerformed ( evt ) ;
after: public static void after ( ) { StepsBase . cleanup ( ) ;
getArea: void getArea ( ) { assertEquals ( 314.1592653589793 , circle . getArea ( ) , DELTA ) ;
UpdateRole: void UpdateRole ( ) { Role role = Role . builder ( ) . id ( 3L ) . roleName ( "单元测试角色" ) . roleCode ( "unitTest" ) . description ( "单元测试更新的角色" ) . sort ( 3 ) . build ( ) ; roleService . addRole ( role ) ; log . info ( "更新角色方法测试成功！" ) ;
getSteamVolume: public double getSteamVolume ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
checkPointOfInterest: private float checkPointOfInterest ( int pointOfInterest ) { return pointsOfInterest . get ( pointOfInterest , 1.0f ) ;
addInterest: public void addInterest ( ) { balance += balance * interestRate ;
list: public CommonResult < CommonPage < ResourceCategory > > list ( @ RequestBody @ Valid ResourceCategoryPageListParam param ) { List < ResourceCategory > listPage = resourceCategoryService . getResourceCategoryListPage ( param . getPageNum ( ) , param . getPageSize ( ) , param . getQueryKey ( ) ) ; return CommonResult . success ( CommonPage . restPage ( listPage ) ) ;
setShapeRenderer: public void setShapeRenderer ( IShapeRenderer shapeRenderer ) { mShapeRenderer = shapeRenderer ;
overrideUrlLoading: private boolean overrideUrlLoading ( final Context context , WebView view , String url ) { LogUtils . e ( TAG , "捕捉到的链接是：" + url ) ; if ( ! StringUtils . isEmpty ( url ) && url . toLowerCase ( ) . startsWith ( "file" ) ) { if ( mCallBack != null ) { return mCallBack . onWebViewShouldOverrideUrl ( view , url ) ; } return false ; } else if ( ! StringUtils . isEmpty ( url ) && ( ! url . toLowerCase ( ) . startsWith ( "http" ) || url . toLowerCase ( ) . endsWith ( "apk" ) ) ) { Uri uri = Uri . parse ( url ) ; try { Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; LogUtils . e ( TAG , "===Exception===本地没有安装此App====>" ) ; BasePreferencesUtils . saveRequestUrlToLocal ( context , url ) ; } return true ; } else if ( ! isRedirectUrl ( view ) ) { if ( mCallBack != null ) { return mCallBack . onWebViewShouldOverrideUrl ( view , url ) ; } return false ; } return false ;
getCurrentWeapon: public WeaponData getCurrentWeapon ( ) { PlayerData playerData = getPlayerData ( ) ; if ( playerData == null ) return null ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; if ( poc == null ) return null ; ConsumableRecord record = poc . getCurrentInstrumentRecord ( ) ; if ( record == null ) return null ; if ( ! ( record . getItem ( ) instanceof InstrumentConsumableItem ) ) return null ; InstrumentData instrumentData = ( ( InstrumentConsumableItem ) record . getItem ( ) ) . getInstrumentData ( ) ; if ( ! ( instrumentData instanceof WeaponData ) ) return null ; return ( ( WeaponData ) instrumentData ) ;
getChannelByteString: public ByteString getChannelByteString ( ) { return mChannel . toByteString ( ) ;
updateCriterion: public VoucherCriterion updateCriterion ( String shopKey , String countryCode , Integer voucherId , Integer voucherCriterionId , VoucherCriterion model ) throws ApiErrorException , ConnectionException { Class < VoucherCriterion > responseModel = ( Class < VoucherCriterion > ) ( Class < ? > ) VoucherCriterion . class ; return this . request ( "put" , this . resolvePath ( "/shops/%s/countries/%s/vouchers/%s/criteria/%s" , shopKey , countryCode , voucherId , voucherCriterionId ) , null , null , responseModel , model ) ;
success: public void success ( JSONObject response ) { waitLoadingMenu . pop ( ) ; gs . popMenu ( BanPlayerMenu . this ) ; gs . pushMenu ( new AlertPopup ( "OK" ) ) ;
minioClient: public MinioClient minioClient ( OSSProperties ossProperties ) { OSSProperties . Minio minio = ossProperties . getMinio ( ) ; try { log . info ( "minio 初始化:{}" , objectMapper . writeValueAsString ( minio ) ) ; } catch ( JsonProcessingException ignored ) { log . error ( "minio 初始化配置解析异常！" ) ; } return new MinioClient . Builder ( )
getHead: public double getHead ( ) { return currentHead ;
setEffect: public void setEffect ( Effect effect ) { this . effect = effect ;
startMessage: public static Protocol . StartMessage . Builder startMessage ( int entries , String key , Map . Entry < String , String > ... stateEntries ) { return startMessage ( entries , key )
sendMessageToGPT: public String sendMessageToGPT ( String message , String conversationId ) { return chatGPTService . sendMessageToGPT ( message , conversationId , null ) ;
damage: private void damage ( ) { Map map = getMap ( ) ; if ( map == null ) return ; for ( ActiveData activeData : map . getActivesForTag ( Constants . ActiveTags . WITH_HEALTH , false ) )
releaseRounds: public void releaseRounds ( ) { if ( source . hasMagazineManagement ( ) ) { detachMagazine ( ) ; onUnloadMagazine ( ) ; return ; } if ( bullet != null )
isVisible: public boolean isVisible ( ) { return mVisible ;
subscribePeerEvents: public Observable < lnrpc . LightningOuterClass . PeerEvent > subscribePeerEvents ( lnrpc . LightningOuterClass . PeerEventSubscription request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . subscribePeerEvents ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
onClick: public void onClick ( View v ) { ToastUtils . showToast ( mContext , "Not yet open, please wait" ) ; shareLayout . setVisibility ( View . GONE ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { toggleLACActionPerformed ( evt ) ;
getCommand: No method body
getTag: public String getTag ( ) { return tag ;
attachUpgrade: public void attachUpgrade ( String key , Upgrade upgrade ) { getUpgrades ( ) . put ( key , upgrade ) ; upgrade . preApply ( this ) ; upgrade . postApply ( this ) ; for ( ContentComponent component : upgrade . getComponents ( ) ) { if ( component instanceof UpgradeComponent ) { UpgradeComponent upg = ( UpgradeComponent ) component ; if ( ! upg . pre ( ) ) { upg . upgrade ( this ) ; } } } Component it = getFistComponent ( ) ; while ( it != null ) { if ( it instanceof AffectedByUpgrades ) { AffectedByUpgrades upg = ( AffectedByUpgrades ) it ; upg . upgraded ( getUpgrades ( ) ) ; } it = it . getNext ( ) ; } BrainOut . EventMgr . sendEvent ( this , SimpleEvent . obtain ( SimpleEvent . Action . upgradesUpdated ) ) ;
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case gameController : { break ; } } return false ;
hasIcon: public boolean hasIcon ( ) { return true ;
onEvent: public boolean onEvent ( Event event ) { return false ;
getName: public CharSequence getName ( ) { return name ;
validateActive: public boolean validateActive ( Active active ) { if ( active instanceof Flag ) { return false ; } return true ;
acquireMap: No method body
getMix: public float getMix ( ) { return mix ;
isSupported: static boolean isSupported ( Discovery . ServiceDiscoveryProtocolVersion serviceDiscoveryProtocolVersion ) { return MIN_SERVICE_DISCOVERY_PROTOCOL_VERSION . getNumber ( )
removeUser: public Object removeUser ( @ PathVariable ( ORGANIZATIONID ) Long organizationId , @ RequestParam ( name = "userRoleId" , required = true ) long userRoleId ) { debug ( "[removeUser] orgId {}" , organizationId ) ; return removeUserRole ( userRoleId )
setLength: public void setLength ( int length ) { this . length = length ;
getUniform: public boolean getUniform ( ) { return uniform ;
saveAliasToLocal: public static void saveAliasToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_ALIAS , value ) ;
unregiterActive: public void unregiterActive ( ActiveData activeData ) { actives . remove ( activeData ) ;
activateSwamp: private boolean activateSwamp ( Client myClient , PlayerData activator ) { if ( ! ( getComponentObject ( ) instanceof PlayerData ) ) return false ; if ( ! playerData . isAlive ( ) ) return false ; FreeplayPlayerComponentData fp = playerData . getComponent ( FreeplayPlayerComponentData . class ) ; if ( fp == null ) return false ; if ( ! fp . isSwamp ( ) ) return false ; if ( ! activator . isAlive ( ) ) return false ; if ( activator . isWounded ( ) ) return false ; if ( ! ( myClient instanceof PlayerClient ) ) return false ; PlayerClient myPlayerClient = ( ( PlayerClient ) myClient ) ; String myPartyId = myPlayerClient . getPartyId ( ) ; if ( myPartyId == null || myPartyId . isEmpty ( ) ) return false ; int otherOwnerId = activator . getOwnerId ( ) ; Client otherClient = BrainOutServer . Controller . getClients ( ) . get ( otherOwnerId ) ; if ( ! ( otherClient instanceof PlayerClient ) ) return false ; PlayerClient otherPlayerClient = ( ( PlayerClient ) otherClient ) ; if ( ! myPartyId . equals ( otherPlayerClient . getPartyId ( ) ) ) return false ; ActiveProgressComponentData progress = activator . getComponent ( ActiveProgressComponentData . class ) ; if ( progress == null ) return false ; otherPlayerClient . enablePlayer ( false ) ; { SimplePhysicsComponentData phy = activator . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy != null ) { phy . getSpeed ( ) . set ( 0 , 0 ) ; otherPlayerClient . getServerPlayerController ( ) . sendPlayerData ( false , 0 ) ; } } progress . startCancellable ( getContentComponent ( ) . getReviveTime ( ) , ( ) -> { otherPlayerClient . enablePlayer ( true ) ; myPlayerClient . enablePlayer ( true ) ; SimplePhysicsComponentData phy = playerData . getComponentWithSubclass ( SimplePhysicsComponentData . class ) ; if ( phy != null ) { phy . setEnabled ( true ) ; phy . updated ( playerData ) ; } myPlayerClient . moveTo ( activator . getDimension ( ) , activator . getX ( ) , activator . getY ( ) ) ; fp . setSwamp ( false ) ; fp . sync ( ) ; } , ( ) -> { otherPlayerClient . enablePlayer ( true ) ; } ) ; return true ;
setCreatedById: public void setCreatedById ( Long createdById ) { this . createdById = createdById ;
getPreferences: public static SharedPreferences getPreferences ( ) { return sp ; }
testAllAttributes: public void testAllAttributes ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < Attribute > responseEntity = this . api . productVariants ( ) . allAttributes ( Identifier . fromId ( 1 ) , Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductVariantAllAttributesResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( Attribute entity : responseEntity . getEntities ( ) ) {
save: No method body
getApiToken: public String getApiToken ( ) { return apiToken ;
getNextMagazineId: private int getNextMagazineId ( ) { int next = 0 ; while ( true )
setDarkColor: public void setDarkColor ( Color tint ) { dark . set ( tint ) ; darkPacked = tint . toFloatBits ( ) ;
createQRCode: public static Bitmap createQRCode ( String content , int heightPix , Bitmap logo ) { Map < EncodeHintType , Object > hints = new HashMap < > ( ) ; hints . put ( EncodeHintType . CHARACTER_SET , "utf-8" ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . L ) ; hints . put ( EncodeHintType . MARGIN , 1 ) ; return createQRCode ( content , heightPix , logo , hints ) ;
shadeColor: public int shadeColor ( int color ) { String hax = Integer . toHexString ( color ) ; String result = "01" + hax . substring ( 2 ) ; return Integer . valueOf ( result , 16 ) ;
intersectsSegment: public @ Null BoundingBoxAttachment intersectsSegment ( float x1 , float y1 , float x2 , float y2 ) { Object [ ] polygons = this . polygons . items ; for ( int i = 0 , n = this . polygons . size ; i < n ; i ++ ) if ( intersectsSegment ( ( FloatArray ) polygons [ i ] , x1 , y1 , x2 , y2 ) ) return boundingBoxes . get ( i ) ; return null ;
setEndTime: public void setEndTime ( long endTime ) { long now = System . currentTimeMillis ( ) / 1000L ; this . endTime = now + endTime ;
deleteOrganization: protected PageModelMap deleteOrganization ( Long id ) { debug ( "[deleteOrganization] id {}" , id ) ; return Flow . init ( this , id )
getData: public LayerData getData ( ParallaxData parallaxData , Map map ) { if ( texture == null ) return null ; return new RepeatedStaticLayerData ( this , parallaxData , map ) ;
received: public boolean received ( final TakeCardOffDeckOntoTable msg ) { notifyCardEvent ( msg ) ; return true ;
getMixY: public float getMixY ( ) { return mixY ;
getComponent: public InstrumentUpgradeComponentData getComponent ( ComponentObject componentObject ) { return new InstrumentUpgradeComponentData ( componentObject , this ) ;
connectPeer: No method body
getButtonSprite: public SpriteData getButtonSprite ( ) { ActiveData activeData = findActiveData ( buttonSprite ) ; if ( ! ( activeData instanceof SpriteData ) ) return null ; return ( ( SpriteData ) activeData ) ;
getName: public String getName ( ) { return name ;
requiresReCaptcha: public boolean requiresReCaptcha ( ) { return Arrays . stream ( frontendMappingDefinition . fields ) . anyMatch ( a -> a . isReCaptcha ( this ) ) ;
FPart: private static float FPart ( float value ) { return value - IPart ( value ) ;
refresh: public void refresh ( ) { this . sumWeight = 0 ; this . sumPrice = 0 ; for ( ObjectMap . Entry < Slot , SlotItem . Selection > contentItem : items )
copyFolder: public static boolean copyFolder ( String oldPath , String newPath ) { boolean isok = true ; try { ( new File ( newPath ) ) . mkdirs ( ) ; File a = new File ( oldPath ) ; String [ ] file = a . list ( ) ; File temp = null ; for ( int i = 0 ; i < file . length ; i ++ ) { if ( oldPath . endsWith ( File . separator ) ) { temp = new File ( oldPath + file [ i ] ) ; } else { temp = new File ( oldPath + File . separator + file [ i ] ) ; } if ( temp . isFile ( ) ) { FileInputStream input = new FileInputStream ( temp ) ; FileOutputStream output = new FileOutputStream ( newPath + "/" + ( temp . getName ( ) ) . toString ( ) ) ; byte [ ] b = new byte [ 1024 * 5 ] ; int len ; while ( ( len = input . read ( b ) ) != - 1 ) { output . write ( b , 0 , len ) ; } output . flush ( ) ; output . close ( ) ; input . close ( ) ; } if ( temp . isDirectory ( ) ) { copyFolder ( oldPath + "/" + file [ i ] , newPath + "/" + file [ i ] ) ; } } } catch ( Exception e ) { isok = false ; } return isok ;
getRGBLuminanceSource: private static RGBLuminanceSource getRGBLuminanceSource ( @ NonNull Bitmap bitmap ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; int [ ] pixels = new int [ width * height ] ; bitmap . getPixels ( pixels , 0 , bitmap . getWidth ( ) , 0 , 0 , bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; return new RGBLuminanceSource ( width , height , pixels ) ;
dispose: public void dispose ( ) throws IOException { client . dispose ( ) ;
update: public void update ( float dt ) { for ( ObjectMap . Entry < Integer , Client > entry : this )
update: public void update ( float dt ) { if ( this . detected ) return ; float angle = activeData . getAngle ( ) ; float distance = getContentComponent ( ) . getDetectDistance ( ) ; float x = activeData . getX ( ) + MathUtils . cosDeg ( angle ) * distance , y = activeData . getY ( ) + MathUtils . sinDeg ( angle ) * distance ; Map map = getMap ( ) ; BlockData block = map . getBlockAt ( x , y , Constants . Layers . BLOCK_LAYER_FOREGROUND ) ; if ( block != null && block . isConcrete ( ) )
testDeleteCustomData: public void testDeleteCustomData ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shopCountries ( ) . deleteCustomData ( "acme" , "acme" , options ) ;
getTitle: public String getTitle ( ) { return title ;
waitFor: public Conversation < TRequest , TResponse > waitFor ( final long duration , final TimeUnit timeUnit ) { return waitFor ( duration , timeUnit , false ) ;
getFormSize: public float getFormSize ( ) { return mFormSize ;
setOperation: public void setOperation ( AuditOperation operation ) { this . operation = operation ;
move: private void move ( ServerElevatorFloorComponentData floor ) { if ( state != State . closed ) return ; state = State . running ; currentFloor = floor ; currentTask = new TimerTask ( ) { @ Override public void run ( ) { BrainOutServer . PostRunnable ( ( ) -> { currentTask = null ; arrived ( floor ) ; } ) ; } } ; long t = ( long ) ( getContentComponent ( ) . getMoveTime ( ) * 1000.0f ) ; BrainOutServer . Timer . schedule ( currentTask , t ) ;
write: public JSONObject write ( ) { JSONObject o = new JSONObject ( ) ; o . put ( "c" , content ) ; o . put ( "id" , id ) ; o . put ( "l" , location ) ; if ( items != null && items . notEmpty ( ) ) { JSONObject i = new JSONObject ( ) ; o . put ( "i" , i ) ; for ( ObjectMap . Entry < String , ObjectAtLocation > entry : items ) { i . put ( entry . key , entry . value . write ( ) ) ; } } return o ;
setUserId: public void setUserId ( Long userId ) { this . userId = userId ;
outputPayloadFromExecutableElement: private PayloadType outputPayloadFromExecutableElement ( ExecutableElement element ) { return payloadFromTypeMirrorAndAnnotations (
notify: public void notify ( NotifyAward notifyAward , float amount , NotifyReason reason , NotifyMethod method , NotifyData data , boolean priority ) { if ( ! priority ) { BrainOutServer . PostRunnable ( ( ) -> sendTCP ( new NotifyMsg ( notifyAward , amount , reason , method , data ) ) ) ; return ; } sendTCP ( new NotifyMsg ( notifyAward , amount , reason , method , data ) ) ;
updateAudience: public Audience updateAudience ( String audienceId , AudienceUpdateRequest model , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Audience > responseModel = ( Class < Audience > ) ( Class < ? > ) Audience . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "put" , this . resolvePath ( "/promotions/audiences/%s" , audienceId ) , query , null , responseModel , model ) ;
writeTo: public void writeTo ( BufferedSink sink ) throws IOException { if ( bufferedSink == null ) { bufferedSink = Okio . buffer ( sink ( sink ) ) ; } requestBody . writeTo ( bufferedSink ) ; bufferedSink . flush ( ) ;
release: public void release ( ) { if ( mAlertDialog != null ) {
getYRange: public float getYRange ( ) { return mYAxis . mAxisRange ;
getFollowX: private float getFollowX ( ) { ClientPlayerComponent cpc = follow . getComponent ( ClientPlayerComponent . class ) ; if ( cpc != null ) { return x + cpc . getMouseOffsetX ( ) ; } return x ;
getAngle: public float getAngle ( ) { return 0 ;
broadcastEvent: public TriggerEventResponse broadcastEvent ( final TriggerEventRequest request ) throws IOException , NovuNetworkException { try {
invokeConsumerMethod: private void invokeConsumerMethod ( Method consumerMethod , Object consumerObj , T eventObject , String [ ] staticParameter ) throws InvocationTargetException , IllegalAccessException { debug ( "[invokeConsumerMethod] method: {} consumer: {} event: {} parameters: {}" , consumerMethod , consumerObj , eventObject , staticParameter ) ; if ( staticParameter . length == 1 ) { this . consumerMethod . invoke ( consumerObj , eventObject , staticParameter [ 0 ] ) ; } if ( staticParameter . length == 2 ) { this . consumerMethod . invoke ( consumerObj , eventObject , staticParameter [ 0 ] , staticParameter [ 1 ] ) ; } if ( staticParameter . length == 3 ) { this . consumerMethod . invoke ( consumerObj , eventObject , staticParameter [ 0 ] , staticParameter [ 1 ] , staticParameter [ 2 ] ) ; } if ( staticParameter . length == 4 ) {
getSkinKey: public String getSkinKey ( ) { return getItem ( ) . getID ( ) + "-skin" ;
addUser: void addUser ( ) { User user = User . builder ( ) . username ( "unitTest" ) . password ( "666666" ) . avatar ( "" ) . email ( "unitTest@qq.com" ) . name ( "unitTest" ) . realName ( "单元测试" ) . telephone ( "0" ) . birthday ( LocalDateTime . now ( ) ) . sex ( 1 ) . remark ( "这是一条单元测试新增的数据" ) . build ( ) ; userService . addUser ( user ) ; log . info ( "新增用户测试成功！" ) ;
setGradientColors: public void setGradientColors ( int [ ] colors ) { this . mGradientColors = colors ;
setForegroundColor: public void setForegroundColor ( Color activeColor ) { this . activeColor = activeColor ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { overflow3ActionPerformed ( evt ) ;
setScanner: No method body
run: public void run ( ) { BrainOutServer . PostRunnable ( ( ) -> BrainOutServer . Controller . setSpeed ( 1f ) ) ;
getDashPathEffect: public DashPathEffect getDashPathEffect ( ) { return mDashPathEffect ;
onGameStarted: public void onGameStarted ( String roomId , String slot , String key , String host , ArrayList < Integer > ports , JSONObject roomSettings ) { if ( Log . INFO ) Log . info ( "Game started!" ) ; Gdx . app . postRunnable ( ( ) ->
estimateFee: public Single < lnrpc . LightningOuterClass . EstimateFeeResponse > estimateFee ( lnrpc . LightningOuterClass . EstimateFeeRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . estimateFee ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
delete: public void delete ( Integer subscriptionId , ApiOptions options ) throws ApiErrorException , ConnectionException { Map < String , Object > query = options . all ( ) ; this . request ( "delete" , this . resolvePath ( "/webhooks/subscriptions/%s" , subscriptionId ) , query , null , null ) ;
renderIcon: public void renderIcon ( WidgetGroup to ) { if ( getItems ( ) . size == 0 ) return ; Content item = getItems ( ) . first ( ) ; if ( item == null ) return ; IconComponent iconComponent = item . getComponent ( IconComponent . class ) ; if ( iconComponent != null ) { TextureRegion bigIcon = iconComponent . getIcon ( "big-icon" , null ) ; if ( bigIcon != null ) { Image iconImage = new Image ( bigIcon ) ; iconImage . setTouchable ( Touchable . disabled ) ; iconImage . setScaling ( Scaling . none ) ; iconImage . setFillParent ( true ) ; to . addActor ( iconImage ) ; if ( getItems ( ) . size > 1 ) { SequenceAction seq = Actions . sequence ( ) ; for ( Content content : getItems ( ) ) { IconComponent ii = content . getComponent ( IconComponent . class ) ; if ( ii == null ) continue ; TextureRegion bi = ii . getIcon ( "big-icon" , null ) ; if ( bi == null ) continue ; seq . addAction ( Actions . delay ( 1.0f ) ) ; seq . addAction ( Actions . run ( ( ) -> iconImage . setDrawable ( new TextureRegionDrawable ( bi ) ) ) ) ; } iconImage . addAction ( Actions . repeat ( RepeatAction . FOREVER , seq ) ) ; } return ; } } if ( item instanceof Instrument ) { Table holder = new Table ( ) ; holder . setTouchable ( Touchable . disabled ) ; holder . setFillParent ( true ) ; Instrument instrument = ( ( Instrument ) item ) ; ContentImage . RenderInstrument ( holder , instrument , instrument . getDefaultSkin ( ) ) ; to . addActor ( holder ) ; return ; } if ( iconComponent == null ) return ; TextureRegion icon = iconComponent . getIcon ( "icon" ) ; if ( icon == null ) return ; Image iconImage = new Image ( icon ) ; iconImage . setTouchable ( Touchable . disabled ) ; iconImage . setScaling ( Scaling . none ) ; iconImage . setFillParent ( true ) ; if ( getItems ( ) . size > 1 ) { SequenceAction seq = Actions . sequence ( ) ; for ( Content content : getItems ( ) ) { IconComponent ii = content . getComponent ( IconComponent . class ) ; if ( ii == null ) continue ; TextureRegion bi = ii . getIcon ( "icon" , null ) ; if ( bi == null ) continue ; seq . addAction ( Actions . delay ( 1.0f ) ) ; seq . addAction ( Actions . run ( ( ) -> iconImage . setDrawable ( new TextureRegionDrawable ( bi ) ) ) ) ; } iconImage . addAction ( Actions . repeat ( RepeatAction . FOREVER , seq ) ) ; } to . addActor ( iconImage ) ;
getTenantedResource4: public void getTenantedResource4 ( ) { Mockito . when ( request . getServletPath ( ) ) . thenReturn ( _HTML_ORGANIZATION + "/232" + _ORGANIZATION + _SETTINGS ) ; Mockito . when ( request . getRequestURI ( ) ) . thenReturn ( _HTML_ORGANIZATION + "/232" + _ORGANIZATION + _SETTINGS ) ; TenantResolver . TenantedResource t = urlHelper . getTenantedResource ( request ) ; assertEquals ( Long . valueOf ( 232L ) , t . organizationId ) ; assertEquals ( "organization" , t . entityKey ) ;
get: public Order get ( String shopKey , String countryCode , Identifier orderIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Order > responseModel = ( Class < Order > ) ( Class < ? > ) Order . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/countries/%s/orders/%s" , shopKey , countryCode , orderIdentifier ) , query , null , responseModel ) ;
isNearBottomIgnoringTouch: public final boolean isNearBottomIgnoringTouch ( ) { return ( this . scrollState$1 & 4 ) != 0 ;
getResetX: public static double getResetX ( Context context , double x ) { double ratioX = ( double ) 375 / getScreenWidth ( context ) ; return x / ratioX ;
isDropEnabled: public boolean isDropEnabled ( PlayerData playerData ) { PlayState ps = getPlayState ( ) ; if ( ! ( ps instanceof ServerPSGame ) ) return false ; GameMode mode = ( ( ServerPSGame ) ps ) . getMode ( ) ; if ( mode == null ) return false ; return ( ( ServerRealization ) mode . getRealization ( ) ) . isDeathDropEnabled ( playerData ) ;
trackPaymentV2: public Observable < lnrpc . LightningOuterClass . Payment > trackPaymentV2 ( routerrpc . RouterOuterClass . TrackPaymentRequest request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . oBTrackPaymentV2 ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
hasGlobalPrivilege: public boolean hasGlobalPrivilege ( Privilege p ) { return hasGlobalPrivilege ( p , globalPrivileges ) ;
onComplete: public void onComplete ( ) { endResponse ( ) ;
encode: public static String encode ( byte [ ] in ) { int length = ( in . length + 2 ) * 4 / 3 ; byte [ ] out = new byte [ length ] ; int index = 0 , end = in . length - in . length % 3 ; for ( int i = 0 ; i < end ; i += 3 ) { out [ index ++ ] = map [ ( in [ i ] & 0xff ) > > 2 ] ; out [ index ++ ] = map [ ( ( in [ i ] & 0x03 ) << 4 ) | ( ( in [ i + 1 ] & 0xff ) > > 4 ) ] ; out [ index ++ ] = map [ ( ( in [ i + 1 ] & 0x0f ) << 2 ) | ( ( in [ i + 2 ] & 0xff ) > > 6 ) ] ; out [ index ++ ] = map [ ( in [ i + 2 ] & 0x3f ) ] ; } switch ( in . length % 3 ) { case 1 : out [ index ++ ] = map [ ( in [ end ] & 0xff ) > > 2 ] ; out [ index ++ ] = map [ ( in [ end ] & 0x03 ) << 4 ] ; out [ index ++ ] = '=' ; out [ index ++ ] = '=' ; break ; case 2 : out [ index ++ ] = map [ ( in [ end ] & 0xff ) > > 2 ] ; out [ index ++ ] = map [ ( ( in [ end ] & 0x03 ) << 4 ) | ( ( in [ end + 1 ] & 0xff ) > > 4 ) ] ; out [ index ++ ] = map [ ( ( in [ end + 1 ] & 0x0f ) << 2 ) ] ; out [ index ++ ] = '=' ; break ; } return new String ( out , 0 , index , StandardCharsets . US_ASCII ) ;
hasBadge: public boolean hasBadge ( UserProfile profile , Involve involve ) { return profile . hasBadge ( "battle-pass-tasks-daily" ) || profile . hasBadge ( "battle-pass-tasks-weekly" ) || profile . hasBadge ( "battle-pass-rewards" ) ;
exportToFile: public ComponentEntity exportToFile ( ComponentEntity entity ) { debug ( "[processEntityToYaml]" ) ; EntityToYamlConverter < Object , Object > converter = ( EntityToYamlConverter < Object , Object > ) converterMap . get ( entity . getClass ( ) ) ; if ( converter == null ) { throw new IllegalArgumentException ( "No parent converter found for entity " + entity . getClass ( ) . getName ( ) ) ; } converter . saveToFile ( entity ) ; return entity ;
setIndexString: public void setIndexString ( String indexString ) { this . indexString = indexString ;
getConsumerClassName: public String getConsumerClassName ( boolean userFriendly ) { if ( userFriendly ) { return NameHelper . getClassName ( getConsumerClassName ( ) ) ; } return getConsumerClassName ( ) ;
initCustom: public void initCustom ( ) { String parallaxCustom = getCustom ( "parallax" ) ; if ( parallaxCustom == null ) parallaxCustom = getCustom ( "PARALLAX" ) ; if ( parallaxCustom != null ) { Parallax parallax = ( Parallax ) BrainOut . ContentMgr . get ( parallaxCustom ) ; if ( parallax != null ) { setParallax ( parallax . getData ( this ) ) ; } else { setParallax ( null ) ; } } String musicListCustom = getCustom ( "music-list" ) ; if ( musicListCustom == null ) musicListCustom = getCustom ( "musicList" ) ; if ( musicListCustom != null ) { musicList = ( ( MusicList ) BrainOut . ContentMgr . get ( musicListCustom ) ) ; BrainOutClient . MusicMng . stopMusic ( ) ; playMusic ( ) ; } String ambientLightCustom = getCustom ( "ambient-light" ) ; if ( ambientLightCustom == null ) ambientLightCustom = getCustom ( "ambientLight" ) ; if ( ambientLightCustom != null ) { try { float f = Float . valueOf ( ambientLightCustom ) ; ambientLight . set ( 0 , 0 , 0 , f ) ; } catch ( NumberFormatException e ) { try { ambientLight . set ( Color . valueOf ( ambientLightCustom ) ) ; } catch ( StringIndexOutOfBoundsException ignored ) { } } } if ( lights != null )
toString: public String toString ( ) { return "JRPCClient{" +
delete: public void delete ( String shopKey , String countryCode , Integer emailKeyId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/emails/keys/%s" , shopKey , countryCode , emailKeyId ) , null , null , null ) ;
hasRender: public boolean hasRender ( ) { return false ;
getLastEdit: public String getLastEdit ( ) { return lastEdit ;
preferableShootMode: protected int preferableShootMode ( Array < Weapon . ShootMode > shootModes ) { String weaponId = getData ( ) . getWeapon ( ) . getID ( ) ; Weapon . ShootMode pref = BrainOutClient . ClientController . getUserProfile ( ) . getPreferableShootMode ( weaponId ) ; int index = shootModes . indexOf ( pref , false ) ; return index >= 0 ? index : 0 ;
mav: public < O > O mav ( ResultAndModelFunction < O , R > forSuccessAndError ) { return mav ( forSuccessAndError , forSuccessAndError ) ;
getPoints: public int getPoints ( Team team ) { return ( int ) Math . ceil ( this . points . get ( team , 0.0f ) ) ;
setFormSize: public void setFormSize ( float formSize ) { mFormSize = formSize ;
getContentView: protected int getContentView ( ) { return R . layout . activity_webview ;
getLayoutId: public int getLayoutId ( ) { return R . layout . activity_capture ;
getLevel: public int getLevel ( String kind , int def ) { if ( profile != null ) { return profile . getLevel ( kind , def ) ; } return def ;
getIconId: No method body
getLastName: public String getLastName ( ) { return lastName ;
update: public void update ( ) { StringBuilder strBuilder = new StringBuilder ( ) ; for ( String event : autoControl . eventLog ) { strBuilder . append ( event ) ; strBuilder . append ( "\n" ) ; } jTextArea1 . setText ( strBuilder . toString ( ) ) ;
setValue: public void setValue ( int value ) { int val = ( ( value & 0x000000FF ) << 16 ) + ( ( value & 0x0000FF00 ) > > > 8 ) + ( ( value & 0x00FF0000 ) << 8 ) + ( ( value & 0xFF000000 ) > > > 16 ) ; this . value = val ^ 0xA9B8C7D6 ;
setTimeStamp: public void setTimeStamp ( long timeStamp ) { this . timeStamp = timeStamp ;
getNextBilling: public LocalDateTime getNextBilling ( ) { return nextBilling ;
getTmpFile: private File getTmpFile ( boolean create ) throws IOException { String tmpFileStringPath = testObject . getFileDirectory ( ) + File . separator + "file.tmp" ; File fileToCopy = new File ( tmpFileStringPath ) ; if ( create ) { Files . write ( fileToCopy . toPath ( ) , "temp_data" . getBytes ( ) ) ; } return fileToCopy ;
getDescription: public LocalizedString getDescription ( ) { return description ; }
registerBlockEpochNtfn: public Observable < chainrpc . Chainnotifier . BlockEpoch > registerBlockEpochNtfn ( chainrpc . Chainnotifier . BlockEpoch request ) { return DefaultObservable . createDefault ( emitter -> asyncStub . registerBlockEpochNtfn ( request , new RemoteObdStreamObserver < > ( emitter ) ) ) ;
getDecimals: public static int getDecimals ( float number ) { float i = roundToNextSignificant ( number ) ; if ( Float . isInfinite ( i ) ) return 0 ; return ( int ) Math . ceil ( - Math . log10 ( i ) ) + 2 ;
testCreateOrUpdateCustomDataForKey: public void testCreateOrUpdateCustomDataForKey ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/BrandCreateOrUpdateCustomDataForKeyRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . brands ( ) . createOrUpdateCustomDataForKey ( 1 , "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/BrandCreateOrUpdateCustomDataForKeyResponse.json" ) ; assertThatJson ( expectedResponseJson )
setPinned: private static void setPinned ( WidgetChannelsList fragment , Long id , boolean pin ) { synchronized ( ChatPins . class ) {
genRefParams: public static String genRefParams ( Table t , Map < Table , List < Column > > map ) { StringBuilder paramsBuilder = new StringBuilder ( t . name + " obj, " ) ; map . forEach ( ( t1 , columns ) -> { if ( t1 == t ) return ; for ( Column col : columns ) { String paramName = getParamName ( t1 , col ) ; paramsBuilder . append ( "Class<" + t1 . name + "> " + paramName + ", boolean remove_" + paramName + ", " ) ; } } ) ; String params = paramsBuilder . toString ( ) ; if ( params . endsWith ( ", " ) ) params = params . substring ( 0 , params . length ( ) - 2 ) ; return params ;
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCountryCreateRequest.json" ) ; ShopCountry requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , ShopCountry . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ShopCountry responseEntity = this . api . shopCountries ( ) . create ( "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCountryCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
inc: public void inc ( ) { setValue ( getValue ( ) + 1 ) ;
update: public void update ( ) { checkAlarms ( ) ; if ( this . isVisible ( ) ) {
received: public boolean received ( final PlaceBlockMsg msg ) { received ( ( PlayerMoveMsg ) msg ) ; if ( playerData != null && playerController != null ) { BrainOutServer . PostRunnable ( ( ) -> { if ( playerData == null ) return ; PlayerOwnerComponent poc = playerData . getComponent ( PlayerOwnerComponent . class ) ; InstrumentData currentInstrument = poc . getCurrentInstrument ( ) ; if ( ! ( currentInstrument instanceof PlaceBlockData ) ) return ; Block block ; if ( currentInstrument instanceof BoxData ) { block = ( ( Box ) ( ( BoxData ) currentInstrument ) . getPlaceBlock ( ) ) . getBlock ( ) ; } else { Content blockContent = BrainOut . ContentMgr . get ( msg . blockObject ) ; if ( ! ( blockContent instanceof Block ) ) return ; block = ( ( Block ) blockContent ) ; } final ConsumableRecord record = poc . getConsumableContainer ( ) . get ( msg . recordId ) ; if ( record != null ) { playerController . placeBlock ( block , record , msg . layer , msg . placeX , msg . placeY ) ; } } ) ; } return true ;
getDataSet: public IPieDataSet getDataSet ( ) { return mDataSets . get ( 0 ) ;
getProfileRU: private int getProfileRU ( ) { return BrainOutClient . ClientController . getUserProfile ( ) . getInt ( "ru" , 0 ) ;
release: public void release ( ) { super . release ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . chat , this ) ;
getDefaultSkin: public Skin getDefaultSkin ( ) { return defaultSkin ;
func: public float func ( float x , float y , float coef ) { ActiveData it = ( ( ActiveData ) getComponentObject ( ) ) ; float dist = Math . abs ( it . getX ( ) - x ) ; float max = getContentComponent ( ) . getDistance ( ) * coef ; if ( dist > max ) return 0 ; return ( 1.0f - dist / max ) ;
isConcurrentResponseProcessing: boolean isConcurrentResponseProcessing ( ) { return concurrentResponseProcessing ;
createOrganizationNotificationWithSubject: public Notification createOrganizationNotificationWithSubject ( Notification . NotificationType type , String subject , String message , Long organizationId , String requiredPrivilege , String attachmentURL , boolean propagate , boolean hiddenFromAuthor ) { debug ( "[createOrganizationNotificationWithSubject]" ) ; Notification notification = new Notification ( subject , message , type , organizationId , requiredPrivilege , propagate , hiddenFromAuthor ) ; notification . setAttachmentURL ( attachmentURL ) ; Notification n = notificationRepository . save ( notification ) ; services . applicationEvent . emitEvent ( ApplicationEvent . NOTIFICATION_CREATED , new NotificationDto ( notification ) ) ; return n ;
getShopCart: public ShopCart getShopCart ( ) { return shopCart ;
getChartWidth: public float getChartWidth ( ) { return mChartWidth ;
hasRender: public boolean hasRender ( ) { return false ;
getContent: public String getContent ( FrontendResource entity ) { return entity . getContent ( ) ;
getRoleId: public Long getRoleId ( ) { return roleId ;
removeForm: public boolean removeForm ( Long formId ) { debug ( "[removeForm]" ) ; Form form = repositories . unsecure . form . findOne ( formId ) ; if ( form != null ) { return unregisterForm ( form ) ; } return false ;
setPlayerData: public void setPlayerData ( PlayerData playerData ) { this . playerData = playerData ;
checkBorderAndCenterWhenScale: private void checkBorderAndCenterWhenScale ( ) { RectF rect = getMatrixRectF ( ) ; float delaX = 0 ; float delaY = 0 ; int width = getWidth ( ) ; int height = getHeight ( ) ; if ( rect . width ( ) >= width ) { if ( rect . left > 0 ) { delaX = - rect . left ; } if ( rect . right < width ) { delaX = width - rect . right ; } } if ( rect . height ( ) >= height ) { if ( rect . top > 0 ) { delaY = - rect . top ; } if ( rect . bottom < height ) { delaY = height - rect . bottom ; } } if ( rect . width ( ) < width ) { delaX = width / 2 - rect . right + rect . width ( ) / 2f ; } if ( rect . height ( ) < height ) { delaY = height / 2 - rect . bottom + rect . height ( ) / 2f ; } mMatrix . postTranslate ( delaX , delaY ) ;
isBrainPassActive: public boolean isBrainPassActive ( ) { return this . bp != null && getProfile ( ) . hasItem ( BrainOut . ContentMgr . get ( this . bp , BattlePass . class ) , false ) ;
statAdded: public void statAdded ( String stat , float amount ) { if ( stat != null && stat . equals ( getTargetStat ( ) ) )
init: public static < A1 , A2 , A3 , CP > Flow < Tuple3 < A1 , A2 , A3 > , Tuple3 < A1 , A2 , A3 > , CP > init ( CP services , A1 a1 , A2 a2 , A3 a3 ) { return new Flow < > ( initParamsMap ( null ) , services , a -> Tuples . of ( a1 , a2 , a3 ) ) ;
getSubscriber: public SingleSubscriberResponse getSubscriber ( final String subscriberId ) throws IOException , NovuNetworkException { try {
update: public void update ( float dt ) { duration -= dt ;
draw: public void draw ( Skeleton skeleton ) { if ( skeleton == null ) throw new IllegalArgumentException ( "skeleton cannot be null." ) ; Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; int srcFunc = premultipliedAlpha ? GL20 . GL_ONE : GL20 . GL_SRC_ALPHA ; Gdx . gl . glBlendFunc ( srcFunc , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; ShapeRenderer shapes = this . shapes ; Array < Bone > bones = skeleton . getBones ( ) ; Array < Slot > slots = skeleton . getSlots ( ) ; shapes . begin ( ShapeType . Filled ) ; if ( drawBones ) { for ( int i = 0 , n = bones . size ; i < n ; i ++ ) { Bone bone = bones . get ( i ) ; if ( bone . parent == null || ! bone . active ) continue ; float length = bone . data . length , width = boneWidth ; if ( length == 0 ) { length = 8 ; width /= 2 ; shapes . setColor ( boneOriginColor ) ; } else shapes . setColor ( boneLineColor ) ; float x = length * bone . a + bone . worldX ; float y = length * bone . c + bone . worldY ; shapes . rectLine ( bone . worldX , bone . worldY , x , y , width * scale ) ; } shapes . x ( skeleton . getX ( ) , skeleton . getY ( ) , 4 * scale ) ; } if ( drawPoints ) { shapes . setColor ( boneOriginColor ) ; for ( int i = 0 , n = slots . size ; i < n ; i ++ ) { Slot slot = slots . get ( i ) ; Attachment attachment = slot . attachment ; if ( ! ( attachment instanceof PointAttachment ) ) continue ; PointAttachment point = ( PointAttachment ) attachment ; point . computeWorldPosition ( slot . getBone ( ) , temp1 ) ; temp2 . set ( 8 , 0 ) . rotate ( point . computeWorldRotation ( slot . getBone ( ) ) ) ; shapes . rectLine ( temp1 , temp2 , boneWidth / 2 * scale ) ; } } shapes . end ( ) ; shapes . begin ( ShapeType . Line ) ; if ( drawRegionAttachments ) { shapes . setColor ( attachmentLineColor ) ; for ( int i = 0 , n = slots . size ; i < n ; i ++ ) { Slot slot = slots . get ( i ) ; Attachment attachment = slot . attachment ; if ( attachment instanceof RegionAttachment ) { RegionAttachment region = ( RegionAttachment ) attachment ; float [ ] vertices = this . vertices . items ; region . computeWorldVertices ( slot . getBone ( ) , vertices , 0 , 2 ) ; shapes . line ( vertices [ 0 ] , vertices [ 1 ] , vertices [ 2 ] , vertices [ 3 ] ) ; shapes . line ( vertices [ 2 ] , vertices [ 3 ] , vertices [ 4 ] , vertices [ 5 ] ) ; shapes . line ( vertices [ 4 ] , vertices [ 5 ] , vertices [ 6 ] , vertices [ 7 ] ) ; shapes . line ( vertices [ 6 ] , vertices [ 7 ] , vertices [ 0 ] , vertices [ 1 ] ) ; } } } if ( drawMeshHull || drawMeshTriangles ) { for ( int i = 0 , n = slots . size ; i < n ; i ++ ) { Slot slot = slots . get ( i ) ; Attachment attachment = slot . attachment ; if ( ! ( attachment instanceof MeshAttachment ) ) continue ; MeshAttachment mesh = ( MeshAttachment ) attachment ; float [ ] vertices = this . vertices . setSize ( mesh . getWorldVerticesLength ( ) ) ; mesh . computeWorldVertices ( slot , 0 , mesh . getWorldVerticesLength ( ) , vertices , 0 , 2 ) ; short [ ] triangles = mesh . getTriangles ( ) ; int hullLength = mesh . getHullLength ( ) ; if ( drawMeshTriangles ) { shapes . setColor ( triangleLineColor ) ; for ( int ii = 0 , nn = triangles . length ; ii < nn ; ii += 3 ) { int v1 = triangles [ ii ] * 2 , v2 = triangles [ ii + 1 ] * 2 , v3 = triangles [ ii + 2 ] * 2 ; shapes . triangle ( vertices [ v1 ] , vertices [ v1 + 1 ] , vertices [ v2 ] , vertices [ v2 + 1 ] , vertices [ v3 ] , vertices [ v3 + 1 ] ) ; } } if ( drawMeshHull && hullLength > 0 ) { shapes . setColor ( attachmentLineColor ) ; float lastX = vertices [ hullLength - 2 ] , lastY = vertices [ hullLength - 1 ] ; for ( int ii = 0 , nn = hullLength ; ii < nn ; ii += 2 ) { float x = vertices [ ii ] , y = vertices [ ii + 1 ] ; shapes . line ( x , y , lastX , lastY ) ; lastX = x ; lastY = y ; } } } } if ( drawBoundingBoxes ) { SkeletonBounds bounds = this . bounds ; bounds . update ( skeleton , true ) ; shapes . setColor ( aabbColor ) ; shapes . rect ( bounds . getMinX ( ) , bounds . getMinY ( ) , bounds . getWidth ( ) , bounds . getHeight ( ) ) ; Array < FloatArray > polygons = bounds . getPolygons ( ) ; Array < BoundingBoxAttachment > boxes = bounds . getBoundingBoxes ( ) ; for ( int i = 0 , n = polygons . size ; i < n ; i ++ ) { FloatArray polygon = polygons . get ( i ) ; shapes . setColor ( boxes . get ( i ) . getColor ( ) ) ; shapes . polygon ( polygon . items , 0 , polygon . size ) ; } } if ( drawClipping ) { for ( int i = 0 , n = slots . size ; i < n ; i ++ ) { Slot slot = slots . get ( i ) ; Attachment attachment = slot . attachment ; if ( ! ( attachment instanceof ClippingAttachment ) ) continue ; ClippingAttachment clip = ( ClippingAttachment ) attachment ; int nn = clip . getWorldVerticesLength ( ) ; float [ ] vertices = this . vertices . setSize ( nn ) ; clip . computeWorldVertices ( slot , 0 , nn , vertices , 0 , 2 ) ; shapes . setColor ( clip . getColor ( ) ) ; for ( int ii = 2 ; ii < nn ; ii += 2 ) shapes . line ( vertices [ ii - 2 ] , vertices [ ii - 1 ] , vertices [ ii ] , vertices [ ii + 1 ] ) ; shapes . line ( vertices [ 0 ] , vertices [ 1 ] , vertices [ nn - 2 ] , vertices [ nn - 1 ] ) ; } } if ( drawPaths ) { for ( int i = 0 , n = slots . size ; i < n ; i ++ ) { Slot slot = slots . get ( i ) ; Attachment attachment = slot . attachment ; if ( ! ( attachment instanceof PathAttachment ) ) continue ; PathAttachment path = ( PathAttachment ) attachment ; int nn = path . getWorldVerticesLength ( ) ; float [ ] vertices = this . vertices . setSize ( nn ) ; path . computeWorldVertices ( slot , 0 , nn , vertices , 0 , 2 ) ; Color color = path . getColor ( ) ; float x1 = vertices [ 2 ] , y1 = vertices [ 3 ] , x2 = 0 , y2 = 0 ; if ( path . getClosed ( ) ) { shapes . setColor ( color ) ; float cx1 = vertices [ 0 ] , cy1 = vertices [ 1 ] , cx2 = vertices [ nn - 2 ] , cy2 = vertices [ nn - 1 ] ; x2 = vertices [ nn - 4 ] ; y2 = vertices [ nn - 3 ] ; shapes . curve ( x1 , y1 , cx1 , cy1 , cx2 , cy2 , x2 , y2 , 32 ) ; shapes . setColor ( Color . LIGHT_GRAY ) ; shapes . line ( x1 , y1 , cx1 , cy1 ) ; shapes . line ( x2 , y2 , cx2 , cy2 ) ; } nn -= 4 ; for ( int ii = 4 ; ii < nn ; ii += 6 ) { float cx1 = vertices [ ii ] , cy1 = vertices [ ii + 1 ] , cx2 = vertices [ ii + 2 ] , cy2 = vertices [ ii + 3 ] ; x2 = vertices [ ii + 4 ] ; y2 = vertices [ ii + 5 ] ; shapes . setColor ( color ) ; shapes . curve ( x1 , y1 , cx1 , cy1 , cx2 , cy2 , x2 , y2 , 32 ) ; shapes . setColor ( Color . LIGHT_GRAY ) ; shapes . line ( x1 , y1 , cx1 , cy1 ) ; shapes . line ( x2 , y2 , cx2 , cy2 ) ; x1 = x2 ; y1 = y2 ; } } } shapes . end ( ) ; shapes . begin ( ShapeType . Filled ) ; if ( drawBones ) { shapes . setColor ( boneOriginColor ) ; for ( int i = 0 , n = bones . size ; i < n ; i ++ ) { Bone bone = bones . get ( i ) ; if ( ! bone . active ) continue ; shapes . circle ( bone . worldX , bone . worldY , 3 * scale , 8 ) ; } } if ( drawPoints ) { shapes . setColor ( boneOriginColor ) ; for ( int i = 0 , n = slots . size ; i < n ; i ++ ) { Slot slot = slots . get ( i ) ; Attachment attachment = slot . attachment ; if ( ! ( attachment instanceof PointAttachment ) ) continue ; PointAttachment point = ( PointAttachment ) attachment ; point . computeWorldPosition ( slot . getBone ( ) , temp1 ) ; shapes . circle ( temp1 . x , temp1 . y , 3 * scale , 8 ) ; } } shapes . end ( ) ;
lockRender: public boolean lockRender ( ) { return super . lockRender ( ) ;
testUpdate: public void testUpdate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/VoucherUpdateRequest.json" ) ; Voucher requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Voucher . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Voucher responseEntity = this . api . vouchers ( ) . update ( "acme" , "acme" , 1 , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/VoucherUpdateResponse.json" ) ; assertThatJson ( expectedResponseJson )
setEvent: public void setEvent ( String event ) { this . event = event ;
getBinaryStream: public InputStream getBinaryStream ( ) throws SQLException { return new ByteArrayInputStream ( data ) ;
switchState: public void switchState ( GameState gameState ) { while ( hasState ( ) ) { popState ( ) ; } pushState ( gameState ) ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { regen2ActionPerformed ( evt ) ;
arrayToList: private List < T > arrayToList ( T [ ] array ) { List < T > list = new ArrayList < > ( ) ; for ( T set : array ) { list . add ( set ) ; } return list ;
release: public void release ( ) { if ( mBasePopWindow != null ) {
getScale: public float getScale ( ) { return scale ;
setBuyerCompanyCountry: public void setBuyerCompanyCountry ( String buyerCompanyCountry ) { this . buyerCompanyCountry = buyerCompanyCountry ;
getComponent: public BlockHealthComponentData getComponent ( ComponentObject componentObject ) { return new BlockHealthComponentData ( ( ( BlockData ) componentObject ) , this ) ;
getSpawnX: public float getSpawnX ( ) { return getX ( ) ;
removeFirst: void removeFirst ( ) { l . addFirst ( "nicola" ) ; l . addFirst ( "marco" ) ; l . addFirst ( "giovanni" ) ; assertEquals ( "giovanni" , l . removeFirst ( ) ) ;
getFillLinePosition: public float getFillLinePosition ( ILineDataSet dataSet , LineDataProvider dataProvider ) { float fillMin = 0f ; float chartMaxY = dataProvider . getYChartMax ( ) ; float chartMinY = dataProvider . getYChartMin ( ) ; LineData data = dataProvider . getLineData ( ) ; if ( dataSet . getYMax ( ) > 0 && dataSet . getYMin ( ) < 0 ) { fillMin = 0f ; } else { float max , min ; if ( data . getYMax ( ) > 0 ) max = 0f ; else max = chartMaxY ; if ( data . getYMin ( ) < 0 ) min = 0f ; else min = chartMinY ; fillMin = dataSet . getYMin ( ) >= 0 ? min : max ; } return fillMin ;
setImageResource: public ViewHolder setImageResource ( int viewId , int resourceId ) { ImageView imageView = getView ( viewId ) ; imageView . setImageResource ( resourceId ) ; return this ;
toString: public String toString ( ) { return getClass ( ) . getName ( ) ;
requiredArgs: public int requiredArgs ( ) { return 0 ;
getInterpolation: public float getInterpolation ( float input ) { return - ( float ) Math . cos ( input * ( Math . PI / 2f ) ) + 1f ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------startOnError------------------" + e . getMessage ( ) ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( new Runnable ( ) {
renderQuestTree: private void renderQuestTree ( Tree tree ) { selectedQuestInfo . clear ( ) ; selectedQuest . clear ( ) ; Quest currentQuest = tree . getCurrentQuest ( userProfile , BrainOutClient . ClientController . getMyAccount ( ) ) ; if ( currentQuest == null ) { return ; } if ( currentQuest instanceof DailyQuest ) { selectedQuestInfo . add ( new Label ( L . get ( "MENU_DAILY_MISSION" ) , BrainOutClient . Skin , "title-small" ) ) ; Image img = new Image ( BrainOutClient . Skin , "icon-quest-daily" ) ; img . setScaling ( Scaling . none ) ; selectedQuestInfo . add ( img ) ; } else if ( currentQuest . isPerTaskReward ( ) ) { selectedQuestInfo . add ( new Label ( L . get ( "MENU_QUEST_CHALLENGE" ) , BrainOutClient . Skin , "title-small" ) ) ; selectedQuestInfo . add ( new Image ( BrainOutClient . Skin , "icon-tag-level" ) ) ; } else if ( currentQuest . isCoop ( ) ) { selectedQuestInfo . add ( new Label ( L . get ( "MENU_QUEST_COOP" ) , BrainOutClient . Skin , "title-small" ) ) ; selectedQuestInfo . add ( new Image ( BrainOutClient . Skin , "icon-coop" ) ) ; } Table contents = new Table ( BrainOutClient . Skin ) ; contents . setBackground ( "form-default" ) ; Table page = new Table ( BrainOutClient . Skin ) ; page . align ( Align . top | Align . center ) ; renderQuestPage ( page , tree , currentQuest ) ; ScrollPane pane = new ScrollPane ( page , BrainOutClient . Skin , "scroll-default" ) ; pane . setFadeScrollBars ( false ) ; setScrollFocus ( pane ) ; contents . add ( pane ) . expand ( ) . fill ( ) . row ( ) ; selectedQuest . add ( contents ) . height ( getQuestsPanelHeight ( ) ) . expandX ( ) . fillX ( ) . row ( ) ; { Label joinKind = new Label ( getJoinTitleBeforeButtons ( currentQuest ) , BrainOutClient . Skin , "title-small" ) ; joinKind . setAlignment ( Align . center ) ; joinKind . setWrap ( true ) ; selectedQuest . add ( joinKind ) . expandX ( ) . fillX ( ) . pad ( 16 ) . padLeft ( 64 ) . padRight ( 64 ) . row ( ) ; } renderQuestActionButtons ( selectedQuest ) ;
shouldInterceptRequest: No method body
delete: public void delete ( List < ProductSorting > model ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/product-sortings" ) , null , null , null , model ) ;
allowEffect: private boolean allowEffect ( String dimension , ActiveData at ) { ServerMap map = Map . Get ( dimension , ServerMap . class ) ; if ( map == null ) return false ; ChunkData chunk = map . getChunkAt ( ( int ) at . getX ( ) , ( int ) at . getY ( ) ) ; return chunk == null || ! chunk . hasFlag ( ChunkData . ChunkFlag . hideOthers ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
hasRender: public boolean hasRender ( ) { return false ;
getUserJobFromLocal: public static String getUserJobFromLocal ( Context context ) { return getString ( SETTINGS , context , KEY_USER_JOB ) ;
getMixScaleY: public float getMixScaleY ( ) { return mixScaleY ;
isCancellable: public boolean isCancellable ( ) { return cancellable ;
getNew: No method body
resetAccessToken: public void resetAccessToken ( ) { this . accessToken = "" ;
release: public void release ( ) { this . playerData = null ;
testRun: void testRun ( ) { final AzureOpenAiChatCompletionsChain chain = new AzureOpenAiChatCompletionsChain ( "my-azure-resource-name" , "gpt-35-turbo" , "2023-05-15" , "Hello, this is ${name}. What was my name again?" , new OpenAiChatCompletionsParameters ( ) , System . getenv ( "AZURE_OPENAI_API_KEY" ) ) ; final String name = "Manuel" ; final String result = chain . run ( Collections . singletonMap ( "name" , name ) ) ; LOGGER . info ( result ) ; assertNotNull ( result , "got no result from OpenAiChatCompletionsChain" ) ; assertTrue ( result . contains ( name ) , "The answer did not contain the name" ) ;
getOldValue: public Long getOldValue ( ) { return oldValue ;
write: public void write ( Json json ) { json . writeValue ( "owner" , owner ) ; json . writeValue ( "name" , name ) ; json . writeValue ( "payload" , payload . write ( ) . toString ( ) ) ;
received: public boolean received ( final PartyStartedMsg msg ) { Gdx . app . postRunnable ( ( ) -> { JSONObject settings = new JSONObject ( msg . settings ) ; Matchmaking . Connect ( msg . key , msg . host , msg . ports , settings , new Runnable ( ) { @ Override public void run ( ) { BrainOutClient . ClientController . setState ( new CSError ( L . get ( "MENU_FAILED_TO_CONNECT" ) , ( ) -> BrainOutClient . ClientController . setState ( new CSGetRegions ( ) ) ) ) ; } } ) ; } ) ; return true ;
registerHtmlCrudController: default CRUDControllerConfiguration registerHtmlCrudController ( FrontendMappingDefinition definition , ScopedSecureRepository repository , String readPrivilege , String writePrivilege ) { return registerHtmlCrudController ( definition , repository , PrivilegeHelper . valueOfString ( readPrivilege ) , PrivilegeHelper . valueOfString ( writePrivilege ) ) ;
checkBlock: private void checkBlock ( Map map , BlockData blockData , int x , int y , float loss ) { final float powerPass = power - loss ; BlockData check = map . getBlock ( x , y , Constants . Layers . BLOCK_LAYER_FOREGROUND ) ; if ( check instanceof ConcreteBD ) return ; BlockData blockAt = map . getBlock ( x , y , Constants . Layers . BLOCK_LAYER_UPPER ) ; if ( blockAt == null )
setPostSavePrivilege: public CRUDControllerConfiguration < D , E , F > setPostSavePrivilege ( PrivilegeBase postSavePrivilege ) { this . postSavePrivilege = postSavePrivilege ; return this ;
anonymize: public void anonymize ( String shopKey , String countryCode , Identifier customerIdentifier ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/anonymize" , shopKey , countryCode , customerIdentifier ) , null , null , null ) ;
updateSubscriberOnlineStatus: public SingleSubscriberResponse updateSubscriberOnlineStatus ( final UpdateSubscriberOnlineStatusRequest request , final String subscriberId ) throws IOException , NovuNetworkException { try {
plural: public static String plural ( String str , long number ) { return number != 1 ? str + "s" : str ;
onValueChange: No method body
isRegisterApiCrudController: public boolean isRegisterApiCrudController ( ) { return registerApiCrudController ;
hasRender: public boolean hasRender ( ) { return false ;
getAngle: public float getAngle ( ) { return angle ;
getID: public ID getID ( ) { return ID . instrumentActivate ;
copy: public static void copy ( InputStream is , OutputStream os ) throws IOException { try
onReceive: public void onReceive ( @ NonNull MessageContext < Request > context ) { final Request request = context . getRequest ( ) ; final List < PlayerDTO > players = Bukkit . getOnlinePlayers ( ) . stream ( ) . map ( PlayerDTO :: fromPlayer ) . toList ( ) ; context . replyDirectly ( new Response ( request , players ) ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
renderBottomLine: protected Actor renderBottomLine ( ) { if ( userProfile == null || item == null ) return null ; int need = item . getLockItem ( ) . getParam ( ) + item . getLockItem ( ) . getDisplayOffset ( ) ; if ( need == 1 ) return null ; int have = Math . max ( item . getLockItem ( ) . getUnlockValue ( userProfile , 0 ) + item . getLockItem ( ) . getDisplayOffset ( ) , 0 ) ; Group progress = new Group ( ) ; ProgressBar scoreBar = new ProgressBar ( 0 , need , 1 , false , BrainOutClient . Skin , "progress-score" ) ; scoreBar . setBounds ( 0 , - 1 , 512 , ClientConstants . Menu . PlayerInfo . LABEL_HEIGHT ) ; scoreBar . setValue ( have ) ; progress . addActor ( scoreBar ) ; Label scoreValue = new Label ( String . valueOf ( have ) + " / " + need , BrainOutClient . Skin , "title-small" ) ; scoreValue . setAlignment ( Align . center ) ; scoreValue . setFillParent ( true ) ; progress . addActor ( scoreValue ) ; return progress ;
multiMessage: void multiMessage ( ) { AssertSubscriber < InvocationInput > assertSubscriber = AssertSubscriber . create ( Long . MAX_VALUE ) ; Multi . createFrom ( ) . items ( ProtoUtils . messageToByteString ( startMessage ( 1 , "my-key" , entry ( "key" , "value" ) ) ) , ProtoUtils . messageToByteString ( inputMessage ( "my-value" ) ) ) . subscribe ( new MessageDecoder ( assertSubscriber ) ) ; assertThat ( assertSubscriber . getItems ( ) )
checkEnemy: private boolean checkEnemy ( ) { GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; ServerFlagComponentData fg = flagData . getComponent ( ServerFlagComponentData . class ) ; float maxDistance = 64f ; Array < ActiveData > a = getMap ( ) . getActivesForTag ( Constants . ActiveTags . PLAYERS , activeData -> { if ( activeData == getPlayerData ( ) ) return false ; if ( ! ( activeData instanceof PlayerData ) ) return false ; if ( activeData . getOwnerId ( ) >= 0 && getPlayerData ( ) . getOwnerId ( ) >= 0 ) { if ( ! gameMode . isEnemies ( activeData . getOwnerId ( ) , getPlayerData ( ) . getOwnerId ( ) ) ) return false ; ServerTeamVisibilityComponentData tm = activeData . getComponent ( ServerTeamVisibilityComponentData . class ) ; if ( tm != null && ! tm . isVisibleTo ( getPlayerData ( ) . getOwnerId ( ) ) ) { return false ; } } else { if ( ! gameMode . isEnemies ( activeData . getTeam ( ) , getPlayerData ( ) . getTeam ( ) ) ) return false ; if ( ! getController ( ) . checkVisibility ( activeData , maxDistance , null ) ) return false ; } if ( Vector2 . dst2 ( activeData . getX ( ) , activeData . getY ( ) , getPlayerData ( ) . getX ( ) , getPlayerData ( ) . getY ( ) ) > fg . getTakingDistance ( ) * fg . getTakingDistance ( ) ) { if ( ! getController ( ) . checkVisibility ( activeData , maxDistance , null ) ) return false ; } return true ; } ) ; if ( a . size > 0 ) { pushTask ( new TaskShootTarget ( getStack ( ) , a . random ( ) , new RandomValue ( 0.5f , 1.0f ) , new RandomValue ( 0.05f , 0.1f ) ) ) ; return true ; } return false ;
getAlphaValueAsInt: protected int getAlphaValueAsInt ( ) { return Math . round ( colorWheelRenderOption . alpha * 255 ) ;
setVersion: public void setVersion ( String version ) { this . version = version ;
collatzSequence: void collatzSequence ( ) { assertIterableEquals ( List . of ( ) , CollatzSequence . collatzSequence ( 0 ) ) ; assertIterableEquals ( List . of ( 1L ) , CollatzSequence . collatzSequence ( 1 ) ) ; assertIterableEquals ( List . of ( 2L , 1L ) , CollatzSequence . collatzSequence ( 2 ) ) ; assertIterableEquals ( List . of ( 3L , 10L , 5L , 16L , 8L , 4L , 2L , 1L ) , CollatzSequence . collatzSequence ( 3 ) ) ; assertIterableEquals ( List . of ( 4L , 2L , 1L ) , CollatzSequence . collatzSequence ( 4 ) ) ;
newUser: public GameUser newUser ( ) { return new GameUser ( ) ;
check: No method body
getRunningDir: public String getRunningDir ( ) { return new File ( getClass ( ) . getProtectionDomain ( )
setupCharacterCounter: private void setupCharacterCounter ( ) { if ( inst . mediaTrayView != null ) {
onResponseSuccess: protected void onResponseSuccess ( UserInfoEntity result ) { saveUserInfo ( mContext , result ) ; if ( mCallback != null ) {
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { waterInVStop2ActionPerformed ( evt ) ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < ProductImage > responseEntity = this . api . productImages ( ) . all ( Identifier . fromId ( 1 ) , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ProductImageAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( ProductImage entity : responseEntity . getEntities ( ) ) {
listPayments: public Single < lnrpc . LightningOuterClass . ListPaymentsResponse > listPayments ( lnrpc . LightningOuterClass . ListPaymentsRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . oBListPayments ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
getString: protected static String getString ( String name , Context context , String key ) { return getString ( name , context , key , null ) ;
generateDefaultValueFormatter: private static IValueFormatter generateDefaultValueFormatter ( ) { final DefaultValueFormatter formatter = new DefaultValueFormatter ( 1 ) ; return formatter ;
run: public void run ( ) { MenuAction menuAction = this ; ps . getActionList ( ) . clearActions ( ) ; ps . popAllUntil ( ActionPhaseMenu . class ) ; ps . pushMenu ( new FadeInMenu ( 1.0f , ( ) ->
getBadgeId: public String getBadgeId ( ) { return null ;
t7: public Tuple7 t7 ( ) { return Tuples . of ( list [ 0 ] , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] , list [ 5 ] , list [ 6 ] ) ;
getZIndex: public int getZIndex ( ) { return 1 ;
getCreator: public Block getCreator ( ) { return ( ( Block ) getContent ( ) ) ; }
setEventClassName: public void setEventClassName ( String eventClassName ) { this . eventClassName = eventClassName ;
setBasecampRefreshToken: public void setBasecampRefreshToken ( String basecampRefreshToken ) { this . basecampRefreshToken = basecampRefreshToken ;
getOffsetScaleY: public float getOffsetScaleY ( ) { return offsetScaleY ;
ByteArrayToInt: public static int ByteArrayToInt ( byte [ ] b ) { return b [ 3 ] & 0xFF |
v0: public Object v0 ( ) { return list [ 0 ] ; }
getSteamMass: public double getSteamMass ( ) { throw new UnsupportedOperationException ( "Unimplemented method 'getSteamMass'" ) ;
getID: public ID getID ( ) { return ID . error ;
convertServiceType: private static Service . Ty convertServiceType ( ServiceType serviceType ) { switch ( serviceType ) { case WORKFLOW : return Service . Ty . WORKFLOW ; case SERVICE : return Service . Ty . SERVICE ; case VIRTUAL_OBJECT : return Service . Ty . VIRTUAL_OBJECT ; } throw new IllegalStateException ( ) ;
getCurrentMonth: public static int getCurrentMonth ( ) { return getMonth ( new Date ( ) ) ;
render: public void render ( Batch batch , RenderContext context ) { if ( this . region == null ) return ; if ( ! context . drawRecursive ) { return ; } camera . update ( ) ; if ( fadeOut > 0 ) { float f = Interpolation . circleOut . apply ( fadeOut / effect . getFadeOutDuration ( ) ) ; batch . end ( ) ; Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; this . batch . setProjectionMatrix ( camera . combined ) ; this . batch . begin ( ) ; this . batch . setColor ( 1 , 1 , 1 , f ) ; this . batch . draw ( region , 0 , 0 , BrainOutClient . getWidth ( ) , BrainOutClient . getHeight ( ) ) ; this . batch . end ( ) ; batch . begin ( ) ; } if ( flashBang > 0 )
release: public void release ( ) { pool . free ( this ) ; super . release ( ) ;
hashCode: public int hashCode ( ) { return Objects . hash ( item , person , begin , end ) ;
hasRender: public boolean hasRender ( ) { return false ;
isLocked: public boolean isLocked ( ) { return locked ;
release: public void release ( ) { super . release ( ) ; Log . info ( "Chip destroyed!" ) ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ;
getDatePlusDaysFromCurrent: public static LocalDateTime getDatePlusDaysFromCurrent ( long days ) { return LocalDateTime . now ( ) . plusDays ( days ) ;
masterCategories: public MasterCategoryService masterCategories ( ) { MasterCategoryService service = this . getService ( "com.scayle.adminapi.service.MasterCategoryService" ) ; return service ;
convertIntegers: public static int [ ] convertIntegers ( List < Integer > integers ) { int [ ] ret = new int [ integers . size ( ) ] ; copyIntegers ( integers , ret ) ; return ret ;
isAutoKickEnabled: public boolean isAutoKickEnabled ( ) { return false ;
getZIndex: public int getZIndex ( ) { return zIndex ;
received: public boolean received ( ItemActionMsg msg ) { BrainOutServer . PostRunnable ( ( ) -> { if ( playerData == null ) return ; Map map = playerData . getMap ( ) ; ActiveData activeData = map . getActiveData ( msg . object ) ; if ( activeData instanceof ItemData ) { if ( Vector2 . dst2 ( playerData . getX ( ) , playerData . getY ( ) , activeData . getX ( ) , activeData . getY ( ) ) <= 100 ) { BrainOutServer . Controller . getClients ( ) . sendTCP ( msg ) ; } } } ) ; return true ;
setCenterTextColor: public void setCenterTextColor ( int color ) { ( ( PieChartRenderer ) mRenderer ) . getPaintCenterText ( ) . setColor ( color ) ;
read: public void read ( Json json , JsonValue jsonData ) { owner . read ( json , jsonData ) ; additionalData . read ( json , jsonData ) ;
getOrganizationId: public Long getOrganizationId ( ) { return organizationId ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { off5ActionPerformed ( evt ) ;
measureScrapChild: private void measureScrapChild ( RecyclerView . Recycler recycler , int position , int widthSpec , int heightSpec , int [ ] measuredDimension ) { if ( position < getItemCount ( ) ) {
release: public void release ( ) { super . release ( ) ; ( ( ClientMap ) getMap ( ) ) . setLightsEnabled ( true ) ;
searchIndexUpdaterJob: public void searchIndexUpdaterJob ( ) { searchIndexUpdaterJob . updateSearchIndexes ( ) ;
getResponse: No method body
isSaveEmpty: public boolean isSaveEmpty ( ) { return saveEmpty ;
isDrawSlicesUnderHoleEnabled: public boolean isDrawSlicesUnderHoleEnabled ( ) { return mDrawSlicesUnderHole ;
createRequest: protected OpenAiCompletionsRequest createRequest ( final Map < String , String > input ) { return new OpenAiCompletionsRequest ( new StringSubstitutor ( input ) . replace ( getPromptTemplate ( ) ) ) ;
setLabel: public void setLabel ( String label ) { this . label = label ;
getAll: public Object getAll ( @ Qualifier ( "event" ) Pageable pageable , @ RequestParam ( required = false , defaultValue = "" , name = "event_search" ) String search ) { debug ( "[getAll]" ) ; return findListenersFlow ( search , null , pageable )
getInterpolation: public float getInterpolation ( float input ) { return input * input ;
getV3: public Object getV3 ( ) { return list [ 3 ] ; }
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; parts = jsonData . getInt ( "parts" , 1 ) ;
setTableName: public void setTableName ( String tableName ) { this . tableName = tableName ;
initView: No method body
requiredArgs: public int requiredArgs ( ) { return 0 ;
switchMenu: private void switchMenu ( ) { if ( menuMode == MenuMode . event ) { menuMode = MenuMode . tournament ; } else { menuMode = MenuMode . event ; } switch ( menuMode ) { case event : switchButton . setText ( L . get ( "MENU_TOP" ) ) ; break ; case tournament : switchButton . setText ( L . get ( "MENU_EVENTS" ) ) ; break ; } renderHeader ( ) ; renderEventInfo ( ) ;
getOutputAsync: No method body
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case activeAction : { ActiveActionEvent actionEvent = ( ( ActiveActionEvent ) event ) ; switch ( actionEvent . action ) { case added : { onActiveAdded ( actionEvent . activeData , actionEvent . componentWriter ) ; break ; } case removed : { onActiveRemoved ( actionEvent . activeData , actionEvent . flag ) ; break ; } case updated : { onActiveUpdated ( actionEvent . activeData , actionEvent . componentWriter ) ; break ; } } break ; } case activeChangeDimension : { ActiveChangeDimensionEvent e = ( ( ActiveChangeDimensionEvent ) event ) ; onActiveDimensionChanged ( e . activeData , e . oldId , e . oldDimension , e . newDimension ) ; break ; } case blockHitConfirmation : { BlockHitConfirmationEvent ev = ( ( BlockHitConfirmationEvent ) event ) ; confirmBlockHit ( ev ) ; break ; } case componentUpdated : { ComponentUpdatedEvent componentUpdatedEvent = ( ( ComponentUpdatedEvent ) event ) ; onComponentUpdated ( componentUpdatedEvent ) ; break ; } case playStateUpdated : { playStateChanged ( ) ; break ; } case setBlock : { SetBlockEvent setBlockEvent = ( ( SetBlockEvent ) event ) ; Object msg ; if ( setBlockEvent . blockData == null ) { msg = new BlockDestroyMsg ( setBlockEvent . x , setBlockEvent . y , setBlockEvent . layer , setBlockEvent . dimension ) ; } else { String data = Data . ComponentSerializer . toJson ( setBlockEvent . blockData , Data . ComponentWriter . TRUE , - 1 ) ; msg = new BlockAddMsg ( setBlockEvent . x , setBlockEvent . y , setBlockEvent . layer , data , setBlockEvent . dimension ) ; } getClients ( ) . foreach ( client -> { if ( client instanceof PlayerClient ) { PlayerClient playerClient = ( PlayerClient ) client ; if ( playerClient . isMapDownloading ( ) ) { playerClient . addOutgoingTCPMessage ( ( ) -> msg ) ; } else { playerClient . sendTCP ( msg ) ; } } } ) ; break ; } } return false ;
setFirstName: public void setFirstName ( String firstName ) { this . firstName = firstName ;
getSet: public EffectSet getSet ( ) { return set ;
onClick: public void onClick ( View v ) { rootView . findViewById ( R . id . lv_swap_step_one ) . setVisibility ( View . GONE ) ; rootView . findViewById ( R . id . lv_swap_step_two ) . setVisibility ( View . VISIBLE ) ; rootView . findViewById ( R . id . layout_cancel ) . setVisibility ( View . GONE ) ; rootView . findViewById ( R . id . layout_close ) . setVisibility ( View . VISIBLE ) ;
getEventString: public String getEventString ( ) { return StringUtils . join ( new String [ ] { eventClassName , eventName , eventObjectType } , "," ) ;
copyFrom: public void copyFrom ( final T parameters ) { this . setMaxTokens ( parameters . getMaxTokens ( ) ) ; this . setModel ( parameters . getModel ( ) ) ; this . setN ( parameters . getN ( ) ) ; this . setTemperature ( parameters . getTemperature ( ) ) ;
getHighlight: No method body
isActive: public boolean isActive ( ) { return active ;
deleteUserRoleByRoleId: No method body
obtain: public static Event obtain ( String achievementId ) { AchievementCompletedEvent e = obtain ( AchievementCompletedEvent . class ) ; if ( e == null ) return null ; return e . init ( achievementId ) ;
discard: public void discard ( ) { this . setVisible ( false ) ;
getUsername: public String getUsername ( ) { return username ;
run: public void run ( ) { mMenuPopWindow . dismiss ( ) ; mLoadingDialog . dismiss ( ) ; UnlockDialog mUnlockDialog = new UnlockDialog ( mContext ) ; mUnlockDialog . show ( ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { if ( premium && ! isPassPurchased ( ) ) { Menu . playSound ( MenuSound . denied ) ; return ; } if ( stage . isRewardRedeemed ( premium , iii ) ) { return ; } if ( st . completedIndex >= stage . index )
addExtension: public void addExtension ( String name , int dataStart , int length ) { addExtension ( name , dataStart , length , false ) ;
show: public void show ( final View view ) { if ( mBasePopWindow == null ) {
logUpload: No method body
onRelease: public void onRelease ( ) { super . onRelease ( ) ; suppressErrors = true ; if ( party != null )
setSaveEmpty: public void setSaveEmpty ( boolean saveEmpty ) { this . saveEmpty = saveEmpty ;
valid: public boolean valid ( ) { return System . currentTimeMillis ( ) <= endTime ;
isChecked: public boolean isChecked ( ) { return getValue ( ) ;
onClick: public void onClick ( View v ) { mBasePopWindow . dismiss ( ) ; shareLayout . setVisibility ( View . GONE ) ;
transform: No method body
startWebsocketd: private static void startWebsocketd ( ) throws IOException { int port = DEFAULT_WEBSOCKET_PORT ; if ( System . getProperty ( "ws_port" ) != null ) { port = Integer . parseInt ( System . getProperty ( "ws_port" ) ) ; } new Websocketd ( port ) . start ( 24 * 60 * 60000 , false ) ; System . out . println ( "Websocket server start at port  " + port ) ; Global . wsPort = port ;
getLockItem: public ContentLockTree . LockItem getLockItem ( ) { return original . getLockItem ( ) ;
rescheduleNonExisting: public void rescheduleNonExisting ( ) { mockAndAuthenticateUser ( 1l , "test@openkoda.com" , "TEST" , "(canManageBackend)" ) ; Scheduler scheduler = new Scheduler ( SCHEDULER_CRON_EXPRESSION , SCHEDULER_EVENT_DATA , false ) ; long schedulerId = 1L ; scheduler . setId ( schedulerId ) ; boolean result = schedulerService . reschedule ( schedulerId , scheduler ) ; assertFalse ( result ) ;
getUses: public int getUses ( ) { return uses ;
killAll: private void killAll ( ) { for ( ObjectMap . Entry < Integer , Client > entry : BrainOutServer . Controller . getClients ( ) )
basicAlert: public static void basicAlert ( Context context , String title , String message ) { if ( ! canShowDialog ( context ) ) return ; newBuilder ( context )
getColors: No method body
playInSoundChannel: public void playInSoundChannel ( ) { if ( music == null ) return ; try
tryResolve: No method body
updateSubscriberOnlineStatus: No method body
sendUDP: public int sendUDP ( Object object ) { return connection . sendUDP ( object ) ;
onResponse: public void onResponse ( byte [ ] bytes ) { if ( bytes == null ) { return ; } try {
selectAllByQueryKey: No method body
getPane: public ScrollPane getPane ( ) { return pane ;
getPathConstraintIndex: public int getPathConstraintIndex ( ) { return pathConstraintIndex ;
accept: No method body
noSliders: public ColorPickerDialogBuilder noSliders ( ) { isLightnessSliderEnabled = false ; isAlphaSliderEnabled = false ; return this ;
sendUDPExceptDistance: private void sendUDPExceptDistance ( UdpMessage msg ) { clients . sendUDPExcept ( msg , clientId , this :: validDistance ) ;
getAccessLevel: public AccessLevel getAccessLevel ( ) { return accessLevel ;
getFrameEntries: public int getFrameEntries ( ) { return ENTRIES ;
createWorkflowOverride: public WorkflowOverrideResponse createWorkflowOverride ( final CreateWorkflowOverrideRequest request ) throws IOException , NovuNetworkException { Response < WorkflowOverrideResponse > response = workflowOverrideApi . createWorkflowOverride ( request ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
gen: public static void gen ( ) { StringBuilder baseBuilder = new StringBuilder ( ) ; String baseOutFile = "./baselibrary/src/main/temp.txt" ; float index = 0.5f ; while ( index <= 500 ) { index = index + 0.5f ; baseBuilder . append ( "<dimen name=\"main_" + index + "\">" + index + "dp</dimen>" ) . append ( "\n" ) ; } try {
auth: No method body
getRotation: public float getRotation ( ) { return rotation ;
getCode: public String getCode ( ) { return this . code ;
mockAndAuthenticateUser: protected User mockAndAuthenticateUser ( Long userId , String email , String role , String globalPrivileges ) { reset ( userRepository ) ; User user = mock ( User . class ) ; when ( user . getEmail ( ) ) . thenReturn ( "test@openkoda.com" ) ; when ( user . getId ( ) ) . thenReturn ( userId ) ; when ( user . getName ( ) ) . thenReturn ( "Test User" ) ; when ( userRepository . getUserRolesAndPrivileges ( anyLong ( ) ) ) . thenReturn ( Collections . singletonList ( new Tuple ( Long . valueOf ( 1 ) , "TEST" , globalPrivileges , null , null ) ) ) ; when ( userRepository . wasModifiedSince ( eq ( userId ) , any ( ) ) ) . thenReturn ( Optional . of ( false ) ) ; runAsService . authRunAsUser ( user , false , new MockHttpServletRequest ( ) , new MockHttpServletResponse ( ) ) ; return user ;
getEmail: public String getEmail ( ) { return email ;
getMethods: public List < Handler > getMethods ( ) { return handlers ;
getType: public FrontendResource . Type getType ( ) { return type ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; spriteName = jsonData . getString ( "sprite" ) ; scale = jsonData . getFloat ( "scale" , 1 ) ;
getName: public String getName ( ) { return name ;
zoom: public Matrix zoom ( float scaleX , float scaleY , float x , float y ) { Matrix save = new Matrix ( ) ; zoom ( scaleX , scaleY , x , y , save ) ; return save ;
contact: private void contact ( ) { if ( launchData == null ) return ; getContentComponent ( ) . getEffect ( ) . launchEffects ( launchData ) ;
getTemperatureCoef: public float getTemperatureCoef ( ) { return temperature / getContentComponent ( ) . getTemperatureMax ( ) ;
getAmount: public double getAmount ( ) { return amount ;
onRelease: public void onRelease ( ) { super . onRelease ( ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . notify , this ) ; BrainOutClient . EventMgr . unsubscribe ( Event . ID . caseOpenResult , this ) ; for ( Event event : delayedEvents ) { BrainOutClient . EventMgr . sendDelayedEvent ( event ) ; } delayedEvents . clear ( ) ;
updateWaterInflow: public void updateWaterInflow ( double flow , double tempC ) { throw new UnsupportedOperationException ( "Unimplemented method 'updateWaterInFlow'" ) ;
attachDamage: public void attachDamage ( DamagedEvent lastHit ) { this . lastHit = lastHit ;
setTransformMatrix: public void setTransformMatrix ( Matrix4 transform ) { if ( drawing ) flush ( ) ; transformMatrix . set ( transform ) ; if ( drawing ) setupMatrices ( ) ;
getStreamBuilderAccept: public static Stream < Student > getStreamBuilderAccept ( ) { Stream . Builder < Student > builder = Stream . builder ( ) ; builder . accept ( new Student ( "Dimebag" , "Darrell" , 27 ) ) ; builder . accept ( new Student ( "Diana" , "Krall" , 23 ) ) ; builder . accept ( new Student ( "Melody" , "Gardot" , 30 ) ) ; return builder . build ( ) ;
error: No method body
write: public < TRequest extends Packet , TResponse extends Packet > Conversation < TRequest , TResponse > write ( final @ NonNull TRequest packet , final @ NonNull MessageTarget target , final @ Nullable Class < TResponse > expectedResponse , final @ Nullable ConversationUID conversationUID ) { final ConversationUID uid = conversationUID == null ? ConversationUID . newUid ( ) : conversationUID ; final JRPCMessage message = JRPCMessageBuilder . builder ( ) . source ( client ) . target ( target . target ( ) ) . targetType ( target . type ( ) ) . conversationUid ( uid ) . data ( PacketDataSerializer . serialize ( packet ) ) . build ( ) ; final boolean channelActive = channel != null && channel . isActive ( ) ; final Conversation < TRequest , TResponse > conversation = newConversation ( packet , message . conversationId ( ) , expectedResponse , channelActive ) ; if ( channelActive ) { channel . writeAndFlush ( message ) ; logPacketDispatch ( packet , target , uid , message ) ; } else { queueMessage ( conversation , message ) ; } return conversation ;
search: public Page < T > search ( String searchTerm , Long organizationId , int page , int size , String sortField , String sortDirection ) { return wrapped . search ( scope , searchTerm , organizationId , page , size , sortField , sortDirection ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
removeFileReference: No method body
getMenuAlign: protected MenuAlign getMenuAlign ( ) { return MenuAlign . fill ;
getNeighbors: ObjectMap < Integer , Neighbor > getNeighbors ( ) { return neighbors ;
completeLoad: public void completeLoad ( AssetManager assetManager ) { super . completeLoad ( assetManager ) ; sound = assetManager . get ( fileName , Sound . class ) ;
createPackage: public ContentPackage createPackage ( String name ) throws ContentPackage . ValidationException { return new ZipContentPackage ( name ) ;
testAll: public void testAll ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; ApiCollection < MasterCategory > responseEntity = this . api . masterCategories ( ) . all ( options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/MasterCategoryAllResponse.json" ) ; assertThatJson ( expectedResponseJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( responseEntity ) ) ; for ( MasterCategory entity : responseEntity . getEntities ( ) ) {
passwordChangeForm: public Object passwordChangeForm ( ) { debug ( "[passwordChangeForm]" ) ; ModelAndView mav = new ModelAndView ( frontendResourceTemplateNamePrefix + "password-recovery" ) ; Object user = SecurityContextHolder . getContext ( ) . getAuthentication ( ) . getPrincipal ( ) ; if ( user instanceof OrganizationUser ) { mav . addObject ( "passwordChangeForm" , new PasswordChangeForm ( ( ( OrganizationUser ) user ) . getUser ( ) . getId ( ) ) ) ; } return mav ;
createOrUpdateCustomDataForKey: public Map < String , Object > createOrUpdateCustomDataForKey ( Identifier campaignId , String key , Map < String , Object > model ) throws ApiErrorException , ConnectionException { Class < Map < String , Object > > responseModel = ( Class < Map < String , Object > > ) ( Class < ? > ) Map . class ; return this . request ( "put" , this . resolvePath ( "/campaigns/%s/custom-data/%s" , campaignId , key ) , null , null , responseModel , model ) ;
reset: public void reset ( ) { this . damage = 0 ; this . map = null ; this . info = null ; this . bulletData = null ;
savePath: public HttpUtils savePath ( String savePath ) { this . mSavePath = savePath ; return this ;
testCreate: public void testCreate ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/VoucherCreateRequest.json" ) ; Voucher requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Voucher . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Voucher responseEntity = this . api . vouchers ( ) . create ( "acme" , "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/VoucherCreateResponse.json" ) ; assertThatJson ( expectedResponseJson )
getSettings: public ClientSettings getSettings ( ) { return settings ;
setRemovable: public void setRemovable ( Boolean removable ) { this . removable = removable ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; good = jsonData . getInt ( "good" , 0 ) ; needsValidation = jsonData . getBoolean ( "needsValidation" , true ) ; bulletAtLaunch = jsonData . getInt ( "bulletAtLaunch" , 1 ) ; dropAtOnce = jsonData . getInt ( "dropAtOnce" , 15 ) ; dropable = jsonData . getBoolean ( "dropable" , true ) ; speed = jsonData . getFloat ( "speed" ) ; power = jsonData . getFloat ( "power" ) ; mass = jsonData . getFloat ( "mass" ) ; damageCoeficient = jsonData . getFloat ( "damageCoeficient" , 1 ) ; headMultiplier = jsonData . getFloat ( "headMultiplier" , 1f ) ; powerDistance = jsonData . getFloat ( "powerDistance" , 64.0f ) ; hitImpulse = jsonData . getFloat ( "hitImpulse" , 10.0f ) ; damageMyself = jsonData . getBoolean ( "damageMyself" , false ) ; hitEffectNormal = jsonData . getBoolean ( "hitEffectNormal" , true ) ; hitShake = jsonData . getFloat ( "hitShake" , 0.2f ) ; blockEffectEnabled = jsonData . getBoolean ( "blockEffect" , true ) ; timeToLive = jsonData . getFloat ( "timeToLive" , Constants . Core . BULLET_TIME_TO_LIVE ) ; if ( jsonData . has ( "bulletTags" ) ) { if ( jsonData . get ( "bulletTags" ) . isString ( ) ) { bulletTags . add ( jsonData . getString ( "bulletTags" ) ) ; } else { bulletTags . addAll ( jsonData . get ( "bulletTags" ) . asStringArray ( ) ) ; } } PowerFunction powerFunction = PowerFunction . valueOf ( jsonData . getString ( "function" , PowerFunction . pow2Out . toString ( ) ) ) ; switch ( powerFunction ) { case pow5In : { function = Interpolation . pow5In ; break ; } case pow2In : { function = Interpolation . pow2In ; break ; } case pow2Out : default : { function = Interpolation . pow2Out ; break ; } } slot = BulletSlot . valueOf ( jsonData . getString ( "slot" , BulletSlot . primary . toString ( ) ) ) ;
getDoorAnimation: public AnimationData getDoorAnimation ( ) { ActiveData activeData = findActiveData ( doorAnimation ) ; if ( ! ( activeData instanceof AnimationData ) ) return null ; return ( ( AnimationData ) activeData ) ;
calculateThermalDrivingHead: public static double calculateThermalDrivingHead ( double density1 , double density2 , double depth ) { return ( density1 - density2 ) * depth * 9.81 ;
computeSize: protected void computeSize ( ) { mAxisLabelPaint . setTypeface ( mXAxis . getTypeface ( ) ) ; mAxisLabelPaint . setTextSize ( mXAxis . getTextSize ( ) ) ; String longest = mXAxis . getLongestLabel ( ) ; final FSize labelSize = Utils . calcTextSize ( mAxisLabelPaint , longest ) ; final float labelWidth = ( int ) ( labelSize . width + mXAxis . getXOffset ( ) * 3.5f ) ; final float labelHeight = labelSize . height ; final FSize labelRotatedSize = Utils . getSizeOfRotatedRectangleByDegrees ( labelSize . width , labelHeight , mXAxis . getLabelRotationAngle ( ) ) ; mXAxis . mLabelWidth = Math . round ( labelWidth ) ; mXAxis . mLabelHeight = Math . round ( labelHeight ) ; mXAxis . mLabelRotatedWidth = ( int ) ( labelRotatedSize . width + mXAxis . getXOffset ( ) * 3.5f ) ; mXAxis . mLabelRotatedHeight = Math . round ( labelRotatedSize . height ) ; FSize . recycleInstance ( labelRotatedSize ) ;
findByOrganizationIdAndUserIdIsNull: No method body
click: void click ( ) { counter . click ( ) ; assertEquals ( 1 , counter . getValue ( ) ) ;
newDragAndDropInventory: protected DragAndDropInventory newDragAndDropInventory ( ) { return new DragAndDropInventory ( pane , this :: updateBackgroundPanel )
getRemovable: public Boolean getRemovable ( ) { return removable ;
restoreLoadView: private void restoreLoadView ( ) { if ( ! mIsCanLoad || mLoadView == null ) { LogUtils . e ( TAG , "没有开启上拉加载或者loadView为null" ) ; return ; } int currentBottomMargin = ( ( ViewGroup . MarginLayoutParams ) mLoadView . getLayoutParams ( ) ) . bottomMargin ; int finalBottomMargin = 0 ; if ( mCurrentLoadStatus == LOAD_STATUS_LOOSEN_LOADING ) { LogUtils . e ( TAG , "正在加载" ) ; mCurrentLoadStatus = LOAD_STATUS_LOADING ; if ( mLoadCreator != null ) { mLoadCreator . onLoading ( ) ; } if ( mListener != null ) { mListener . onLoad ( ) ; } } else if ( mCurrentLoadStatus == LOAD_STATUS_PULL_DOWN_REFRESH ) { if ( mLoadCreator != null ) { mLoadCreator . onCancelLoad ( ) ; } } else if ( mCurrentLoadStatus == LOAD_STATUS_LOADING ) { if ( mLoadCreator != null ) { mLoadCreator . onLoading ( ) ; } } int distance = currentBottomMargin - finalBottomMargin ; if ( distance < 0 ) { return ; } ValueAnimator animator = ObjectAnimator . ofFloat ( currentBottomMargin , finalBottomMargin ) . setDuration ( distance ) ; animator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { float currentTopMargin = ( float ) animation . getAnimatedValue ( ) ; setLoadViewMarginBottom ( ( int ) currentTopMargin ) ; } } ) ; animator . start ( ) ; mCurrentDrag = false ;
execute: public String execute ( String [ ] args , Client client ) { String id = args [ 1 ] ; Content content = BrainOutServer . ContentMgr . get ( id ) ; if ( content != null ) { int amount = 1 ; int quality = - 1 ; if ( args . length >= 3 ) { try { amount = Integer . valueOf ( args [ 2 ] ) ; } catch ( NumberFormatException e ) { return "Bad format" ; } } if ( args . length >= 4 ) { try { quality = Integer . valueOf ( args [ 3 ] ) ; } catch ( NumberFormatException e ) { return "Bad quality" ; } if ( quality < 0 || quality > 100 ) { return "Bad quality" ; } } if ( client instanceof PlayerClient ) { PlayerClient player = ( ( PlayerClient ) client ) ; if ( player . getPlayerData ( ) == null ) return "Player not spawned" ; PlayerOwnerComponent ownerComponent = player . getPlayerData ( ) . getComponent ( PlayerOwnerComponent . class ) ; String dimension = player . getPlayerData ( ) . getDimension ( ) ; if ( content instanceof RealEstateItem ) { if ( System . getenv ( "VALPHA" ) == null ) { return "This is not possible here." ; } MarketService marketService = MarketService . Get ( ) ; ConsumableRecord r = new ConsumableRecord ( new RealEstateItemConsumableItem ( ( ( RealEstateItem ) content ) ) , amount , - 1 ) ; MarketService . MarketItemEntry rr = MarketUtils . ConsumableRecordToMarketEntry ( r ) ; if ( rr == null ) { return "Ugh I don't know about this." ; } marketService . updateMarketItem ( "freeplay" , rr . name , rr . payload , rr . amount , player . getAccessToken ( ) , ( request , result ) -> BrainOutServer . PostRunnable ( ( ) -> { if ( result == Request . Result . success ) { player . sendChat ( "Okay done." ) ; } else { player . sendChat ( "Couldn't do that: " + result . toString ( ) ) ; } } ) ) ; return "Trying." ; } else if ( content instanceof Instrument ) { Instrument instrument = ( ( Instrument ) content ) ; InstrumentData instrumentData = instrument . getData ( dimension ) ; instrumentData . setSkin ( instrument . getDefaultSkin ( ) ) ; ownerComponent . getConsumableContainer ( ) . putConsumable ( amount , new InstrumentConsumableItem ( instrumentData , dimension ) ) ; } else if ( content instanceof ConsumableContent ) { ownerComponent . getConsumableContainer ( ) . putConsumable ( amount , ( ( ConsumableContent ) content ) . acquireConsumableItem ( ) , quality ) ; } player . sendConsumable ( ) ; } else { return "Not a player" ; } return "Done" ; } return "No such content." ;
hasRender: public boolean hasRender ( ) { return false ;
getBoneIndex: public int getBoneIndex ( ) { return boneIndex ;
newObject: protected ShotBulletData newObject ( ) { return new ShotBulletData ( ShotBullet . this , this ) ;
getUser: public User getUser ( ) { return user ;
getMemberships: public ApiCollection < CustomerMembership > getMemberships ( String shopKey , String countryCode , Identifier customerIdentifier , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < CustomerMembership > responseModel = ( Class < CustomerMembership > ) ( Class < ? > ) CustomerMembership . class ; Map < String , Object > query = options . all ( ) ; return this . requestCollection ( "get" , this . resolvePath ( "/shops/%s/countries/%s/customers/%s/memberships" , shopKey , countryCode , customerIdentifier ) , query , null , responseModel ) ;
delete: public < S extends DynamicPrivilege > void delete ( S entity ) { throw new NotImplementedException ( NO_IMPLEMENTATION_IN_CORE_OPENKODA ) ;
onMessageSent: protected void onMessageSent ( ) { closeChatFromReply ( ) ;
mock: public static String mock ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( ) ; boolean b = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isLetter ( c ) ) { if ( b ) { c = Character . toUpperCase ( c ) ; b = false ; } else { b = true ; } } sb . append ( c ) ; } return sb . toString ( ) ;
shouldAccept: public boolean shouldAccept ( @ NonNull Packet packet ) { return packet instanceof Request ;
getContent: public RealEstateItem getContent ( ) { return item ;
isEmpty: public boolean isEmpty ( ) { return false ;
getConsumerString: public String getConsumerString ( ) { int n = staticData1 == null ? 0 : staticData2 == null ? 1 : staticData3 == null ? 2 : staticData4 == null ? 3 : 4 ; return Consumer . canonicalMethodName ( consumerClassName , consumerMethodName , consumerParameterClassName , n ) ;
markAllSubscriberMessagesFeedAs: No method body
update: protected void update ( float dt ) { timer -= dt ; if ( timer > 0 ) return ; timer = 0.25f ; if ( ! follow . isAlive ( ) ) { if ( ! pickAnotherPlayerToFollow ( ) ) { pushTask ( new TaskHide ( getStack ( ) , null ) ) ; } return ; } Map map = getMap ( ) ; if ( map == goTo ) { pop ( ) ; BrainOut . EventMgr . sendDelayedEvent ( getPlayerData ( ) , DestroyEvent . obtain ( ) ) ; exit . run ( ) ; return ; } if ( MapDimensionsGraph . IsNeighbor ( map , goTo ) ) { ActiveData reFollowTo = goTo . getRandomActiveForTag ( Constants . ActiveTags . PORTAL ) ; if ( reFollowTo != null ) { pushTask ( new TaskFollowTarget ( getStack ( ) , reFollowTo , null , true ) ) ; } return ; } if ( getController ( ) . isFollowing ( follow ) ) return ; if ( Vector2 . dst2 ( follow . getX ( ) , follow . getY ( ) , getPlayerData ( ) . getX ( ) , getPlayerData ( ) . getY ( ) ) < 5.0f * 5.0f ) return ; getController ( ) . follow ( follow , this :: done , this :: stuck , this :: gotBlocksInOurWay ) ;
onError: public void onError ( Exception e ) { LogUtils . e ( TAG , "------------------oB_GetOmniTransactionOnError------------------" + e . getMessage ( ) ) ;
setTitle: public Builder setTitle ( int id ) { P . mTitleText = mContext . getResources ( ) . getString ( id ) ; return this ;
onEvent: public boolean onEvent ( Event event ) { return false ;
updatePlayerData: private void updatePlayerData ( ) { BrainOut . EventMgr . sendDelayedEvent ( MyPlayerSetEvent . obtain ( ( ( PlayerData ) data . getOwner ( ) ) ) ) ;
getKey: public ConsumableContent getKey ( ) { return key ;
getComponent: public ServerDeckOfCardsComponentData getComponent ( ComponentObject componentObject ) { return new ServerDeckOfCardsComponentData ( componentObject , this ) ;
getRandomItem: private < T extends Content > T getRandomItem ( Array < T > items ) { return RandomWeightComponent . GetRandomItem ( items ) ;
isReadable: public static boolean isReadable ( String filename ) { return Files . isReadable ( Paths . get ( filename ) ) ;
addPossibleResultPoint: public void addPossibleResultPoint ( ResultPoint point ) { if ( isShowResultPoint ) {
setId: public void setId ( int id ) { this . id = id ;
saveNodeVersionToLocal: public static void saveNodeVersionToLocal ( Context context , String value ) { putString ( SETTINGS , context , KEY_NODE_VERSION , value ) ;
getDescription: public String getDescription ( CardData cardData ) { ContentCardData contentCardData = ( ( ContentCardData ) cardData ) ; OwnableContent content = contentCardData . getCardContent ( ) ; if ( BrainOut . R . instanceOf ( InstrumentSkin . class , content ) ) { return L . get ( "CARD_TITLE_SKIN" ) ; } return super . getDescription ( cardData ) ;
initBuffers: public void initBuffers ( ) { BarData barData = mChart . getBarData ( ) ; mBarBuffers = new BarBuffer [ barData . getDataSetCount ( ) ] ; for ( int i = 0 ; i < mBarBuffers . length ; i ++ ) {
allowZoom: public boolean allowZoom ( ) { return false ;
getGood: public int getGood ( ) { return good ;
getFullyQualifiedMethodName: public String getFullyQualifiedMethodName ( ) { return syscalls . getFullyQualifiedMethodName ( ) ;
onClick: public void onClick ( View v ) { shareLayout . setVisibility ( View . GONE ) ;
setNickname: public Builder setNickname ( String nickname ) { this . mNickname = nickname ; return this ;
givenClass_whenGetsFields_thenCorrect: public void givenClass_whenGetsFields_thenCorrect ( ) throws ClassNotFoundException { final Class < ? > animalClass = Class . forName ( "com.nbicocchi.tutorials.reflection.Animal" ) ; final Field [ ] fields = animalClass . getDeclaredFields ( ) ; final List < String > actualFields = getFieldNames ( fields ) ; assertEquals ( 2 , actualFields . size ( ) ) ; assertTrue ( actualFields . containsAll ( Arrays . asList ( "name" , "CATEGORY" ) ) ) ;
bindOpenChannel: private void bindOpenChannel ( ByteString channelString ) throws InvalidProtocolBufferException { LightningOuterClass . Channel channel = LightningOuterClass . Channel . parseFrom ( channelString ) ; mRemoteName . setText ( Wallet . getInstance ( ) . getNodeAliasFromPubKey ( channel . getRemotePubkey ( ) , mContext ) ) ; mRemotePubkey . setText ( channel . getRemotePubkey ( ) ) ; if ( channel . getAssetId ( ) == 0 ) { mAssetLogo . setImageResource ( R . mipmap . icon_btc_logo_small ) ; mAssetUnit . setText ( "BTC" ) ; mLocalBalanceUnit . setText ( "BTC" ) ; mRemoteBalanceUnit . setText ( "BTC" ) ; long availableCapacity = channel . getBtcCapacity ( ) - channel . getCommitFee ( ) ; setBalances ( channel . getLocalBalance ( ) , channel . getRemoteBalance ( ) , availableCapacity ) ; String activity = UtilFunctions . roundDouble ( ( ( double ) ( channel . getTotalSatoshisSent ( ) + channel . getTotalSatoshisReceived ( ) ) / channel . getBtcCapacity ( ) * 100 ) , 2 ) + "%" ; mActivity . setText ( activity ) ; mTotalSent . setText ( channel . getLocalConstraints ( ) . getChanReserveSat ( ) + " sat" ) ; mTotalReceived . setText ( channel . getRemoteConstraints ( ) . getChanReserveSat ( ) + " sat" ) ; } else { mAssetLogo . setImageResource ( R . mipmap . icon_usdt_logo_small ) ; mAssetUnit . setText ( "dollar" ) ; mLocalBalanceUnit . setText ( "dollar" ) ; mRemoteBalanceUnit . setText ( "dollar" ) ; long availableCapacity = channel . getAssetCapacity ( ) - channel . getCommitFee ( ) ; setBalances ( channel . getLocalAssetBalance ( ) , channel . getRemoteAssetBalance ( ) , availableCapacity ) ; String activity = UtilFunctions . roundDouble ( ( ( double ) ( channel . getTotalSatoshisSent ( ) + channel . getTotalSatoshisReceived ( ) ) / channel . getAssetCapacity ( ) * 100 ) , 2 ) + "%" ; mActivity . setText ( activity ) ; mTotalSent . setText ( channel . getLocalConstraints ( ) . getChanReserveSat ( ) + " unit" ) ; mTotalReceived . setText ( channel . getRemoteConstraints ( ) . getChanReserveSat ( ) + " unit" ) ; } mFundingTransaction . setText ( channel . getChannelPoint ( ) . substring ( 0 , channel . getChannelPoint ( ) . indexOf ( ':' ) ) ) ; mChannelPoint = channel . getChannelPoint ( ) ; showClosingButton ( ! channel . getActive ( ) , channel . getCsvDelay ( ) ) ; if ( channel . getActive ( ) ) { mStatusDot . setBackgroundResource ( R . drawable . bg_btn_round_009b19_25 ) ; } else { mStatusDot . setBackgroundResource ( R . drawable . bg_btn_round_99000000_25 ) ; } mAnotherInfo . setVisibility ( View . VISIBLE ) ; long timeLockInSeconds = channel . getLocalConstraints ( ) . getCsvDelay ( ) * 10 * 60 ; String timeLock = String . valueOf ( channel . getLocalConstraints ( ) . getCsvDelay ( ) ) + " (" + TimeFormatUtil . formattedDurationShort ( timeLockInSeconds , mContext ) + ")" ; mTimeLock . setText ( timeLock ) ;
emitBackupCreated: private void emitBackupCreated ( ) { debug ( "[emitBackupCreated]" ) ; String tarBackupFile = backupWriter . getTarBackupFile ( ) ; services . applicationEvent . emitEvent ( BACKUP_CREATED , new File ( tarBackupFile ) ) ;
get: public Campaign get ( String shopKey , Integer campaignId , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Campaign > responseModel = ( Class < Campaign > ) ( Class < ? > ) Campaign . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/shops/%s/campaigns/%s" , shopKey , campaignId ) , query , null , responseModel ) ;
getPathToYamlComponentFile: public String getPathToYamlComponentFile ( ControllerEndpoint entity ) { return null ;
setBuilderStart: public void setBuilderStart ( Map < String , String > builderStart ) { this . builderStart = builderStart ;
valuesKeys: void valuesKeys ( ) { assertFalse ( ValuesKeys . valuesKeys ( Map . of ( "a" , "1" , "b" , "2" , "c" , "3" ) ) ) ; assertTrue ( ValuesKeys . valuesKeys ( Map . of ( "a" , "1" , "b" , "2" , "c" , "a" ) ) ) ;
init: private Event init ( Kind kind , LaunchData launchData , String custom ) { this . kind = kind ; this . launchData = launchData ; this . custom = custom ; return this ;
launchEffects: public void launchEffects ( String key , EffectSet . EffectAttacher attacher ) { if ( key == null ) return ; EffectSet set = get ( key ) ; if ( set != null )
update: public void update ( float dt ) { super . update ( dt ) ; { Map map = Map . GetDefault ( ) ; counter -= dt * map . getSpeed ( ) ; } if ( counter < 0 )
withdraw: public double withdraw ( double amount ) { double outAmount = super . withdraw ( amount ) ; applyFee ( ) ; return outAmount ;
getSpacingMode: public SpacingMode getSpacingMode ( ) { return spacingMode ;
isOnlineEnabled: public boolean isOnlineEnabled ( ) { return ! BrainOutServer . getInstance ( ) . offline ;
setBleeding: public boolean setBleeding ( float intensity , float time ) { if ( brokenBonesDelay > 0 && fp . isBleeding ( ) ) return false ; bleedingTime = Math . max ( time , bleedingTime ) ; bleedingCounter = 0 ; if ( bleedingIntensity != 0 ) { bleedingIntensity = Math . min ( bleedingIntensity , intensity ) ; } else { bleedingIntensity = intensity ; } fp . setBleeding ( true ) ; return true ;
getMessages: public SocialMessages getMessages ( ) { return messages ;
getHeight: No method body
deleteMessage: public DeleteMessageResponse deleteMessage ( final String messageId ) throws IOException , NovuNetworkException { Response < DeleteMessageResponse > response = messageApi . deleteMessage ( messageId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return null ;
StringEquals: public static Boolean StringEquals ( String str1 , String str2 , Boolean isCase ) { if ( isCase ) { return str1 . equals ( str2 ) ; } if ( TextUtils . isEmpty ( str1 ) && TextUtils . isEmpty ( str2 ) ) { return true ; } if ( "null" . equals ( str1 ) && "null" . equals ( str2 ) ) { return true ; } if ( ! isEmpty ( str1 ) && ! isEmpty ( str2 ) ) {
main: public static void main ( String [ ] args ) { Point p1 = new Point ( 0 , 0 ) ; Point p2 = new Point ( 10 , 10 ) ; System . out . println ( p1 ) ; System . out . println ( p2 ) ; swap ( p1 , p2 ) ; System . out . println ( p1 ) ; System . out . println ( p2 ) ; }
registerAndExposeCRUDController: public CRUDControllerConfiguration registerAndExposeCRUDController ( FrontendMappingDefinition frontendMappingDefinition , ScopedSecureRepository secureRepository , Class formClass , PrivilegeBase readPrivilege , PrivilegeBase writePrivilege ) { CRUDControllerConfiguration c = super . registerCRUDController ( frontendMappingDefinition , secureRepository , formClass , readPrivilege , writePrivilege ) ; setOrgIdAndExpose ( frontendMappingDefinition . name , c ) ; return c ;
calcMinMax: protected void calcMinMax ( Entry e , AxisDependency axis ) { if ( mYMax < e . getY ( ) ) mYMax = e . getY ( ) ; if ( mYMin > e . getY ( ) ) mYMin = e . getY ( ) ; if ( mXMax < e . getX ( ) ) mXMax = e . getX ( ) ; if ( mXMin > e . getX ( ) ) mXMin = e . getX ( ) ; if ( axis == AxisDependency . LEFT ) {
greet: public String greet ( ObjectContext context , String request ) { return request ;
setDataSet: public void setDataSet ( int index ) { this . mDataSetIndex = index ;
onCreate: public void onCreate ( ) { super . onCreate ( ) ; SoLoader . init ( this , false ) ; if ( BuildConfig . IS_NEW_ARCHITECTURE_ENABLED ) { DefaultNewArchitectureEntryPoint . load ( ) ; } ReactNativeFlipper . initializeFlipper ( this , getReactNativeHost ( ) . getReactInstanceManager ( ) ) ;
getID: public ID getID ( ) { return ID . collide ;
doConnect: private void doConnect ( ) { ClientController C = BrainOutClient . ClientController ; BrainOutClient . Network . connect (
detectFormConstructor: private void detectFormConstructor ( ) throws NoSuchMethodException { try {
writePdfToStream: No method body
getViewfinderViewId: public int getViewfinderViewId ( ) { return R . id . viewfinderView ;
onClick: public void onClick ( View v ) { mMenuPopWindow . dismiss ( ) ; Intent intent = new Intent ( mContext , BackupChannelActivity . class ) ; mContext . startActivity ( intent ) ;
clicked: public void clicked ( InputEvent event , float x , float y ) { setEditorMode ( EditorMode . Mode . actives ,
notifyOnPrivilagesChange: public Object notifyOnPrivilagesChange ( ) { debug ( "[notifyOnPrivilagesChange] Privileges have changed, notifying" ) ; applicationEventPublisher . publishEvent ( new PrivilegeChangeEvent ( this ) ) ; return null ;
finishActivityExpect: public void finishActivityExpect ( String className ) { if ( activityStack != null ) {
copy: public CandleEntry copy ( ) { CandleEntry c = new CandleEntry ( getX ( ) , mShadowHigh , mShadowLow , mOpen , mClose , getData ( ) ) ; return c ;
longToStringTime: public synchronized static String longToStringTime ( long countTime ) { if ( countTime <= 0 ) { return "0秒" ; } long [ ] tempLongTime = new long [ 4 ] ; formatLongTime ( tempLongTime , countTime ) ; long days = tempLongTime [ 0 ] ; long hours = tempLongTime [ 1 ] ; long minutes = tempLongTime [ 2 ] ; long second = tempLongTime [ 3 ] ; long oneDay = 1000 * 60 * 60 * 24 ; long oneHours = 1000 * 60 * 60 ; long oneMinute = 1000 * 60 ; if ( countTime >= oneDay ) { return days + "天" + hours + "时" + minutes + "分" + second + "秒" ; } else if ( countTime >= oneHours && countTime < oneDay ) { return hours + "时" + minutes + "分" + second + "秒" ; } else if ( countTime >= oneMinute && countTime < oneHours ) { return minutes + "分" + second + "秒" ; } else if ( countTime < oneMinute ) { return second + "秒" ; } return days + "天" + hours + "时" + minutes + "分" + second + "秒" ;
popState: public void popState ( ) { if ( hasState ( ) ) { topState ( ) . onRelease ( ) ; statesStack . pop ( ) ; } if ( hasState ( ) )
getTags: public int getTags ( ) { return super . getTags ( ) | WithTag . TAG ( Constants . ActiveTags . SPAWNABLE ) | WithTag . TAG ( Constants . ActiveTags . FLAG ) ;
getWidth: public static int getWidth ( ) { return Gdx . graphics . getWidth ( ) ;
setTableColumns: public void setTableColumns ( String tableColumns ) { this . tableColumns = tableColumns ;
updateAssetDataPrice: void updateAssetDataPrice ( String propertyId , double price ) { try {
getStartCreate: public static Boolean getStartCreate ( Context context ) { return getBoolean ( SETTINGS , context , START_CREATE ) ;
run: public void run ( HandlerSpecification < REQ , RES > handlerSpecification , Syscalls syscalls , @ Nullable Options options , SyscallCallback < ByteBuffer > callback ) { if ( options == null ) { options = Options . DEFAULT ; } Options finalOptions = options ; Executor wrapped = runnable -> finalOptions . executor . execute ( ( ) -> { SYSCALLS_THREAD_LOCAL . set ( syscalls ) ; try ( Scope ignored = syscalls . request ( ) . otelContext ( ) . makeCurrent ( ) ) { runnable . run ( ) ; } finally { SYSCALLS_THREAD_LOCAL . remove ( ) ; } } ) ; wrapped . execute (
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; fontId = jsonData . getString ( "id" ) ; fileName = jsonData . getString ( "fileName" ) ;
onLoadRoundsBoth: protected void onLoadRoundsBoth ( WeaponSlotComponent otherSlot ) { BrainOutClient . ClientController . sendTCP (
spawn: public void spawn ( ) { if ( currentBlock != null && closedBlock != null ) { Map map = Map . Get ( currentDimension ) ; if ( map != null ) { BlockData closed = closedBlock . getBlock ( ) ; map . setBlock ( currentBlockX , currentBlockY , closed , Constants . Layers . BLOCK_LAYER_FOREGROUND , true , 300 ) ; } currentBlock = null ; closedBlock = null ; return ; } ActiveData random = spawners . random ( ) ; if ( random == null ) { return ; } TargetBlocksSpawnerComponentData sp = random . getComponent ( TargetBlocksSpawnerComponentData . class ) ; if ( sp == null ) { spawners . removeValue ( random , true ) ; spawn ( ) ; return ; } Block block = sp . getOpenedBlock ( ) ; int x = ( int ) random . getX ( ) , y = ( int ) random . getY ( ) ; Map map = random . getMap ( ) ; if ( map == null ) return ; currentBlock = block . getBlock ( ) ; currentDimension = random . getDimension ( ) ; currentBlockX = x ; currentBlockY = y ; closedBlock = sp . getClosedBlock ( ) ; ShootingRangeTargetBlockComponentData bcb = currentBlock . getComponent ( ShootingRangeTargetBlockComponentData . class ) ; if ( bcb != null ) { bcb . setGroup ( group ) ; } map . setBlock ( x , y , currentBlock , Constants . Layers . BLOCK_LAYER_FOREGROUND , true ) ;
getReverbFilename: private String getReverbFilename ( String fileName ) { String [ ] split = fileName . split ( ":" ) ; String package_ = split [ 0 ] ; String path = split [ 1 ] ; String [ ] folders = path . split ( "/" ) ; String [ ] resFolders = new String [ folders . length + 1 ] ; if ( folders . length - 2 >= 0 ) System . arraycopy ( folders , 0 , resFolders , 0 , folders . length - 1 ) ; resFolders [ folders . length - 1 ] = "reverb" ; resFolders [ folders . length ] = folders [ folders . length - 1 ] ; return package_ + ":" + String . join ( "/" , resFolders ) ;
claim: No method body
setEntityClassName: public void setEntityClassName ( String entityClassName ) { this . entityClassName = entityClassName ;
groupQuery: public CommonResult < List < Dict > > groupQuery ( @ RequestParam ( "groupName" ) String groupName ) { List < Dict > dicts = dictService . queryAllByGroup ( groupName ) ; return CommonResult . success ( dicts ) ;
unitFormat: private static String unitFormat ( long i ) { String retStr ; if ( i >= 0 && i < 10 ) retStr = "0" + Long . toString ( i ) ; else retStr = "" + i ; return retStr ;
getContent: No method body
newMeshAttachment: No method body
getPressure: public double getPressure ( ) { return pressure ;
getSpec: public HandlerSpecification < REQ , RES > getSpec ( ) { return spec ;
onPulling: No method body
toString: public String toString ( ) { return id ;
getSelection: public Selection getSelection ( ) { return new PlayerSkinSlotSelection ( ) ;
readAnimation: private void readAnimation ( JsonValue map , String name , SkeletonData skeletonData ) { float scale = this . scale ; Array < Timeline > timelines = new Array ( ) ; for ( JsonValue slotMap = map . getChild ( "slots" ) ; slotMap != null ; slotMap = slotMap . next ) { SlotData slot = skeletonData . findSlot ( slotMap . name ) ; if ( slot == null ) throw new SerializationException ( "Slot not found: " + slotMap . name ) ; for ( JsonValue timelineMap = slotMap . child ; timelineMap != null ; timelineMap = timelineMap . next ) { JsonValue keyMap = timelineMap . child ; if ( keyMap == null ) continue ; int frames = timelineMap . size ; String timelineName = timelineMap . name ; if ( timelineName . equals ( "attachment" ) ) { AttachmentTimeline timeline = new AttachmentTimeline ( frames , slot . index ) ; for ( int frame = 0 ; keyMap != null ; keyMap = keyMap . next , frame ++ ) timeline . setFrame ( frame , keyMap . getFloat ( "time" , 0 ) , keyMap . getString ( "name" ) ) ; timelines . add ( timeline ) ; } else if ( timelineName . equals ( "rgba" ) ) { RGBATimeline timeline = new RGBATimeline ( frames , frames << 2 , slot . index ) ; float time = keyMap . getFloat ( "time" , 0 ) ; String color = keyMap . getString ( "color" ) ; float r = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float g = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float b = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; float a = Integer . parseInt ( color . substring ( 6 , 8 ) , 16 ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b , a ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; color = nextMap . getString ( "color" ) ; float nr = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float ng = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float nb = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; float na = Integer . parseInt ( color . substring ( 6 , 8 ) , 16 ) / 255f ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) { bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , r , nr , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 1 , time , time2 , g , ng , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 2 , time , time2 , b , nb , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 3 , time , time2 , a , na , 1 ) ; } time = time2 ; r = nr ; g = ng ; b = nb ; a = na ; keyMap = nextMap ; } timelines . add ( timeline ) ; } else if ( timelineName . equals ( "rgb" ) ) { RGBTimeline timeline = new RGBTimeline ( frames , frames * 3 , slot . index ) ; float time = keyMap . getFloat ( "time" , 0 ) ; String color = keyMap . getString ( "color" ) ; float r = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float g = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float b = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; color = nextMap . getString ( "color" ) ; float nr = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float ng = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float nb = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) { bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , r , nr , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 1 , time , time2 , g , ng , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 2 , time , time2 , b , nb , 1 ) ; } time = time2 ; r = nr ; g = ng ; b = nb ; keyMap = nextMap ; } timelines . add ( timeline ) ; } else if ( timelineName . equals ( "alpha" ) ) { timelines . add ( readTimeline ( keyMap , new AlphaTimeline ( frames , frames , slot . index ) , 0 , 1 ) ) ; } else if ( timelineName . equals ( "rgba2" ) ) { RGBA2Timeline timeline = new RGBA2Timeline ( frames , frames * 7 , slot . index ) ; float time = keyMap . getFloat ( "time" , 0 ) ; String color = keyMap . getString ( "light" ) ; float r = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float g = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float b = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; float a = Integer . parseInt ( color . substring ( 6 , 8 ) , 16 ) / 255f ; color = keyMap . getString ( "dark" ) ; float r2 = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float g2 = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float b2 = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b , a , r2 , g2 , b2 ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; color = nextMap . getString ( "light" ) ; float nr = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float ng = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float nb = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; float na = Integer . parseInt ( color . substring ( 6 , 8 ) , 16 ) / 255f ; color = nextMap . getString ( "dark" ) ; float nr2 = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float ng2 = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float nb2 = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) { bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , r , nr , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 1 , time , time2 , g , ng , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 2 , time , time2 , b , nb , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 3 , time , time2 , a , na , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 4 , time , time2 , r2 , nr2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 5 , time , time2 , g2 , ng2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 6 , time , time2 , b2 , nb2 , 1 ) ; } time = time2 ; r = nr ; g = ng ; b = nb ; a = na ; r2 = nr2 ; g2 = ng2 ; b2 = nb2 ; keyMap = nextMap ; } timelines . add ( timeline ) ; } else if ( timelineName . equals ( "rgb2" ) ) { RGB2Timeline timeline = new RGB2Timeline ( frames , frames * 6 , slot . index ) ; float time = keyMap . getFloat ( "time" , 0 ) ; String color = keyMap . getString ( "light" ) ; float r = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float g = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float b = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; color = keyMap . getString ( "dark" ) ; float r2 = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float g2 = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float b2 = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , r , g , b , r2 , g2 , b2 ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; color = nextMap . getString ( "light" ) ; float nr = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float ng = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float nb = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; color = nextMap . getString ( "dark" ) ; float nr2 = Integer . parseInt ( color . substring ( 0 , 2 ) , 16 ) / 255f ; float ng2 = Integer . parseInt ( color . substring ( 2 , 4 ) , 16 ) / 255f ; float nb2 = Integer . parseInt ( color . substring ( 4 , 6 ) , 16 ) / 255f ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) { bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , r , nr , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 1 , time , time2 , g , ng , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 2 , time , time2 , b , nb , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 3 , time , time2 , r2 , nr2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 4 , time , time2 , g2 , ng2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 5 , time , time2 , b2 , nb2 , 1 ) ; } time = time2 ; r = nr ; g = ng ; b = nb ; r2 = nr2 ; g2 = ng2 ; b2 = nb2 ; keyMap = nextMap ; } timelines . add ( timeline ) ; } else throw new RuntimeException ( "Invalid timeline type for a slot: " + timelineName + " (" + slotMap . name + ")" ) ; } } for ( JsonValue boneMap = map . getChild ( "bones" ) ; boneMap != null ; boneMap = boneMap . next ) { BoneData bone = skeletonData . findBone ( boneMap . name ) ; if ( bone == null ) throw new SerializationException ( "Bone not found: " + boneMap . name ) ; for ( JsonValue timelineMap = boneMap . child ; timelineMap != null ; timelineMap = timelineMap . next ) { JsonValue keyMap = timelineMap . child ; if ( keyMap == null ) continue ; int frames = timelineMap . size ; String timelineName = timelineMap . name ; if ( timelineName . equals ( "rotate" ) ) timelines . add ( readTimeline ( keyMap , new RotateTimeline ( frames , frames , bone . index ) , 0 , 1 ) ) ; else if ( timelineName . equals ( "translate" ) ) { TranslateTimeline timeline = new TranslateTimeline ( frames , frames << 1 , bone . index ) ; timelines . add ( readTimeline ( keyMap , timeline , "x" , "y" , 0 , scale ) ) ; } else if ( timelineName . equals ( "translatex" ) ) { timelines . add ( readTimeline ( keyMap , new TranslateXTimeline ( frames , frames , bone . index ) , 0 , scale ) ) ; } else if ( timelineName . equals ( "translatey" ) ) { timelines . add ( readTimeline ( keyMap , new TranslateYTimeline ( frames , frames , bone . index ) , 0 , scale ) ) ; } else if ( timelineName . equals ( "scale" ) ) { ScaleTimeline timeline = new ScaleTimeline ( frames , frames << 1 , bone . index ) ; timelines . add ( readTimeline ( keyMap , timeline , "x" , "y" , 1 , 1 ) ) ; } else if ( timelineName . equals ( "scalex" ) ) timelines . add ( readTimeline ( keyMap , new ScaleXTimeline ( frames , frames , bone . index ) , 1 , 1 ) ) ; else if ( timelineName . equals ( "scaley" ) ) timelines . add ( readTimeline ( keyMap , new ScaleYTimeline ( frames , frames , bone . index ) , 1 , 1 ) ) ; else if ( timelineName . equals ( "shear" ) ) { ShearTimeline timeline = new ShearTimeline ( frames , frames << 1 , bone . index ) ; timelines . add ( readTimeline ( keyMap , timeline , "x" , "y" , 0 , 1 ) ) ; } else if ( timelineName . equals ( "shearx" ) ) timelines . add ( readTimeline ( keyMap , new ShearXTimeline ( frames , frames , bone . index ) , 0 , 1 ) ) ; else if ( timelineName . equals ( "sheary" ) ) timelines . add ( readTimeline ( keyMap , new ShearYTimeline ( frames , frames , bone . index ) , 0 , 1 ) ) ; else throw new RuntimeException ( "Invalid timeline type for a bone: " + timelineName + " (" + boneMap . name + ")" ) ; } } for ( JsonValue timelineMap = map . getChild ( "ik" ) ; timelineMap != null ; timelineMap = timelineMap . next ) { JsonValue keyMap = timelineMap . child ; if ( keyMap == null ) continue ; IkConstraintData constraint = skeletonData . findIkConstraint ( timelineMap . name ) ; IkConstraintTimeline timeline = new IkConstraintTimeline ( timelineMap . size , timelineMap . size << 1 , skeletonData . getIkConstraints ( ) . indexOf ( constraint , true ) ) ; float time = keyMap . getFloat ( "time" , 0 ) ; float mix = keyMap . getFloat ( "mix" , 1 ) , softness = keyMap . getFloat ( "softness" , 0 ) * scale ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , mix , softness , keyMap . getBoolean ( "bendPositive" , true ) ? 1 : - 1 , keyMap . getBoolean ( "compress" , false ) , keyMap . getBoolean ( "stretch" , false ) ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; float mix2 = nextMap . getFloat ( "mix" , 1 ) , softness2 = nextMap . getFloat ( "softness" , 0 ) * scale ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) { bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , mix , mix2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 1 , time , time2 , softness , softness2 , scale ) ; } time = time2 ; mix = mix2 ; softness = softness2 ; keyMap = nextMap ; } timelines . add ( timeline ) ; } for ( JsonValue timelineMap = map . getChild ( "transform" ) ; timelineMap != null ; timelineMap = timelineMap . next ) { JsonValue keyMap = timelineMap . child ; if ( keyMap == null ) continue ; TransformConstraintData constraint = skeletonData . findTransformConstraint ( timelineMap . name ) ; TransformConstraintTimeline timeline = new TransformConstraintTimeline ( timelineMap . size , timelineMap . size * 6 , skeletonData . getTransformConstraints ( ) . indexOf ( constraint , true ) ) ; float time = keyMap . getFloat ( "time" , 0 ) ; float mixRotate = keyMap . getFloat ( "mixRotate" , 1 ) ; float mixX = keyMap . getFloat ( "mixX" , 1 ) , mixY = keyMap . getFloat ( "mixY" , mixX ) ; float mixScaleX = keyMap . getFloat ( "mixScaleX" , 1 ) , mixScaleY = keyMap . getFloat ( "mixScaleY" , mixScaleX ) ; float mixShearY = keyMap . getFloat ( "mixShearY" , 1 ) ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , mixRotate , mixX , mixY , mixScaleX , mixScaleY , mixShearY ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; float mixRotate2 = nextMap . getFloat ( "mixRotate" , 1 ) ; float mixX2 = nextMap . getFloat ( "mixX" , 1 ) , mixY2 = nextMap . getFloat ( "mixY" , mixX2 ) ; float mixScaleX2 = nextMap . getFloat ( "mixScaleX" , 1 ) , mixScaleY2 = nextMap . getFloat ( "mixScaleY" , mixScaleX2 ) ; float mixShearY2 = nextMap . getFloat ( "mixShearY" , 1 ) ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) { bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , mixRotate , mixRotate2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 1 , time , time2 , mixX , mixX2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 2 , time , time2 , mixY , mixY2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 3 , time , time2 , mixScaleX , mixScaleX2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 4 , time , time2 , mixScaleY , mixScaleY2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 5 , time , time2 , mixShearY , mixShearY2 , 1 ) ; } time = time2 ; mixRotate = mixRotate2 ; mixX = mixX2 ; mixY = mixY2 ; mixScaleX = mixScaleX2 ; mixScaleY = mixScaleY2 ; mixScaleX = mixScaleX2 ; keyMap = nextMap ; } timelines . add ( timeline ) ; } for ( JsonValue constraintMap = map . getChild ( "path" ) ; constraintMap != null ; constraintMap = constraintMap . next ) { PathConstraintData constraint = skeletonData . findPathConstraint ( constraintMap . name ) ; if ( constraint == null ) throw new SerializationException ( "Path constraint not found: " + constraintMap . name ) ; int index = skeletonData . pathConstraints . indexOf ( constraint , true ) ; for ( JsonValue timelineMap = constraintMap . child ; timelineMap != null ; timelineMap = timelineMap . next ) { JsonValue keyMap = timelineMap . child ; if ( keyMap == null ) continue ; int frames = timelineMap . size ; String timelineName = timelineMap . name ; if ( timelineName . equals ( "position" ) ) { CurveTimeline1 timeline = new PathConstraintPositionTimeline ( frames , frames , index ) ; timelines . add ( readTimeline ( keyMap , timeline , 0 , constraint . positionMode == PositionMode . fixed ? scale : 1 ) ) ; } else if ( timelineName . equals ( "spacing" ) ) { CurveTimeline1 timeline = new PathConstraintSpacingTimeline ( frames , frames , index ) ; timelines . add ( readTimeline ( keyMap , timeline , 0 , constraint . spacingMode == SpacingMode . length || constraint . spacingMode == SpacingMode . fixed ? scale : 1 ) ) ; } else if ( timelineName . equals ( "mix" ) ) { PathConstraintMixTimeline timeline = new PathConstraintMixTimeline ( frames , frames * 3 , index ) ; float time = keyMap . getFloat ( "time" , 0 ) ; float mixRotate = keyMap . getFloat ( "mixRotate" , 1 ) ; float mixX = keyMap . getFloat ( "mixX" , 1 ) , mixY = keyMap . getFloat ( "mixY" , mixX ) ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { timeline . setFrame ( frame , time , mixRotate , mixX , mixY ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; float mixRotate2 = nextMap . getFloat ( "mixRotate" , 1 ) ; float mixX2 = nextMap . getFloat ( "mixX" , 1 ) , mixY2 = nextMap . getFloat ( "mixY" , mixX2 ) ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) { bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , mixRotate , mixRotate2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 1 , time , time2 , mixX , mixX2 , 1 ) ; bezier = readCurve ( curve , timeline , bezier , frame , 2 , time , time2 , mixY , mixY2 , 1 ) ; } time = time2 ; mixRotate = mixRotate2 ; mixX = mixX2 ; mixY = mixY2 ; keyMap = nextMap ; } timelines . add ( timeline ) ; } } } for ( JsonValue deformMap = map . getChild ( "deform" ) ; deformMap != null ; deformMap = deformMap . next ) { Skin skin = skeletonData . findSkin ( deformMap . name ) ; if ( skin == null ) throw new SerializationException ( "Skin not found: " + deformMap . name ) ; for ( JsonValue slotMap = deformMap . child ; slotMap != null ; slotMap = slotMap . next ) { SlotData slot = skeletonData . findSlot ( slotMap . name ) ; if ( slot == null ) throw new SerializationException ( "Slot not found: " + slotMap . name ) ; for ( JsonValue timelineMap = slotMap . child ; timelineMap != null ; timelineMap = timelineMap . next ) { JsonValue keyMap = timelineMap . child ; if ( keyMap == null ) continue ; VertexAttachment attachment = ( VertexAttachment ) skin . getAttachment ( slot . index , timelineMap . name ) ; if ( attachment == null ) throw new SerializationException ( "Deform attachment not found: " + timelineMap . name ) ; boolean weighted = attachment . getBones ( ) != null ; float [ ] vertices = attachment . getVertices ( ) ; int deformLength = weighted ? ( vertices . length / 3 ) << 1 : vertices . length ; DeformTimeline timeline = new DeformTimeline ( timelineMap . size , timelineMap . size , slot . index , attachment ) ; float time = keyMap . getFloat ( "time" , 0 ) ; for ( int frame = 0 , bezier = 0 ; ; frame ++ ) { float [ ] deform ; JsonValue verticesValue = keyMap . get ( "vertices" ) ; if ( verticesValue == null ) deform = weighted ? new float [ deformLength ] : vertices ; else { deform = new float [ deformLength ] ; int start = keyMap . getInt ( "offset" , 0 ) ; arraycopy ( verticesValue . asFloatArray ( ) , 0 , deform , start , verticesValue . size ) ; if ( scale != 1 ) { for ( int i = start , n = i + verticesValue . size ; i < n ; i ++ ) deform [ i ] *= scale ; } if ( ! weighted ) { for ( int i = 0 ; i < deformLength ; i ++ ) deform [ i ] += vertices [ i ] ; } } timeline . setFrame ( frame , time , deform ) ; JsonValue nextMap = keyMap . next ; if ( nextMap == null ) { timeline . shrink ( bezier ) ; break ; } float time2 = nextMap . getFloat ( "time" , 0 ) ; JsonValue curve = keyMap . get ( "curve" ) ; if ( curve != null ) bezier = readCurve ( curve , timeline , bezier , frame , 0 , time , time2 , 0 , 1 , 1 ) ; time = time2 ; keyMap = nextMap ; } timelines . add ( timeline ) ; } } } JsonValue drawOrdersMap = map . get ( "drawOrder" ) ; if ( drawOrdersMap != null ) { DrawOrderTimeline timeline = new DrawOrderTimeline ( drawOrdersMap . size ) ; int slotCount = skeletonData . slots . size ; int frame = 0 ; for ( JsonValue drawOrderMap = drawOrdersMap . child ; drawOrderMap != null ; drawOrderMap = drawOrderMap . next , frame ++ ) { int [ ] drawOrder = null ; JsonValue offsets = drawOrderMap . get ( "offsets" ) ; if ( offsets != null ) { drawOrder = new int [ slotCount ] ; for ( int i = slotCount - 1 ; i >= 0 ; i -- ) drawOrder [ i ] = - 1 ; int [ ] unchanged = new int [ slotCount - offsets . size ] ; int originalIndex = 0 , unchangedIndex = 0 ; for ( JsonValue offsetMap = offsets . child ; offsetMap != null ; offsetMap = offsetMap . next ) { SlotData slot = skeletonData . findSlot ( offsetMap . getString ( "slot" ) ) ; if ( slot == null ) throw new SerializationException ( "Slot not found: " + offsetMap . getString ( "slot" ) ) ; while ( originalIndex != slot . index ) unchanged [ unchangedIndex ++ ] = originalIndex ++ ; drawOrder [ originalIndex + offsetMap . getInt ( "offset" ) ] = originalIndex ++ ; } while ( originalIndex < slotCount ) unchanged [ unchangedIndex ++ ] = originalIndex ++ ; for ( int i = slotCount - 1 ; i >= 0 ; i -- ) if ( drawOrder [ i ] == - 1 ) drawOrder [ i ] = unchanged [ -- unchangedIndex ] ; } timeline . setFrame ( frame , drawOrderMap . getFloat ( "time" , 0 ) , drawOrder ) ; } timelines . add ( timeline ) ; } JsonValue eventsMap = map . get ( "events" ) ; if ( eventsMap != null ) { EventTimeline timeline = new EventTimeline ( eventsMap . size ) ; int frame = 0 ; for ( JsonValue eventMap = eventsMap . child ; eventMap != null ; eventMap = eventMap . next , frame ++ ) { EventData eventData = skeletonData . findEvent ( eventMap . getString ( "name" ) ) ; if ( eventData == null ) throw new SerializationException ( "Event not found: " + eventMap . getString ( "name" ) ) ; Event event = new Event ( eventMap . getFloat ( "time" , 0 ) , eventData ) ; event . intValue = eventMap . getInt ( "int" , eventData . intValue ) ; event . floatValue = eventMap . getFloat ( "float" , eventData . floatValue ) ; event . stringValue = eventMap . getString ( "string" , eventData . stringValue ) ; if ( event . getData ( ) . audioPath != null ) { event . volume = eventMap . getFloat ( "volume" , eventData . volume ) ; event . balance = eventMap . getFloat ( "balance" , eventData . balance ) ; } timeline . setFrame ( frame , event ) ; } timelines . add ( timeline ) ; } timelines . shrink ( ) ; float duration = 0 ; Object [ ] items = timelines . items ; for ( int i = 0 , n = timelines . size ; i < n ; i ++ ) duration = Math . max ( duration , ( ( Timeline ) items [ i ] ) . getDuration ( ) ) ; skeletonData . animations . add ( new Animation ( name , timelines , duration ) ) ;
init: public void init ( ) { SteamEnvironment env = ( ( SteamEnvironment ) BrainOutClient . Env ) ; user = new SteamUser ( new SteamUserCallback ( ) { @ Override public void onAuthSessionTicket ( SteamAuthTicket authTicket , SteamResult result ) { } @ Override public void onValidateAuthTicket ( SteamID steamID , SteamAuth . AuthSessionResponse authSessionResponse , SteamID ownerSteamID ) { } @ Override public void onMicroTxnAuthorization ( int appID , long orderID , boolean authorized ) { if ( authorized ) { if ( appID == SteamConstants . APP_ID ) { BrainOutClient . ClientController . updateOrder ( orderID ) ; } } Menu topMenu = BrainOutClient . getInstance ( ) . topState ( ) . topMenu ( ) ; if ( topMenu != null ) { topMenu . onFocusIn ( ) ; } } @ Override public void onEncryptedAppTicket ( SteamResult result ) { } } ) ; env . getGameUser ( ) . setSteamUser ( user ) ; getTicket ( ) ;
getFlipX: public boolean getFlipX ( ) { return false ;
getID: public ID getID ( ) { return ID . deathmatch ;
reset: public void reset ( ObjectContext ctx ) { ctx . clearAll ( ) ;
getTitle: public String getTitle ( CardData cardData ) { ContentCardData contentCardData = ( ( ContentCardData ) cardData ) ; OwnableContent cardContent = contentCardData . getCardContent ( ) ; ContentCardComponent c = contentCardData . getCard ( ) . getComponentFrom ( ContentCardComponent . class ) ; int amount = c != null ? c . getAmount ( ) : contentCardData . getAmount ( ) ; if ( BrainOut . R . instanceOf ( Case . class , cardContent ) ) { return "x" + amount ; } return ( amount > 1 ? "x" + amount + " " : "" ) + cardContent . getTitle ( ) . get ( ) ;
postProcess: public Owner postProcess ( ) { if ( getOwner ( ) == Owner . neutral ) { int neighborsA = 0 ; int neighborsB = 0 ; for ( ZoneData neighbor : neighbors ) { if ( neighbor . getOwner ( ) == Owner . a ) { neighborsA ++ ; } if ( neighbor . getOwner ( ) == Owner . b ) { neighborsB ++ ; } } if ( neighborsA == 0 && neighborsB > 0 ) { return Owner . a ; } if ( neighborsB == 0 && neighborsA > 0 ) { return Owner . b ; } } return Owner . neutral ;
getSteamMass: public double getSteamMass ( ) { return 0 ;
timedOut: public boolean timedOut ( PlayStateEndGame . GameResult gameResult ) { return false ;
init: public void init ( ) { super . init ( ) ; if ( instrumentData == null || instrumentData . getOwner ( ) == null ) return ; this . playerAnimation = instrumentData . getOwner ( ) . getComponent ( PlayerAnimationComponentData . class ) ; launchPointData = new BonePointData ( getSkeleton ( ) . findBone ( "fire-bone" ) , instrumentLaunch ) ;
getShortName: public String getShortName ( Type type ) { String result = "" ; if ( type instanceof Class < ? > ) { Class < ? > cType = ( Class < ? > ) type ; return cType . getSimpleName ( ) ; } else if ( type instanceof ParameterizedType ) { ParameterizedType pType = ( ParameterizedType ) type ; List < String > replaces = new ArrayList < > ( ) ; replaces . add ( ( ( Class < ? > ) pType . getRawType ( ) ) . getPackageName ( ) ) ; for ( Type t : pType . getActualTypeArguments ( ) ) { if ( t instanceof Class < ? > ) { replaces . add ( ( ( Class < ? > ) t ) . getPackageName ( ) ) ; } } result = type . getTypeName ( ) ; for ( String rep : replaces ) { result = result . replace ( rep + "." , "" ) ; } } return result ;
release: protected void release ( ) { if ( ! StringUtils . isEmpty ( mNextPageClass ) ) {
getCompress: public boolean getCompress ( ) { return compress ;
getDto: public D getDto ( ) { return dto ;
validateMxRecordSetupForInboundParse: No method body
getMsg: private static String getMsg ( String msg ) { if ( isExpandMsg ) msg = mark + msg ; return msg ;
getContentView: protected int getContentView ( ) { return R . layout . activity_init_wallet_menu ;
sendEmailViaMailSender: void sendEmailViaMailSender ( String fullTo , final MimeMessage mimeMessage ) { try { mailSender . send ( mimeMessage ) ; } catch ( MailException e ) { error ( "[sendEmail] Error sending email to {} : {}" , fullTo , e ) ; } info ( "[sendEmail] Mail to {} sent" , fullTo ) ;
acquireVelocityTracker: private void acquireVelocityTracker ( final MotionEvent event ) { if ( null == mVelocityTracker ) { mVelocityTracker = VelocityTracker . obtain ( ) ; } mVelocityTracker . addMovement ( event ) ;
get: public static Clock get ( ) { return ( ) -> - 1 ;
onFocusIn: public void onFocusIn ( ) { BrainOutClient . Env . getGameController ( ) . setControllerMode ( GameController . ControllerMode . actionWithNoMouseLocking ) ; BrainOutClient . Env . getGameController ( ) . reset ( ) ; enablePlayerAimMarker ( false ) ; if ( ClientConstants . Client . MOUSE_LOCK )
createUserTest: public void createUserTest ( ) { reset ( userRepository ) ; User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( 1L ) ; when ( userRepository . save ( any ( User . class ) ) ) . thenReturn ( user ) ; userService . createUser ( USER_FIRST_NAME , USER_LAST_NAME , USER_EMAIL , true , null , null ) ; verify ( userRepository ) . save ( any ( User . class ) ) ; verify ( userRepository ) . findOne ( anyLong ( ) ) ;
asInt: public int asInt ( ) { try
getDimension: public String getDimension ( ) { return itemData . getDimension ( ) ;
setCode: public void setCode ( String code ) { this . code = code ;
registerService: private void registerService ( ) { this . service = new JRPCBukkitService ( this ) ; if ( ! service . start ( ) ) { getLogger ( ) . severe ( "Service could not be created, exiting." ) ; Bukkit . getPluginManager ( ) . disablePlugin ( this ) ; return ; } Bukkit . getServicesManager ( ) . register ( JRPCBukkitService . class , service , this , ServicePriority . Highest ) ;
setLengths: public void setLengths ( float [ ] lengths ) { this . lengths = lengths ;
init: public void init ( WeaponSlotComponent slot ) { if ( magazines != null && magazines . size == 0 )
testChainedRun: void testChainedRun ( ) { final OpenAiCompletionsParameters parameters = new OpenAiCompletionsParameters ( ) ; parameters . setModel ( "text-davinci-003" ) ; final Chain < Map < String , String > , String > chain = new OpenAiCompletionsChain ( "Hello, this is ${name}. What is your name?" , parameters , System . getenv ( "OPENAI_API_KEY" ) ) . chain ( prev -> Collections . singletonMap ( "result" , prev ) ) . chain ( new OpenAiCompletionsChain ( "What was the question for the following answer: ${result}" , parameters , System . getenv ( "OPENAI_API_KEY" ) ) ) ; final String result = chain . run ( Collections . singletonMap ( "name" , "Manuel" ) ) ; LOGGER . info ( result ) ; assertNotNull ( result , "got no result from chain" ) ;
setCurrentSlot: public boolean setCurrentSlot ( WeaponSlotComponent currentSlot ) { if ( this . currentSlot != currentSlot ) { this . currentSlot = currentSlot ; return true ; } return false ;
execute: public String execute ( String [ ] args , Client client ) { String item = args [ 1 ] ; String amount = args [ 2 ] ; try { float amountInt = Float . valueOf ( amount ) ; client . setStat ( item , amountInt ) ; if ( client instanceof PlayerClient ) { ( ( PlayerClient ) client ) . sendUserProfile ( ) ; } } catch ( NumberFormatException e ) { return "Bad format" ; } return "Done" ;
isSlackIntegrated: public boolean isSlackIntegrated ( Long orgId ) { IntegrationModuleOrganizationConfiguration config = integrationService . getOrganizationConfiguration ( orgId ) ; return StringUtils . isNotBlank ( config . getSlackWebhookUrl ( ) ) ;
buildLuminanceSource: public PlanarYUVLuminanceSource buildLuminanceSource ( byte [ ] data , int width , int height ) { Rect rect = getFramingRectInPreview ( ) ; if ( rect == null ) { return null ; } if ( isFullScreenScan ) { return new PlanarYUVLuminanceSource ( data , width , height , 0 , 0 , width , height , false ) ; } int size = Math . min ( width , height ) ; int left = ( width - size ) / 2 ; int top = ( height - size ) / 2 ; return new PlanarYUVLuminanceSource ( data , width , height , left , top ,
matches: public int matches ( ItemData itemData , ConsumableRecord record ) { if ( record . getItem ( ) . getContent ( ) . hasComponent ( ServerCampfireActivatorComponent . class ) ) return 0 ; if ( record . getItem ( ) . getContent ( ) . hasComponent ( CampFireFuelComponent . class ) ) return 1 ; return 0 ;
downloadLogs: public Object downloadLogs ( ) { debug ( "[downloadLogs]" ) ; return services . logConfig . getDebugEntries ( ) ;
isKeepPositionOnRotation: public boolean isKeepPositionOnRotation ( ) { return mKeepPositionOnRotation ;
setLoad: public WeaponLoad setLoad ( String slot , int amount , int chambered ) { WeaponLoad load = loads . get ( slot ) ; if ( load == null ) { load = new WeaponLoad ( ) ; loads . put ( slot , load ) ; } load . amount = amount ; load . chambered = chambered ; return load ;
isLightsVisible: public boolean isLightsVisible ( ) { return lightsVisible ;
mouseDown: public boolean mouseDown ( Vector2 position , int button ) { this . position . set ( position ) ; updateActiveDatas ( ) ; if ( isCutterEnabled ( ) ) { if ( closestActive != null ) { BrainOutClient . ClientController . sendTCP ( new Editor2ActiveRemoveMsg ( closestActive ) ) ; } } else { if ( closestActive == null ) { BrainOutClient . ClientController . sendTCP ( new Editor2ActiveAddMsg ( light , position . x , position . y , getMenu ( ) . getDimension ( ) ) ) ; } } return true ;
getLineWidth: public float getLineWidth ( ) { return mLineWidth ;
isHidden: public boolean isHidden ( ) { return this . hidden ; }
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jRadioButtonMenuItem1ActionPerformed ( evt ) ;
copyLiveToDraft: public Object copyLiveToDraft ( @ PathVariable ( ID ) Long frontendResourceId ) { debug ( "[copyLiveToDraft] FrontendResourceId: {}" , frontendResourceId ) ; return copyLiveContentToDraft ( frontendResourceId )
lookupInvoiceV2: No method body
hasUpdate: public boolean hasUpdate ( ) { return false ;
getDefaultSkin: public @ Null Skin getDefaultSkin ( ) { return defaultSkin ;
refresh: private void refresh ( boolean resetScroll , boolean uncheckAll ) { if ( resetScroll ) { scrollY = 0 ; } if ( giveItemFilter == null ) categoriesButtons . setChecked ( L . get ( NO_FILTER_CATEGORY_NAME ) ) ; if ( uncheckAll ) categoriesButtons . uncheckAll ( ) ; if ( giveItemFilterTitle == null && giveItemFilter != null && giveItemPayloadFilter != null ) { search . clearChildren ( ) ; search . setBackground ( "form-dark-blue" ) ; String itemText ; if ( giveItemFilterTitle != null ) { itemText = giveItemFilterTitle ; } else { ConsumableRecord record = MarketUtils . MarketObjectToConsumableRecord ( giveItemFilter , giveItemPayloadFilter , 1 ) ; if ( record != null ) { itemText = getItemText ( record ) ; } else { itemText = "???" ; } } Label searchFor = new Label ( itemText , BrainOutClient . Skin , "title-small" ) ; searchFor . setEllipsis ( true ) ; searchFor . setWrap ( true ) ; searchFor . setAlignment ( Align . center ) ; search . add ( searchFor ) . expand ( ) . fill ( ) ; ImageButton closeSearch = new ImageButton ( BrainOutClient . Skin , "button-reject" ) ; closeSearch . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; hideSortingButton = false ; giveItemFilterTitle = null ; giveItemFilter = null ; giveItemPayloadFilter = null ; refresh ( true ) ; } } ) ; search . add ( closeSearch ) . size ( 32 ) . row ( ) ; } else { setSearchInactive ( ) ; } setKeyboardFocus ( null ) ; orders . clearChildren ( ) ; orders . add ( new LoadingBlock ( ) ) . expand ( ) . center ( ) . pad ( 128 ) . row ( ) ; if ( sorting != null ) { sorting . setVisible ( ! hideSortingButton ) ; sorting . setText ( L . get ( getSortFilter ( ) == MarketService . MarkerEntriesOrder . none ? "MENU_ORDER_DATE" : "MENU_ORDER_PRICE" ) ) ; } MarketService marketService = MarketService . Get ( ) ; LoginService loginService = LoginService . Get ( ) ; if ( marketService != null && loginService != null )
lockRender: public boolean lockRender ( ) { return true ;
validDimension: private boolean validDimension ( Client client ) { if ( playerData == null || client . getPlayerData ( ) == null ) { return true ; } return client . getPlayerData ( ) . getDimension ( ) . equals ( playerData . getDimension ( ) ) ;
notifyDataChanged: public void notifyDataChanged ( ) { calcMinMax ( ) ;
test_getSubscribersWithNullParams: public void test_getSubscribersWithNullParams ( ) throws IOException , NovuNetworkException , InterruptedException { mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( new SubscriberResponse ( ) ) ) ) ; subscribersHandler . getSubscribers ( null , null ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/subscribers" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ;
processEmail: public void processEmail ( String message ) { log . info ( "Email Receiver:{}" , message ) ;
initChars: public void initChars ( ) { CampFireFuelComponent cf = record . getItem ( ) . getContent ( ) . getComponent ( CampFireFuelComponent . class ) ; if ( cf != null ) { add ( "item-char-burning-time" , "MENU_BURNING_TIME" , ( ) -> cf . getDuration ( record . getQuality ( ) ) , new SimpleView ( "MENU_SECONDS" ) ) ; } AddWeightComponent aw = record . getItem ( ) . getContent ( ) . getComponent ( AddWeightComponent . class ) ; if ( aw != null ) { add ( "item-char-weight" , "MENU_WEIGHT_BOOST" , ( ) -> aw . getWeight ( record . getQuality ( ) ) , new SimpleView ( ) ) ; } if ( record . getItem ( ) instanceof RealEstateConsumableItem ) { RealEstateConsumableItem rci = ( ( RealEstateConsumableItem ) record . getItem ( ) ) ; add ( "item-char-location" , "MENU_REAL_ESTATE_LOCATION" , ( ) -> 0 , new TextView ( L . get ( "REAL_ESTATE_LOCATION_" + rci . getLocation ( ) ) ) ) ; String code = rci . getId ( ) ; if ( code . startsWith ( "A" ) ) { code = code . substring ( 1 ) ; } while ( code . length ( ) < 3 ) { code = "0" + code ; } String fcode = code ; add ( "item-char-id" , "MENU_REAL_ESTATE_UNIT" , ( ) -> 0 , new TextView ( rci . getId ( ) ) ) ; add ( "item-char-id" , "MENU_REAL_ESTATE_CODE" , ( ) -> 0 , new TextView ( fcode ) ) ; add ( "item-char-rooms" , "MENU_REAL_ESTATE_ROOMS" , ( ) -> 0 , new TextView ( rci . getContent ( ) . getRooms ( ) ) ) ; add ( "item-char-rooms" , "MENU_REAL_ESTATE_VARIANT" , ( ) -> 0 , new TextView ( rci . getContent ( ) . getVariant ( ) ) ) ; } if ( record . getItem ( ) instanceof RealEstateItemConsumableItem ) { RealEstateItemConsumableItem rcii = ( ( RealEstateItemConsumableItem ) record . getItem ( ) ) ; SpriteWithBlocksComponent cc = rcii . getContent ( ) . getComponent ( SpriteWithBlocksComponent . class ) ; if ( cc != null ) { add ( null , null , ( ) -> 0 , new View ( ) { @ Override public void render ( Data from , Table to ) { Group g = new Group ( ) ; g . setSize ( cc . getWidth ( ) * Constants . Graphics . BLOCK_SIZE , cc . getHeight ( ) * Constants . Graphics . BLOCK_SIZE ) ; for ( SpriteWithBlocksComponent . SpriteImage image : cc . getImages ( ) ) { Image im = new Image ( BrainOutClient . Skin , image . getImage ( ) ) ; im . setBounds ( image . getX ( ) * Constants . Graphics . BLOCK_SIZE , image . getY ( ) * Constants . Graphics . BLOCK_SIZE , image . getW ( ) * Constants . Graphics . BLOCK_SIZE , image . getH ( ) * Constants . Graphics . BLOCK_SIZE ) ; im . setScaling ( Scaling . fill ) ; im . setTouchable ( Touchable . disabled ) ; g . addActor ( im ) ; } to . add ( g ) . size ( cc . getWidth ( ) * Constants . Graphics . BLOCK_SIZE , cc . getHeight ( ) * Constants . Graphics . BLOCK_SIZE ) ; } @ Override public boolean hasLabel ( ) { return false ; } @ Override public float getExpectedHeight ( ) { return cc . getHeight ( ) * Constants . Graphics . BLOCK_SIZE + 24 ; } } ) ; } } if ( record . getItem ( ) instanceof ArmorConsumableItem ) { ArmorConsumableItem armor = ( ( ArmorConsumableItem ) record . getItem ( ) ) ; float head = armor . getProtect ( "head" , record . getQuality ( ) ) ; if ( head > 0 ) { add ( "item-char-protection" , "MENU_ARMOR_HEAD" , ( ) -> head , new SimpleView ( ) ) ; } float body = armor . getProtect ( "body" , record . getQuality ( ) ) ; if ( body > 0 ) { add ( "item-char-protection" , "MENU_ARMOR_BODY" , ( ) -> body , new SimpleView ( ) ) ; } } BoosterActivatorComponent booster = record . getItem ( ) . getContent ( ) . getComponent ( BoosterActivatorComponent . class ) ; if ( booster != null )
test_getExecutionDetails: public void test_getExecutionDetails ( ) throws IOException , NovuNetworkException , InterruptedException { ExecutiveDetailsResponse executiveDetailsResponse = new ExecutiveDetailsResponse ( ) ; ExecutionDetails executionDetails = new ExecutionDetails ( ) ; executionDetails . setTransactionId ( "tId" ) ; executionDetails . setProviderId ( "pId" ) ; executionDetails . setDetail ( "detail" ) ; executionDetails . setNotificationId ( "nId" ) ; executionDetails . setSubscriberId ( "sId" ) ; executiveDetailsResponse . setData ( Collections . singletonList ( executionDetails ) ) ; Gson gson = new Gson ( ) ; mockWebServer . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( gson . toJson ( executiveDetailsResponse ) ) ) ; ExecutiveDetailsResponse response = executiveDetailsHandler . getExecutionDetails ( "nId" , "sId" ) ; RecordedRequest request = mockWebServer . takeRequest ( ) ; assertEquals ( "/execution-details?subscriberId=sId&notificationId=nId" , request . getPath ( ) ) ; assertEquals ( "GET" , request . getMethod ( ) ) ; assertEquals ( gson . toJson ( executiveDetailsResponse ) , gson . toJson ( response ) ) ;
createOrContinue: public static void createOrContinue ( Class element , boolean fullscreen , boolean justInit ) { for ( UIUpdateable i : elementsToUpdate ) { if ( i . getClass ( ) == element ) { i . setVisibility ( true ) ; ( ( JFrame ) i ) . toFront ( ) ; ( ( JFrame ) i ) . requestFocus ( ) ; return ; } } try {
onEvent: public boolean onEvent ( Event event ) { switch ( event . getID ( ) ) { case setInstrument : { if ( particle == null ) updateParticles ( ) ; break ; } case simple : { SimpleEvent e = ( ( SimpleEvent ) event ) ; if ( e . getAction ( ) == SimpleEvent . Action . deselected ) { removeParticle ( ) ; } break ; } } return false ;
clicked: public void clicked ( InputEvent event , float x , float y ) { editMapProperies ( ) ;
get: public < T1 , T2 , T3 , T4 , T5 , T6 > Tuple6 < T1 , T2 , T3 , T4 , T5 , T6 > get ( PageAttr < T1 > key1 , PageAttr < T2 > key2 , PageAttr < T3 > key3 , PageAttr < T4 > key4 , PageAttr < T5 > key5 , PageAttr < T6 > key6 ) { return Tuples . of ( ( T1 ) super . get ( key1 . name ) , ( T2 ) super . get ( key2 . name ) , ( T3 ) super . get ( key3 . name ) , ( T4 ) super . get ( key4 . name ) , ( T5 ) super . get ( key5 . name ) , ( T6 ) super . get ( key6 . name ) ) ;
onClick: public void onClick ( View v ) { result . cancel ( ) ; dialog . dismiss ( ) ;
isForceUpdate: public boolean isForceUpdate ( ) { return false ;
getContent: public Content getContent ( ) { return content ;
insertOrUpdateAssetDataByAmount: void insertOrUpdateAssetDataByAmount ( String propertyId , double amount , long date ) { boolean dataExist = checkDataExist ( propertyId , date ) ; double price = 0 ; double channelAmount = 0 ; if ( dataExist ) {
getAmount: public int getAmount ( ) { return amount ;
A: public synchronized void A ( ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " A()" ) ; try {
getComponent: public TraceEffectComponentData getComponent ( ComponentObject componentObject ) { return new TraceEffectComponentData ( componentObject , this ) ;
getID: public ID getID ( ) { return ID . actives ;
addLast: void addLast ( ) { l . addLast ( "nicola" ) ; l . addLast ( "giovanni" ) ; assertEquals ( 2 , l . size ( ) ) ; assertEquals ( "giovanni" , l . removeLast ( ) ) ;
findByName: public DynamicPrivilege findByName ( String name ) { return dynamicPrivilegeRepository . findByName ( name ) ;
createUI: public Table createUI ( ) { Table list = new Table ( ) ; list . align ( Align . center ) ; Table content = new Table ( ) ; initContent ( content ) ; ScrollPane items = new ScrollPane ( content ) ; list . add ( items ) . pad ( 4 ) . expand ( ) . fillX ( ) . maxHeight ( BrainOutClient . getHeight ( ) - 20f ) ; return list ;
getTask: public T getTask ( ) { return task ;
onFail: No method body
updateWorldTransform: public void updateWorldTransform ( ) { Object [ ] bones = this . bones . items ; for ( int i = 0 , n = this . bones . size ; i < n ; i ++ ) { Bone bone = ( Bone ) bones [ i ] ; bone . ax = bone . x ; bone . ay = bone . y ; bone . arotation = bone . rotation ; bone . ascaleX = bone . scaleX ; bone . ascaleY = bone . scaleY ; bone . ashearX = bone . shearX ; bone . ashearY = bone . shearY ; } Object [ ] updateCache = this . updateCache . items ; for ( int i = 0 , n = this . updateCache . size ; i < n ; i ++ )
setShowIndicator: public void setShowIndicator ( boolean show ) { this . mShowIndicator = show ;
getLoginForm: public Object getLoginForm ( @ RequestParam ( required = false ) String error , @ RequestParam ( required = false ) String logout ) { debug ( "[getLoginForm]" ) ; ModelAndView mav = new ModelAndView ( frontendResourceTemplateNamePrefix + "login::login-form" ) ; if ( error != null ) { mav . addObject ( "param.error" , error ) ; } if ( logout != null ) { mav . addObject ( "param.logout" , logout ) ; } return mav ;
getAdapter: private RecyclerView . Adapter getAdapter ( ) { return mAdapter ;
setFrontendResourceId: public void setFrontendResourceId ( Long frontendResourceId ) { this . frontendResourceId = frontendResourceId ;
toString: public String toString ( ) { return data . name ;
setRandomPlayerAsFox: private void setRandomPlayerAsFox ( Client fox ) { Array < Client > clientList = new Array < > ( ) ; for ( ObjectMap . Entry < Integer , Client > entry : BrainOutServer . Controller . getClients ( ) ) { Client client1 = entry . value ; if ( client1 == fox || ! client1 . isAlive ( ) ) continue ; clientList . add ( client1 ) ; } if ( clientList . size > 0 )
sourceAt: public TemplateSource sourceAt ( String location ) { Path path = Paths . get ( location ) ; return new TemplateSource ( ) {
getTarget: public Bone getTarget ( ) { return target ;
getResponseCode: public int getResponseCode ( ) { return responseCode ;
checkExistingFollowing: private boolean checkExistingFollowing ( ) { return getController ( ) . isFollowing ( flagData ) ;
getInterpolation: public float getInterpolation ( float input ) { input *= 2f ; if ( input < 1f ) { return 0.5f * ( float ) Math . pow ( input , 3 ) ; } input -= 2f ; return 0.5f * ( ( float ) Math . pow ( input , 3 ) + 2f ) ;
error: public static AjaxResult error ( int code , String message ) { return new AjaxResult ( code , message , null ) ;
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; repeatY = jsonData . getFloat ( "repeatY" , 0 ) ;
wordFrequency: void wordFrequency ( ) throws IOException { assertEquals ( "yesterdays" , WordAfterWord . wordAfterWord ( filename , "yesterday" ) ) ; assertEquals ( "gold" , WordAfterWord . wordAfterWord ( filename , "goings" ) ) ; assertEquals ( "zero" , WordAfterWord . wordAfterWord ( filename , "zermatt" ) ) ;
updateInstrument: private void updateInstrument ( ) { if ( myPlayerData != null )
additionalCss: public FormFieldDefinitionBuilder < V > additionalCss ( String additionalCss ) { fields . set ( fields . size ( ) - 1 , lastField = createFormFieldDefinition ( formName , lastField , additionalCss ) ) ; return this ;
hasRender: public boolean hasRender ( ) { return false ;
rejectAwakeable: public void rejectAwakeable ( String serializedId , String reason , SyscallCallback < Void > callback ) { wrapAndPropagateExceptions (
getAll: void getAll ( ) throws JsonProcessingException { List < ResourceDto > resourceDtoList = resourceService . getAll ( ) ; assertNotNull ( resourceDtoList ) ; log . info ( "获取所有资源树方法测试成功:{}" , objectMapper . writeValueAsString ( resourceDtoList ) ) ;
renderLights: protected void renderLights ( ) { if ( isLightsVisible ( ) )
getHeaderStyle: private String getHeaderStyle ( TaskState state ) { switch ( state )
f: public final String f ( ) { return null ; }
validate: public IntegrationGitHubForm validate ( BindingResult br ) { if ( StringUtils . isBlank ( dto . getGitHubRepoName ( ) ) ) { br . rejectValue ( "dto.gitHubRepoName" , "not.empty" ) ; } if ( StringUtils . isBlank ( dto . getGitHubRepoOwner ( ) ) ) { br . rejectValue ( "dto.gitHubRepoOwner" , "not.empty" ) ; } return this ;
init: private Event init ( boolean ragdoll ) { this . info = null ; this . destroyer = - 1 ; this . x = 0 ; this . y = 0 ; this . angle = - 1 ; this . notify = true ; this . ragdoll = ragdoll ; return this ;
validateBlocksForAdding: public boolean validateBlocksForAdding ( Map map , int atX , int atY ) { if ( atX < 0 || atY < 0 || atX > map . getWidth ( ) - getWidth ( ) || atY > map . getHeight ( ) - getHeight ( ) ) return false ; for ( int j = 0 ; j < getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < getWidth ( ) ; i ++ ) { int x = atX + i , y = atY + j ; BlockData b = map . getBlock ( x , y , getContentComponent ( ) . getBlocksLayer ( ) ) ; if ( b != null ) return false ; } } return true ;
received: public boolean received ( final AnalyticsResourceEventMsg msg ) { Gdx . app . postRunnable ( ( ) -> { } ) ; return true ;
onInit: public void onInit ( ) { super . onInit ( ) ; MenuHelper . AddCloseButton ( this , this :: pop ) ; leftButtons = MenuHelper . AddLeftButtonsContainers ( this ) ; BrainOut . EventMgr . subscribe ( Event . ID . onlineEventsUpdated , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . onlineEventUpdated , this ) ; BrainOut . EventMgr . subscribe ( Event . ID . simple , this ) ;
clear: private void clear ( ) { for ( WayPoint wayPoint : wayPoints . values ( ) ) { wayPoint . release ( ) ; } chunkWayPoints . clear ( ) ; wayPoints . clear ( ) ; if ( cacheGrid != null )
getInstance: public static AppManager getInstance ( ) { return instance ;
checkPipes: public static boolean checkPipes ( ) { for ( int i = 0 ; i < mKnownPipes . length ; i ++ ) { String pipes = mKnownPipes [ i ] ; File qemuSocket = new File ( pipes ) ; if ( qemuSocket . exists ( ) ) { LogUtils . e ( TAG , "Find pipes!" ) ; return true ; } } LogUtils . e ( TAG , "Not Find pipes!" ) ; return false ;
publish: public < TRequest extends Packet , TResponse extends Packet > Conversation < TRequest , TResponse > publish ( final @ NonNull TRequest packet , final @ NonNull MessageTarget target , final @ Nullable Class < TResponse > expectedResponse , final @ Nullable ConversationUID conversationUID ) { return handler . write ( packet , target , expectedResponse , conversationUID ) ;
onPageFinished: public void onPageFinished ( WebView view , String url ) { if ( mIsLoading || url . startsWith ( "about:" ) ) { mIsLoading = false ; } pageFinished ( view ) ;
createQuery: private static ObjectNode createQuery ( final ObjectMapper objectMapper , final String question ) { final ObjectNode query = objectMapper . createObjectNode ( ) ; query . putObject ( "match" ) . put ( PromptConstants . CONTENT , question ) ; return query ;
testGet: public void testGet ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; EmailKey responseEntity = this . api . emailKeys ( ) . get ( "acme" , "acme" , 1 , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/EmailKeyGetResponse.json" ) ; assertThatJson ( expectedResponseJson )
write: public void write ( Json json ) { String d = getDimension ( ) ; if ( d != null )
setName: public void setName ( String name ) { this . name = name ;
getScale: public float getScale ( ) { return scale ;
getName: public String getName ( ) { return this . name ;
sendUDP: public void sendUDP ( UdpMessage object ) { if ( serverConnection != null )
getCenterOfView: No method body
getPlayerX: public float getPlayerX ( Watcher watcher ) { return super . getPlayerX ( watcher ) + flowedX ;
getZoneByKey: public Zone getZoneByKey ( String key ) { return zonesMap . get ( key , null ) ;
setMousePos: private Vector2 setMousePos ( int screenX , int screenY ) { map . GetMouseScaleWatcher ( screenX - BrainOutClient . getWidth ( ) / 2f , - ( screenY - BrainOutClient . getHeight ( ) / 2f ) , sendPos ) ; return sendPos ;
updateHookedInstrument: public void updateHookedInstrument ( ) { playerData . setHookedInstrument ( getHookedInstrument ( ) ) ;
getCacheSize: public static String getCacheSize ( File file ) throws Exception { return getFormatSize ( getFolderSize ( file ) ) ;
getChannelByteString: public ByteString getChannelByteString ( ) { return mChannel . toByteString ( ) ;
getRemoteAmount: public double getRemoteAmount ( ) { return remoteAmount ;
enter: private void enter ( Client client , PlayerData playerData ) { if ( ! ( client instanceof PlayerClient ) ) return ; PlayerClient playerClient = ( ( PlayerClient ) client ) ; ActiveProgressComponentData progress = playerData . getComponent ( ActiveProgressComponentData . class ) ; if ( progress == null ) return ; if ( ! isAllowedToLeave ( playerData ) ) return ; PlayState playState = BrainOutServer . Controller . getPlayState ( ) ; if ( playState . getID ( ) != PlayState . ID . game ) return ; GameMode mode = ( ( ServerPSGame ) playState ) . getMode ( ) ; if ( mode . getID ( ) != GameMode . ID . free ) return ; ServerFreeRealization free = ( ( ServerFreeRealization ) mode . getRealization ( ) ) ; playerClient . enablePlayer ( false ) ; progress . startCancellable ( 5.0f , ( ) ->
isDrawCubicEnabled: No method body
getAuthenticationToken: No method body
statUpdated: public void statUpdated ( String stat , float newValue , float added ) { PlayerClient client = getClient ( ) ; if ( client != null )
getWorkflowOverride: No method body
read: public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; this . fileName = jsonData . getString ( "file" ) ;
setOperation: public void setOperation ( Audit . AuditOperation operation ) { this . operation = operation ;
register: public void register ( RestateLambdaEndpointBuilder builder ) { builder . bind ( new JavaCounterService ( ) ) . bind ( KotlinCounterServiceKt . counter ( ) ) ;
setX: public void setX ( float x ) { this . x = x ;
renderTimeLeft: protected Cell < Table > renderTimeLeft ( Table container ) { Cell < Table > cell = super . renderTimeLeft ( container ) ; if ( cell != null ) { cell . padBottom ( - 16 ) ; } return cell ;
setPlayState: public void setPlayState ( PlayState . ID playState ) { this . playState = playState ;
getRightTextView: public TextView getRightTextView ( ) { D params = ( D ) getParams ( ) ; if ( params . mAddRightText ) { return ( TextView ) getView ( R . id . tv_right ) ; } return null ;
failed: public void failed ( Throwable th ) { ThreadUtils . runOnIOThread ( ( ) -> ret . fail ( th ) ) ;
retarget: private void retarget ( ) { retries ++ ; target = null ; getController ( ) . stopFollowing ( ) ; if ( retries > 10 )
setUrl: public void setUrl ( String url ) { this . url = url ;
doReload: public boolean doReload ( boolean fineToAutoLoadRounds ) { if ( ! isEnabled ( false ) ) return false ; builtUp = false ; if ( weaponProperties . isUnlimited ( ) ) { load ( ) ; return true ; } if ( state == State . fetching || state == State . loadMagazineRound || state == State . reloading ) return false ; if ( weaponProperties . isNoHalfReload ( ) && getRounds ( ) > 0 ) { return false ; } if ( data . getOwner ( ) == null ) return false ; PlayerOwnerComponent owner = data . getOwner ( ) . getComponent ( PlayerOwnerComponent . class ) ; if ( owner == null ) return false ; if ( isPlayingCustomAnimation ( ) ) { return false ; } if ( weaponProperties . canReloadBoth ( ) ) { WeaponSlotComponent otherSlot ; if ( getSlot ( ) . equals ( Constants . Properties . SLOT_PRIMARY ) ) { otherSlot = getOtherSlot ( Constants . Properties . SLOT_SECONDARY ) ; } else { otherSlot = getOtherSlot ( Constants . Properties . SLOT_PRIMARY ) ; } if ( otherSlot != null ) { boolean canDoA = ( ( owner . hasAmmo ( getBullet ( ) ) && getRounds ( ) < clipSize . asInt ( ) ) || isStuck ( ) ) ; boolean canDoB = ( ( owner . hasAmmo ( otherSlot . getBullet ( ) ) && otherSlot . getRounds ( ) < otherSlot . clipSize . asInt ( ) ) || otherSlot . isStuck ( ) ) ; if ( reloadBothTime . asFloat ( ) > 0 && canDoA && canDoB ) { timer = reloadBothTime . asFloat ( ) ; onReload ( Instrument . Action . reloadBoth ) ; loadBoth ( otherSlot , otherSlot . getBullet ( ) ) ; setState ( State . reloadingBoth ) ; return true ; } } } if ( data . getOwner ( ) == null ) return false ; boolean fineToReload = reloadTime . asFloat ( ) > 0 && ( ( owner . hasAmmo ( getBullet ( ) ) && getRounds ( ) < clipSize . asInt ( ) ) || isStuck ( ) ) ; if ( source . hasMagazineManagement ( ) ) { fineToReload = false ; IntMap . Keys keys = source . getMagazines ( ) ; while ( keys . hasNext ) { int id = keys . next ( ) ; if ( source . getMagazineStatus ( id ) > 0 ) { fineToReload = true ; break ; } } } if ( fineToReload ) { timer = reloadTime . asFloat ( ) ; onReload ( null ) ; load ( ) ; setState ( State . reloading ) ; return true ; } else { if ( fineToAutoLoadRounds && source . hasMagazineManagement ( ) && source . getMagazinesCount ( ) > 0 && hasAmmo ( ) ) { IntMap . Keys keys = source . getMagazines ( ) ; if ( keys . hasNext ) { int id = keys . next ( ) ; doLoadRounds ( id ) ; } return true ; } } return false ;
runCommandCallbackPerLine: public boolean runCommandCallbackPerLine ( String command , Function < String , Object > f ) throws InterruptedException { try { Process process = startProcess ( command ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedException ( ) ; } f . apply ( line ) ; } } } catch ( IOException e ) { return false ; } return true ;
setUp: public static void setUp ( ) throws Exception { Instrumentation instrumentation = ByteBuddyAgent . install ( ) ; Global . instrumentation = instrumentation ; Global . fillLoadedClasses ( ) ;
withAdditionalEnv: public RestateRunnerBuilder withAdditionalEnv ( String key , String value ) { this . additionalEnv . put ( key , value ) ; return this ;
getDecreasingPaintStyle: No method body
setPubKey: public Builder setPubKey ( @ NonNull String pubKey ) { this . mPubKey = pubKey ; return this ;
onClick: public final void onClick ( View v ) { long currentClickTime = SystemClock . uptimeMillis ( ) ; long elapsedTime = currentClickTime - mLastClickTime ; mLastClickTime = currentClickTime ; if ( elapsedTime <= MIN_CLICK_INTERVAL ) return ; onSingleClick ( v ) ;
render: public void render ( ) { BrainOutClient . drawFade ( 0.5f , getBatch ( ) ) ; super . render ( ) ;
isAudioMessage: public static boolean isAudioMessage ( Message message ) { if ( message == null || ! message . hasAttachments ( ) ) { return false ; } for ( MessageAttachment attachment : message . getAttachments ( ) ) { if ( isAudioMessage ( attachment ) ) { return true ; } } return false ;
findCurrentDbVersion: No method body
getGameProgress: public float getGameProgress ( ) { float max = 0 ; for ( ObjectMap . Entry < Team , Integer > entry : points ) { max = Math . max ( max , entry . value + getTakingPoints ( entry . key ) * 0.5f ) ; } return ( float ) max / ( float ) winPoints ;
getDimension: public String getDimension ( ) { return itemData . getDimension ( ) ;
getAttribute: public Attribute getAttribute ( Identifier productIdentifier , Identifier imageIdentifier , String attributeGroupName , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Attribute > responseModel = ( Class < Attribute > ) ( Class < ? > ) Attribute . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/products/%s/images/%s/attributes/%s" , productIdentifier , imageIdentifier , attributeGroupName ) , query , null , responseModel ) ;
clear: public void clear ( ) { accounts . clear ( ) ;
setBuild: public void setBuild ( Integer build ) { this . build = build ;
deleteByModule: No method body
renderError: private void renderError ( ) { content . clear ( ) ; Label loading = new Label ( L . get ( "MENU_ONLINE_COMMON_ERROR" ) , BrainOutClient . Skin , "title-messages-red" ) ; loading . setAlignment ( Align . center ) ; content . add ( loading ) . pad ( 8 ) . expand ( ) . fill ( ) . row ( ) ;
minioStorage: StorageService minioStorage ( OSSProperties ossProperties ) { MinioClient client = minioClient ( ossProperties ) ; return new MinioServiceImpl ( client , ossProperties ) ;
unserializeApiObject: public < T > T unserializeApiObject ( String json , Class < T > modelClass ) { Gson gson = this . createGson ( modelClass ) ; return ( T ) ( gson . fromJson ( json , modelClass ) ) ;
testCreateOrUpdateCustomDataForKey: public void testCreateOrUpdateCustomDataForKey ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCreateOrUpdateCustomDataForKeyRequest.json" ) ; Map < String , Object > requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , Map . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; Map < String , Object > responseEntity = this . api . shops ( ) . createOrUpdateCustomDataForKey ( "acme" , "acme" , requestEntity , options ) ; String expectedResponseJson = this . loadFixture ( "/fixtures/ShopCreateOrUpdateCustomDataForKeyResponse.json" ) ; assertThatJson ( expectedResponseJson )
reward: private void reward ( PlayerClient client ) { if ( getContent ( ) instanceof Case ) { Case asCase = ( ( Case ) getContent ( ) ) ; if ( ! asCase . applicable ( client . getProfile ( ) ) ) { return ; } } client . gotOwnable ( getContent ( ) , "reward-plugin" , ClientProfile . OnwAction . owned , 1 ) ; BrainOutServer . Controller . getClients ( ) . sendTCP (
getOKText: public String getOKText ( ) { return L . get ( "MENU_OK" ) ;
run: public void run ( ) { super . run ( ) ; if ( distantVolume != 0 )
getColorOf: public Color getColorOf ( ActiveData data ) { return null ;
renderQuestTrees: private void renderQuestTrees ( Table root ) { buttons . clear ( ) ; selectedTree = null ; for ( Tree tree : trees )
createUI: public Table createUI ( ) { Table data = new Table ( ) ; { Table header = new Table ( BrainOutClient . Skin ) ; header . setBackground ( "form-red" ) ; Label title = new Label ( L . get ( "EDITOR_MAP_DIMENSIONS" ) , BrainOutClient . Skin , "title-yellow" ) ; header . add ( title ) . expandX ( ) . row ( ) ; data . add ( header ) . expandX ( ) . fillX ( ) . row ( ) ; } Table body = new Table ( BrainOutClient . Skin ) ; body . setBackground ( "form-default" ) ; Table content = new Table ( BrainOutClient . Skin ) ; renderDimensions ( content ) ; ScrollPane scrollPane = new ScrollPane ( content , BrainOutClient . Skin , "scroll-default" ) ; setScrollFocus ( scrollPane ) ; body . add ( scrollPane ) . size ( 600 , 300 ) . pad ( 8 ) . row ( ) ; { Table buttons = new Table ( ) ; { TextButton create = new TextButton ( L . get ( "MENU_CREATE" ) , BrainOutClient . Skin , "button-green" ) ; create . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; doCreate ( ) ; } } ) ; buttons . add ( create ) . size ( 128 , 32 ) . padRight ( 8 ) ; } { TextButton close = new TextButton ( L . get ( "MENU_CLOSE" ) , BrainOutClient . Skin , "button-default" ) ; close . addListener ( new ClickOverListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { Menu . playSound ( MenuSound . select ) ; canceled ( ) ; } } ) ; buttons . add ( close ) . size ( 128 , 32 ) . padLeft ( 8 ) . row ( ) ; } body . add ( buttons ) . expandX ( ) . fillX ( ) . pad ( 8 ) . padTop ( 0 ) . row ( ) ; } data . add ( body ) . expand ( ) . fill ( ) . row ( ) ; return data ;
testUnlink: public void testUnlink ( ) throws Exception { String expectedRequestJson = this . loadFixture ( "/fixtures/ShopCategoryProductSetUnlinkInstructionUnlinkRequest.json" ) ; ShopCategoryProductSetUnlinkInstruction requestEntity = this . jsonSerializer . unserializeApiObject ( expectedRequestJson , ShopCategoryProductSetUnlinkInstruction . class ) ; assertThatJson ( expectedRequestJson ) . when ( TREATING_NULL_AS_ABSENT ) . isEqualTo ( this . jsonSerializer . serializeApiObject ( requestEntity ) ) ; ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . shopCategoryProductSetUnlinkInstructions ( ) . unlink ( "acme" , 1 , requestEntity , options ) ;
setMix: public void setMix ( float mix ) { this . mix = mix ;
copy: protected void copy ( DataSet dataSet ) { super . copy ( dataSet ) ;
render: public void render ( ) { BrainOutClient . drawFade ( Constants . Menu . MENU_BACKGROUND_FADE_DOUBLE , getBatch ( ) ) ; super . render ( ) ;
onEvent: public boolean onEvent ( Event event ) { if ( event . getID ( ) == Event . ID . playerSaved ) { playerSaved ( ( ( PlayerSavedEvent ) event ) . client ) ; } return false ;
setupTargets: private void setupTargets ( ) { setupTarget ( "primary" , 2000 , 1200 ) ; setupTarget ( "secondary" , 2000 , 1000 ) ; setupTarget ( "sniper" , 1500 , 1500 ) ; setupTarget ( "base" , 1500 , 2000 ) ;
showAsDropDown: public void showAsDropDown ( View anchor , int xOff , int yOff ) { if ( Build . VERSION . SDK_INT == 24 ) { Rect rect = new Rect ( ) ; anchor . getGlobalVisibleRect ( rect ) ; int h = anchor . getResources ( ) . getDisplayMetrics ( ) . heightPixels - rect . bottom ; setHeight ( h ) ; } super . showAsDropDown ( anchor , xOff , yOff ) ;
registerEventConsumerWithMethod: synchronized public < T > boolean registerEventConsumerWithMethod ( Class < T > eventClass , Class eventConsumerClass , String eventConsumerMethodName , String description , EventConsumerCategory category , Class ... methodStaticParamsClass ) { debug ( "[registerEventConsumerWithMethod] methodName: {} description: {}" , eventConsumerMethodName , description ) ; try { EventConsumer < T > eventConsumer ; if ( methodStaticParamsClass . length == 0 ) { eventConsumer = new EventConsumer < > ( eventConsumerClass . getMethod ( eventConsumerMethodName , eventClass ) , eventClass , 0 , description , category ) ; } else { Class [ ] eventClassInArray = { eventClass } ; Class [ ] allMethodParamsClass = ArrayUtils . addAll ( eventClassInArray , methodStaticParamsClass ) ; eventConsumer = new EventConsumer < > ( eventConsumerClass . getMethod ( eventConsumerMethodName , allMethodParamsClass ) , eventClass , methodStaticParamsClass . length , description , category ) ; } info ( "Registering Event Consumer {} with method {} for event type {}. {}" , eventConsumerClass , eventConsumerMethodName , eventClass , description ) ; return registerEventConsumer ( eventClass , eventConsumer ) ; } catch ( NoSuchMethodException e ) { error ( e , "Could not find event consumer method [{}, {}]. Consumer not registered." , eventConsumerClass . getName ( ) , eventConsumerMethodName ) ; } return false ;
isLaunching: public boolean isLaunching ( ) { return launching ;
getColorId: static public int getColorId ( Context context , int id ) { return context . getResources ( ) . getColor ( id ) ;
setNewFeature: public void setNewFeature ( String newFeature ) { this . newFeature = newFeature ;
getAxisLineWidth: public float getAxisLineWidth ( ) { return mAxisLineWidth ;
isValid: private boolean isValid ( ) { int l = nameValue . getText ( ) . length ( ) ; return l >= 3 && l <= 32 ;
byteStringFromHex: private static ByteString byteStringFromHex ( String hexString ) { byte [ ] hexBytes = BaseEncoding . base16 ( ) . decode ( hexString . toUpperCase ( ) ) ; return ByteString . copyFrom ( hexBytes ) ;
sharedHandler: public String sharedHandler ( SharedWorkflowContext context , String myInput ) { var client = MyWorkflowClient . fromContext ( context , context . key ( ) ) ; return client . sharedHandler ( myInput ) . await ( ) ;
isValid: public boolean isValid ( ) { return cnt != null ;
setBaseOptions: private void setBaseOptions ( ) { setCompressionQuality ( 95 ) ; setCompressionFormat ( Bitmap . CompressFormat . JPEG ) ; setActiveControlsWidgetColor ( Color . BLACK ) ; setLogoColor ( Color . DKGRAY ) ; setStatusBarColor ( Color . parseColor ( "#ff000000" ) ) ; setToolbarColor ( Color . parseColor ( "#ff111111" ) ) ; setToolbarWidgetColor ( Color . WHITE ) ; setRootViewBackgroundColor ( Color . parseColor ( "#ff000000" ) ) ; setImageToCropBoundsAnimDuration ( 1000 / 60 * 12 ) ; setShowCropGrid ( false ) ;
getReflect: public String getReflect ( ) { return reflect ;
replaceNumberString: public static String replaceNumberString ( String str , String nullStr , String unit ) { if ( "0" . equals ( nullString2Number ( str ) ) ) {
setBindingResult: public void setBindingResult ( BindingResult bindingResult ) { this . bindingResult = bindingResult ;
getType: public String getType ( ) { return type ;
hasRender: public boolean hasRender ( ) { return false ;
received: public boolean received ( ModeMessage modeMessage ) { return receiver . received ( modeMessage , this ) ;
isOnMasterOnly: public boolean isOnMasterOnly ( ) { return onMasterOnly ;
getState: public int getState ( ) { return state ;
isDetached: No method body
populateTo: protected FrontendResource populateTo ( FrontendResource entity ) { entity . setName ( getSafeValue ( entity . getName ( ) , URL_PATH_ ) ) ; entity . setType ( FrontendResource . Type . HTML ) ; entity . setIncludeInSitemap ( true ) ; return entity ;
hasGlobalOrOrgPrivilege: public boolean hasGlobalOrOrgPrivilege ( Privilege privilege , Long orgId ) { return hasGlobalOrOrgPrivilege ( privilege , orgId , globalPrivileges , organizationPrivileges ) ;
draw: public void draw ( PolygonRegion region , float x , float y ) { if ( ! drawing ) throw new IllegalStateException ( "begin must be called before draw." ) ; final short [ ] triangles = this . triangles ; final short [ ] regionTriangles = region . getTriangles ( ) ; final int regionTrianglesLength = regionTriangles . length ; final float [ ] regionVertices = region . getVertices ( ) ; final int regionVerticesLength = regionVertices . length ; final Texture texture = region . getRegion ( ) . getTexture ( ) ; if ( texture != lastTexture ) switchTexture ( texture ) ; else if ( triangleIndex + regionTrianglesLength > triangles . length || vertexIndex + regionVerticesLength * VERTEX_SIZE / 2 > vertices . length ) flush ( ) ; int triangleIndex = this . triangleIndex ; int vertexIndex = this . vertexIndex ; final int startVertex = vertexIndex / VERTEX_SIZE ; for ( int i = 0 ; i < regionTrianglesLength ; i ++ ) triangles [ triangleIndex ++ ] = ( short ) ( regionTriangles [ i ] + startVertex ) ; this . triangleIndex = triangleIndex ; final float [ ] vertices = this . vertices ; final float light = this . lightPacked ; final float dark = this . darkPacked ; final float [ ] textureCoords = region . getTextureCoords ( ) ; for ( int i = 0 ; i < regionVerticesLength ; i += 2 ) { vertices [ vertexIndex ++ ] = regionVertices [ i ] + x ; vertices [ vertexIndex ++ ] = regionVertices [ i + 1 ] + y ; vertices [ vertexIndex ++ ] = light ; vertices [ vertexIndex ++ ] = dark ; vertices [ vertexIndex ++ ] = textureCoords [ i ] ; vertices [ vertexIndex ++ ] = textureCoords [ i + 1 ] ; } this . vertexIndex = vertexIndex ;
integrations: public Object integrations ( ) { debug ( "[integrations]" ) ; return getIntegrations ( )
getId: public Long getId ( ) { return id ;
commandToString: public static String commandToString ( String command ) { try {
convertAndSave: public EventListenerEntry convertAndSave ( EventListenerEntryConversionDto dto , String filePath , Map < String , String > resources ) { debug ( "[convertAndSave]" ) ; EventListenerEntry eventListenerEntry = convertAndSave ( dto , filePath ) ; services . eventListener . registerListenerClusterAware ( eventListenerEntry ) ; return eventListenerEntry ;
run: public void run ( ) { try {
getSubscriberUnseenNotificationsCount: public UnseenNotificationsCountResponse getSubscriberUnseenNotificationsCount ( final String subscriberId ) throws IOException , NovuNetworkException { Response < UnseenNotificationsCountResponse > response = subscribersApi . getSubscriberUnseenNotificationsCount ( subscriberId ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
showNotFound: public void showNotFound ( ) { list . clearItems ( ) ; setActor ( notFoundLabel ) ; notFoundLabel . padLeft ( getStyle ( ) . background . getLeftWidth ( ) + list . getStyle ( ) . background . getLeftWidth ( ) ) ;
testDelete: public void testDelete ( ) throws Exception { ApiOptions options = ApiOptions . builder ( ) . build ( ) ; this . api . promotions ( ) . delete ( "645e0c241a93369ff53f26e0" , options ) ;
pickUpItem: public void pickUpItem ( ItemData itemData ) { Map map = itemData . getMap ( ) ; if ( map == null ) return ; if ( BrainOutServer . EventMgr . sendEvent ( itemData , EarnEvent . obtain ( playerData ) ) )
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { mFW2CloseItemStateChanged ( evt ) ;
f0: public final Observable < List < T > > f0 ( ) { return null ;
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { dwLowActionPerformed ( evt ) ;
onClick: public void onClick ( View v ) { shareLayout . setVisibility ( View . VISIBLE ) ;
getMenuDict: public CommonResult < List < MenuDictDto > > getMenuDict ( ) { List < MenuDictDto > menuDict = menuService . getMenuDict ( ) ; return CommonResult . success ( menuDict ) ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcOpen2ItemStateChanged ( evt ) ;
getReloadBothTime: public UpgradableProperty getReloadBothTime ( ) { return reloadBothTimer ;
getTokenRefresher: public String getTokenRefresher ( ) { return tokenRefresher ;
setItem: protected void setItem ( ConflictSize item ) { conflictSize = item . getSize ( ) ;
getEnterDoor: public ActiveData getEnterDoor ( ) { return enterDoor ;
empty: private void empty ( ) { effect ( Constants . Effects . EMPTY_EFFECT ) ;
needsDeploymentsCheck: public boolean needsDeploymentsCheck ( ) { return false ;
regenerateApiKeys: public ApiKeyResponse regenerateApiKeys ( ) throws IOException , NovuNetworkException { Response < ApiKeyResponse > response = environmentApi . regenerateApiKeys ( ) . execute ( ) ; return restHandler . extractResponse ( response ) ;
getConvertView: private View getConvertView ( ) { for ( int i = 0 ; i < mConvertViews . size ( ) ; i ++ ) { View convertView = mConvertViews . get ( i ) ; if ( convertView . getParent ( ) == null ) { return convertView ; } } return null ;
setState: public void setState ( State state ) { if ( this . state != state )
setHealth: public void setHealth ( float health ) { this . health = health ;
check: private void check ( ) { ItemData itemData = ( ( ItemData ) getComponentObject ( ) ) ; float bs = burnSpeed ; GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( gameMode instanceof GameModeFree ) { ServerFreeRealization r = ( ( ServerFreeRealization ) gameMode . getRealization ( ) ) ; burnSpeed = r . isRain ( ) ? 3 : 1 ; } else { burnSpeed = 1 ; } ActiveData closest = getMap ( ) . getClosestActiveForTag ( 32 , itemData . getX ( ) , itemData . getY ( ) , ActiveData . class , Constants . ActiveTags . WIND , activeData -> true ) ; if ( closest != null ) { burnSpeed *= 2 ; } if ( bs != burnSpeed ) { updated ( itemData ) ; } if ( duration > 300 ) return ; ConsumableContainer cnt = itemData . getRecords ( ) ; for ( ObjectMap . Entry < Integer , ConsumableRecord > entry : cnt . getData ( ) )
executeTest: void executeTest ( String testName , TestExecutor executor , TestDefinition definition ) { executor . executeTest ( definition ) ;
getMyPlayers: public int getMyPlayers ( ) { return myPlayers ;
update: protected void update ( float dt ) { timer -= dt ; if ( timer > 0 ) return ; timer = 0.25f ; if ( getController ( ) . isFollowing ( followTarget ) ) return ; getController ( ) . follow ( followTarget , this :: done , this :: stuck , this :: gotBlocksInOurWay ) ;
getRequiredReadPrivilege: public String getRequiredReadPrivilege ( ) { return requiredReadPrivilege ;
onResourceReady: public void onResourceReady ( GlideDrawable resource , GlideAnimation < ? super GlideDrawable > glideAnimation ) { this . view . setBackground ( resource . getCurrent ( ) ) ;
init: public void init ( ) { super . init ( ) ; SocialController . init ( ) ; Voice . init ( ) ; initMainMenu ( ) . loadPackages ( ) ; Gdx . app . postRunnable ( this :: postInit ) ;
createFeed: No method body
preHandle: public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { debug ( "[preHandle]" ) ; String uri = request . getRequestURI ( ) ; if ( ! uri . equals ( "/" ) && uri . endsWith ( "/" ) ) { response . sendRedirect ( uri . substring ( 0 , uri . length ( ) - 1 ) ) ; return false ; } return true ;
isGridDashedLineEnabled: public boolean isGridDashedLineEnabled ( ) { return mGridDashPathEffect == null ? false : true ;
deleteSubscriberCredentials: public DeleteCredentialsResponse deleteSubscriberCredentials ( final String subscriberId , final String providerId ) throws IOException , NovuNetworkException { try {
setValue: public void setValue ( Object value ) { this . value = value ;
getDimension: public String getDimension ( ) { return d ;
log: public static void log ( @ NotNull String tag , @ Nullable String content ) { if ( content == null ) content = "[NULL]" ; content = tag + ": " + content ; if ( content . length ( ) > 20000 ) { Log . e ( BASE_TAG_NAME , content . substring ( 0 , 3980 ) + " ... TRUNCATED" ) ; return ; } if ( content . length ( ) > 4000 ) {
getWebViewId: protected int getWebViewId ( ) { return R . id . main_web_view ;
defaultHandlerType: private HandlerType defaultHandlerType ( ServiceType serviceType ) { switch ( serviceType ) { case SERVICE : return HandlerType . STATELESS ; case VIRTUAL_OBJECT : return HandlerType . EXCLUSIVE ; case WORKFLOW : return HandlerType . SHARED ; } throw new IllegalStateException ( "Unexpected" ) ;
queryScores: public Single < autopilotrpc . AutopilotOuterClass . QueryScoresResponse > queryScores ( autopilotrpc . AutopilotOuterClass . QueryScoresRequest request ) { return DefaultSingle . createDefault ( emitter -> asyncStub . queryScores ( request , new RemoteObdSingleObserver < > ( emitter ) ) ) ;
checkEnemy: private boolean checkEnemy ( ) { ActiveData enemy = checkForEnemies ( ) ; if ( enemy != null ) { return enemyNoticedCallback . noticed ( getStack ( ) , enemy ) ; } return false ;
newNetworkClient: public NetworkClient newNetworkClient ( Kryo kryo , NetworkConnectionListener listener ) { return new KryoNetworkClient ( kryo , listener ) ;
addDepart: public void addDepart ( @ NonNull Depart depart ) { eventPublisher . publishEvent ( new ClearCacheEvent ( SystemDictConstants . DEPART ) ) ; Assert . isTrue ( this . baseMapper . insert ( depart ) > 0 , "新增部门失败！" ) ;
getComponent: public Component getComponent ( ComponentObject componentObject ) { return new FlyByComponentData ( ( BulletData ) componentObject , this ) ;
getMainComponentName: protected String getMainComponentName ( ) { return "TestForE2E" ;
getWindowBackground: protected Drawable getWindowBackground ( ) { return ContextCompat . getDrawable ( mContext , R . color . color_f9f9f9 ) ;
getRequiredBaseOffset: protected float getRequiredBaseOffset ( ) { return mXAxis . isEnabled ( ) && mXAxis . isDrawLabelsEnabled ( ) ?
lightnessOfColor: public static float lightnessOfColor ( int color ) { float [ ] hsv = new float [ 3 ] ; Color . colorToHSV ( color , hsv ) ; return hsv [ 2 ] ;
onClick: public void onClick ( View v ) { mLoadingDialog . show ( ) ; startNode ( ) ;
get: public Company get ( Integer companyId , ApiOptions options ) throws ApiErrorException , ConnectionException { Class < Company > responseModel = ( Class < Company > ) ( Class < ? > ) Company . class ; Map < String , Object > query = options . all ( ) ; return this . request ( "get" , this . resolvePath ( "/companies/%s" , companyId ) , query , null , responseModel ) ;
stripQuality: private JSONObject stripQuality ( JSONObject filter ) { if ( filter == null ) { return null ; } String [ ] names = JSONObject . getNames ( filter ) ; if ( names == null ) { return null ; } JSONObject o = new JSONObject ( filter , names ) ; if ( o . has ( "q" ) ) { o . remove ( "q" ) ; } return o ;
setUser: public void setUser ( User user ) { this . user = user ;
consecutiveGetWithEmpty: No method body
actionPerformed: public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton4ActionPerformed ( evt ) ;
length: public long length ( ) throws SQLException { return data . length ;
registerFont: public void registerFont ( String fontId , BitmapFont bitmapFont ) { fonts . put ( fontId , bitmapFont ) ; BrainOutClient . Skin . add ( fontId , bitmapFont ) ;
getLength: public int getLength ( ) { return length ;
check: public boolean check ( ) { return this . test . equals ( "" + x + y + layer + d ) ;
setItem: public void setItem ( String item ) { this . item = item ;
hasRichLocalization: public boolean hasRichLocalization ( ) { return false ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcOpen2ItemStateChanged ( evt ) ;
setBackgroundColor: public void setBackgroundColor ( int viewId , int color ) { if ( color != 0 ) {
main: public static void main ( String [ ] argv ) { CheckPreemption c = new CheckPreemption ( ) ; new Thread ( c , "... to be" ) . start ( ) ; new Thread ( c , "not to be" ) . start ( ) ;
getSteamVolume: public double getSteamVolume ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
hasRender: public boolean hasRender ( ) { return false ;
connected: public void connected ( final NetworkConnection connection ) { Gdx . app . log ( "connection" , "Connected to server " + ( connection != null ? connection . getHost ( ) : "[unknown]" ) ) ; Gdx . app . postRunnable ( ( ) -> clientController . onConnect ( connection ) ) ;
run: public void run ( ) { BrainOut . getInstance ( ) . postRunnable ( ( ) ->
hasRender: public boolean hasRender ( ) { return true ;
messageParser: public Parser < ? extends MessageLite > messageParser ( ) { switch ( this ) { case StartMessage : return Protocol . StartMessage . parser ( ) ; case CompletionMessage : return Protocol . CompletionMessage . parser ( ) ; case SuspensionMessage : return Protocol . SuspensionMessage . parser ( ) ; case EndMessage : return Protocol . EndMessage . parser ( ) ; case ErrorMessage : return Protocol . ErrorMessage . parser ( ) ; case EntryAckMessage : return Protocol . EntryAckMessage . parser ( ) ; case InputEntryMessage : return Protocol . InputEntryMessage . parser ( ) ; case OutputEntryMessage : return Protocol . OutputEntryMessage . parser ( ) ; case GetStateEntryMessage : return Protocol . GetStateEntryMessage . parser ( ) ; case SetStateEntryMessage : return Protocol . SetStateEntryMessage . parser ( ) ; case ClearStateEntryMessage : return Protocol . ClearStateEntryMessage . parser ( ) ; case ClearAllStateEntryMessage : return Protocol . ClearAllStateEntryMessage . parser ( ) ; case GetStateKeysEntryMessage : return Protocol . GetStateKeysEntryMessage . parser ( ) ; case GetPromiseEntryMessage : return Protocol . GetPromiseEntryMessage . parser ( ) ; case PeekPromiseEntryMessage : return Protocol . PeekPromiseEntryMessage . parser ( ) ; case CompletePromiseEntryMessage : return Protocol . CompletePromiseEntryMessage . parser ( ) ; case SleepEntryMessage : return Protocol . SleepEntryMessage . parser ( ) ; case CallEntryMessage : return Protocol . CallEntryMessage . parser ( ) ; case OneWayCallEntryMessage : return Protocol . OneWayCallEntryMessage . parser ( ) ; case AwakeableEntryMessage : return Protocol . AwakeableEntryMessage . parser ( ) ; case CompleteAwakeableEntryMessage : return Protocol . CompleteAwakeableEntryMessage . parser ( ) ; case CombinatorAwaitableEntryMessage : return Java . CombinatorAwaitableEntryMessage . parser ( ) ; case RunEntryMessage : return Protocol . RunEntryMessage . parser ( ) ; } throw new IllegalStateException ( ) ;
addStat: public float addStat ( String stat , float amount ) { if ( BrainOutServer . IsCustom ( ) ) { return 0 ; } localStats . put ( stat , localStats . get ( stat , 0.0f ) + amount ) ; if ( profile == null ) return 0 ; return profile . addStat ( stat , amount , true ) ;
setVerified: public void setVerified ( boolean verified ) { this . verified = verified ;
getTarget: public String getTarget ( ) { return target ;
deleteAudience: public void deleteAudience ( String audienceId ) throws ApiErrorException , ConnectionException { this . request ( "delete" , this . resolvePath ( "/promotions/audiences/%s" , audienceId ) , null , null , null ) ;
measureText: private void measureText ( ) { String text = String . valueOf ( mEndNumber ) ; int length = text . length ( ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { builder . append ( "0" ) ; } text = builder . toString ( ) ; mTextPaint . getTextBounds ( text , 0 , text . length ( ) , mTextBounds ) ; if ( mFlagText != null ) {
received: public boolean received ( BlockDestroyMsg msg ) { final int x = msg . x , y = msg . y , layer = msg . layer ; final String dimension = Map . FindDimension ( msg . d ) ; Gdx . app . postRunnable ( ( ) -> { ClientMap map = Map . Get ( dimension , ClientMap . class ) ; if ( map == null ) return ; final BlockData blockData = map . getBlock ( x , y , layer ) ; if ( blockData != null ) { BrainOut . EventMgr . sendEvent ( blockData , DestroyBlockEvent . obtain ( map , x , y , layer , true ) ) ; } } ) ; return true ;
effect: private void effect ( String name ) { ActiveData me = ( ( ActiveData ) getComponentObject ( ) ) ; BrainOutServer . Controller . getClients ( ) . sendUDP (
getTypeface: public Typeface getTypeface ( ) { return mTypeface ;
itemStateChanged: public void itemStateChanged ( java . awt . event . ItemEvent evt ) { sdvcOpen3ItemStateChanged ( evt ) ;
getId: public Long getId ( ) { return id ;
getSpotifyToken: No method body
setFilename: public void setFilename ( String filename ) { this . filename = filename ;
init: public void init ( ) { super . init ( ) ; if ( weaponData != null )
converToStandardTime: public static String converToStandardTime ( String time ) { SimpleDateFormat sdf1 = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; SimpleDateFormat sdf2 = new SimpleDateFormat ( "MM-dd HH:mm" ) ; String format = null ; try { format = sdf2 . format ( sdf1 . parse ( time ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return format ;
update: public void update ( float dt ) { super . update ( dt ) ; counter -= dt ; if ( counter < 0 )
equals: public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; CallRequestOptions that = ( CallRequestOptions ) o ; return Objects . equals ( idempotencyKey , that . idempotencyKey ) ;
openConflictSession: private void openConflictSession ( ) { LoginService loginService = LoginService . Get ( ) ; GameService gameService = GameService . Get ( ) ; conflictSession = gameService . openExistingPartySession (
initContent: protected void initContent ( Table data ) { if ( texture != null ) { image = new Image ( texture ) ; } else { image = new Image ( ) ; } image . setScaling ( Scaling . fit ) ; data . add ( image ) . expand ( ) . fill ( ) . row ( ) ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
generate: public void generate ( ConsumableContainer container , String dimension ) { container . putConsumable ( amount , item . acquireConsumableItem ( ) ) ;
hasOrgPrivilege: default boolean hasOrgPrivilege ( String p , Long orgId ) { Optional < OrganizationUser > user = UserProvider . getFromContext ( ) ; if ( user . isPresent ( ) ) { return user . get ( ) . hasOrgPrivilege ( p , orgId ) ; } return false ;
updateSteamOutflow: public void updateSteamOutflow ( double flow , double tempC ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
getContentBackgroundStyle: protected String getContentBackgroundStyle ( ) { return "form-border-red" ;
move: public boolean move ( float x , float y , float aimX , float aimY , float moveX , float moveY ) { PlayerData pl = playerData ; if ( pl == null ) return false ; if ( ! isEnabled ( ) ) return true ; PlayerComponentData pcd = pl . getComponent ( PlayerComponentData . class ) ; if ( pcd == null ) return false ; pcd . getMousePosition ( ) . set ( aimX , aimY ) ; float angle = pcd . getMousePosition ( ) . angleDeg ( ) ; ServerPhysicsSyncComponentData sync = pl . getComponent ( ServerPhysicsSyncComponentData . class ) ; if ( sync != null ) { setMoveDirection ( moveX , moveY ) ; return sync . sync ( x , y , angle ) ; } return false ;
hasUpdate: public boolean hasUpdate ( ) { return true ;
firstToLowerCase: public static String firstToLowerCase ( String s ) { return ( "" + s . charAt ( 0 ) ) . toLowerCase ( ) + s . substring ( 1 ) ;
getX: public float getX ( ) { return x ;
renderEmpty: private void renderEmpty ( ) { content . clear ( ) ; connectButton . setText ( L . get ( "MENU_QUICK_PLAY" ) ) ; Label loading = new Label ( L . get ( "MENU_NO_SERVERS" ) , BrainOutClient . Skin , "title-gray" ) ; loading . setAlignment ( Align . center ) ; content . add ( loading ) . pad ( 8 ) . expand ( ) . fill ( ) . row ( ) ;
getEffect: public ShakeEffectData getEffect ( LaunchData launchData ) { return new ShakeEffectData ( this , launchData ) ;
getReferenceString: public String getReferenceString ( ) { return referenceString ;
handleError: public Object handleError ( @ RequestParam ( name = "requestId" , required = false ) String reqId , @ RequestParam ( name = "status" , required = false , defaultValue = "NOT_FOUND" ) HttpStatus responseStatus , HttpServletRequest request ) { debug ( "[handleError] ReqId: {}" , reqId ) ; PageModelMap model = new PageModelMap ( ) ; Optional < String > requestUri = getErrorRequestUri ( request ) ; Optional < String > requestErrorMessage = getErrorMessage ( request ) ; model . put ( errorMessage , requestErrorMessage . orElse ( null ) ) ; model . put ( errorHttpStatus , responseStatus ) ; if ( reqId == null ) { reqId = RequestIdHolder . getId ( ) ; String userAgent = request . getHeader ( "User-Agent" ) ; boolean isExcludedUserAgent = ErrorLoggingExceptionResolver . isExcludedUserAgent ( userAgent ) ; if ( not ( isExcludedUserAgent ) ) { if ( pageNotFoundStatus . equals ( responseStatus ) && requestUri . isPresent ( ) ) { if ( unavailablePages . contains ( requestUri . get ( ) ) ) { model . put ( requestId , reqId ) ; return new ModelAndView ( "frontend-resource/error" , model , responseStatus ) ; } unavailablePages . add ( requestUri . get ( ) ) ; } lastErrors . add ( String . format ( "%s %s %s" , responseStatus , requestUri , LocalDateTime . now ( ) ) ) ; if ( lastErrors . size ( ) >= lastErrorsSize ) { warn ( "Last ca. {} errors outside the controller flow: {}" , lastErrorsSize , lastErrors . toString ( ) ) ; lastErrors . clear ( ) ; } } } if ( getErrorRequestUri ( request ) . map ( a -> a . startsWith ( _API ) ) . orElse ( false ) ) { return ResponseEntity . status ( responseStatus ) . body ( model ) ; } model . put ( requestId , reqId ) ; return new ModelAndView ( "frontend-resource/error" , model , responseStatus ) ;
onEvent: public boolean onEvent ( Event event ) { if ( super . onEvent ( event ) ) { return true ; } switch ( event . getID ( ) ) { case flagTaken : { FlagTakenEvent flagTakenEvent = ( ( FlagTakenEvent ) event ) ; flagTaken ( flagTakenEvent . team , flagTakenEvent . flagData ) ; break ; } } return false ;
getInt: public int getInt ( ) { return intValue ;
onCancel: public void onCancel ( @ Nullable Throwable t ) { onFailure . accept ( t ) ;
write: public void write ( Json json ) { super . write ( json ) ; json . writeValue ( "code" , code ) ; json . writeValue ( "locked" , locked ) ;
enter: public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { Stage stage = searchField . getStage ( ) ; oldFocus = stage . getScrollFocus ( ) ; stage . setScrollFocus ( list . getParent ( ) ) ;
register: public void register ( RestateLambdaEndpointBuilder builder ) { for ( String serviceClass :
calculatePosition: public void calculatePosition ( RenderContext context ) { Watcher watcher = Map . GetWatcher ( ) ; float offsetX = 0 , offsetY = 0 ; if ( watcher != null ) { if ( ! watcher . getDimension ( ) . equals ( getParallaxData ( ) . getDimension ( ) ) ) return ; float s ; if ( isScale ( ) ) { s = textureSize . y < context . height ? context . height / textureSize . y : 1.0f ; } else { s = 1.0f ; } float w = textureSize . x * s ; offsetX = - getPlayerX ( watcher ) * Constants . Graphics . RES_SIZE * getCoefX ( ) % w - w ; offsetY = - watcher . getWatchY ( ) * Constants . Graphics . RES_SIZE * getCoefY ( ) ; } position . set ( getX ( ) + getCameraX ( ) + offsetX , getCameraY ( ) + getY ( ) + offsetY ) ;
received: public boolean received ( final ChangeNameMsg msg ) { if ( profile != null ) { BrainOutServer . PostRunnable ( ( ) -> { profile . setName ( msg . name ) ; profile . setDirty ( ) ; sendUserProfile ( ) ; profile . flush ( ) ; } ) ; } return true ;
onReceive: public void onReceive ( Context context , Intent intent ) { if ( intent == null ) { return ; } if ( ConnectivityManager . CONNECTIVITY_ACTION . equals ( intent . getAction ( ) ) ) {
execute: public String execute ( String [ ] args , Client client ) { GameMode gameMode = BrainOutServer . Controller . getGameMode ( ) ; if ( ! ( gameMode . getRealization ( ) instanceof ServerEditorRealization ) ) return "Not in editor" ; ServerEditorRealization editor = ( ( ServerEditorRealization ) gameMode . getRealization ( ) ) ; int width , height ; String dimension = args [ 1 ] ; int alignX = 0 ; int alignY = 0 ; try { width = Integer . valueOf ( args [ 2 ] ) ; height = Integer . valueOf ( args [ 3 ] ) ; if ( args . length >= 5 ) { alignX = Integer . valueOf ( args [ 4 ] ) ; } if ( args . length >= 6 ) { alignY = Integer . valueOf ( args [ 5 ] ) ; } } catch ( NumberFormatException e ) { return "Bad format." ; } ServerMap map = Map . Get ( dimension , ServerMap . class ) ; map . resize ( width , height , alignX , alignY ) ; editor . redeliverMap ( ) ; return "Done." ;
GetMarketItemCategory: public static String GetMarketItemCategory ( String itemName ) { switch ( itemName )
